/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const OutputSentinelOneAiSiemType = {
  SentinelOneAiSiem: "sentinel_one_ai_siem",
} as const;
export type OutputSentinelOneAiSiemType = OpenEnum<
  typeof OutputSentinelOneAiSiemType
>;

/**
 * The SentinelOne region to send events to. In most cases you can find the region by either looking at your SentinelOne URL or knowing what geographic region your SentinelOne instance is contained in.
 */
export const OutputSentinelOneAiSiemRegion = {
  Us: "US",
  Ca: "CA",
  Emea: "EMEA",
  Ap: "AP",
  Aps: "APS",
  Au: "AU",
  Custom: "Custom",
} as const;
/**
 * The SentinelOne region to send events to. In most cases you can find the region by either looking at your SentinelOne URL or knowing what geographic region your SentinelOne instance is contained in.
 */
export type OutputSentinelOneAiSiemRegion = OpenEnum<
  typeof OutputSentinelOneAiSiemRegion
>;

/**
 * Regional endpoint used to send events to, such as /services/collector/event or /services/collector/raw
 */
export const AISIEMEndpointPath = {
  RootServicesCollectorEvent: "/services/collector/event",
  RootServicesCollectorRaw: "/services/collector/raw",
} as const;
/**
 * Regional endpoint used to send events to, such as /services/collector/event or /services/collector/raw
 */
export type AISIEMEndpointPath = OpenEnum<typeof AISIEMEndpointPath>;

export type OutputSentinelOneAiSiemExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputSentinelOneAiSiemFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputSentinelOneAiSiemFailedRequestLoggingMode = OpenEnum<
  typeof OutputSentinelOneAiSiemFailedRequestLoggingMode
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const OutputSentinelOneAiSiemAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type OutputSentinelOneAiSiemAuthenticationMethod = OpenEnum<
  typeof OutputSentinelOneAiSiemAuthenticationMethod
>;

export type OutputSentinelOneAiSiemResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputSentinelOneAiSiemTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSentinelOneAiSiemBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSentinelOneAiSiemBackpressureBehavior = OpenEnum<
  typeof OutputSentinelOneAiSiemBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputSentinelOneAiSiemCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSentinelOneAiSiemCompression = OpenEnum<
  typeof OutputSentinelOneAiSiemCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSentinelOneAiSiemQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSentinelOneAiSiemQueueFullBehavior = OpenEnum<
  typeof OutputSentinelOneAiSiemQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSentinelOneAiSiemMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSentinelOneAiSiemMode = OpenEnum<
  typeof OutputSentinelOneAiSiemMode
>;

export type OutputSentinelOneAiSiemPqControls = {};

export type OutputSentinelOneAiSiem = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputSentinelOneAiSiemType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The SentinelOne region to send events to. In most cases you can find the region by either looking at your SentinelOne URL or knowing what geographic region your SentinelOne instance is contained in.
   */
  region?: OutputSentinelOneAiSiemRegion | undefined;
  /**
   * Regional endpoint used to send events to, such as /services/collector/event or /services/collector/raw
   */
  endpoint?: AISIEMEndpointPath | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputSentinelOneAiSiemExtraHttpHeader> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputSentinelOneAiSiemFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: OutputSentinelOneAiSiemAuthenticationMethod | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputSentinelOneAiSiemResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?:
    | OutputSentinelOneAiSiemTimeoutRetrySettings
    | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSentinelOneAiSiemBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * In the SentinelOne Console select Policy & Settings then select the Singularity AI SIEM section, API Keys will be at the bottom. Under Log Access Keys select a Write token and copy it here
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Base URL of the endpoint used to send events to, such as https://<Your-S1-Tenant>.sentinelone.net. Must begin with http:// or https://, can include a port number, and no trailing slashes. Matches pattern: ^https?://[a-zA-Z0-9.-]+(:[0-9]+)?$.
   */
  baseUrl?: string | undefined;
  /**
   * Define serverHost for events using a JavaScript expression. You must enclose text constants in quotes (such as, 'myServer').
   */
  hostExpression?: string | undefined;
  /**
   * Define logFile for events using a JavaScript expression. You must enclose text constants in quotes (such as, 'myLogFile.txt').
   */
  sourceExpression?: string | undefined;
  /**
   * Define the parser for events using a JavaScript expression. This value helps parse data into AI SIEM. You must enclose text constants in quotes (such as, 'dottedJson'). For custom parsers, substitute 'dottedJson' with your parser's name.
   */
  sourceTypeExpression?: string | undefined;
  /**
   * Define the dataSource.category for events using a JavaScript expression. This value helps categorize data and helps enable extra features in SentinelOne AI SIEM. You must enclose text constants in quotes. The default value is 'security'.
   */
  dataSourceCategoryExpression?: string | undefined;
  /**
   * Define the dataSource.name for events using a JavaScript expression. This value should reflect the type of data being inserted into AI SIEM. You must enclose text constants in quotes (such as, 'networkActivity' or 'authLogs').
   */
  dataSourceNameExpression?: string | undefined;
  /**
   * Define the dataSource.vendor for events using a JavaScript expression. This value should reflect the vendor of the data being inserted into AI SIEM. You must enclose text constants in quotes (such as, 'Cisco' or 'Microsoft').
   */
  dataSourceVendorExpression?: string | undefined;
  /**
   * Optionally, define the event.type for events using a JavaScript expression. This value acts as a label, grouping events into meaningful categories. You must enclose text constants in quotes (such as, 'Process Creation' or 'Network Connection').
   */
  eventTypeExpression?: string | undefined;
  /**
   * Define the serverHost for events using a JavaScript expression. This value will be passed to AI SIEM. You must enclose text constants in quotes (such as, 'myServerName').
   */
  host?: string | undefined;
  /**
   * Specify the logFile value to pass as a parameter to SentinelOne AI SIEM. Don't quote this value. The default is cribl.
   */
  source?: string | undefined;
  /**
   * Specify the sourcetype parameter for SentinelOne AI SIEM, which determines the parser. Don't quote this value. For custom parsers, substitute hecRawParser with your parser's name. The default is hecRawParser.
   */
  sourceType?: string | undefined;
  /**
   * Specify the dataSource.category value to pass as a parameter to SentinelOne AI SIEM. This value helps categorize data and enables additional features. Don't quote this value. The default is security.
   */
  dataSourceCategory?: string | undefined;
  /**
   * Specify the dataSource.name value to pass as a parameter to AI SIEM. This value should reflect the type of data being inserted. Don't quote this value. The default is cribl.
   */
  dataSourceName?: string | undefined;
  /**
   * Specify the dataSource.vendorvalue to pass as a parameter to AI SIEM. This value should reflect the vendor of the data being inserted. Don't quote this value. The default is cribl.
   */
  dataSourceVendor?: string | undefined;
  /**
   * Specify the event.type value to pass as an optional parameter to AI SIEM. This value acts as a label, grouping events into meaningful categories like Process Creation, File Modification, or Network Connection. Don't quote this value. By default, this field is empty.
   */
  eventType?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSentinelOneAiSiemCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSentinelOneAiSiemQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSentinelOneAiSiemMode | undefined;
  pqControls?: OutputSentinelOneAiSiemPqControls | undefined;
};

export const OutputDynatraceOtlpType = {
  DynatraceOtlp: "dynatrace_otlp",
} as const;
export type OutputDynatraceOtlpType = OpenEnum<typeof OutputDynatraceOtlpType>;

/**
 * Select a transport option for Dynatrace
 */
export const OutputDynatraceOtlpProtocol = {
  Http: "http",
} as const;
/**
 * Select a transport option for Dynatrace
 */
export type OutputDynatraceOtlpProtocol = OpenEnum<
  typeof OutputDynatraceOtlpProtocol
>;

/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export const OutputDynatraceOTLPOTLPVersion = {
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export type OutputDynatraceOTLPOTLPVersion = OpenEnum<
  typeof OutputDynatraceOTLPOTLPVersion
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const OutputDynatraceOtlpCompressCompression = {
  None: "none",
  Deflate: "deflate",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type OutputDynatraceOtlpCompressCompression = OpenEnum<
  typeof OutputDynatraceOtlpCompressCompression
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const OutputDynatraceOtlpHttpCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type OutputDynatraceOtlpHttpCompressCompression = OpenEnum<
  typeof OutputDynatraceOtlpHttpCompressCompression
>;

export type OutputDynatraceOtlpMetadatum = {
  key?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputDynatraceOtlpFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputDynatraceOtlpFailedRequestLoggingMode = OpenEnum<
  typeof OutputDynatraceOtlpFailedRequestLoggingMode
>;

/**
 * Select the type of Dynatrace endpoint configured
 */
export const EndpointType = {
  Saas: "saas",
  Ag: "ag",
} as const;
/**
 * Select the type of Dynatrace endpoint configured
 */
export type EndpointType = OpenEnum<typeof EndpointType>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputDynatraceOtlpBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputDynatraceOtlpBackpressureBehavior = OpenEnum<
  typeof OutputDynatraceOtlpBackpressureBehavior
>;

export type OutputDynatraceOtlpExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

export type OutputDynatraceOtlpResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputDynatraceOtlpTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const OutputDynatraceOtlpPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputDynatraceOtlpPqCompressCompression = OpenEnum<
  typeof OutputDynatraceOtlpPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputDynatraceOtlpQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputDynatraceOtlpQueueFullBehavior = OpenEnum<
  typeof OutputDynatraceOtlpQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputDynatraceOtlpMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputDynatraceOtlpMode = OpenEnum<typeof OutputDynatraceOtlpMode>;

export type OutputDynatraceOtlpPqControls = {};

export type OutputDynatraceOtlp = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputDynatraceOtlpType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select a transport option for Dynatrace
   */
  protocol?: OutputDynatraceOtlpProtocol | undefined;
  /**
   * The endpoint where Dynatrace events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets)
   */
  endpoint?: string | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when structuring data to send
   */
  otlpVersion?: OutputDynatraceOTLPOTLPVersion | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  compress?: OutputDynatraceOtlpCompressCompression | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  httpCompress?: OutputDynatraceOtlpHttpCompressCompression | undefined;
  /**
   * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpTracesEndpointOverride?: string | undefined;
  /**
   * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpMetricsEndpointOverride?: string | undefined;
  /**
   * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpLogsEndpointOverride?: string | undefined;
  /**
   * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
   */
  metadata?: Array<OutputDynatraceOtlpMetadatum> | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size (in KB) of the request body. The maximum payload size is 4 MB. If this limit is exceeded, the entire OTLP message is dropped
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputDynatraceOtlpFailedRequestLoggingMode
    | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * How often the sender should ping the peer to keep the connection open
   */
  keepAliveTime?: number | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Select the type of Dynatrace endpoint configured
   */
  endpointType?: EndpointType | undefined;
  /**
   * Select or create a stored text secret
   */
  tokenSecret: string;
  authTokenName?: string | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputDynatraceOtlpBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputDynatraceOtlpExtraHttpHeader> | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputDynatraceOtlpResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputDynatraceOtlpTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputDynatraceOtlpPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputDynatraceOtlpQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputDynatraceOtlpMode | undefined;
  pqControls?: OutputDynatraceOtlpPqControls | undefined;
};

export const OutputDynatraceHttpType = {
  DynatraceHttp: "dynatrace_http",
} as const;
export type OutputDynatraceHttpType = OpenEnum<typeof OutputDynatraceHttpType>;

/**
 * The method to use when sending events
 */
export const Method = {
  Post: "POST",
  Put: "PUT",
  Patch: "PATCH",
} as const;
/**
 * The method to use when sending events
 */
export type Method = OpenEnum<typeof Method>;

export type OutputDynatraceHttpExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputDynatraceHttpFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputDynatraceHttpFailedRequestLoggingMode = OpenEnum<
  typeof OutputDynatraceHttpFailedRequestLoggingMode
>;

export type OutputDynatraceHttpResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputDynatraceHttpTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputDynatraceHttpBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputDynatraceHttpBackpressureBehavior = OpenEnum<
  typeof OutputDynatraceHttpBackpressureBehavior
>;

export const OutputDynatraceHttpAuthenticationType = {
  Token: "token",
  TextSecret: "textSecret",
} as const;
export type OutputDynatraceHttpAuthenticationType = OpenEnum<
  typeof OutputDynatraceHttpAuthenticationType
>;

/**
 * How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
 */
export const OutputDynatraceHttpFormat = {
  JsonArray: "json_array",
  Plaintext: "plaintext",
} as const;
/**
 * How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
 */
export type OutputDynatraceHttpFormat = OpenEnum<
  typeof OutputDynatraceHttpFormat
>;

export const Endpoint = {
  Cloud: "cloud",
  ActiveGate: "activeGate",
  Manual: "manual",
} as const;
export type Endpoint = OpenEnum<typeof Endpoint>;

export const TelemetryType = {
  Logs: "logs",
  Metrics: "metrics",
} as const;
export type TelemetryType = OpenEnum<typeof TelemetryType>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputDynatraceHttpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputDynatraceHttpCompression = OpenEnum<
  typeof OutputDynatraceHttpCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputDynatraceHttpQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputDynatraceHttpQueueFullBehavior = OpenEnum<
  typeof OutputDynatraceHttpQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputDynatraceHttpMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputDynatraceHttpMode = OpenEnum<typeof OutputDynatraceHttpMode>;

export type OutputDynatraceHttpPqControls = {};

export type OutputDynatraceHttp = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputDynatraceHttpType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<OutputDynatraceHttpExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputDynatraceHttpFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputDynatraceHttpResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputDynatraceHttpTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputDynatraceHttpBackpressureBehavior | undefined;
  authType?: OutputDynatraceHttpAuthenticationType | undefined;
  /**
   * How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
   */
  format?: OutputDynatraceHttpFormat | undefined;
  endpoint?: Endpoint | undefined;
  telemetryType?: TelemetryType | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputDynatraceHttpCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputDynatraceHttpQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputDynatraceHttpMode | undefined;
  pqControls?: OutputDynatraceHttpPqControls | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * ID of the environment to send to
   */
  environmentId?: string | undefined;
  /**
   * ActiveGate domain with Log analytics collector module enabled. For example https://{activeGate-domain}:9999/e/{environment-id}/api/v2/logs/ingest.
   */
  activeGateDomain?: string | undefined;
  /**
   * URL to send events to. Can be overwritten by an event's __url field.
   */
  url?: string | undefined;
};

export const OutputNetflowType = {
  Netflow: "netflow",
} as const;
export type OutputNetflowType = OpenEnum<typeof OutputNetflowType>;

export type OutputNetflowHost = {
  /**
   * Destination host
   */
  host: string;
  /**
   * Destination port, default is 2055
   */
  port?: number | undefined;
};

export type OutputNetflow = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputNetflowType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * One or more NetFlow destinations to forward events to
   */
  hosts: Array<OutputNetflowHost>;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
};

export const OutputClickHouseType = {
  ClickHouse: "click_house",
} as const;
export type OutputClickHouseType = OpenEnum<typeof OutputClickHouseType>;

export const OutputClickHouseAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  SslUserCertificate: "sslUserCertificate",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
export type OutputClickHouseAuthenticationType = OpenEnum<
  typeof OutputClickHouseAuthenticationType
>;

/**
 * Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
 */
export const OutputClickHouseFormat = {
  JsonCompactEachRowWithNames: "json-compact-each-row-with-names",
  JsonEachRow: "json-each-row",
} as const;
/**
 * Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
 */
export type OutputClickHouseFormat = OpenEnum<typeof OutputClickHouseFormat>;

/**
 * How event fields are mapped to ClickHouse columns.
 */
export const MappingType = {
  Automatic: "automatic",
  Custom: "custom",
} as const;
/**
 * How event fields are mapped to ClickHouse columns.
 */
export type MappingType = OpenEnum<typeof MappingType>;

export const OutputClickHouseMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputClickHouseMinimumTLSVersion = OpenEnum<
  typeof OutputClickHouseMinimumTLSVersion
>;

export const OutputClickHouseMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputClickHouseMaximumTLSVersion = OpenEnum<
  typeof OutputClickHouseMaximumTLSVersion
>;

export type OutputClickHouseTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputClickHouseMinimumTLSVersion | undefined;
  maxVersion?: OutputClickHouseMaximumTLSVersion | undefined;
};

export type OutputClickHouseExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputClickHouseFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputClickHouseFailedRequestLoggingMode = OpenEnum<
  typeof OutputClickHouseFailedRequestLoggingMode
>;

export type OutputClickHouseResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputClickHouseTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputClickHouseBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputClickHouseBackpressureBehavior = OpenEnum<
  typeof OutputClickHouseBackpressureBehavior
>;

export type OutputClickHouseOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OutputClickHouseOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type ColumnMapping = {
  /**
   * Name of the column in ClickHouse that will store field value
   */
  columnName: string;
  /**
   * Type of the column in the ClickHouse database
   */
  columnType?: string | undefined;
  /**
   * JavaScript expression to compute value to be inserted into ClickHouse table
   */
  columnValueExpression: string;
};

/**
 * Codec to use to compress the persisted data
 */
export const OutputClickHouseCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputClickHouseCompression = OpenEnum<
  typeof OutputClickHouseCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputClickHouseQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputClickHouseQueueFullBehavior = OpenEnum<
  typeof OutputClickHouseQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputClickHouseMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputClickHouseMode = OpenEnum<typeof OutputClickHouseMode>;

export type OutputClickHousePqControls = {};

export type OutputClickHouse = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputClickHouseType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of the ClickHouse instance. Example: http://localhost:8123/
   */
  url: string;
  authType?: OutputClickHouseAuthenticationType | undefined;
  database: string;
  /**
   * Name of the ClickHouse table where data will be inserted. Name can contain letters (A-Z, a-z), numbers (0-9), and the character "_", and must start with either a letter or the character "_".
   */
  tableName: string;
  /**
   * Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
   */
  format?: OutputClickHouseFormat | undefined;
  /**
   * How event fields are mapped to ClickHouse columns.
   */
  mappingType?: MappingType | undefined;
  /**
   * Collect data into batches for later processing. Disable to write to a ClickHouse table immediately.
   */
  asyncInserts?: boolean | undefined;
  tls?: OutputClickHouseTLSSettingsClientSide | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputClickHouseExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputClickHouseFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputClickHouseResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputClickHouseTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Log the most recent event that fails to match the table schema
   */
  dumpFormatErrorsToDisk?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputClickHouseBackpressureBehavior | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OutputClickHouseOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OutputClickHouseOauthHeader> | undefined;
  /**
   * Username for certificate authentication
   */
  sqlUsername?: string | undefined;
  /**
   * Cribl will wait for confirmation that data has been fully inserted into the ClickHouse database before proceeding. Disabling this option can increase throughput, but Cribl won’t be able to verify data has been completely inserted.
   */
  waitForAsyncInserts?: boolean | undefined;
  /**
   * Fields to exclude from sending to ClickHouse
   */
  excludeMappingFields?: Array<string> | undefined;
  /**
   * Retrieves the table schema from ClickHouse and populates the Column Mapping table
   */
  describeTable?: string | undefined;
  columnMappings?: Array<ColumnMapping> | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputClickHouseCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputClickHouseQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputClickHouseMode | undefined;
  pqControls?: OutputClickHousePqControls | undefined;
};

export const OutputSecurityLakeType = {
  SecurityLake: "security_lake",
} as const;
export type OutputSecurityLakeType = OpenEnum<typeof OutputSecurityLakeType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputSecurityLakeAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputSecurityLakeAuthenticationMethod = OpenEnum<
  typeof OutputSecurityLakeAuthenticationMethod
>;

/**
 * Signature version to use for signing Amazon Security Lake requests
 */
export const OutputSecurityLakeSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Amazon Security Lake requests
 */
export type OutputSecurityLakeSignatureVersion = OpenEnum<
  typeof OutputSecurityLakeSignatureVersion
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const OutputSecurityLakeObjectACL = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type OutputSecurityLakeObjectACL = OpenEnum<
  typeof OutputSecurityLakeObjectACL
>;

/**
 * Storage class to select for uploaded objects
 */
export const OutputSecurityLakeStorageClass = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
  StandardIa: "STANDARD_IA",
  OnezoneIa: "ONEZONE_IA",
  IntelligentTiering: "INTELLIGENT_TIERING",
  Glacier: "GLACIER",
  GlacierIr: "GLACIER_IR",
  DeepArchive: "DEEP_ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type OutputSecurityLakeStorageClass = OpenEnum<
  typeof OutputSecurityLakeStorageClass
>;

export const OutputSecurityLakeServerSideEncryptionForUploadedObjects = {
  Aes256: "AES256",
  AwsKms: "aws:kms",
} as const;
export type OutputSecurityLakeServerSideEncryptionForUploadedObjects = OpenEnum<
  typeof OutputSecurityLakeServerSideEncryptionForUploadedObjects
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSecurityLakeBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSecurityLakeBackpressureBehavior = OpenEnum<
  typeof OutputSecurityLakeBackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputSecurityLakeDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputSecurityLakeDiskSpaceProtection = OpenEnum<
  typeof OutputSecurityLakeDiskSpaceProtection
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputSecurityLakeParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputSecurityLakeParquetVersion = OpenEnum<
  typeof OutputSecurityLakeParquetVersion
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputSecurityLakeDataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputSecurityLakeDataPageVersion = OpenEnum<
  typeof OutputSecurityLakeDataPageVersion
>;

export type OutputSecurityLakeKeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputSecurityLake = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputSecurityLakeType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * Region where the Amazon Security Lake is located.
   */
  region: string;
  awsSecretKey?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputSecurityLakeAuthenticationMethod | undefined;
  /**
   * Amazon Security Lake service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Amazon Security Lake-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Amazon Security Lake requests
   */
  signatureVersion?: OutputSecurityLakeSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn: string;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: OutputSecurityLakeObjectACL | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: OutputSecurityLakeStorageClass | undefined;
  serverSideEncryption?:
    | OutputSecurityLakeServerSideEncryptionForUploadedObjects
    | undefined;
  /**
   * ID or ARN of the KMS customer-managed key to use for encryption
   */
  kmsKeyId?: string | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSecurityLakeBackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputSecurityLakeDiskSpaceProtection | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Maximum number of files that can be waiting for upload before backpressure is applied
   */
  maxClosingFilesToBackpressure?: number | undefined;
  /**
   * ID of the AWS account whose data the Destination will write to Security Lake. This should have been configured when creating the Amazon Security Lake custom source.
   */
  accountId: string;
  /**
   * Name of the custom source configured in Amazon Security Lake
   */
  customSource: string;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputSecurityLakeParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputSecurityLakeDataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<OutputSecurityLakeKeyValueMetadatum> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
   */
  parquetSchema?: string | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const OutputDlS3Type = {
  DlS3: "dl_s3",
} as const;
export type OutputDlS3Type = OpenEnum<typeof OutputDlS3Type>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputDlS3AuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputDlS3AuthenticationMethod = OpenEnum<
  typeof OutputDlS3AuthenticationMethod
>;

/**
 * Signature version to use for signing S3 requests
 */
export const OutputDlS3SignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type OutputDlS3SignatureVersion = OpenEnum<
  typeof OutputDlS3SignatureVersion
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const OutputDlS3ObjectACL = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type OutputDlS3ObjectACL = OpenEnum<typeof OutputDlS3ObjectACL>;

/**
 * Storage class to select for uploaded objects
 */
export const OutputDlS3StorageClass = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
  StandardIa: "STANDARD_IA",
  OnezoneIa: "ONEZONE_IA",
  IntelligentTiering: "INTELLIGENT_TIERING",
  Glacier: "GLACIER",
  GlacierIr: "GLACIER_IR",
  DeepArchive: "DEEP_ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type OutputDlS3StorageClass = OpenEnum<typeof OutputDlS3StorageClass>;

export const OutputDlS3ServerSideEncryptionForUploadedObjects = {
  Aes256: "AES256",
  AwsKms: "aws:kms",
} as const;
export type OutputDlS3ServerSideEncryptionForUploadedObjects = OpenEnum<
  typeof OutputDlS3ServerSideEncryptionForUploadedObjects
>;

/**
 * Format of the output data
 */
export const OutputDlS3DataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputDlS3DataFormat = OpenEnum<typeof OutputDlS3DataFormat>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputDlS3BackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputDlS3BackpressureBehavior = OpenEnum<
  typeof OutputDlS3BackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputDlS3DiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputDlS3DiskSpaceProtection = OpenEnum<
  typeof OutputDlS3DiskSpaceProtection
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputDlS3Compression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputDlS3Compression = OpenEnum<typeof OutputDlS3Compression>;

/**
 * Compression level to apply before moving files to final destination
 */
export const OutputDlS3CompressionLevel = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type OutputDlS3CompressionLevel = OpenEnum<
  typeof OutputDlS3CompressionLevel
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputDlS3ParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputDlS3ParquetVersion = OpenEnum<
  typeof OutputDlS3ParquetVersion
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputDlS3DataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputDlS3DataPageVersion = OpenEnum<
  typeof OutputDlS3DataPageVersion
>;

export type OutputDlS3KeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputDlS3 = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputDlS3Type | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * Region where the S3 bucket is located
   */
  region?: string | undefined;
  /**
   * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
   */
  awsSecretKey?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputDlS3AuthenticationMethod | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: OutputDlS3SignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`
   */
  destPath?: string | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: OutputDlS3ObjectACL | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: OutputDlS3StorageClass | undefined;
  serverSideEncryption?:
    | OutputDlS3ServerSideEncryptionForUploadedObjects
    | undefined;
  /**
   * ID or ARN of the KMS customer-managed key to use for encryption
   */
  kmsKeyId?: string | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * Format of the output data
   */
  format?: OutputDlS3DataFormat | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputDlS3BackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputDlS3DiskSpaceProtection | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Maximum number of files that can be waiting for upload before backpressure is applied
   */
  maxClosingFilesToBackpressure?: number | undefined;
  /**
   * List of fields to partition the path by, in addition to time, which is included automatically. The effective partition will be YYYY/MM/DD/HH/<list/of/fields>.
   */
  partitioningFields?: Array<string> | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputDlS3Compression | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: OutputDlS3CompressionLevel | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputDlS3ParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputDlS3DataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<OutputDlS3KeyValueMetadatum> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const OutputCrowdstrikeNextGenSiemType = {
  CrowdstrikeNextGenSiem: "crowdstrike_next_gen_siem",
} as const;
export type OutputCrowdstrikeNextGenSiemType = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemType
>;

export type OutputCrowdstrikeNextGenSiemExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode
>;

/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export const OutputCrowdstrikeNextGenSiemRequestFormat = {
  Json: "JSON",
  Raw: "raw",
} as const;
/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export type OutputCrowdstrikeNextGenSiemRequestFormat = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemRequestFormat
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const OutputCrowdstrikeNextGenSiemAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type OutputCrowdstrikeNextGenSiemAuthenticationMethod = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemAuthenticationMethod
>;

export type OutputCrowdstrikeNextGenSiemResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputCrowdstrikeNextGenSiemTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputCrowdstrikeNextGenSiemBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputCrowdstrikeNextGenSiemBackpressureBehavior = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputCrowdstrikeNextGenSiemCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputCrowdstrikeNextGenSiemCompression = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputCrowdstrikeNextGenSiemQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputCrowdstrikeNextGenSiemQueueFullBehavior = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputCrowdstrikeNextGenSiemMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputCrowdstrikeNextGenSiemMode = OpenEnum<
  typeof OutputCrowdstrikeNextGenSiemMode
>;

export type OutputCrowdstrikeNextGenSiemPqControls = {};

export type OutputCrowdstrikeNextGenSiem = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputCrowdstrikeNextGenSiemType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL provided from a CrowdStrike data connector.
   *
   * @remarks
   * Example: https://ingest.<region>.crowdstrike.com/api/ingest/hec/<connection-id>/v1/services/collector
   */
  url: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?:
    | Array<OutputCrowdstrikeNextGenSiemExtraHttpHeader>
    | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
   */
  format?: OutputCrowdstrikeNextGenSiemRequestFormat | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: OutputCrowdstrikeNextGenSiemAuthenticationMethod | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputCrowdstrikeNextGenSiemResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?:
    | OutputCrowdstrikeNextGenSiemTimeoutRetrySettings
    | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputCrowdstrikeNextGenSiemBackpressureBehavior | undefined;
  description?: string | undefined;
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputCrowdstrikeNextGenSiemCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputCrowdstrikeNextGenSiemQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputCrowdstrikeNextGenSiemMode | undefined;
  pqControls?: OutputCrowdstrikeNextGenSiemPqControls | undefined;
};

export const OutputHumioHecType = {
  HumioHec: "humio_hec",
} as const;
export type OutputHumioHecType = OpenEnum<typeof OutputHumioHecType>;

export type OutputHumioHecExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputHumioHecFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputHumioHecFailedRequestLoggingMode = OpenEnum<
  typeof OutputHumioHecFailedRequestLoggingMode
>;

/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export const OutputHumioHecRequestFormat = {
  Json: "JSON",
  Raw: "raw",
} as const;
/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export type OutputHumioHecRequestFormat = OpenEnum<
  typeof OutputHumioHecRequestFormat
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const OutputHumioHecAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type OutputHumioHecAuthenticationMethod = OpenEnum<
  typeof OutputHumioHecAuthenticationMethod
>;

export type OutputHumioHecResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputHumioHecTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputHumioHecBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputHumioHecBackpressureBehavior = OpenEnum<
  typeof OutputHumioHecBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputHumioHecCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputHumioHecCompression = OpenEnum<
  typeof OutputHumioHecCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputHumioHecQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputHumioHecQueueFullBehavior = OpenEnum<
  typeof OutputHumioHecQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputHumioHecMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputHumioHecMode = OpenEnum<typeof OutputHumioHecMode>;

export type OutputHumioHecPqControls = {};

export type OutputHumioHec = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputHumioHecType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL to a CrowdStrike Falcon LogScale endpoint to send events to. Examples: https://cloud.us.humio.com/api/v1/ingest/hec for JSON and https://cloud.us.humio.com/api/v1/ingest/hec/raw for raw
   */
  url?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputHumioHecExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: OutputHumioHecFailedRequestLoggingMode | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
   */
  format?: OutputHumioHecRequestFormat | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: OutputHumioHecAuthenticationMethod | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<OutputHumioHecResponseRetrySetting> | undefined;
  timeoutRetrySettings?: OutputHumioHecTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputHumioHecBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * CrowdStrike Falcon LogScale authentication token
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputHumioHecCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputHumioHecQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputHumioHecMode | undefined;
  pqControls?: OutputHumioHecPqControls | undefined;
};

export const OutputServiceNowType = {
  ServiceNow: "service_now",
} as const;
export type OutputServiceNowType = OpenEnum<typeof OutputServiceNowType>;

/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export const OutputServiceNowOTLPVersion = {
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export type OutputServiceNowOTLPVersion = OpenEnum<
  typeof OutputServiceNowOTLPVersion
>;

/**
 * Select a transport option for OpenTelemetry
 */
export const OutputServiceNowProtocol = {
  Grpc: "grpc",
  Http: "http",
} as const;
/**
 * Select a transport option for OpenTelemetry
 */
export type OutputServiceNowProtocol = OpenEnum<
  typeof OutputServiceNowProtocol
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const OutputServiceNowCompressCompression = {
  None: "none",
  Deflate: "deflate",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type OutputServiceNowCompressCompression = OpenEnum<
  typeof OutputServiceNowCompressCompression
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const OutputServiceNowHttpCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type OutputServiceNowHttpCompressCompression = OpenEnum<
  typeof OutputServiceNowHttpCompressCompression
>;

export type OutputServiceNowMetadatum = {
  key?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputServiceNowFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputServiceNowFailedRequestLoggingMode = OpenEnum<
  typeof OutputServiceNowFailedRequestLoggingMode
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputServiceNowBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputServiceNowBackpressureBehavior = OpenEnum<
  typeof OutputServiceNowBackpressureBehavior
>;

export type OutputServiceNowExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

export type OutputServiceNowResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputServiceNowTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export const OutputServiceNowMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputServiceNowMinimumTLSVersion = OpenEnum<
  typeof OutputServiceNowMinimumTLSVersion
>;

export const OutputServiceNowMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputServiceNowMaximumTLSVersion = OpenEnum<
  typeof OutputServiceNowMaximumTLSVersion
>;

export type OutputServiceNowTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputServiceNowMinimumTLSVersion | undefined;
  maxVersion?: OutputServiceNowMaximumTLSVersion | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const OutputServiceNowPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputServiceNowPqCompressCompression = OpenEnum<
  typeof OutputServiceNowPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputServiceNowQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputServiceNowQueueFullBehavior = OpenEnum<
  typeof OutputServiceNowQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputServiceNowMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputServiceNowMode = OpenEnum<typeof OutputServiceNowMode>;

export type OutputServiceNowPqControls = {};

export type OutputServiceNow = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputServiceNowType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The endpoint where ServiceNow events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets)
   */
  endpoint?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  tokenSecret: string;
  authTokenName?: string | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when structuring data to send
   */
  otlpVersion?: OutputServiceNowOTLPVersion | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Select a transport option for OpenTelemetry
   */
  protocol?: OutputServiceNowProtocol | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  compress?: OutputServiceNowCompressCompression | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  httpCompress?: OutputServiceNowHttpCompressCompression | undefined;
  /**
   * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpTracesEndpointOverride?: string | undefined;
  /**
   * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpMetricsEndpointOverride?: string | undefined;
  /**
   * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpLogsEndpointOverride?: string | undefined;
  /**
   * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
   */
  metadata?: Array<OutputServiceNowMetadatum> | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputServiceNowFailedRequestLoggingMode
    | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * How often the sender should ping the peer to keep the connection open
   */
  keepAliveTime?: number | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputServiceNowBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputServiceNowExtraHttpHeader> | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputServiceNowResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputServiceNowTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  tls?: OutputServiceNowTLSSettingsClientSide | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputServiceNowPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputServiceNowQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputServiceNowMode | undefined;
  pqControls?: OutputServiceNowPqControls | undefined;
};

export const OutputOpenTelemetryType = {
  OpenTelemetry: "open_telemetry",
} as const;
export type OutputOpenTelemetryType = OpenEnum<typeof OutputOpenTelemetryType>;

/**
 * Select a transport option for OpenTelemetry
 */
export const OutputOpenTelemetryProtocol = {
  Grpc: "grpc",
  Http: "http",
} as const;
/**
 * Select a transport option for OpenTelemetry
 */
export type OutputOpenTelemetryProtocol = OpenEnum<
  typeof OutputOpenTelemetryProtocol
>;

/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export const OutputOpenTelemetryOTLPVersion = {
  ZeroDot10Dot0: "0.10.0",
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export type OutputOpenTelemetryOTLPVersion = OpenEnum<
  typeof OutputOpenTelemetryOTLPVersion
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const OutputOpenTelemetryCompressCompression = {
  None: "none",
  Deflate: "deflate",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type OutputOpenTelemetryCompressCompression = OpenEnum<
  typeof OutputOpenTelemetryCompressCompression
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const OutputOpenTelemetryHttpCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type OutputOpenTelemetryHttpCompressCompression = OpenEnum<
  typeof OutputOpenTelemetryHttpCompressCompression
>;

/**
 * OpenTelemetry authentication type
 */
export const OutputOpenTelemetryAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * OpenTelemetry authentication type
 */
export type OutputOpenTelemetryAuthenticationType = OpenEnum<
  typeof OutputOpenTelemetryAuthenticationType
>;

export type OutputOpenTelemetryMetadatum = {
  key?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputOpenTelemetryFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputOpenTelemetryFailedRequestLoggingMode = OpenEnum<
  typeof OutputOpenTelemetryFailedRequestLoggingMode
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputOpenTelemetryBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputOpenTelemetryBackpressureBehavior = OpenEnum<
  typeof OutputOpenTelemetryBackpressureBehavior
>;

export type OutputOpenTelemetryOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OutputOpenTelemetryOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type OutputOpenTelemetryExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

export type OutputOpenTelemetryResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputOpenTelemetryTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export const OutputOpenTelemetryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputOpenTelemetryMinimumTLSVersion = OpenEnum<
  typeof OutputOpenTelemetryMinimumTLSVersion
>;

export const OutputOpenTelemetryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputOpenTelemetryMaximumTLSVersion = OpenEnum<
  typeof OutputOpenTelemetryMaximumTLSVersion
>;

export type OutputOpenTelemetryTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputOpenTelemetryMinimumTLSVersion | undefined;
  maxVersion?: OutputOpenTelemetryMaximumTLSVersion | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const OutputOpenTelemetryPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputOpenTelemetryPqCompressCompression = OpenEnum<
  typeof OutputOpenTelemetryPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputOpenTelemetryQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputOpenTelemetryQueueFullBehavior = OpenEnum<
  typeof OutputOpenTelemetryQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputOpenTelemetryMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputOpenTelemetryMode = OpenEnum<typeof OutputOpenTelemetryMode>;

export type OutputOpenTelemetryPqControls = {};

export type OutputOpenTelemetry = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputOpenTelemetryType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select a transport option for OpenTelemetry
   */
  protocol?: OutputOpenTelemetryProtocol | undefined;
  /**
   * The endpoint where OTel events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Unspecified ports will default to 4317, unless the endpoint is an HTTPS-based URL or TLS is enabled, in which case 443 will be used.
   */
  endpoint: string;
  /**
   * The version of OTLP Protobuf definitions to use when structuring data to send
   */
  otlpVersion?: OutputOpenTelemetryOTLPVersion | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  compress?: OutputOpenTelemetryCompressCompression | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  httpCompress?: OutputOpenTelemetryHttpCompressCompression | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: OutputOpenTelemetryAuthenticationType | undefined;
  /**
   * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpTracesEndpointOverride?: string | undefined;
  /**
   * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpMetricsEndpointOverride?: string | undefined;
  /**
   * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpLogsEndpointOverride?: string | undefined;
  /**
   * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
   */
  metadata?: Array<OutputOpenTelemetryMetadatum> | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputOpenTelemetryFailedRequestLoggingMode
    | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * How often the sender should ping the peer to keep the connection open
   */
  keepAliveTime?: number | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputOpenTelemetryBackpressureBehavior | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OutputOpenTelemetryOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OutputOpenTelemetryOauthHeader> | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputOpenTelemetryExtraHttpHeader> | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputOpenTelemetryResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputOpenTelemetryTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  tls?: OutputOpenTelemetryTLSSettingsClientSide | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputOpenTelemetryPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputOpenTelemetryQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputOpenTelemetryMode | undefined;
  pqControls?: OutputOpenTelemetryPqControls | undefined;
};

export const OutputPrometheusType = {
  Prometheus: "prometheus",
} as const;
export type OutputPrometheusType = OpenEnum<typeof OutputPrometheusType>;

export type OutputPrometheusExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputPrometheusFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputPrometheusFailedRequestLoggingMode = OpenEnum<
  typeof OutputPrometheusFailedRequestLoggingMode
>;

export type OutputPrometheusResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputPrometheusTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputPrometheusBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputPrometheusBackpressureBehavior = OpenEnum<
  typeof OutputPrometheusBackpressureBehavior
>;

/**
 * Remote Write authentication type
 */
export const OutputPrometheusAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type OutputPrometheusAuthenticationType = OpenEnum<
  typeof OutputPrometheusAuthenticationType
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputPrometheusCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputPrometheusCompression = OpenEnum<
  typeof OutputPrometheusCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputPrometheusQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputPrometheusQueueFullBehavior = OpenEnum<
  typeof OutputPrometheusQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputPrometheusMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputPrometheusMode = OpenEnum<typeof OutputPrometheusMode>;

export type OutputPrometheusPqControls = {};

export type OutputPrometheusOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OutputPrometheusOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type OutputPrometheus = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputPrometheusType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions to generated metrics.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The endpoint to send metrics to
   */
  url: string;
  /**
   * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>.
   */
  metricRenameExpr?: string | undefined;
  /**
   * Generate and send metadata (`type` and `metricFamilyName`) requests
   */
  sendMetadata?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputPrometheusExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputPrometheusFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputPrometheusResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputPrometheusTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputPrometheusBackpressureBehavior | undefined;
  /**
   * Remote Write authentication type
   */
  authType?: OutputPrometheusAuthenticationType | undefined;
  description?: string | undefined;
  /**
   * How frequently metrics metadata is sent out. Value cannot be smaller than the base Flush period set above.
   */
  metricsFlushPeriodSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputPrometheusCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputPrometheusQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputPrometheusMode | undefined;
  pqControls?: OutputPrometheusPqControls | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OutputPrometheusOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OutputPrometheusOauthHeader> | undefined;
};

export const OutputLokiType = {
  Loki: "loki",
} as const;
export type OutputLokiType = OpenEnum<typeof OutputLokiType>;

/**
 * Format to use when sending logs to Loki (Protobuf or JSON)
 */
export const MessageFormat = {
  Protobuf: "protobuf",
  Json: "json",
} as const;
/**
 * Format to use when sending logs to Loki (Protobuf or JSON)
 */
export type MessageFormat = OpenEnum<typeof MessageFormat>;

export type Label = {
  name?: string | undefined;
  value: string;
};

export const OutputLokiAuthenticationType = {
  None: "none",
  Token: "token",
  TextSecret: "textSecret",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
} as const;
export type OutputLokiAuthenticationType = OpenEnum<
  typeof OutputLokiAuthenticationType
>;

export type OutputLokiExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputLokiFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputLokiFailedRequestLoggingMode = OpenEnum<
  typeof OutputLokiFailedRequestLoggingMode
>;

export type OutputLokiResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputLokiTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputLokiBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputLokiBackpressureBehavior = OpenEnum<
  typeof OutputLokiBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputLokiCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputLokiCompression = OpenEnum<typeof OutputLokiCompression>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputLokiQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputLokiQueueFullBehavior = OpenEnum<
  typeof OutputLokiQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputLokiMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputLokiMode = OpenEnum<typeof OutputLokiMode>;

export type OutputLokiPqControls = {};

export type OutputLoki = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputLokiType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as labels to generated logs.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The endpoint to send logs to
   */
  url: string;
  /**
   * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
   */
  message?: string | undefined;
  /**
   * Format to use when sending logs to Loki (Protobuf or JSON)
   */
  messageFormat?: MessageFormat | undefined;
  /**
   * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field. Example: '__labels: {host: "cribl.io", level: "error"}'
   */
  labels?: Array<Label> | undefined;
  authType?: OutputLokiAuthenticationType | undefined;
  /**
   * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki to complain about entries being delivered out of order.
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputLokiExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: OutputLokiFailedRequestLoggingMode | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<OutputLokiResponseRetrySetting> | undefined;
  timeoutRetrySettings?: OutputLokiTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputLokiBackpressureBehavior | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Username for authentication
   */
  username?: string | undefined;
  /**
   * Password (API key in Grafana Cloud domain) for authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputLokiCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputLokiQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputLokiMode | undefined;
  pqControls?: OutputLokiPqControls | undefined;
};

export const OutputSumoLogicType = {
  SumoLogic: "sumo_logic",
} as const;
export type OutputSumoLogicType = OpenEnum<typeof OutputSumoLogicType>;

/**
 * Preserve the raw event format instead of JSONifying it
 */
export const OutputSumoLogicDataFormat = {
  Json: "json",
  Raw: "raw",
} as const;
/**
 * Preserve the raw event format instead of JSONifying it
 */
export type OutputSumoLogicDataFormat = OpenEnum<
  typeof OutputSumoLogicDataFormat
>;

export type OutputSumoLogicExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputSumoLogicFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputSumoLogicFailedRequestLoggingMode = OpenEnum<
  typeof OutputSumoLogicFailedRequestLoggingMode
>;

export type OutputSumoLogicResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputSumoLogicTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSumoLogicBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSumoLogicBackpressureBehavior = OpenEnum<
  typeof OutputSumoLogicBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputSumoLogicCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSumoLogicCompression = OpenEnum<
  typeof OutputSumoLogicCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSumoLogicQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSumoLogicQueueFullBehavior = OpenEnum<
  typeof OutputSumoLogicQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSumoLogicMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSumoLogicMode = OpenEnum<typeof OutputSumoLogicMode>;

export type OutputSumoLogicPqControls = {};

export type OutputSumoLogic = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputSumoLogicType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Sumo Logic HTTP collector URL to which events should be sent
   */
  url: string;
  /**
   * Override the source name configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceName field.
   */
  customSource?: string | undefined;
  /**
   * Override the source category configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceCategory field.
   */
  customCategory?: string | undefined;
  /**
   * Preserve the raw event format instead of JSONifying it
   */
  format?: OutputSumoLogicDataFormat | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputSumoLogicExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputSumoLogicFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputSumoLogicResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputSumoLogicTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSumoLogicBackpressureBehavior | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSumoLogicCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSumoLogicQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSumoLogicMode | undefined;
  pqControls?: OutputSumoLogicPqControls | undefined;
};

export const OutputSnmpType = {
  Snmp: "snmp",
} as const;
export type OutputSnmpType = OpenEnum<typeof OutputSnmpType>;

export type OutputSnmpHost = {
  /**
   * Destination host
   */
  host: string;
  /**
   * Destination port, default is 162
   */
  port?: number | undefined;
};

export type OutputSnmp = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputSnmpType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * One or more SNMP destinations to forward traps to
   */
  hosts: Array<OutputSnmpHost>;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every trap sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
};

export const OutputSqsType = {
  Sqs: "sqs",
} as const;
export type OutputSqsType = OpenEnum<typeof OutputSqsType>;

/**
 * The queue type used (or created). Defaults to Standard.
 */
export const CreateOutputQueueType = {
  Standard: "standard",
  Fifo: "fifo",
} as const;
/**
 * The queue type used (or created). Defaults to Standard.
 */
export type CreateOutputQueueType = OpenEnum<typeof CreateOutputQueueType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputSqsAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputSqsAuthenticationMethod = OpenEnum<
  typeof OutputSqsAuthenticationMethod
>;

/**
 * Signature version to use for signing SQS requests
 */
export const OutputSqsSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing SQS requests
 */
export type OutputSqsSignatureVersion = OpenEnum<
  typeof OutputSqsSignatureVersion
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSqsBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSqsBackpressureBehavior = OpenEnum<
  typeof OutputSqsBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputSqsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSqsCompression = OpenEnum<typeof OutputSqsCompression>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSqsQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSqsQueueFullBehavior = OpenEnum<
  typeof OutputSqsQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSqsMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSqsMode = OpenEnum<typeof OutputSqsMode>;

export type OutputSqsPqControls = {};

export type OutputSqs = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputSqsType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created). Defaults to Standard.
   */
  queueType?: CreateOutputQueueType | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value.
   */
  messageGroupId?: string | undefined;
  /**
   * Create queue if it does not exist.
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputSqsAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: OutputSqsSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Maximum number of queued batches before blocking.
   */
  maxQueueSize?: number | undefined;
  /**
   * Maximum size (KB) of batches to send. Per the SQS spec, the max allowed value is 256 KB.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * The maximum number of in-progress API requests before backpressure is applied.
   */
  maxInProgress?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSqsBackpressureBehavior | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSqsCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSqsQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSqsMode | undefined;
  pqControls?: OutputSqsPqControls | undefined;
};

export const OutputSnsType = {
  Sns: "sns",
} as const;
export type OutputSnsType = OpenEnum<typeof OutputSnsType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputSnsAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputSnsAuthenticationMethod = OpenEnum<
  typeof OutputSnsAuthenticationMethod
>;

/**
 * Signature version to use for signing SNS requests
 */
export const OutputSnsSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing SNS requests
 */
export type OutputSnsSignatureVersion = OpenEnum<
  typeof OutputSnsSignatureVersion
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSnsBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSnsBackpressureBehavior = OpenEnum<
  typeof OutputSnsBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputSnsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSnsCompression = OpenEnum<typeof OutputSnsCompression>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSnsQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSnsQueueFullBehavior = OpenEnum<
  typeof OutputSnsQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSnsMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSnsMode = OpenEnum<typeof OutputSnsMode>;

export type OutputSnsPqControls = {};

export type OutputSns = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputSnsType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The ARN of the SNS topic to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`
   */
  topicArn: string;
  /**
   * Messages in the same group are processed in a FIFO manner. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  messageGroupId: string;
  /**
   * Maximum number of retries before the output returns an error. Note that not all errors are retryable. The retries use an exponential backoff policy.
   */
  maxRetries?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputSnsAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the SNS is located
   */
  region?: string | undefined;
  /**
   * SNS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SNS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SNS requests
   */
  signatureVersion?: OutputSnsSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SNS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSnsBackpressureBehavior | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSnsCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSnsQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSnsMode | undefined;
  pqControls?: OutputSnsPqControls | undefined;
};

export const OutputRouterType = {
  Router: "router",
} as const;
export type OutputRouterType = OpenEnum<typeof OutputRouterType>;

export type CreateOutputRule = {
  /**
   * JavaScript expression to select events to send to output
   */
  filter: string;
  /**
   * Output to send matching events to
   */
  output: string;
  /**
   * Description of this rule's purpose
   */
  description?: string | undefined;
  /**
   * Flag to control whether to stop the event from being checked against other rules
   */
  final?: boolean | undefined;
};

export type OutputRouter = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputRouterType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Event routing rules
   */
  rules: Array<CreateOutputRule>;
  description?: string | undefined;
};

export const OutputGraphiteType = {
  Graphite: "graphite",
} as const;
export type OutputGraphiteType = OpenEnum<typeof OutputGraphiteType>;

/**
 * Protocol to use when communicating with the destination.
 */
export const OutputGraphiteDestinationProtocol = {
  Udp: "udp",
  Tcp: "tcp",
} as const;
/**
 * Protocol to use when communicating with the destination.
 */
export type OutputGraphiteDestinationProtocol = OpenEnum<
  typeof OutputGraphiteDestinationProtocol
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputGraphiteBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputGraphiteBackpressureBehavior = OpenEnum<
  typeof OutputGraphiteBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputGraphiteCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputGraphiteCompression = OpenEnum<
  typeof OutputGraphiteCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputGraphiteQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputGraphiteQueueFullBehavior = OpenEnum<
  typeof OutputGraphiteQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputGraphiteMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputGraphiteMode = OpenEnum<typeof OutputGraphiteMode>;

export type OutputGraphitePqControls = {};

export type OutputGraphite = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputGraphiteType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Protocol to use when communicating with the destination.
   */
  protocol?: OutputGraphiteDestinationProtocol | undefined;
  /**
   * The hostname of the destination.
   */
  host: string;
  /**
   * Destination port.
   */
  port?: number | undefined;
  /**
   * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
   */
  mtu?: number | undefined;
  /**
   * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputGraphiteBackpressureBehavior | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputGraphiteCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputGraphiteQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputGraphiteMode | undefined;
  pqControls?: OutputGraphitePqControls | undefined;
};

export const OutputStatsdExtType = {
  StatsdExt: "statsd_ext",
} as const;
export type OutputStatsdExtType = OpenEnum<typeof OutputStatsdExtType>;

/**
 * Protocol to use when communicating with the destination.
 */
export const OutputStatsdExtDestinationProtocol = {
  Udp: "udp",
  Tcp: "tcp",
} as const;
/**
 * Protocol to use when communicating with the destination.
 */
export type OutputStatsdExtDestinationProtocol = OpenEnum<
  typeof OutputStatsdExtDestinationProtocol
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputStatsdExtBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputStatsdExtBackpressureBehavior = OpenEnum<
  typeof OutputStatsdExtBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputStatsdExtCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputStatsdExtCompression = OpenEnum<
  typeof OutputStatsdExtCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputStatsdExtQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputStatsdExtQueueFullBehavior = OpenEnum<
  typeof OutputStatsdExtQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputStatsdExtMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputStatsdExtMode = OpenEnum<typeof OutputStatsdExtMode>;

export type OutputStatsdExtPqControls = {};

export type OutputStatsdExt = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputStatsdExtType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Protocol to use when communicating with the destination.
   */
  protocol?: OutputStatsdExtDestinationProtocol | undefined;
  /**
   * The hostname of the destination.
   */
  host: string;
  /**
   * Destination port.
   */
  port?: number | undefined;
  /**
   * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
   */
  mtu?: number | undefined;
  /**
   * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputStatsdExtBackpressureBehavior | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputStatsdExtCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputStatsdExtQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputStatsdExtMode | undefined;
  pqControls?: OutputStatsdExtPqControls | undefined;
};

export const OutputStatsdType = {
  Statsd: "statsd",
} as const;
export type OutputStatsdType = OpenEnum<typeof OutputStatsdType>;

/**
 * Protocol to use when communicating with the destination.
 */
export const OutputStatsdDestinationProtocol = {
  Udp: "udp",
  Tcp: "tcp",
} as const;
/**
 * Protocol to use when communicating with the destination.
 */
export type OutputStatsdDestinationProtocol = OpenEnum<
  typeof OutputStatsdDestinationProtocol
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputStatsdBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputStatsdBackpressureBehavior = OpenEnum<
  typeof OutputStatsdBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputStatsdCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputStatsdCompression = OpenEnum<typeof OutputStatsdCompression>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputStatsdQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputStatsdQueueFullBehavior = OpenEnum<
  typeof OutputStatsdQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputStatsdMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputStatsdMode = OpenEnum<typeof OutputStatsdMode>;

export type OutputStatsdPqControls = {};

export type OutputStatsd = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputStatsdType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Protocol to use when communicating with the destination.
   */
  protocol?: OutputStatsdDestinationProtocol | undefined;
  /**
   * The hostname of the destination.
   */
  host: string;
  /**
   * Destination port.
   */
  port?: number | undefined;
  /**
   * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
   */
  mtu?: number | undefined;
  /**
   * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputStatsdBackpressureBehavior | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputStatsdCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputStatsdQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputStatsdMode | undefined;
  pqControls?: OutputStatsdPqControls | undefined;
};

export const OutputMinioType = {
  Minio: "minio",
} as const;
export type OutputMinioType = OpenEnum<typeof OutputMinioType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputMinioAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputMinioAuthenticationMethod = OpenEnum<
  typeof OutputMinioAuthenticationMethod
>;

/**
 * Signature version to use for signing MinIO requests
 */
export const OutputMinioSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing MinIO requests
 */
export type OutputMinioSignatureVersion = OpenEnum<
  typeof OutputMinioSignatureVersion
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const OutputMinioObjectACL = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type OutputMinioObjectACL = OpenEnum<typeof OutputMinioObjectACL>;

/**
 * Storage class to select for uploaded objects
 */
export const OutputMinioStorageClass = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type OutputMinioStorageClass = OpenEnum<typeof OutputMinioStorageClass>;

/**
 * Server-side encryption for uploaded objects
 */
export const ServerSideEncryption = {
  Aes256: "AES256",
} as const;
/**
 * Server-side encryption for uploaded objects
 */
export type ServerSideEncryption = OpenEnum<typeof ServerSideEncryption>;

/**
 * Format of the output data
 */
export const OutputMinioDataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputMinioDataFormat = OpenEnum<typeof OutputMinioDataFormat>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputMinioBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputMinioBackpressureBehavior = OpenEnum<
  typeof OutputMinioBackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputMinioDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputMinioDiskSpaceProtection = OpenEnum<
  typeof OutputMinioDiskSpaceProtection
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputMinioCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputMinioCompression = OpenEnum<typeof OutputMinioCompression>;

/**
 * Compression level to apply before moving files to final destination
 */
export const OutputMinioCompressionLevel = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type OutputMinioCompressionLevel = OpenEnum<
  typeof OutputMinioCompressionLevel
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputMinioParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputMinioParquetVersion = OpenEnum<
  typeof OutputMinioParquetVersion
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputMinioDataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputMinioDataPageVersion = OpenEnum<
  typeof OutputMinioDataPageVersion
>;

export type OutputMinioKeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputMinio = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputMinioType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * MinIO service url (e.g. http://minioHost:9000)
   */
  endpoint: string;
  /**
   * Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputMinioAuthenticationMethod | undefined;
  /**
   * Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`).
   */
  awsSecretKey?: string | undefined;
  /**
   * Region where the MinIO service/cluster is located
   */
  region?: string | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks.
   */
  destPath?: string | undefined;
  /**
   * Signature version to use for signing MinIO requests
   */
  signatureVersion?: OutputMinioSignatureVersion | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: OutputMinioObjectACL | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: OutputMinioStorageClass | undefined;
  /**
   * Server-side encryption for uploaded objects
   */
  serverSideEncryption?: ServerSideEncryption | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: OutputMinioDataFormat | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputMinioBackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputMinioDiskSpaceProtection | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputMinioCompression | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: OutputMinioCompressionLevel | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputMinioParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputMinioDataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<OutputMinioKeyValueMetadatum> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const OutputCloudwatchType = {
  Cloudwatch: "cloudwatch",
} as const;
export type OutputCloudwatchType = OpenEnum<typeof OutputCloudwatchType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputCloudwatchAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputCloudwatchAuthenticationMethod = OpenEnum<
  typeof OutputCloudwatchAuthenticationMethod
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputCloudwatchBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputCloudwatchBackpressureBehavior = OpenEnum<
  typeof OutputCloudwatchBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputCloudwatchCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputCloudwatchCompression = OpenEnum<
  typeof OutputCloudwatchCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputCloudwatchQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputCloudwatchQueueFullBehavior = OpenEnum<
  typeof OutputCloudwatchQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputCloudwatchMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputCloudwatchMode = OpenEnum<typeof OutputCloudwatchMode>;

export type OutputCloudwatchPqControls = {};

export type OutputCloudwatch = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputCloudwatchType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * CloudWatch log group to associate events with
   */
  logGroupName: string;
  /**
   * Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId
   */
  logStreamName: string;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputCloudwatchAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the CloudWatchLogs is located
   */
  region: string;
  /**
   * CloudWatchLogs service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to CloudWatchLogs-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access CloudWatchLogs
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Maximum number of queued batches before blocking
   */
  maxQueueSize?: number | undefined;
  /**
   * Maximum size (KB) of each individual record before compression. For non compressible data 1MB is the max recommended size
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputCloudwatchBackpressureBehavior | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputCloudwatchCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputCloudwatchQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputCloudwatchMode | undefined;
  pqControls?: OutputCloudwatchPqControls | undefined;
};

export const OutputInfluxdbType = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType = OpenEnum<typeof OutputInfluxdbType>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision = {
  Ns: "ns",
  U: "u",
  Ms: "ms",
  S: "s",
  M: "m",
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision = OpenEnum<typeof TimestampPrecision>;

export type OutputInfluxdbExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputInfluxdbFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputInfluxdbFailedRequestLoggingMode = OpenEnum<
  typeof OutputInfluxdbFailedRequestLoggingMode
>;

export type OutputInfluxdbResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputInfluxdbTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputInfluxdbBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputInfluxdbBackpressureBehavior = OpenEnum<
  typeof OutputInfluxdbBackpressureBehavior
>;

/**
 * InfluxDB authentication type
 */
export const OutputInfluxdbAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * InfluxDB authentication type
 */
export type OutputInfluxdbAuthenticationType = OpenEnum<
  typeof OutputInfluxdbAuthenticationType
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputInfluxdbCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputInfluxdbCompression = OpenEnum<
  typeof OutputInfluxdbCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputInfluxdbQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputInfluxdbQueueFullBehavior = OpenEnum<
  typeof OutputInfluxdbQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputInfluxdbMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputInfluxdbMode = OpenEnum<typeof OutputInfluxdbMode>;

export type OutputInfluxdbPqControls = {};

export type OutputInfluxdbOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OutputInfluxdbOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type OutputInfluxdb = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputInfluxdbType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputInfluxdbExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: OutputInfluxdbFailedRequestLoggingMode | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<OutputInfluxdbResponseRetrySetting> | undefined;
  timeoutRetrySettings?: OutputInfluxdbTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputInfluxdbBackpressureBehavior | undefined;
  /**
   * InfluxDB authentication type
   */
  authType?: OutputInfluxdbAuthenticationType | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputInfluxdbCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputInfluxdbQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputInfluxdbMode | undefined;
  pqControls?: OutputInfluxdbPqControls | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OutputInfluxdbOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OutputInfluxdbOauthHeader> | undefined;
};

export const OutputNewrelicEventsType = {
  NewrelicEvents: "newrelic_events",
} as const;
export type OutputNewrelicEventsType = OpenEnum<
  typeof OutputNewrelicEventsType
>;

/**
 * Which New Relic region endpoint to use.
 */
export const OutputNewrelicEventsRegion = {
  Us: "US",
  Eu: "EU",
  Custom: "Custom",
} as const;
/**
 * Which New Relic region endpoint to use.
 */
export type OutputNewrelicEventsRegion = OpenEnum<
  typeof OutputNewrelicEventsRegion
>;

export type OutputNewrelicEventsExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputNewrelicEventsFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputNewrelicEventsFailedRequestLoggingMode = OpenEnum<
  typeof OutputNewrelicEventsFailedRequestLoggingMode
>;

export type OutputNewrelicEventsResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputNewrelicEventsTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputNewrelicEventsBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputNewrelicEventsBackpressureBehavior = OpenEnum<
  typeof OutputNewrelicEventsBackpressureBehavior
>;

/**
 * Enter API key directly, or select a stored secret
 */
export const OutputNewrelicEventsAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter API key directly, or select a stored secret
 */
export type OutputNewrelicEventsAuthenticationMethod = OpenEnum<
  typeof OutputNewrelicEventsAuthenticationMethod
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputNewrelicEventsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputNewrelicEventsCompression = OpenEnum<
  typeof OutputNewrelicEventsCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputNewrelicEventsQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputNewrelicEventsQueueFullBehavior = OpenEnum<
  typeof OutputNewrelicEventsQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputNewrelicEventsMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputNewrelicEventsMode = OpenEnum<
  typeof OutputNewrelicEventsMode
>;

export type OutputNewrelicEventsPqControls = {};

export type OutputNewrelicEvents = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputNewrelicEventsType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Which New Relic region endpoint to use.
   */
  region?: OutputNewrelicEventsRegion | undefined;
  /**
   * New Relic account ID
   */
  accountId: string;
  /**
   * Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words).
   */
  eventType: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputNewrelicEventsExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputNewrelicEventsFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputNewrelicEventsResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputNewrelicEventsTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputNewrelicEventsBackpressureBehavior | undefined;
  /**
   * Enter API key directly, or select a stored secret
   */
  authType?: OutputNewrelicEventsAuthenticationMethod | undefined;
  description?: string | undefined;
  customUrl?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputNewrelicEventsCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputNewrelicEventsQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputNewrelicEventsMode | undefined;
  pqControls?: OutputNewrelicEventsPqControls | undefined;
  /**
   * New Relic API key. Can be overridden using __newRelic_apiKey field.
   */
  apiKey?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const OutputElasticCloudType = {
  ElasticCloud: "elastic_cloud",
} as const;
export type OutputElasticCloudType = OpenEnum<typeof OutputElasticCloudType>;

export type OutputElasticCloudExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputElasticCloudFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputElasticCloudFailedRequestLoggingMode = OpenEnum<
  typeof OutputElasticCloudFailedRequestLoggingMode
>;

export type OutputElasticCloudExtraParam = {
  name: string;
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const OutputElasticCloudAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  ManualAPIKey: "manualAPIKey",
  TextSecret: "textSecret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type OutputElasticCloudAuthenticationMethod = OpenEnum<
  typeof OutputElasticCloudAuthenticationMethod
>;

export type OutputElasticCloudAuth = {
  disabled?: boolean | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: OutputElasticCloudAuthenticationMethod | undefined;
};

export type OutputElasticCloudResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputElasticCloudTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputElasticCloudBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputElasticCloudBackpressureBehavior = OpenEnum<
  typeof OutputElasticCloudBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputElasticCloudCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputElasticCloudCompression = OpenEnum<
  typeof OutputElasticCloudCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputElasticCloudQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputElasticCloudQueueFullBehavior = OpenEnum<
  typeof OutputElasticCloudQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputElasticCloudMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputElasticCloudMode = OpenEnum<typeof OutputElasticCloudMode>;

export type OutputElasticCloudPqControls = {};

export type OutputElasticCloud = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputElasticCloudType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enter Cloud ID of the Elastic Cloud environment to send events to
   */
  url: string;
  /**
   * Data stream or index to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
   */
  index: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputElasticCloudExtraHttpHeader> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputElasticCloudFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Extra parameters to use in HTTP requests
   */
  extraParams?: Array<OutputElasticCloudExtraParam> | undefined;
  auth?: OutputElasticCloudAuth | undefined;
  /**
   * Optional Elastic Cloud Destination pipeline
   */
  elasticPipeline?: string | undefined;
  /**
   * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream)
   */
  includeDocId?: boolean | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputElasticCloudResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputElasticCloudTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputElasticCloudBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputElasticCloudCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputElasticCloudQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputElasticCloudMode | undefined;
  pqControls?: OutputElasticCloudPqControls | undefined;
};

export const OutputElasticType = {
  Elastic: "elastic",
} as const;
export type OutputElasticType = OpenEnum<typeof OutputElasticType>;

export type OutputElasticExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputElasticFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputElasticFailedRequestLoggingMode = OpenEnum<
  typeof OutputElasticFailedRequestLoggingMode
>;

export type OutputElasticResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputElasticTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputElasticExtraParam = {
  name: string;
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const OutputElasticAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  ManualAPIKey: "manualAPIKey",
  TextSecret: "textSecret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type OutputElasticAuthenticationMethod = OpenEnum<
  typeof OutputElasticAuthenticationMethod
>;

export type OutputElasticAuth = {
  disabled?: boolean | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: OutputElasticAuthenticationMethod | undefined;
};

/**
 * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
 */
export const ElasticVersion = {
  Auto: "auto",
  Six: "6",
  Seven: "7",
} as const;
/**
 * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
 */
export type ElasticVersion = OpenEnum<typeof ElasticVersion>;

/**
 * Action to use when writing events. Must be set to `Create` when writing to a data stream.
 */
export const WriteAction = {
  Index: "index",
  Create: "create",
} as const;
/**
 * Action to use when writing events. Must be set to `Create` when writing to a data stream.
 */
export type WriteAction = OpenEnum<typeof WriteAction>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputElasticBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputElasticBackpressureBehavior = OpenEnum<
  typeof OutputElasticBackpressureBehavior
>;

export type Url = {
  /**
   * The URL to an Elastic node to send events to. Example: http://elastic:9200/_bulk
   */
  url: string;
  /**
   * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
   */
  weight?: number | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const OutputElasticCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputElasticCompression = OpenEnum<
  typeof OutputElasticCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputElasticQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputElasticQueueFullBehavior = OpenEnum<
  typeof OutputElasticQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputElasticMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputElasticMode = OpenEnum<typeof OutputElasticMode>;

export type OutputElasticPqControls = {};

export type OutputElastic = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputElasticType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  /**
   * Index or data stream to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
   */
  index: string;
  /**
   * Document type to use for events. Can be overwritten by an event's __type field.
   */
  docType?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputElasticExtraHttpHeader> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: OutputElasticFailedRequestLoggingMode | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<OutputElasticResponseRetrySetting> | undefined;
  timeoutRetrySettings?: OutputElasticTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  extraParams?: Array<OutputElasticExtraParam> | undefined;
  auth?: OutputElasticAuth | undefined;
  /**
   * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
   */
  elasticVersion?: ElasticVersion | undefined;
  /**
   * Optional Elasticsearch destination pipeline
   */
  elasticPipeline?: string | undefined;
  /**
   * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream)
   */
  includeDocId?: boolean | undefined;
  /**
   * Action to use when writing events. Must be set to `Create` when writing to a data stream.
   */
  writeAction?: WriteAction | undefined;
  /**
   * Retry failed events when a bulk request to Elastic is successful, but the response body returns an error for one or more events in the batch
   */
  retryPartialErrors?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputElasticBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * The Cloud ID or URL to an Elastic cluster to send events to. Example: http://elastic:9200/_bulk
   */
  url?: string | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<Url> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputElasticCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputElasticQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputElasticMode | undefined;
  pqControls?: OutputElasticPqControls | undefined;
};

export const OutputMskType = {
  Msk: "msk",
} as const;
export type OutputMskType = OpenEnum<typeof OutputMskType>;

/**
 * Control the number of required acknowledgments.
 */
export const OutputMskAcknowledgments = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments.
 */
export type OutputMskAcknowledgments = OpenEnum<
  typeof OutputMskAcknowledgments
>;

/**
 * Format to use to serialize events before writing to Kafka.
 */
export const OutputMskRecordDataFormat = {
  Json: "json",
  Raw: "raw",
  Protobuf: "protobuf",
} as const;
/**
 * Format to use to serialize events before writing to Kafka.
 */
export type OutputMskRecordDataFormat = OpenEnum<
  typeof OutputMskRecordDataFormat
>;

/**
 * Codec to use to compress the data before sending to Kafka
 */
export const OutputMskCompression = {
  None: "none",
  Gzip: "gzip",
  Snappy: "snappy",
  Lz4: "lz4",
} as const;
/**
 * Codec to use to compress the data before sending to Kafka
 */
export type OutputMskCompression = OpenEnum<typeof OutputMskCompression>;

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type OutputMskAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const OutputMskKafkaSchemaRegistryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputMskKafkaSchemaRegistryMinimumTLSVersion = OpenEnum<
  typeof OutputMskKafkaSchemaRegistryMinimumTLSVersion
>;

export const OutputMskKafkaSchemaRegistryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputMskKafkaSchemaRegistryMaximumTLSVersion = OpenEnum<
  typeof OutputMskKafkaSchemaRegistryMaximumTLSVersion
>;

export type OutputMskKafkaSchemaRegistryTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputMskKafkaSchemaRegistryMinimumTLSVersion | undefined;
  maxVersion?: OutputMskKafkaSchemaRegistryMaximumTLSVersion | undefined;
};

export type OutputMskKafkaSchemaRegistryAuthentication = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: OutputMskAuth | undefined;
  tls?: OutputMskKafkaSchemaRegistryTLSSettingsClientSide | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputMskAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputMskAuthenticationMethod = OpenEnum<
  typeof OutputMskAuthenticationMethod
>;

/**
 * Signature version to use for signing MSK cluster requests
 */
export const OutputMskSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing MSK cluster requests
 */
export type OutputMskSignatureVersion = OpenEnum<
  typeof OutputMskSignatureVersion
>;

export const OutputMskMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputMskMinimumTLSVersion = OpenEnum<
  typeof OutputMskMinimumTLSVersion
>;

export const OutputMskMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputMskMaximumTLSVersion = OpenEnum<
  typeof OutputMskMaximumTLSVersion
>;

export type OutputMskTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputMskMinimumTLSVersion | undefined;
  maxVersion?: OutputMskMaximumTLSVersion | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputMskBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputMskBackpressureBehavior = OpenEnum<
  typeof OutputMskBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputMskPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputMskPqCompressCompression = OpenEnum<
  typeof OutputMskPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputMskQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputMskQueueFullBehavior = OpenEnum<
  typeof OutputMskQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputMskMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputMskMode = OpenEnum<typeof OutputMskMode>;

export type OutputMskPqControls = {};

export type OutputMsk = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputMskType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
   */
  brokers: Array<string>;
  /**
   * The topic to publish events to. Can be overridden using the __topicOut field.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments.
   */
  ack?: OutputMskAcknowledgments | undefined;
  /**
   * Format to use to serialize events before writing to Kafka.
   */
  format?: OutputMskRecordDataFormat | undefined;
  /**
   * Codec to use to compress the data before sending to Kafka
   */
  compression?: OutputMskCompression | undefined;
  /**
   * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * The maximum number of events you want the Destination to allow in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
   */
  flushPeriodSec?: number | undefined;
  kafkaSchemaRegistry?: OutputMskKafkaSchemaRegistryAuthentication | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputMskAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: OutputMskSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: OutputMskTLSSettingsClientSide | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputMskBackpressureBehavior | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Select a set of Protobuf definitions for the events you want to send
   */
  protobufLibraryId?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputMskPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputMskQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputMskMode | undefined;
  pqControls?: OutputMskPqControls | undefined;
};

export const OutputConfluentCloudType = {
  ConfluentCloud: "confluent_cloud",
} as const;
export type OutputConfluentCloudType = OpenEnum<
  typeof OutputConfluentCloudType
>;

export const OutputConfluentCloudMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputConfluentCloudMinimumTLSVersion = OpenEnum<
  typeof OutputConfluentCloudMinimumTLSVersion
>;

export const OutputConfluentCloudMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputConfluentCloudMaximumTLSVersion = OpenEnum<
  typeof OutputConfluentCloudMaximumTLSVersion
>;

export type OutputConfluentCloudTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputConfluentCloudMinimumTLSVersion | undefined;
  maxVersion?: OutputConfluentCloudMaximumTLSVersion | undefined;
};

/**
 * Control the number of required acknowledgments.
 */
export const OutputConfluentCloudAcknowledgments = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments.
 */
export type OutputConfluentCloudAcknowledgments = OpenEnum<
  typeof OutputConfluentCloudAcknowledgments
>;

/**
 * Format to use to serialize events before writing to Kafka.
 */
export const OutputConfluentCloudRecordDataFormat = {
  Json: "json",
  Raw: "raw",
  Protobuf: "protobuf",
} as const;
/**
 * Format to use to serialize events before writing to Kafka.
 */
export type OutputConfluentCloudRecordDataFormat = OpenEnum<
  typeof OutputConfluentCloudRecordDataFormat
>;

/**
 * Codec to use to compress the data before sending to Kafka
 */
export const OutputConfluentCloudCompression = {
  None: "none",
  Gzip: "gzip",
  Snappy: "snappy",
  Lz4: "lz4",
} as const;
/**
 * Codec to use to compress the data before sending to Kafka
 */
export type OutputConfluentCloudCompression = OpenEnum<
  typeof OutputConfluentCloudCompression
>;

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type OutputConfluentCloudAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion = OpenEnum<
  typeof OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion
>;

export const OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion = OpenEnum<
  typeof OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion
>;

export type OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?:
    | OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion
    | undefined;
  maxVersion?:
    | OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion
    | undefined;
};

export type OutputConfluentCloudKafkaSchemaRegistryAuthentication = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: OutputConfluentCloudAuth | undefined;
  tls?:
    | OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide
    | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

export const OutputConfluentCloudSASLMechanism = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type OutputConfluentCloudSASLMechanism = OpenEnum<
  typeof OutputConfluentCloudSASLMechanism
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type OutputConfluentCloudAuthentication = {
  disabled?: boolean | undefined;
  mechanism?: OutputConfluentCloudSASLMechanism | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputConfluentCloudBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputConfluentCloudBackpressureBehavior = OpenEnum<
  typeof OutputConfluentCloudBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputConfluentCloudPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputConfluentCloudPqCompressCompression = OpenEnum<
  typeof OutputConfluentCloudPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputConfluentCloudQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputConfluentCloudQueueFullBehavior = OpenEnum<
  typeof OutputConfluentCloudQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputConfluentCloudMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputConfluentCloudMode = OpenEnum<
  typeof OutputConfluentCloudMode
>;

export type OutputConfluentCloudPqControls = {};

export type OutputConfluentCloud = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputConfluentCloudType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092.
   */
  brokers: Array<string>;
  tls?: OutputConfluentCloudTLSSettingsClientSide | undefined;
  /**
   * The topic to publish events to. Can be overridden using the __topicOut field.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments.
   */
  ack?: OutputConfluentCloudAcknowledgments | undefined;
  /**
   * Format to use to serialize events before writing to Kafka.
   */
  format?: OutputConfluentCloudRecordDataFormat | undefined;
  /**
   * Codec to use to compress the data before sending to Kafka
   */
  compression?: OutputConfluentCloudCompression | undefined;
  /**
   * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * The maximum number of events you want the Destination to allow in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
   */
  flushPeriodSec?: number | undefined;
  kafkaSchemaRegistry?:
    | OutputConfluentCloudKafkaSchemaRegistryAuthentication
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: OutputConfluentCloudAuthentication | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputConfluentCloudBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * Select a set of Protobuf definitions for the events you want to send
   */
  protobufLibraryId?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputConfluentCloudPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputConfluentCloudQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputConfluentCloudMode | undefined;
  pqControls?: OutputConfluentCloudPqControls | undefined;
};

export const OutputKafkaType = {
  Kafka: "kafka",
} as const;
export type OutputKafkaType = OpenEnum<typeof OutputKafkaType>;

/**
 * Control the number of required acknowledgments.
 */
export const OutputKafkaAcknowledgments = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments.
 */
export type OutputKafkaAcknowledgments = OpenEnum<
  typeof OutputKafkaAcknowledgments
>;

/**
 * Format to use to serialize events before writing to Kafka.
 */
export const OutputKafkaRecordDataFormat = {
  Json: "json",
  Raw: "raw",
  Protobuf: "protobuf",
} as const;
/**
 * Format to use to serialize events before writing to Kafka.
 */
export type OutputKafkaRecordDataFormat = OpenEnum<
  typeof OutputKafkaRecordDataFormat
>;

/**
 * Codec to use to compress the data before sending to Kafka
 */
export const OutputKafkaCompression = {
  None: "none",
  Gzip: "gzip",
  Snappy: "snappy",
  Lz4: "lz4",
} as const;
/**
 * Codec to use to compress the data before sending to Kafka
 */
export type OutputKafkaCompression = OpenEnum<typeof OutputKafkaCompression>;

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type OutputKafkaAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const OutputKafkaKafkaSchemaRegistryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputKafkaKafkaSchemaRegistryMinimumTLSVersion = OpenEnum<
  typeof OutputKafkaKafkaSchemaRegistryMinimumTLSVersion
>;

export const OutputKafkaKafkaSchemaRegistryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputKafkaKafkaSchemaRegistryMaximumTLSVersion = OpenEnum<
  typeof OutputKafkaKafkaSchemaRegistryMaximumTLSVersion
>;

export type OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputKafkaKafkaSchemaRegistryMinimumTLSVersion | undefined;
  maxVersion?: OutputKafkaKafkaSchemaRegistryMaximumTLSVersion | undefined;
};

export type OutputKafkaKafkaSchemaRegistryAuthentication = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: OutputKafkaAuth | undefined;
  tls?: OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

export const OutputKafkaSASLMechanism = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type OutputKafkaSASLMechanism = OpenEnum<
  typeof OutputKafkaSASLMechanism
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type OutputKafkaAuthentication = {
  disabled?: boolean | undefined;
  mechanism?: OutputKafkaSASLMechanism | undefined;
};

export const OutputKafkaMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputKafkaMinimumTLSVersion = OpenEnum<
  typeof OutputKafkaMinimumTLSVersion
>;

export const OutputKafkaMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputKafkaMaximumTLSVersion = OpenEnum<
  typeof OutputKafkaMaximumTLSVersion
>;

export type OutputKafkaTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputKafkaMinimumTLSVersion | undefined;
  maxVersion?: OutputKafkaMaximumTLSVersion | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputKafkaBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputKafkaBackpressureBehavior = OpenEnum<
  typeof OutputKafkaBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputKafkaPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputKafkaPqCompressCompression = OpenEnum<
  typeof OutputKafkaPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputKafkaQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputKafkaQueueFullBehavior = OpenEnum<
  typeof OutputKafkaQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputKafkaMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputKafkaMode = OpenEnum<typeof OutputKafkaMode>;

export type OutputKafkaPqControls = {};

export type OutputKafka = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputKafkaType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
   */
  brokers: Array<string>;
  /**
   * The topic to publish events to. Can be overridden using the __topicOut field.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments.
   */
  ack?: OutputKafkaAcknowledgments | undefined;
  /**
   * Format to use to serialize events before writing to Kafka.
   */
  format?: OutputKafkaRecordDataFormat | undefined;
  /**
   * Codec to use to compress the data before sending to Kafka
   */
  compression?: OutputKafkaCompression | undefined;
  /**
   * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * The maximum number of events you want the Destination to allow in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
   */
  flushPeriodSec?: number | undefined;
  kafkaSchemaRegistry?:
    | OutputKafkaKafkaSchemaRegistryAuthentication
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: OutputKafkaAuthentication | undefined;
  tls?: OutputKafkaTLSSettingsClientSide | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputKafkaBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * Select a set of Protobuf definitions for the events you want to send
   */
  protobufLibraryId?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputKafkaPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputKafkaQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputKafkaMode | undefined;
  pqControls?: OutputKafkaPqControls | undefined;
};

export const OutputExabeamType = {
  Exabeam: "exabeam",
} as const;
export type OutputExabeamType = OpenEnum<typeof OutputExabeamType>;

/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export const OutputExabeamSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export type OutputExabeamSignatureVersion = OpenEnum<
  typeof OutputExabeamSignatureVersion
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const OutputExabeamObjectACL = {
  Private: "private",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
  ProjectPrivate: "project-private",
  AuthenticatedRead: "authenticated-read",
  PublicRead: "public-read",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type OutputExabeamObjectACL = OpenEnum<typeof OutputExabeamObjectACL>;

/**
 * Storage class to select for uploaded objects
 */
export const OutputExabeamStorageClass = {
  Standard: "STANDARD",
  Nearline: "NEARLINE",
  Coldline: "COLDLINE",
  Archive: "ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type OutputExabeamStorageClass = OpenEnum<
  typeof OutputExabeamStorageClass
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputExabeamBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputExabeamBackpressureBehavior = OpenEnum<
  typeof OutputExabeamBackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputExabeamDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputExabeamDiskSpaceProtection = OpenEnum<
  typeof OutputExabeamDiskSpaceProtection
>;

export type OutputExabeam = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputExabeamType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination bucket. A constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a JavaScript Global Variable: `myBucket-${C.vars.myVar}`.
   */
  bucket: string;
  /**
   * Region where the bucket is located
   */
  region: string;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Google Cloud Storage service endpoint
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Google Cloud Storage requests
   */
  signatureVersion?: OutputExabeamSignatureVersion | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: OutputExabeamObjectACL | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: OutputExabeamStorageClass | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputExabeamBackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputExabeamDiskSpaceProtection | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Enter an encoded string containing Exabeam configurations
   */
  encodedConfiguration?: string | undefined;
  /**
   * ID of the Exabeam Collector where data should be sent. Example: 11112222-3333-4444-5555-666677778888
   *
   * @remarks
   */
  collectorInstanceId: string;
  /**
   * Constant or JavaScript expression to create an Exabeam site name. Values that aren't successfully evaluated will be treated as string constants.
   */
  siteName?: string | undefined;
  /**
   * Exabeam site ID. If left blank, @{product} will use the value of the Exabeam site name.
   */
  siteId?: string | undefined;
  timezoneOffset?: string | undefined;
  /**
   * HMAC access key. Can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
   */
  awsApiKey?: string | undefined;
  /**
   * HMAC secret. Can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
   */
  awsSecretKey?: string | undefined;
  description?: string | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const OutputGooglePubsubType = {
  GooglePubsub: "google_pubsub",
} as const;
export type OutputGooglePubsubType = OpenEnum<typeof OutputGooglePubsubType>;

/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export const OutputGooglePubsubGoogleAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export type OutputGooglePubsubGoogleAuthenticationMethod = OpenEnum<
  typeof OutputGooglePubsubGoogleAuthenticationMethod
>;

export const FlushPeriodSecType = {
  Number: "number",
} as const;
export type FlushPeriodSecType = OpenEnum<typeof FlushPeriodSecType>;

/**
 * Maximum time to wait before sending a batch (when batch size limit is not reached).
 */
export type FlushPeriodSec = {
  type?: FlushPeriodSecType | undefined;
  default?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputGooglePubsubBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputGooglePubsubBackpressureBehavior = OpenEnum<
  typeof OutputGooglePubsubBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputGooglePubsubCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputGooglePubsubCompression = OpenEnum<
  typeof OutputGooglePubsubCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputGooglePubsubQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputGooglePubsubQueueFullBehavior = OpenEnum<
  typeof OutputGooglePubsubQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputGooglePubsubMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputGooglePubsubMode = OpenEnum<typeof OutputGooglePubsubMode>;

export type OutputGooglePubsubPqControls = {};

export type OutputGooglePubsub = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputGooglePubsubType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * ID of the topic to send events to.
   */
  topicName: string;
  /**
   * If enabled, create topic if it does not exist.
   */
  createTopic?: boolean | undefined;
  /**
   * If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
  /**
   * Region to publish messages to. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: OutputGooglePubsubGoogleAuthenticationMethod | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * The maximum number of items the Google API should batch before it sends them to the topic.
   */
  batchSize?: number | undefined;
  /**
   * The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached).
   */
  batchTimeout?: number | undefined;
  /**
   * Maximum number of queued batches before blocking.
   */
  maxQueueSize?: number | undefined;
  /**
   * Maximum size (KB) of batches to send.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time to wait before sending a batch (when batch size limit is not reached).
   */
  flushPeriodSec?: FlushPeriodSec | undefined;
  /**
   * The maximum number of in-progress API requests before backpressure is applied.
   */
  maxInProgress?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputGooglePubsubBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputGooglePubsubCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputGooglePubsubQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputGooglePubsubMode | undefined;
  pqControls?: OutputGooglePubsubPqControls | undefined;
};

export const OutputGoogleCloudLoggingType = {
  GoogleCloudLogging: "google_cloud_logging",
} as const;
export type OutputGoogleCloudLoggingType = OpenEnum<
  typeof OutputGoogleCloudLoggingType
>;

export const LogLocationType = {
  Project: "project",
  Organization: "organization",
  BillingAccount: "billingAccount",
  Folder: "folder",
} as const;
export type LogLocationType = OpenEnum<typeof LogLocationType>;

/**
 * Format to use when sending payload. Defaults to Text.
 */
export const PayloadFormat = {
  Text: "text",
  Json: "json",
} as const;
/**
 * Format to use when sending payload. Defaults to Text.
 */
export type PayloadFormat = OpenEnum<typeof PayloadFormat>;

export type LogLabel = {
  /**
   * Label name
   */
  label: string;
  /**
   * JavaScript expression to compute the label's value.
   */
  valueExpression: string;
};

export type ResourceTypeLabel = {
  /**
   * Label name
   */
  label: string;
  /**
   * JavaScript expression to compute the label's value.
   */
  valueExpression: string;
};

/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export const OutputGoogleCloudLoggingGoogleAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export type OutputGoogleCloudLoggingGoogleAuthenticationMethod = OpenEnum<
  typeof OutputGoogleCloudLoggingGoogleAuthenticationMethod
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputGoogleCloudLoggingBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputGoogleCloudLoggingBackpressureBehavior = OpenEnum<
  typeof OutputGoogleCloudLoggingBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputGoogleCloudLoggingCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputGoogleCloudLoggingCompression = OpenEnum<
  typeof OutputGoogleCloudLoggingCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputGoogleCloudLoggingQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputGoogleCloudLoggingQueueFullBehavior = OpenEnum<
  typeof OutputGoogleCloudLoggingQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputGoogleCloudLoggingMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputGoogleCloudLoggingMode = OpenEnum<
  typeof OutputGoogleCloudLoggingMode
>;

export type OutputGoogleCloudLoggingPqControls = {};

export type OutputGoogleCloudLogging = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputGoogleCloudLoggingType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  logLocationType: LogLocationType;
  /**
   * JavaScript expression to compute the value of the log name.
   */
  logNameExpression: string;
  /**
   * Format to use when sending payload. Defaults to Text.
   */
  payloadFormat?: PayloadFormat | undefined;
  /**
   * Labels to apply to the log entry
   */
  logLabels?: Array<LogLabel> | undefined;
  /**
   * JavaScript expression to compute the value of the managed resource type field. Must evaluate to one of the valid values [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types). Defaults to "global".
   */
  resourceTypeExpression?: string | undefined;
  /**
   * Labels to apply to the managed resource. These must correspond to the valid labels for the specified resource type (see [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types)). Otherwise, they will be dropped by Google Cloud Logging.
   */
  resourceTypeLabels?: Array<ResourceTypeLabel> | undefined;
  /**
   * JavaScript expression to compute the value of the severity field. Must evaluate to one of the severity values supported by Google Cloud Logging [here](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity) (case insensitive). Defaults to "DEFAULT".
   */
  severityExpression?: string | undefined;
  /**
   * JavaScript expression to compute the value of the insert ID field.
   */
  insertIdExpression?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?:
    | OutputGoogleCloudLoggingGoogleAuthenticationMethod
    | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * Maximum size, in KB, of the request body.
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Max number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Maximum number of ongoing requests before blocking.
   */
  concurrency?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it.
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum number of requests to limit to per second.
   */
  throttleRateReqPerSec?: number | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request method as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  requestMethodExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request URL as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  requestUrlExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  requestSizeExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request method as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  statusExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP response size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  responseSizeExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request user agent as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  userAgentExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request remote IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  remoteIpExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request server IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  serverIpExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request referer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  refererExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request latency, formatted as <seconds>.<nanoseconds>s (for example, 1.23s). See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  latencyExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache lookup as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheLookupExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache hit as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheHitExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache validated with origin server as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheValidatedExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache fill bytes as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheFillBytesExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request protocol as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  protocolExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation ID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  idExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation producer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  producerExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation first flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  firstExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation last flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  lastExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry source location file as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
   */
  fileExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry source location line as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
   */
  lineExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry source location function as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
   */
  functionExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry log split UID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
   */
  uidExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry log split index as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
   */
  indexExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry log split total splits as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
   */
  totalSplitsExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the REST resource name of the trace being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
   */
  traceExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the ID of the cloud trace span associated with the current operation in which the log is being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
   */
  spanIdExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the the sampling decision of the span associated with the log entry. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
   */
  traceSampledExpression?: string | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputGoogleCloudLoggingBackpressureBehavior | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * JavaScript expression to compute the value of the folder ID with which log entries should be associated.
   */
  logLocationExpression: string;
  /**
   * JavaScript expression to compute the value of the payload. Must evaluate to a JavaScript object value. If an invalid value is encountered it will result in the default value instead. Defaults to the entire event.
   */
  payloadExpression?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputGoogleCloudLoggingCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputGoogleCloudLoggingQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputGoogleCloudLoggingMode | undefined;
  pqControls?: OutputGoogleCloudLoggingPqControls | undefined;
};

export const OutputGoogleCloudStorageType = {
  GoogleCloudStorage: "google_cloud_storage",
} as const;
export type OutputGoogleCloudStorageType = OpenEnum<
  typeof OutputGoogleCloudStorageType
>;

/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export const OutputGoogleCloudStorageSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export type OutputGoogleCloudStorageSignatureVersion = OpenEnum<
  typeof OutputGoogleCloudStorageSignatureVersion
>;

export const OutputGoogleCloudStorageAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
export type OutputGoogleCloudStorageAuthenticationMethod = OpenEnum<
  typeof OutputGoogleCloudStorageAuthenticationMethod
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const OutputGoogleCloudStorageObjectACL = {
  Private: "private",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
  ProjectPrivate: "project-private",
  AuthenticatedRead: "authenticated-read",
  PublicRead: "public-read",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type OutputGoogleCloudStorageObjectACL = OpenEnum<
  typeof OutputGoogleCloudStorageObjectACL
>;

/**
 * Storage class to select for uploaded objects
 */
export const OutputGoogleCloudStorageStorageClass = {
  Standard: "STANDARD",
  Nearline: "NEARLINE",
  Coldline: "COLDLINE",
  Archive: "ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type OutputGoogleCloudStorageStorageClass = OpenEnum<
  typeof OutputGoogleCloudStorageStorageClass
>;

/**
 * Format of the output data
 */
export const OutputGoogleCloudStorageDataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputGoogleCloudStorageDataFormat = OpenEnum<
  typeof OutputGoogleCloudStorageDataFormat
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputGoogleCloudStorageBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputGoogleCloudStorageBackpressureBehavior = OpenEnum<
  typeof OutputGoogleCloudStorageBackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputGoogleCloudStorageDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputGoogleCloudStorageDiskSpaceProtection = OpenEnum<
  typeof OutputGoogleCloudStorageDiskSpaceProtection
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputGoogleCloudStorageCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputGoogleCloudStorageCompression = OpenEnum<
  typeof OutputGoogleCloudStorageCompression
>;

/**
 * Compression level to apply before moving files to final destination
 */
export const OutputGoogleCloudStorageCompressionLevel = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type OutputGoogleCloudStorageCompressionLevel = OpenEnum<
  typeof OutputGoogleCloudStorageCompressionLevel
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputGoogleCloudStorageParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputGoogleCloudStorageParquetVersion = OpenEnum<
  typeof OutputGoogleCloudStorageParquetVersion
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputGoogleCloudStorageDataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputGoogleCloudStorageDataPageVersion = OpenEnum<
  typeof OutputGoogleCloudStorageDataPageVersion
>;

export type OutputGoogleCloudStorageKeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputGoogleCloudStorage = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputGoogleCloudStorageType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a Global Variable: `myBucket-${C.vars.myVar}`.
   */
  bucket: string;
  /**
   * Region where the bucket is located
   */
  region: string;
  /**
   * Google Cloud Storage service endpoint
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Google Cloud Storage requests
   */
  signatureVersion?: OutputGoogleCloudStorageSignatureVersion | undefined;
  awsAuthenticationMethod?:
    | OutputGoogleCloudStorageAuthenticationMethod
    | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`
   */
  destPath?: string | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: OutputGoogleCloudStorageObjectACL | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: OutputGoogleCloudStorageStorageClass | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: OutputGoogleCloudStorageDataFormat | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputGoogleCloudStorageBackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?:
    | OutputGoogleCloudStorageDiskSpaceProtection
    | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputGoogleCloudStorageCompression | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: OutputGoogleCloudStorageCompressionLevel | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputGoogleCloudStorageParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputGoogleCloudStorageDataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?:
    | Array<OutputGoogleCloudStorageKeyValueMetadatum>
    | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
  /**
   * HMAC access key. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
   */
  awsApiKey?: string | undefined;
  /**
   * HMAC secret. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
   */
  awsSecretKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export const OutputGoogleChronicleType = {
  GoogleChronicle: "google_chronicle",
} as const;
export type OutputGoogleChronicleType = OpenEnum<
  typeof OutputGoogleChronicleType
>;

export const CreateOutputAPIVersion = {
  V1: "v1",
  V2: "v2",
} as const;
export type CreateOutputAPIVersion = OpenEnum<typeof CreateOutputAPIVersion>;

export const OutputGoogleChronicleAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  ServiceAccount: "serviceAccount",
  ServiceAccountSecret: "serviceAccountSecret",
} as const;
export type OutputGoogleChronicleAuthenticationMethod = OpenEnum<
  typeof OutputGoogleChronicleAuthenticationMethod
>;

export type OutputGoogleChronicleResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputGoogleChronicleTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export const SendEventsAs = {
  Unstructured: "unstructured",
  Udm: "udm",
} as const;
export type SendEventsAs = OpenEnum<typeof SendEventsAs>;

export type OutputGoogleChronicleExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputGoogleChronicleFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputGoogleChronicleFailedRequestLoggingMode = OpenEnum<
  typeof OutputGoogleChronicleFailedRequestLoggingMode
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputGoogleChronicleBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputGoogleChronicleBackpressureBehavior = OpenEnum<
  typeof OutputGoogleChronicleBackpressureBehavior
>;

export type ExtraLogType = {
  logType: string;
  description?: string | undefined;
};

export type CustomLabel = {
  key: string;
  value: string;
};

/**
 * Codec to use to compress the persisted data
 */
export const OutputGoogleChronicleCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputGoogleChronicleCompression = OpenEnum<
  typeof OutputGoogleChronicleCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputGoogleChronicleQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputGoogleChronicleQueueFullBehavior = OpenEnum<
  typeof OutputGoogleChronicleQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputGoogleChronicleMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputGoogleChronicleMode = OpenEnum<
  typeof OutputGoogleChronicleMode
>;

export type OutputGoogleChroniclePqControls = {};

export type OutputGoogleChronicle = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputGoogleChronicleType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  apiVersion?: CreateOutputAPIVersion | undefined;
  authenticationMethod?: OutputGoogleChronicleAuthenticationMethod | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputGoogleChronicleResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputGoogleChronicleTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  logFormatType?: SendEventsAs | undefined;
  /**
   * Regional endpoint to send events to
   */
  region?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputGoogleChronicleExtraHttpHeader> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputGoogleChronicleFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputGoogleChronicleBackpressureBehavior | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * Custom log types. If the value "Custom" is selected in the setting "Default log type" above, the first custom log type in this table will be automatically selected as default log type.
   */
  extraLogTypes?: Array<ExtraLogType> | undefined;
  /**
   * Default log type value to send to SecOps. Can be overwritten by event field __logType.
   */
  logType?: string | undefined;
  /**
   * Name of the event field that contains the log text to send. If not specified, Stream sends a JSON representation of the whole event.
   */
  logTextField?: string | undefined;
  /**
   * Unique identifier (UUID) corresponding to a particular SecOps instance. Provided by your SecOps representative.
   */
  customerId?: string | undefined;
  /**
   * User-configured environment namespace to identify the data domain the logs originated from. Use namespace as a tag to identify the appropriate data domain for indexing and enrichment functionality. Can be overwritten by event field __namespace.
   */
  namespace?: string | undefined;
  /**
   * Custom labels to be added to every batch
   */
  customLabels?: Array<CustomLabel> | undefined;
  /**
   * Organization's API key in Google SecOps
   */
  apiKey?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  apiKeySecret?: string | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  serviceAccountCredentialsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputGoogleChronicleCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputGoogleChronicleQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputGoogleChronicleMode | undefined;
  pqControls?: OutputGoogleChroniclePqControls | undefined;
};

export const OutputAzureEventhubType = {
  AzureEventhub: "azure_eventhub",
} as const;
export type OutputAzureEventhubType = OpenEnum<typeof OutputAzureEventhubType>;

/**
 * Control the number of required acknowledgments
 */
export const OutputAzureEventhubAcknowledgments = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments
 */
export type OutputAzureEventhubAcknowledgments = OpenEnum<
  typeof OutputAzureEventhubAcknowledgments
>;

/**
 * Format to use to serialize events before writing to the Event Hubs Kafka brokers
 */
export const OutputAzureEventhubRecordDataFormat = {
  Json: "json",
  Raw: "raw",
} as const;
/**
 * Format to use to serialize events before writing to the Event Hubs Kafka brokers
 */
export type OutputAzureEventhubRecordDataFormat = OpenEnum<
  typeof OutputAzureEventhubRecordDataFormat
>;

export const OutputAzureEventhubSASLMechanism = {
  Plain: "plain",
  Oauthbearer: "oauthbearer",
} as const;
export type OutputAzureEventhubSASLMechanism = OpenEnum<
  typeof OutputAzureEventhubSASLMechanism
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type OutputAzureEventhubAuthentication = {
  disabled?: boolean | undefined;
  mechanism?: OutputAzureEventhubSASLMechanism | undefined;
};

export type OutputAzureEventhubTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's)
   */
  rejectUnauthorized?: boolean | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputAzureEventhubBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputAzureEventhubBackpressureBehavior = OpenEnum<
  typeof OutputAzureEventhubBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputAzureEventhubCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputAzureEventhubCompression = OpenEnum<
  typeof OutputAzureEventhubCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputAzureEventhubQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputAzureEventhubQueueFullBehavior = OpenEnum<
  typeof OutputAzureEventhubQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputAzureEventhubMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputAzureEventhubMode = OpenEnum<typeof OutputAzureEventhubMode>;

export type OutputAzureEventhubPqControls = {};

export type OutputAzureEventhub = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputAzureEventhubType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka Topic) to publish events. Can be overwritten using field __topicOut.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments
   */
  ack?: OutputAzureEventhubAcknowledgments | undefined;
  /**
   * Format to use to serialize events before writing to the Event Hubs Kafka brokers
   */
  format?: OutputAzureEventhubRecordDataFormat | undefined;
  /**
   * Maximum size of each record batch before compression. Setting should be < message.max.bytes settings in Event Hubs brokers.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum number of events in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: OutputAzureEventhubAuthentication | undefined;
  tls?: OutputAzureEventhubTLSSettingsClientSide | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputAzureEventhubBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputAzureEventhubCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputAzureEventhubQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputAzureEventhubMode | undefined;
  pqControls?: OutputAzureEventhubPqControls | undefined;
};

export const OutputHoneycombType = {
  Honeycomb: "honeycomb",
} as const;
export type OutputHoneycombType = OpenEnum<typeof OutputHoneycombType>;

export type OutputHoneycombExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputHoneycombFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputHoneycombFailedRequestLoggingMode = OpenEnum<
  typeof OutputHoneycombFailedRequestLoggingMode
>;

export type OutputHoneycombResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputHoneycombTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputHoneycombBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputHoneycombBackpressureBehavior = OpenEnum<
  typeof OutputHoneycombBackpressureBehavior
>;

/**
 * Enter API key directly, or select a stored secret
 */
export const OutputHoneycombAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter API key directly, or select a stored secret
 */
export type OutputHoneycombAuthenticationMethod = OpenEnum<
  typeof OutputHoneycombAuthenticationMethod
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputHoneycombCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputHoneycombCompression = OpenEnum<
  typeof OutputHoneycombCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputHoneycombQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputHoneycombQueueFullBehavior = OpenEnum<
  typeof OutputHoneycombQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputHoneycombMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputHoneycombMode = OpenEnum<typeof OutputHoneycombMode>;

export type OutputHoneycombPqControls = {};

export type OutputHoneycomb = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputHoneycombType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the dataset to send events to – e.g., observability
   */
  dataset: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputHoneycombExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputHoneycombFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputHoneycombResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputHoneycombTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputHoneycombBackpressureBehavior | undefined;
  /**
   * Enter API key directly, or select a stored secret
   */
  authType?: OutputHoneycombAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputHoneycombCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputHoneycombQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputHoneycombMode | undefined;
  pqControls?: OutputHoneycombPqControls | undefined;
  /**
   * Team API key where the dataset belongs
   */
  team?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const OutputKinesisType = {
  Kinesis: "kinesis",
} as const;
export type OutputKinesisType = OpenEnum<typeof OutputKinesisType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputKinesisAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputKinesisAuthenticationMethod = OpenEnum<
  typeof OutputKinesisAuthenticationMethod
>;

/**
 * Signature version to use for signing Kinesis stream requests
 */
export const OutputKinesisSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Kinesis stream requests
 */
export type OutputKinesisSignatureVersion = OpenEnum<
  typeof OutputKinesisSignatureVersion
>;

/**
 * Compression type to use for records
 */
export const OutputKinesisCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Compression type to use for records
 */
export type OutputKinesisCompression = OpenEnum<
  typeof OutputKinesisCompression
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputKinesisBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputKinesisBackpressureBehavior = OpenEnum<
  typeof OutputKinesisBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputKinesisPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputKinesisPqCompressCompression = OpenEnum<
  typeof OutputKinesisPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputKinesisQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputKinesisQueueFullBehavior = OpenEnum<
  typeof OutputKinesisQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputKinesisMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputKinesisMode = OpenEnum<typeof OutputKinesisMode>;

export type OutputKinesisPqControls = {};

export type OutputKinesis = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputKinesisType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Kinesis stream name to send events to.
   */
  streamName: string;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputKinesisAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: OutputKinesisSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Maximum number of ongoing put requests before blocking.
   */
  concurrency?: number | undefined;
  /**
   * Maximum size (KB) of each individual record before compression. For uncompressed or non-compressible data 1MB is the max recommended size
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Compression type to use for records
   */
  compression?: OutputKinesisCompression | undefined;
  /**
   * Provides higher stream rate limits, improving delivery speed and reliability by minimizing throttling. See the [ListShards API](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_ListShards.html) documentation for details.
   */
  useListShards?: boolean | undefined;
  /**
   * Batch events into a single record as NDJSON
   */
  asNdjson?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputKinesisBackpressureBehavior | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputKinesisPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputKinesisQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputKinesisMode | undefined;
  pqControls?: OutputKinesisPqControls | undefined;
};

export const OutputAzureLogsType = {
  AzureLogs: "azure_logs",
} as const;
export type OutputAzureLogsType = OpenEnum<typeof OutputAzureLogsType>;

export type OutputAzureLogsExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputAzureLogsFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputAzureLogsFailedRequestLoggingMode = OpenEnum<
  typeof OutputAzureLogsFailedRequestLoggingMode
>;

export type OutputAzureLogsResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputAzureLogsTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputAzureLogsBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputAzureLogsBackpressureBehavior = OpenEnum<
  typeof OutputAzureLogsBackpressureBehavior
>;

/**
 * Enter workspace ID and workspace key directly, or select a stored secret
 */
export const OutputAzureLogsAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter workspace ID and workspace key directly, or select a stored secret
 */
export type OutputAzureLogsAuthenticationMethod = OpenEnum<
  typeof OutputAzureLogsAuthenticationMethod
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputAzureLogsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputAzureLogsCompression = OpenEnum<
  typeof OutputAzureLogsCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputAzureLogsQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputAzureLogsQueueFullBehavior = OpenEnum<
  typeof OutputAzureLogsQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputAzureLogsMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputAzureLogsMode = OpenEnum<typeof OutputAzureLogsMode>;

export type OutputAzureLogsPqControls = {};

export type OutputAzureLogs = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputAzureLogsType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The Log Type of events sent to this LogAnalytics workspace. Defaults to `Cribl`. Use only letters, numbers, and `_` characters, and can't exceed 100 characters. Can be overwritten by event field __logType.
   */
  logType?: string | undefined;
  /**
   * Optional Resource ID of the Azure resource to associate the data with. Can be overridden by the __resourceId event field. This ID populates the _ResourceId property, allowing the data to be included in resource-centric queries. If the ID is neither specified nor overridden, resource-centric queries will omit the data.
   */
  resourceId?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputAzureLogsExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputAzureLogsFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * The DNS name of the Log API endpoint that sends log data to a Log Analytics workspace in Azure Monitor. Defaults to .ods.opinsights.azure.com. @{product} will add a prefix and suffix to construct a URI in this format: <https://<Workspace_ID><your_DNS_name>/api/logs?api-version=<API version>.
   */
  apiUrl?: string | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputAzureLogsResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputAzureLogsTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputAzureLogsBackpressureBehavior | undefined;
  /**
   * Enter workspace ID and workspace key directly, or select a stored secret
   */
  authType?: OutputAzureLogsAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputAzureLogsCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputAzureLogsQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputAzureLogsMode | undefined;
  pqControls?: OutputAzureLogsPqControls | undefined;
  /**
   * Azure Log Analytics Workspace ID. See Azure Dashboard Workspace > Advanced settings.
   */
  workspaceId?: string | undefined;
  /**
   * Azure Log Analytics Workspace Primary or Secondary Shared Key. See Azure Dashboard Workspace > Advanced settings.
   */
  workspaceKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  keypairSecret?: string | undefined;
};

export const OutputAzureDataExplorerType = {
  AzureDataExplorer: "azure_data_explorer",
} as const;
export type OutputAzureDataExplorerType = OpenEnum<
  typeof OutputAzureDataExplorerType
>;

export const IngestionMode = {
  Batching: "batching",
  Streaming: "streaming",
} as const;
export type IngestionMode = OpenEnum<typeof IngestionMode>;

/**
 * Endpoint used to acquire authentication tokens from Azure
 */
export const MicrosoftEntraIDAuthenticationEndpoint = {
  HttpsLoginMicrosoftonlineCom: "https://login.microsoftonline.com",
  HttpsLoginMicrosoftonlineUs: "https://login.microsoftonline.us",
  HttpsLoginPartnerMicrosoftonlineCn:
    "https://login.partner.microsoftonline.cn",
} as const;
/**
 * Endpoint used to acquire authentication tokens from Azure
 */
export type MicrosoftEntraIDAuthenticationEndpoint = OpenEnum<
  typeof MicrosoftEntraIDAuthenticationEndpoint
>;

/**
 * The type of OAuth 2.0 client credentials grant flow to use
 */
export const OutputAzureDataExplorerAuthenticationMethod = {
  ClientSecret: "clientSecret",
  ClientTextSecret: "clientTextSecret",
  Certificate: "certificate",
} as const;
/**
 * The type of OAuth 2.0 client credentials grant flow to use
 */
export type OutputAzureDataExplorerAuthenticationMethod = OpenEnum<
  typeof OutputAzureDataExplorerAuthenticationMethod
>;

export type OutputAzureDataExplorerCertificate = {
  /**
   * The certificate you registered as credentials for your app in the Azure portal
   */
  certificateName?: string | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputAzureDataExplorerBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputAzureDataExplorerBackpressureBehavior = OpenEnum<
  typeof OutputAzureDataExplorerBackpressureBehavior
>;

/**
 * Format of the output data
 */
export const OutputAzureDataExplorerDataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputAzureDataExplorerDataFormat = OpenEnum<
  typeof OutputAzureDataExplorerDataFormat
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputAzureDataExplorerDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputAzureDataExplorerDiskSpaceProtection = OpenEnum<
  typeof OutputAzureDataExplorerDiskSpaceProtection
>;

export const PrefixOptional = {
  DropBy: "dropBy",
  IngestBy: "ingestBy",
} as const;
export type PrefixOptional = OpenEnum<typeof PrefixOptional>;

export type ExtentTag = {
  prefix?: PrefixOptional | undefined;
  value: string;
};

export type IngestIfNotExist = {
  value: string;
};

/**
 * Level of ingestion status reporting. Defaults to FailuresOnly.
 */
export const ReportLevel = {
  FailuresOnly: "failuresOnly",
  DoNotReport: "doNotReport",
  FailuresAndSuccesses: "failuresAndSuccesses",
} as const;
/**
 * Level of ingestion status reporting. Defaults to FailuresOnly.
 */
export type ReportLevel = OpenEnum<typeof ReportLevel>;

/**
 * Target of the ingestion status reporting. Defaults to Queue.
 */
export const ReportMethod = {
  Queue: "queue",
  Table: "table",
  QueueAndTable: "queueAndTable",
} as const;
/**
 * Target of the ingestion status reporting. Defaults to Queue.
 */
export type ReportMethod = OpenEnum<typeof ReportMethod>;

export type AdditionalProperty = {
  key: string;
  value: string;
};

export type OutputAzureDataExplorerResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputAzureDataExplorerTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputAzureDataExplorerCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputAzureDataExplorerCompressCompression = OpenEnum<
  typeof OutputAzureDataExplorerCompressCompression
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputAzureDataExplorerPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputAzureDataExplorerPqCompressCompression = OpenEnum<
  typeof OutputAzureDataExplorerPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputAzureDataExplorerQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputAzureDataExplorerQueueFullBehavior = OpenEnum<
  typeof OutputAzureDataExplorerQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputAzureDataExplorerMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputAzureDataExplorerMode = OpenEnum<
  typeof OutputAzureDataExplorerMode
>;

export type OutputAzureDataExplorerPqControls = {};

export type OutputAzureDataExplorer = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputAzureDataExplorerType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The base URI for your cluster. Typically, `https://<cluster>.<region>.kusto.windows.net`.
   */
  clusterUrl: string;
  /**
   * Name of the database containing the table where data will be ingested
   */
  database: string;
  /**
   * Name of the table to ingest data into
   */
  table: string;
  /**
   * When saving or starting the Destination, validate the database name and credentials; also validate table name, except when creating a new table. Disable if your Azure app does not have both the Database Viewer and the Table Viewer role.
   */
  validateDatabaseSettings?: boolean | undefined;
  ingestMode?: IngestionMode | undefined;
  /**
   * Endpoint used to acquire authentication tokens from Azure
   */
  oauthEndpoint?: MicrosoftEntraIDAuthenticationEndpoint | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory
   */
  tenantId: string;
  /**
   * client_id to pass in the OAuth request parameter
   */
  clientId: string;
  /**
   * Scope to pass in the OAuth request parameter
   */
  scope: string;
  /**
   * The type of OAuth 2.0 client credentials grant flow to use
   */
  oauthType?: OutputAzureDataExplorerAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * The client secret that you generated for your app in the Azure portal
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  certificate?: OutputAzureDataExplorerCertificate | undefined;
  /**
   * The ingestion service URI for your cluster. Typically, `https://ingest-<cluster>.<region>.kusto.windows.net`.
   */
  ingestUrl?: string | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputAzureDataExplorerBackpressureBehavior | undefined;
  /**
   * Send a JSON mapping object instead of specifying an existing named data mapping
   */
  isMappingObj?: boolean | undefined;
  /**
   * Format of the output data
   */
  format?: OutputAzureDataExplorerDataFormat | undefined;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?:
    | OutputAzureDataExplorerDiskSpaceProtection
    | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Bypass the data management service's aggregation mechanism
   */
  flushImmediately?: boolean | undefined;
  /**
   * Prevent blob deletion after ingestion is complete
   */
  retainBlobOnSuccess?: boolean | undefined;
  /**
   * Strings or tags associated with the extent (ingested data shard)
   */
  extentTags?: Array<ExtentTag> | undefined;
  /**
   * Prevents duplicate ingestion by verifying whether an extent with the specified ingest-by tag already exists
   */
  ingestIfNotExists?: Array<IngestIfNotExist> | undefined;
  /**
   * Level of ingestion status reporting. Defaults to FailuresOnly.
   */
  reportLevel?: ReportLevel | undefined;
  /**
   * Target of the ingestion status reporting. Defaults to Queue.
   */
  reportMethod?: ReportMethod | undefined;
  /**
   * Optionally, enter additional configuration properties to send to the ingestion service
   */
  additionalProperties?: Array<AdditionalProperty> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputAzureDataExplorerResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?:
    | OutputAzureDataExplorerTimeoutRetrySettings
    | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputAzureDataExplorerCompressCompression | undefined;
  /**
   * Enter the name of a data mapping associated with your target table. Or, if incoming event and target table fields match exactly, you can leave the field empty.
   */
  mappingRef?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputAzureDataExplorerPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputAzureDataExplorerQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputAzureDataExplorerMode | undefined;
  pqControls?: OutputAzureDataExplorerPqControls | undefined;
};

export const OutputAzureBlobType = {
  AzureBlob: "azure_blob",
} as const;
export type OutputAzureBlobType = OpenEnum<typeof OutputAzureBlobType>;

/**
 * Format of the output data
 */
export const OutputAzureBlobDataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputAzureBlobDataFormat = OpenEnum<
  typeof OutputAzureBlobDataFormat
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputAzureBlobBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputAzureBlobBackpressureBehavior = OpenEnum<
  typeof OutputAzureBlobBackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputAzureBlobDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputAzureBlobDiskSpaceProtection = OpenEnum<
  typeof OutputAzureBlobDiskSpaceProtection
>;

export const OutputAzureBlobAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  ClientSecret: "clientSecret",
  ClientCert: "clientCert",
} as const;
export type OutputAzureBlobAuthenticationMethod = OpenEnum<
  typeof OutputAzureBlobAuthenticationMethod
>;

export const BlobAccessTier = {
  Inferred: "Inferred",
  Hot: "Hot",
  Cool: "Cool",
  Cold: "Cold",
  Archive: "Archive",
} as const;
export type BlobAccessTier = OpenEnum<typeof BlobAccessTier>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputAzureBlobCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputAzureBlobCompression = OpenEnum<
  typeof OutputAzureBlobCompression
>;

/**
 * Compression level to apply before moving files to final destination
 */
export const OutputAzureBlobCompressionLevel = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type OutputAzureBlobCompressionLevel = OpenEnum<
  typeof OutputAzureBlobCompressionLevel
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputAzureBlobParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputAzureBlobParquetVersion = OpenEnum<
  typeof OutputAzureBlobParquetVersion
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputAzureBlobDataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputAzureBlobDataPageVersion = OpenEnum<
  typeof OutputAzureBlobDataPageVersion
>;

export type OutputAzureBlobKeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputAzureBlobCertificate = {
  /**
   * The certificate you registered as credentials for your app in the Azure portal
   */
  certificateName: string;
};

export type OutputAzureBlob = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputAzureBlobType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env["CRIBL_WORKER_ID"]}`.
   */
  containerName: string;
  /**
   * Create the configured container in Azure Blob Storage if it does not already exist
   */
  createContainer?: boolean | undefined;
  /**
   * Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env["CRIBL_WORKER_ID"]}`.
   */
  destPath?: string | undefined;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Maximum number of parts to upload in parallel per file
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: OutputAzureBlobDataFormat | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputAzureBlobBackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputAzureBlobDiskSpaceProtection | undefined;
  authType?: OutputAzureBlobAuthenticationMethod | undefined;
  storageClass?: BlobAccessTier | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputAzureBlobCompression | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: OutputAzureBlobCompressionLevel | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputAzureBlobParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputAzureBlobDataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<OutputAzureBlobKeyValueMetadatum> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: OutputAzureBlobCertificate | undefined;
};

export const OutputS3Type = {
  S3: "s3",
} as const;
export type OutputS3Type = OpenEnum<typeof OutputS3Type>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputS3AuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputS3AuthenticationMethod = OpenEnum<
  typeof OutputS3AuthenticationMethod
>;

/**
 * Signature version to use for signing S3 requests
 */
export const OutputS3SignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type OutputS3SignatureVersion = OpenEnum<
  typeof OutputS3SignatureVersion
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const OutputS3ObjectACL = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type OutputS3ObjectACL = OpenEnum<typeof OutputS3ObjectACL>;

/**
 * Storage class to select for uploaded objects
 */
export const OutputS3StorageClass = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
  StandardIa: "STANDARD_IA",
  OnezoneIa: "ONEZONE_IA",
  IntelligentTiering: "INTELLIGENT_TIERING",
  Glacier: "GLACIER",
  GlacierIr: "GLACIER_IR",
  DeepArchive: "DEEP_ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type OutputS3StorageClass = OpenEnum<typeof OutputS3StorageClass>;

export const OutputS3ServerSideEncryptionForUploadedObjects = {
  Aes256: "AES256",
  AwsKms: "aws:kms",
} as const;
export type OutputS3ServerSideEncryptionForUploadedObjects = OpenEnum<
  typeof OutputS3ServerSideEncryptionForUploadedObjects
>;

/**
 * Format of the output data
 */
export const OutputS3DataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputS3DataFormat = OpenEnum<typeof OutputS3DataFormat>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputS3BackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputS3BackpressureBehavior = OpenEnum<
  typeof OutputS3BackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputS3DiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputS3DiskSpaceProtection = OpenEnum<
  typeof OutputS3DiskSpaceProtection
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputS3Compression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputS3Compression = OpenEnum<typeof OutputS3Compression>;

/**
 * Compression level to apply before moving files to final destination
 */
export const OutputS3CompressionLevel = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type OutputS3CompressionLevel = OpenEnum<
  typeof OutputS3CompressionLevel
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputS3ParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputS3ParquetVersion = OpenEnum<typeof OutputS3ParquetVersion>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputS3DataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputS3DataPageVersion = OpenEnum<typeof OutputS3DataPageVersion>;

export type OutputS3KeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputS3 = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputS3Type | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * Region where the S3 bucket is located
   */
  region?: string | undefined;
  /**
   * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
   */
  awsSecretKey?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputS3AuthenticationMethod | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: OutputS3SignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`
   */
  destPath?: string | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: OutputS3ObjectACL | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: OutputS3StorageClass | undefined;
  serverSideEncryption?:
    | OutputS3ServerSideEncryptionForUploadedObjects
    | undefined;
  /**
   * ID or ARN of the KMS customer-managed key to use for encryption
   */
  kmsKeyId?: string | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: OutputS3DataFormat | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputS3BackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputS3DiskSpaceProtection | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Maximum number of files that can be waiting for upload before backpressure is applied
   */
  maxClosingFilesToBackpressure?: number | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputS3Compression | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: OutputS3CompressionLevel | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputS3ParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputS3DataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<OutputS3KeyValueMetadatum> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const OutputFilesystemType = {
  Filesystem: "filesystem",
} as const;
export type OutputFilesystemType = OpenEnum<typeof OutputFilesystemType>;

/**
 * Format of the output data
 */
export const OutputFilesystemDataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputFilesystemDataFormat = OpenEnum<
  typeof OutputFilesystemDataFormat
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputFilesystemBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputFilesystemBackpressureBehavior = OpenEnum<
  typeof OutputFilesystemBackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputFilesystemDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputFilesystemDiskSpaceProtection = OpenEnum<
  typeof OutputFilesystemDiskSpaceProtection
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputFilesystemCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputFilesystemCompression = OpenEnum<
  typeof OutputFilesystemCompression
>;

/**
 * Compression level to apply before moving files to final destination
 */
export const OutputFilesystemCompressionLevel = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type OutputFilesystemCompressionLevel = OpenEnum<
  typeof OutputFilesystemCompressionLevel
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputFilesystemParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputFilesystemParquetVersion = OpenEnum<
  typeof OutputFilesystemParquetVersion
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputFilesystemDataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputFilesystemDataPageVersion = OpenEnum<
  typeof OutputFilesystemDataPageVersion
>;

export type OutputFilesystemKeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputFilesystem = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputFilesystemType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Final destination for the output files
   */
  destPath: string;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: OutputFilesystemDataFormat | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputFilesystemBackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputFilesystemDiskSpaceProtection | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputFilesystemCompression | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: OutputFilesystemCompressionLevel | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputFilesystemParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputFilesystemDataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<OutputFilesystemKeyValueMetadatum> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const OutputSignalfxType = {
  Signalfx: "signalfx",
} as const;
export type OutputSignalfxType = OpenEnum<typeof OutputSignalfxType>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const OutputSignalfxAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type OutputSignalfxAuthenticationMethod = OpenEnum<
  typeof OutputSignalfxAuthenticationMethod
>;

export type OutputSignalfxExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputSignalfxFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputSignalfxFailedRequestLoggingMode = OpenEnum<
  typeof OutputSignalfxFailedRequestLoggingMode
>;

export type OutputSignalfxResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputSignalfxTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSignalfxBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSignalfxBackpressureBehavior = OpenEnum<
  typeof OutputSignalfxBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputSignalfxCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSignalfxCompression = OpenEnum<
  typeof OutputSignalfxCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSignalfxQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSignalfxQueueFullBehavior = OpenEnum<
  typeof OutputSignalfxQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSignalfxMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSignalfxMode = OpenEnum<typeof OutputSignalfxMode>;

export type OutputSignalfxPqControls = {};

export type OutputSignalfx = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputSignalfxType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: OutputSignalfxAuthenticationMethod | undefined;
  /**
   * SignalFx realm name, e.g. "us0". For a complete list of available SignalFx realm names, please check [here](https://docs.splunk.com/observability/en/get-started/service-description.html#sd-regions).
   */
  realm?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputSignalfxExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: OutputSignalfxFailedRequestLoggingMode | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<OutputSignalfxResponseRetrySetting> | undefined;
  timeoutRetrySettings?: OutputSignalfxTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSignalfxBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * SignalFx API access token (see [here](https://docs.signalfx.com/en/latest/admin-guide/tokens.html#working-with-access-tokens))
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSignalfxCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSignalfxQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSignalfxMode | undefined;
  pqControls?: OutputSignalfxPqControls | undefined;
};

export const OutputWavefrontType = {
  Wavefront: "wavefront",
} as const;
export type OutputWavefrontType = OpenEnum<typeof OutputWavefrontType>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const OutputWavefrontAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type OutputWavefrontAuthenticationMethod = OpenEnum<
  typeof OutputWavefrontAuthenticationMethod
>;

export type OutputWavefrontExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputWavefrontFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputWavefrontFailedRequestLoggingMode = OpenEnum<
  typeof OutputWavefrontFailedRequestLoggingMode
>;

export type OutputWavefrontResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputWavefrontTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputWavefrontBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputWavefrontBackpressureBehavior = OpenEnum<
  typeof OutputWavefrontBackpressureBehavior
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputWavefrontCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputWavefrontCompression = OpenEnum<
  typeof OutputWavefrontCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputWavefrontQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputWavefrontQueueFullBehavior = OpenEnum<
  typeof OutputWavefrontQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputWavefrontMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputWavefrontMode = OpenEnum<typeof OutputWavefrontMode>;

export type OutputWavefrontPqControls = {};

export type OutputWavefront = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputWavefrontType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: OutputWavefrontAuthenticationMethod | undefined;
  /**
   * WaveFront domain name, e.g. "longboard"
   */
  domain?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<OutputWavefrontExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | OutputWavefrontFailedRequestLoggingMode
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<OutputWavefrontResponseRetrySetting>
    | undefined;
  timeoutRetrySettings?: OutputWavefrontTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputWavefrontBackpressureBehavior | undefined;
  description?: string | undefined;
  /**
   * WaveFront API authentication token (see [here](https://docs.wavefront.com/wavefront_api.html#generating-an-api-token))
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputWavefrontCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputWavefrontQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputWavefrontMode | undefined;
  pqControls?: OutputWavefrontPqControls | undefined;
};

export const OutputSplunkLbType = {
  SplunkLb: "splunk_lb",
} as const;
export type OutputSplunkLbType = OpenEnum<typeof OutputSplunkLbType>;

/**
 * How to serialize nested fields into index-time fields
 */
export const OutputSplunkLbNestedFieldSerialization = {
  Json: "json",
  None: "none",
} as const;
/**
 * How to serialize nested fields into index-time fields
 */
export type OutputSplunkLbNestedFieldSerialization = OpenEnum<
  typeof OutputSplunkLbNestedFieldSerialization
>;

export const OutputSplunkLbMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputSplunkLbMinimumTLSVersion = OpenEnum<
  typeof OutputSplunkLbMinimumTLSVersion
>;

export const OutputSplunkLbMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputSplunkLbMaximumTLSVersion = OpenEnum<
  typeof OutputSplunkLbMaximumTLSVersion
>;

export type OutputSplunkLbTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputSplunkLbMinimumTLSVersion | undefined;
  maxVersion?: OutputSplunkLbMaximumTLSVersion | undefined;
};

/**
 * The highest S2S protocol version to advertise during handshake
 */
export const OutputSplunkLbMaxS2SVersion = {
  V3: "v3",
  V4: "v4",
} as const;
/**
 * The highest S2S protocol version to advertise during handshake
 */
export type OutputSplunkLbMaxS2SVersion = OpenEnum<
  typeof OutputSplunkLbMaxS2SVersion
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSplunkLbBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSplunkLbBackpressureBehavior = OpenEnum<
  typeof OutputSplunkLbBackpressureBehavior
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const OutputSplunkLbAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type OutputSplunkLbAuthenticationMethod = OpenEnum<
  typeof OutputSplunkLbAuthenticationMethod
>;

/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export const OutputSplunkLbCompressCompression = {
  Disabled: "disabled",
  Auto: "auto",
  Always: "always",
} as const;
/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export type OutputSplunkLbCompressCompression = OpenEnum<
  typeof OutputSplunkLbCompressCompression
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const IndexerDiscoveryConfigsAuthTokenAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type IndexerDiscoveryConfigsAuthTokenAuthenticationMethod = OpenEnum<
  typeof IndexerDiscoveryConfigsAuthTokenAuthenticationMethod
>;

export type CreateOutputAuthToken = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: IndexerDiscoveryConfigsAuthTokenAuthenticationMethod | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const IndexerDiscoveryConfigsAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type IndexerDiscoveryConfigsAuthenticationMethod = OpenEnum<
  typeof IndexerDiscoveryConfigsAuthenticationMethod
>;

/**
 * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
 */
export type IndexerDiscoveryConfigs = {
  /**
   * Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site.
   */
  site?: string | undefined;
  /**
   * Full URI of Splunk cluster manager (scheme://host:port). Example: https://managerAddress:8089
   */
  masterUri: string;
  /**
   * Time interval, in seconds, between two consecutive indexer list fetches from cluster manager
   */
  refreshIntervalSec?: number | undefined;
  /**
   * During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Tokens required to authenticate to cluster manager for indexer discovery
   */
  authTokens?: Array<CreateOutputAuthToken> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: IndexerDiscoveryConfigsAuthenticationMethod | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/**
 * Whether to inherit TLS configs from group setting or disable TLS
 */
export const Tls = {
  Inherit: "inherit",
  Off: "off",
} as const;
/**
 * Whether to inherit TLS configs from group setting or disable TLS
 */
export type Tls = OpenEnum<typeof Tls>;

export type OutputSplunkLbHost = {
  /**
   * The hostname of the receiver
   */
  host: string;
  /**
   * The port to connect to on the provided host
   */
  port?: number | undefined;
  /**
   * Whether to inherit TLS configs from group setting or disable TLS
   */
  tls?: Tls | undefined;
  /**
   * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
   */
  servername?: string | undefined;
  /**
   * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
   */
  weight?: number | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const OutputSplunkLbPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSplunkLbPqCompressCompression = OpenEnum<
  typeof OutputSplunkLbPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSplunkLbQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSplunkLbQueueFullBehavior = OpenEnum<
  typeof OutputSplunkLbQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSplunkLbMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSplunkLbMode = OpenEnum<typeof OutputSplunkLbMode>;

export type OutputSplunkLbPqControls = {};

export type OutputSplunkLb = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputSplunkLbType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
   */
  maxConcurrentSenders?: number | undefined;
  /**
   * How to serialize nested fields into index-time fields
   */
  nestedFields?: OutputSplunkLbNestedFieldSerialization | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  tls?: OutputSplunkLbTLSSettingsClientSide | undefined;
  /**
   * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
   */
  enableACK?: boolean | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: OutputSplunkLbMaxS2SVersion | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSplunkLbBackpressureBehavior | undefined;
  /**
   * Automatically discover indexers in indexer clustering environment.
   */
  indexerDiscovery?: boolean | undefined;
  /**
   * How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute.
   */
  senderUnhealthyTimeAllowance?: number | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: OutputSplunkLbAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
   */
  maxFailedHealthChecks?: number | undefined;
  /**
   * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
   */
  compress?: OutputSplunkLbCompressCompression | undefined;
  /**
   * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
   */
  indexerDiscoveryConfigs?: IndexerDiscoveryConfigs | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  /**
   * Set of Splunk indexers to load-balance data to.
   */
  hosts: Array<OutputSplunkLbHost>;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSplunkLbPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSplunkLbQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSplunkLbMode | undefined;
  pqControls?: OutputSplunkLbPqControls | undefined;
  /**
   * Shared secret token to use when establishing a connection to a Splunk indexer.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const OutputSplunkType = {
  Splunk: "splunk",
} as const;
export type OutputSplunkType = OpenEnum<typeof OutputSplunkType>;

/**
 * How to serialize nested fields into index-time fields
 */
export const OutputSplunkNestedFieldSerialization = {
  Json: "json",
  None: "none",
} as const;
/**
 * How to serialize nested fields into index-time fields
 */
export type OutputSplunkNestedFieldSerialization = OpenEnum<
  typeof OutputSplunkNestedFieldSerialization
>;

export const OutputSplunkMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputSplunkMinimumTLSVersion = OpenEnum<
  typeof OutputSplunkMinimumTLSVersion
>;

export const OutputSplunkMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type OutputSplunkMaximumTLSVersion = OpenEnum<
  typeof OutputSplunkMaximumTLSVersion
>;

export type OutputSplunkTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: OutputSplunkMinimumTLSVersion | undefined;
  maxVersion?: OutputSplunkMaximumTLSVersion | undefined;
};

/**
 * The highest S2S protocol version to advertise during handshake
 */
export const OutputSplunkMaxS2SVersion = {
  V3: "v3",
  V4: "v4",
} as const;
/**
 * The highest S2S protocol version to advertise during handshake
 */
export type OutputSplunkMaxS2SVersion = OpenEnum<
  typeof OutputSplunkMaxS2SVersion
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSplunkBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSplunkBackpressureBehavior = OpenEnum<
  typeof OutputSplunkBackpressureBehavior
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const OutputSplunkAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type OutputSplunkAuthenticationMethod = OpenEnum<
  typeof OutputSplunkAuthenticationMethod
>;

/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export const OutputSplunkCompressCompression = {
  Disabled: "disabled",
  Auto: "auto",
  Always: "always",
} as const;
/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export type OutputSplunkCompressCompression = OpenEnum<
  typeof OutputSplunkCompressCompression
>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputSplunkPqCompressCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSplunkPqCompressCompression = OpenEnum<
  typeof OutputSplunkPqCompressCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSplunkQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSplunkQueueFullBehavior = OpenEnum<
  typeof OutputSplunkQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSplunkMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSplunkMode = OpenEnum<typeof OutputSplunkMode>;

export type OutputSplunkPqControls = {};

export type OutputSplunk = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputSplunkType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The hostname of the receiver
   */
  host: string;
  /**
   * The port to connect to on the provided host
   */
  port?: number | undefined;
  /**
   * How to serialize nested fields into index-time fields
   */
  nestedFields?: OutputSplunkNestedFieldSerialization | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  tls?: OutputSplunkTLSSettingsClientSide | undefined;
  /**
   * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
   */
  enableACK?: boolean | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: OutputSplunkMaxS2SVersion | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSplunkBackpressureBehavior | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: OutputSplunkAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
   */
  maxFailedHealthChecks?: number | undefined;
  /**
   * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
   */
  compress?: OutputSplunkCompressCompression | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSplunkPqCompressCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSplunkQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSplunkMode | undefined;
  pqControls?: OutputSplunkPqControls | undefined;
  /**
   * Shared secret token to use when establishing a connection to a Splunk indexer.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const OutputSentinelType = {
  Sentinel: "sentinel",
} as const;
export type OutputSentinelType = OpenEnum<typeof OutputSentinelType>;

export type OutputSentinelExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const OutputSentinelFailedRequestLoggingMode = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type OutputSentinelFailedRequestLoggingMode = OpenEnum<
  typeof OutputSentinelFailedRequestLoggingMode
>;

export type OutputSentinelResponseRetrySetting = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type OutputSentinelTimeoutRetrySettings = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputSentinelBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputSentinelBackpressureBehavior = OpenEnum<
  typeof OutputSentinelBackpressureBehavior
>;

export const AuthType = {
  Oauth: "oauth",
} as const;
export type AuthType = OpenEnum<typeof AuthType>;

/**
 * Enter the data collection endpoint URL or the individual ID
 */
export const EndpointConfiguration = {
  Url: "url",
  Id: "ID",
} as const;
/**
 * Enter the data collection endpoint URL or the individual ID
 */
export type EndpointConfiguration = OpenEnum<typeof EndpointConfiguration>;

export const OutputSentinelFormat = {
  Ndjson: "ndjson",
  JsonArray: "json_array",
  Custom: "custom",
  Advanced: "advanced",
} as const;
export type OutputSentinelFormat = OpenEnum<typeof OutputSentinelFormat>;

/**
 * Codec to use to compress the persisted data
 */
export const OutputSentinelCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type OutputSentinelCompression = OpenEnum<
  typeof OutputSentinelCompression
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const OutputSentinelQueueFullBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type OutputSentinelQueueFullBehavior = OpenEnum<
  typeof OutputSentinelQueueFullBehavior
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const OutputSentinelMode = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type OutputSentinelMode = OpenEnum<typeof OutputSentinelMode>;

export type OutputSentinelPqControls = {};

export type OutputSentinel = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputSentinelType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size (KB) of the request body (defaults to the API's maximum limit of 1000 KB)
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<OutputSentinelExtraHttpHeader> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: OutputSentinelFailedRequestLoggingMode | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<OutputSentinelResponseRetrySetting> | undefined;
  timeoutRetrySettings?: OutputSentinelTimeoutRetrySettings | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputSentinelBackpressureBehavior | undefined;
  authType?: AuthType | undefined;
  /**
   * URL for OAuth
   */
  loginUrl: string;
  /**
   * Secret parameter value to pass in request body
   */
  secret: string;
  /**
   * JavaScript expression to compute the Client ID for the Azure application. Can be a constant.
   */
  clientId: string;
  /**
   * Scope to pass in the OAuth request
   */
  scope?: string | undefined;
  /**
   * Enter the data collection endpoint URL or the individual ID
   */
  endpointURLConfiguration?: EndpointConfiguration | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  format?: OutputSentinelFormat | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: OutputSentinelCompression | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: OutputSentinelQueueFullBehavior | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: OutputSentinelMode | undefined;
  pqControls?: OutputSentinelPqControls | undefined;
  /**
   * URL to send events to. Can be overwritten by an event's __url field.
   */
  url?: string | undefined;
  /**
   * Immutable ID for the Data Collection Rule (DCR)
   */
  dcrID?: string | undefined;
  /**
   * Data collection endpoint (DCE) URL. In the format: `https://<Endpoint-Name>-<Identifier>.<Region>.ingest.monitor.azure.com`
   */
  dceEndpoint?: string | undefined;
  /**
   * The name of the stream (Sentinel table) in which to store the events
   */
  streamName?: string | undefined;
};

export const OutputDefaultType = {
  Default: "default",
} as const;
export type OutputDefaultType = OpenEnum<typeof OutputDefaultType>;

export type OutputDefault = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: OutputDefaultType;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.
   */
  defaultId: string;
};

/**
 * New Destination object
 */
export type CreateOutputRequest =
  | OutputAzureDataExplorer
  | OutputSecurityLake
  | OutputSentinel
  | OutputGoogleCloudLogging
  | OutputExabeam
  | OutputMsk
  | OutputCloudwatch
  | OutputClickHouse
  | OutputDefault
  | OutputSplunkLb
  | OutputFilesystem
  | OutputKinesis
  | OutputHoneycomb
  | OutputAzureEventhub
  | OutputGoogleCloudStorage
  | OutputGooglePubsub
  | OutputKafka
  | OutputConfluentCloud
  | OutputElastic
  | OutputElasticCloud
  | OutputNewrelicEvents
  | OutputInfluxdb
  | OutputMinio
  | OutputRouter
  | OutputSns
  | OutputSnmp
  | OutputSumoLogic
  | OutputLoki
  | OutputPrometheus
  | OutputOpenTelemetry
  | OutputNetflow
  | models.OutputWebhook
  | models.OutputDevnull
  | models.OutputSyslog
  | OutputSplunk
  | models.OutputSplunkHec
  | models.OutputTcpjson
  | OutputWavefront
  | OutputSignalfx
  | OutputS3
  | OutputAzureBlob
  | OutputAzureLogs
  | OutputGoogleChronicle
  | models.OutputNewrelic
  | OutputStatsd
  | OutputStatsdExt
  | OutputGraphite
  | OutputSqs
  | models.OutputDatadog
  | models.OutputRing
  | OutputServiceNow
  | models.OutputDataset
  | models.OutputCriblTcp
  | models.OutputCriblHttp
  | OutputCrowdstrikeNextGenSiem
  | OutputDlS3
  | models.OutputCriblLake
  | models.OutputDiskSpool
  | models.OutputXsiam
  | OutputDynatraceOtlp
  | OutputHumioHec
  | OutputDynatraceHttp
  | OutputSentinelOneAiSiem
  | models.OutputGrafanaCloudUnion;

/**
 * a list of Destination objects
 */
export type CreateOutputResponse = {
  /**
   * number of items present in the items array
   */
  count?: number | undefined;
  items?: Array<models.Output> | undefined;
};

/** @internal */
export const OutputSentinelOneAiSiemType$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiemType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelOneAiSiemType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelOneAiSiemType$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiemType,
  z.ZodTypeDef,
  OutputSentinelOneAiSiemType
> = z.union([
  z.nativeEnum(OutputSentinelOneAiSiemType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemType$ {
  /** @deprecated use `OutputSentinelOneAiSiemType$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelOneAiSiemType$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemType$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelOneAiSiemType$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemRegion$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiemRegion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelOneAiSiemRegion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelOneAiSiemRegion$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiemRegion,
  z.ZodTypeDef,
  OutputSentinelOneAiSiemRegion
> = z.union([
  z.nativeEnum(OutputSentinelOneAiSiemRegion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemRegion$ {
  /** @deprecated use `OutputSentinelOneAiSiemRegion$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelOneAiSiemRegion$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemRegion$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelOneAiSiemRegion$outboundSchema;
}

/** @internal */
export const AISIEMEndpointPath$inboundSchema: z.ZodType<
  AISIEMEndpointPath,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AISIEMEndpointPath),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AISIEMEndpointPath$outboundSchema: z.ZodType<
  AISIEMEndpointPath,
  z.ZodTypeDef,
  AISIEMEndpointPath
> = z.union([
  z.nativeEnum(AISIEMEndpointPath),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AISIEMEndpointPath$ {
  /** @deprecated use `AISIEMEndpointPath$inboundSchema` instead. */
  export const inboundSchema = AISIEMEndpointPath$inboundSchema;
  /** @deprecated use `AISIEMEndpointPath$outboundSchema` instead. */
  export const outboundSchema = AISIEMEndpointPath$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemExtraHttpHeader$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiemExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputSentinelOneAiSiemExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputSentinelOneAiSiemExtraHttpHeader$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiemExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputSentinelOneAiSiemExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemExtraHttpHeader$ {
  /** @deprecated use `OutputSentinelOneAiSiemExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelOneAiSiemExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputSentinelOneAiSiemExtraHttpHeader$Outbound;
}

export function outputSentinelOneAiSiemExtraHttpHeaderToJSON(
  outputSentinelOneAiSiemExtraHttpHeader:
    OutputSentinelOneAiSiemExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputSentinelOneAiSiemExtraHttpHeader$outboundSchema.parse(
      outputSentinelOneAiSiemExtraHttpHeader,
    ),
  );
}

export function outputSentinelOneAiSiemExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelOneAiSiemExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSentinelOneAiSiemExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelOneAiSiemExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputSentinelOneAiSiemFailedRequestLoggingMode$inboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemFailedRequestLoggingMode,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputSentinelOneAiSiemFailedRequestLoggingMode),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputSentinelOneAiSiemFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputSentinelOneAiSiemFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputSentinelOneAiSiemFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemFailedRequestLoggingMode$ {
  /** @deprecated use `OutputSentinelOneAiSiemFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelOneAiSiemFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemAuthenticationMethod$inboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputSentinelOneAiSiemAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputSentinelOneAiSiemAuthenticationMethod$outboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemAuthenticationMethod,
    z.ZodTypeDef,
    OutputSentinelOneAiSiemAuthenticationMethod
  > = z.union([
    z.nativeEnum(OutputSentinelOneAiSiemAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemAuthenticationMethod$ {
  /** @deprecated use `OutputSentinelOneAiSiemAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelOneAiSiemAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemResponseRetrySetting$inboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemResponseRetrySetting,
    z.ZodTypeDef,
    unknown
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/** @internal */
export type OutputSentinelOneAiSiemResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSentinelOneAiSiemResponseRetrySetting$outboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemResponseRetrySetting$Outbound,
    z.ZodTypeDef,
    OutputSentinelOneAiSiemResponseRetrySetting
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemResponseRetrySetting$ {
  /** @deprecated use `OutputSentinelOneAiSiemResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelOneAiSiemResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputSentinelOneAiSiemResponseRetrySetting$Outbound;
}

export function outputSentinelOneAiSiemResponseRetrySettingToJSON(
  outputSentinelOneAiSiemResponseRetrySetting:
    OutputSentinelOneAiSiemResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputSentinelOneAiSiemResponseRetrySetting$outboundSchema.parse(
      outputSentinelOneAiSiemResponseRetrySetting,
    ),
  );
}

export function outputSentinelOneAiSiemResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputSentinelOneAiSiemResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSentinelOneAiSiemResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputSentinelOneAiSiemResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputSentinelOneAiSiemTimeoutRetrySettings$inboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemTimeoutRetrySettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/** @internal */
export type OutputSentinelOneAiSiemTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSentinelOneAiSiemTimeoutRetrySettings$outboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemTimeoutRetrySettings$Outbound,
    z.ZodTypeDef,
    OutputSentinelOneAiSiemTimeoutRetrySettings
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemTimeoutRetrySettings$ {
  /** @deprecated use `OutputSentinelOneAiSiemTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelOneAiSiemTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputSentinelOneAiSiemTimeoutRetrySettings$Outbound;
}

export function outputSentinelOneAiSiemTimeoutRetrySettingsToJSON(
  outputSentinelOneAiSiemTimeoutRetrySettings:
    OutputSentinelOneAiSiemTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputSentinelOneAiSiemTimeoutRetrySettings$outboundSchema.parse(
      outputSentinelOneAiSiemTimeoutRetrySettings,
    ),
  );
}

export function outputSentinelOneAiSiemTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputSentinelOneAiSiemTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSentinelOneAiSiemTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputSentinelOneAiSiemTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputSentinelOneAiSiemBackpressureBehavior$inboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemBackpressureBehavior,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputSentinelOneAiSiemBackpressureBehavior),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputSentinelOneAiSiemBackpressureBehavior$outboundSchema:
  z.ZodType<
    OutputSentinelOneAiSiemBackpressureBehavior,
    z.ZodTypeDef,
    OutputSentinelOneAiSiemBackpressureBehavior
  > = z.union([
    z.nativeEnum(OutputSentinelOneAiSiemBackpressureBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemBackpressureBehavior$ {
  /** @deprecated use `OutputSentinelOneAiSiemBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelOneAiSiemBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemCompression$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiemCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelOneAiSiemCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelOneAiSiemCompression$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiemCompression,
  z.ZodTypeDef,
  OutputSentinelOneAiSiemCompression
> = z.union([
  z.nativeEnum(OutputSentinelOneAiSiemCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemCompression$ {
  /** @deprecated use `OutputSentinelOneAiSiemCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelOneAiSiemCompression$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemCompression$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiemQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelOneAiSiemQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelOneAiSiemQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiemQueueFullBehavior,
  z.ZodTypeDef,
  OutputSentinelOneAiSiemQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSentinelOneAiSiemQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemQueueFullBehavior$ {
  /** @deprecated use `OutputSentinelOneAiSiemQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelOneAiSiemQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemMode$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiemMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelOneAiSiemMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelOneAiSiemMode$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiemMode,
  z.ZodTypeDef,
  OutputSentinelOneAiSiemMode
> = z.union([
  z.nativeEnum(OutputSentinelOneAiSiemMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemMode$ {
  /** @deprecated use `OutputSentinelOneAiSiemMode$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelOneAiSiemMode$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemMode$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelOneAiSiemMode$outboundSchema;
}

/** @internal */
export const OutputSentinelOneAiSiemPqControls$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiemPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSentinelOneAiSiemPqControls$Outbound = {};

/** @internal */
export const OutputSentinelOneAiSiemPqControls$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiemPqControls$Outbound,
  z.ZodTypeDef,
  OutputSentinelOneAiSiemPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiemPqControls$ {
  /** @deprecated use `OutputSentinelOneAiSiemPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelOneAiSiemPqControls$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemPqControls$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelOneAiSiemPqControls$outboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiemPqControls$Outbound` instead. */
  export type Outbound = OutputSentinelOneAiSiemPqControls$Outbound;
}

export function outputSentinelOneAiSiemPqControlsToJSON(
  outputSentinelOneAiSiemPqControls: OutputSentinelOneAiSiemPqControls,
): string {
  return JSON.stringify(
    OutputSentinelOneAiSiemPqControls$outboundSchema.parse(
      outputSentinelOneAiSiemPqControls,
    ),
  );
}

export function outputSentinelOneAiSiemPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelOneAiSiemPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSentinelOneAiSiemPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelOneAiSiemPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSentinelOneAiSiem$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSentinelOneAiSiemType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: OutputSentinelOneAiSiemRegion$inboundSchema.default("US"),
  endpoint: AISIEMEndpointPath$inboundSchema.default(
    "/services/collector/event",
  ),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(5120),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(5),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSentinelOneAiSiemExtraHttpHeader$inboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    OutputSentinelOneAiSiemFailedRequestLoggingMode$inboundSchema.default(
      "none",
    ),
  safeHeaders: z.array(z.string()).optional(),
  authType: OutputSentinelOneAiSiemAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSentinelOneAiSiemResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSentinelOneAiSiemTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSentinelOneAiSiemBackpressureBehavior$inboundSchema
    .default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  baseUrl: z.string().default("https://<Your-S1-Tenant>.sentinelone.net"),
  hostExpression: z.string().default("__e.host || C.os.hostname()"),
  sourceExpression: z.string().default(
    "__e.source || (__e.__criblMetrics ? 'metrics' : 'cribl')",
  ),
  sourceTypeExpression: z.string().default("__e.sourcetype || 'dottedJson'"),
  dataSourceCategoryExpression: z.string().default("'security'"),
  dataSourceNameExpression: z.string().default(
    "__e.__dataSourceName || 'cribl'",
  ),
  dataSourceVendorExpression: z.string().default(
    "__e.__dataSourceVendor || 'cribl'",
  ),
  eventTypeExpression: z.string().default(""),
  host: z.string().default("C.os.hostname()"),
  source: z.string().default("cribl"),
  sourceType: z.string().default("hecRawParser"),
  dataSourceCategory: z.string().default("security"),
  dataSourceName: z.string().default("cribl"),
  dataSourceVendor: z.string().default("cribl"),
  eventType: z.string().default(""),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSentinelOneAiSiemCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSentinelOneAiSiemQueueFullBehavior$inboundSchema
    .default("block"),
  pqMode: OutputSentinelOneAiSiemMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSentinelOneAiSiemPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputSentinelOneAiSiem$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  region: string;
  endpoint: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputSentinelOneAiSiemExtraHttpHeader$Outbound>
    | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  authType: string;
  responseRetrySettings?:
    | Array<OutputSentinelOneAiSiemResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputSentinelOneAiSiemTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  baseUrl: string;
  hostExpression: string;
  sourceExpression: string;
  sourceTypeExpression: string;
  dataSourceCategoryExpression: string;
  dataSourceNameExpression: string;
  dataSourceVendorExpression: string;
  eventTypeExpression: string;
  host: string;
  source: string;
  sourceType: string;
  dataSourceCategory: string;
  dataSourceName: string;
  dataSourceVendor: string;
  eventType: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSentinelOneAiSiemPqControls$Outbound | undefined;
};

/** @internal */
export const OutputSentinelOneAiSiem$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiem$Outbound,
  z.ZodTypeDef,
  OutputSentinelOneAiSiem
> = z.object({
  id: z.string(),
  type: OutputSentinelOneAiSiemType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: OutputSentinelOneAiSiemRegion$outboundSchema.default("US"),
  endpoint: AISIEMEndpointPath$outboundSchema.default(
    "/services/collector/event",
  ),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(5120),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(5),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSentinelOneAiSiemExtraHttpHeader$outboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    OutputSentinelOneAiSiemFailedRequestLoggingMode$outboundSchema.default(
      "none",
    ),
  safeHeaders: z.array(z.string()).optional(),
  authType: OutputSentinelOneAiSiemAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSentinelOneAiSiemResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSentinelOneAiSiemTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSentinelOneAiSiemBackpressureBehavior$outboundSchema
    .default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  baseUrl: z.string().default("https://<Your-S1-Tenant>.sentinelone.net"),
  hostExpression: z.string().default("__e.host || C.os.hostname()"),
  sourceExpression: z.string().default(
    "__e.source || (__e.__criblMetrics ? 'metrics' : 'cribl')",
  ),
  sourceTypeExpression: z.string().default("__e.sourcetype || 'dottedJson'"),
  dataSourceCategoryExpression: z.string().default("'security'"),
  dataSourceNameExpression: z.string().default(
    "__e.__dataSourceName || 'cribl'",
  ),
  dataSourceVendorExpression: z.string().default(
    "__e.__dataSourceVendor || 'cribl'",
  ),
  eventTypeExpression: z.string().default(""),
  host: z.string().default("C.os.hostname()"),
  source: z.string().default("cribl"),
  sourceType: z.string().default("hecRawParser"),
  dataSourceCategory: z.string().default("security"),
  dataSourceName: z.string().default("cribl"),
  dataSourceVendor: z.string().default("cribl"),
  eventType: z.string().default(""),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSentinelOneAiSiemCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputSentinelOneAiSiemQueueFullBehavior$outboundSchema
    .default("block"),
  pqMode: OutputSentinelOneAiSiemMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSentinelOneAiSiemPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiem$ {
  /** @deprecated use `OutputSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelOneAiSiem$outboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiem$Outbound` instead. */
  export type Outbound = OutputSentinelOneAiSiem$Outbound;
}

export function outputSentinelOneAiSiemToJSON(
  outputSentinelOneAiSiem: OutputSentinelOneAiSiem,
): string {
  return JSON.stringify(
    OutputSentinelOneAiSiem$outboundSchema.parse(outputSentinelOneAiSiem),
  );
}

export function outputSentinelOneAiSiemFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelOneAiSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSentinelOneAiSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelOneAiSiem' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceOtlpType$inboundSchema: z.ZodType<
  OutputDynatraceOtlpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOtlpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOtlpType$outboundSchema: z.ZodType<
  OutputDynatraceOtlpType,
  z.ZodTypeDef,
  OutputDynatraceOtlpType
> = z.union([
  z.nativeEnum(OutputDynatraceOtlpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpType$ {
  /** @deprecated use `OutputDynatraceOtlpType$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlpType$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpType$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOtlpType$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpProtocol$inboundSchema: z.ZodType<
  OutputDynatraceOtlpProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOtlpProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOtlpProtocol$outboundSchema: z.ZodType<
  OutputDynatraceOtlpProtocol,
  z.ZodTypeDef,
  OutputDynatraceOtlpProtocol
> = z.union([
  z.nativeEnum(OutputDynatraceOtlpProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpProtocol$ {
  /** @deprecated use `OutputDynatraceOtlpProtocol$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlpProtocol$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpProtocol$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOtlpProtocol$outboundSchema;
}

/** @internal */
export const OutputDynatraceOTLPOTLPVersion$inboundSchema: z.ZodType<
  OutputDynatraceOTLPOTLPVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOTLPOTLPVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOTLPOTLPVersion$outboundSchema: z.ZodType<
  OutputDynatraceOTLPOTLPVersion,
  z.ZodTypeDef,
  OutputDynatraceOTLPOTLPVersion
> = z.union([
  z.nativeEnum(OutputDynatraceOTLPOTLPVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOTLPOTLPVersion$ {
  /** @deprecated use `OutputDynatraceOTLPOTLPVersion$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOTLPOTLPVersion$inboundSchema;
  /** @deprecated use `OutputDynatraceOTLPOTLPVersion$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOTLPOTLPVersion$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpCompressCompression$inboundSchema: z.ZodType<
  OutputDynatraceOtlpCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOtlpCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOtlpCompressCompression$outboundSchema: z.ZodType<
  OutputDynatraceOtlpCompressCompression,
  z.ZodTypeDef,
  OutputDynatraceOtlpCompressCompression
> = z.union([
  z.nativeEnum(OutputDynatraceOtlpCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpCompressCompression$ {
  /** @deprecated use `OutputDynatraceOtlpCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpCompressCompression$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpCompressCompression$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpHttpCompressCompression$inboundSchema:
  z.ZodType<OutputDynatraceOtlpHttpCompressCompression, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(OutputDynatraceOtlpHttpCompressCompression),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const OutputDynatraceOtlpHttpCompressCompression$outboundSchema:
  z.ZodType<
    OutputDynatraceOtlpHttpCompressCompression,
    z.ZodTypeDef,
    OutputDynatraceOtlpHttpCompressCompression
  > = z.union([
    z.nativeEnum(OutputDynatraceOtlpHttpCompressCompression),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpHttpCompressCompression$ {
  /** @deprecated use `OutputDynatraceOtlpHttpCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpHttpCompressCompression$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpHttpCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpHttpCompressCompression$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpMetadatum$inboundSchema: z.ZodType<
  OutputDynatraceOtlpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputDynatraceOtlpMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputDynatraceOtlpMetadatum$outboundSchema: z.ZodType<
  OutputDynatraceOtlpMetadatum$Outbound,
  z.ZodTypeDef,
  OutputDynatraceOtlpMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpMetadatum$ {
  /** @deprecated use `OutputDynatraceOtlpMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlpMetadatum$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOtlpMetadatum$outboundSchema;
  /** @deprecated use `OutputDynatraceOtlpMetadatum$Outbound` instead. */
  export type Outbound = OutputDynatraceOtlpMetadatum$Outbound;
}

export function outputDynatraceOtlpMetadatumToJSON(
  outputDynatraceOtlpMetadatum: OutputDynatraceOtlpMetadatum,
): string {
  return JSON.stringify(
    OutputDynatraceOtlpMetadatum$outboundSchema.parse(
      outputDynatraceOtlpMetadatum,
    ),
  );
}

export function outputDynatraceOtlpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceOtlpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDynatraceOtlpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceOtlpMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceOtlpFailedRequestLoggingMode$inboundSchema:
  z.ZodType<
    OutputDynatraceOtlpFailedRequestLoggingMode,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputDynatraceOtlpFailedRequestLoggingMode),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputDynatraceOtlpFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputDynatraceOtlpFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputDynatraceOtlpFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputDynatraceOtlpFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpFailedRequestLoggingMode$ {
  /** @deprecated use `OutputDynatraceOtlpFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const EndpointType$inboundSchema: z.ZodType<
  EndpointType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EndpointType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EndpointType$outboundSchema: z.ZodType<
  EndpointType,
  z.ZodTypeDef,
  EndpointType
> = z.union([
  z.nativeEnum(EndpointType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointType$ {
  /** @deprecated use `EndpointType$inboundSchema` instead. */
  export const inboundSchema = EndpointType$inboundSchema;
  /** @deprecated use `EndpointType$outboundSchema` instead. */
  export const outboundSchema = EndpointType$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpBackpressureBehavior$inboundSchema: z.ZodType<
  OutputDynatraceOtlpBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOtlpBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOtlpBackpressureBehavior$outboundSchema: z.ZodType<
  OutputDynatraceOtlpBackpressureBehavior,
  z.ZodTypeDef,
  OutputDynatraceOtlpBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputDynatraceOtlpBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpBackpressureBehavior$ {
  /** @deprecated use `OutputDynatraceOtlpBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpExtraHttpHeader$inboundSchema: z.ZodType<
  OutputDynatraceOtlpExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputDynatraceOtlpExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputDynatraceOtlpExtraHttpHeader$outboundSchema: z.ZodType<
  OutputDynatraceOtlpExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputDynatraceOtlpExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpExtraHttpHeader$ {
  /** @deprecated use `OutputDynatraceOtlpExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlpExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputDynatraceOtlpExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputDynatraceOtlpExtraHttpHeader$Outbound;
}

export function outputDynatraceOtlpExtraHttpHeaderToJSON(
  outputDynatraceOtlpExtraHttpHeader: OutputDynatraceOtlpExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputDynatraceOtlpExtraHttpHeader$outboundSchema.parse(
      outputDynatraceOtlpExtraHttpHeader,
    ),
  );
}

export function outputDynatraceOtlpExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceOtlpExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputDynatraceOtlpExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceOtlpExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceOtlpResponseRetrySetting$inboundSchema: z.ZodType<
  OutputDynatraceOtlpResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputDynatraceOtlpResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputDynatraceOtlpResponseRetrySetting$outboundSchema: z.ZodType<
  OutputDynatraceOtlpResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputDynatraceOtlpResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpResponseRetrySetting$ {
  /** @deprecated use `OutputDynatraceOtlpResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputDynatraceOtlpResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputDynatraceOtlpResponseRetrySetting$Outbound;
}

export function outputDynatraceOtlpResponseRetrySettingToJSON(
  outputDynatraceOtlpResponseRetrySetting:
    OutputDynatraceOtlpResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputDynatraceOtlpResponseRetrySetting$outboundSchema.parse(
      outputDynatraceOtlpResponseRetrySetting,
    ),
  );
}

export function outputDynatraceOtlpResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputDynatraceOtlpResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputDynatraceOtlpResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputDynatraceOtlpResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceOtlpTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputDynatraceOtlpTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputDynatraceOtlpTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputDynatraceOtlpTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputDynatraceOtlpTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputDynatraceOtlpTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpTimeoutRetrySettings$ {
  /** @deprecated use `OutputDynatraceOtlpTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputDynatraceOtlpTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputDynatraceOtlpTimeoutRetrySettings$Outbound;
}

export function outputDynatraceOtlpTimeoutRetrySettingsToJSON(
  outputDynatraceOtlpTimeoutRetrySettings:
    OutputDynatraceOtlpTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputDynatraceOtlpTimeoutRetrySettings$outboundSchema.parse(
      outputDynatraceOtlpTimeoutRetrySettings,
    ),
  );
}

export function outputDynatraceOtlpTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputDynatraceOtlpTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputDynatraceOtlpTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputDynatraceOtlpTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceOtlpPqCompressCompression$inboundSchema: z.ZodType<
  OutputDynatraceOtlpPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOtlpPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOtlpPqCompressCompression$outboundSchema: z.ZodType<
  OutputDynatraceOtlpPqCompressCompression,
  z.ZodTypeDef,
  OutputDynatraceOtlpPqCompressCompression
> = z.union([
  z.nativeEnum(OutputDynatraceOtlpPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpPqCompressCompression$ {
  /** @deprecated use `OutputDynatraceOtlpPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpQueueFullBehavior$inboundSchema: z.ZodType<
  OutputDynatraceOtlpQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOtlpQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOtlpQueueFullBehavior$outboundSchema: z.ZodType<
  OutputDynatraceOtlpQueueFullBehavior,
  z.ZodTypeDef,
  OutputDynatraceOtlpQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputDynatraceOtlpQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpQueueFullBehavior$ {
  /** @deprecated use `OutputDynatraceOtlpQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceOtlpQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceOtlpQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpMode$inboundSchema: z.ZodType<
  OutputDynatraceOtlpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceOtlpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceOtlpMode$outboundSchema: z.ZodType<
  OutputDynatraceOtlpMode,
  z.ZodTypeDef,
  OutputDynatraceOtlpMode
> = z.union([
  z.nativeEnum(OutputDynatraceOtlpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpMode$ {
  /** @deprecated use `OutputDynatraceOtlpMode$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlpMode$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpMode$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOtlpMode$outboundSchema;
}

/** @internal */
export const OutputDynatraceOtlpPqControls$inboundSchema: z.ZodType<
  OutputDynatraceOtlpPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputDynatraceOtlpPqControls$Outbound = {};

/** @internal */
export const OutputDynatraceOtlpPqControls$outboundSchema: z.ZodType<
  OutputDynatraceOtlpPqControls$Outbound,
  z.ZodTypeDef,
  OutputDynatraceOtlpPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlpPqControls$ {
  /** @deprecated use `OutputDynatraceOtlpPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlpPqControls$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlpPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOtlpPqControls$outboundSchema;
  /** @deprecated use `OutputDynatraceOtlpPqControls$Outbound` instead. */
  export type Outbound = OutputDynatraceOtlpPqControls$Outbound;
}

export function outputDynatraceOtlpPqControlsToJSON(
  outputDynatraceOtlpPqControls: OutputDynatraceOtlpPqControls,
): string {
  return JSON.stringify(
    OutputDynatraceOtlpPqControls$outboundSchema.parse(
      outputDynatraceOtlpPqControls,
    ),
  );
}

export function outputDynatraceOtlpPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceOtlpPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDynatraceOtlpPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceOtlpPqControls' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceOtlp$inboundSchema: z.ZodType<
  OutputDynatraceOtlp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputDynatraceOtlpType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputDynatraceOtlpProtocol$inboundSchema.default("http"),
  endpoint: z.string().default(
    "https://{your-environment-id}.live.dynatrace.com/api/v2/otlp",
  ),
  otlpVersion: OutputDynatraceOTLPOTLPVersion$inboundSchema.default("1.3.1"),
  compress: OutputDynatraceOtlpCompressCompression$inboundSchema.default(
    "gzip",
  ),
  httpCompress: OutputDynatraceOtlpHttpCompressCompression$inboundSchema
    .default("gzip"),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => OutputDynatraceOtlpMetadatum$inboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(2048),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode:
    OutputDynatraceOtlpFailedRequestLoggingMode$inboundSchema.default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  endpointType: EndpointType$inboundSchema.default("saas"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("Authorization"),
  onBackpressure: OutputDynatraceOtlpBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputDynatraceOtlpExtraHttpHeader$inboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputDynatraceOtlpResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputDynatraceOtlpTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputDynatraceOtlpPqCompressCompression$inboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputDynatraceOtlpQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputDynatraceOtlpMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputDynatraceOtlpPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputDynatraceOtlp$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  endpoint: string;
  otlpVersion: string;
  compress: string;
  httpCompress: string;
  httpTracesEndpointOverride?: string | undefined;
  httpMetricsEndpointOverride?: string | undefined;
  httpLogsEndpointOverride?: string | undefined;
  metadata?: Array<OutputDynatraceOtlpMetadatum$Outbound> | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  timeoutSec: number;
  flushPeriodSec: number;
  failedRequestLoggingMode: string;
  connectionTimeout: number;
  keepAliveTime: number;
  keepAlive: boolean;
  endpointType: string;
  tokenSecret: string;
  authTokenName: string;
  onBackpressure: string;
  description?: string | undefined;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  extraHttpHeaders?:
    | Array<OutputDynatraceOtlpExtraHttpHeader$Outbound>
    | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputDynatraceOtlpResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputDynatraceOtlpTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputDynatraceOtlpPqControls$Outbound | undefined;
};

/** @internal */
export const OutputDynatraceOtlp$outboundSchema: z.ZodType<
  OutputDynatraceOtlp$Outbound,
  z.ZodTypeDef,
  OutputDynatraceOtlp
> = z.object({
  id: z.string(),
  type: OutputDynatraceOtlpType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputDynatraceOtlpProtocol$outboundSchema.default("http"),
  endpoint: z.string().default(
    "https://{your-environment-id}.live.dynatrace.com/api/v2/otlp",
  ),
  otlpVersion: OutputDynatraceOTLPOTLPVersion$outboundSchema.default("1.3.1"),
  compress: OutputDynatraceOtlpCompressCompression$outboundSchema.default(
    "gzip",
  ),
  httpCompress: OutputDynatraceOtlpHttpCompressCompression$outboundSchema
    .default("gzip"),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => OutputDynatraceOtlpMetadatum$outboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(2048),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode:
    OutputDynatraceOtlpFailedRequestLoggingMode$outboundSchema.default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  endpointType: EndpointType$outboundSchema.default("saas"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("Authorization"),
  onBackpressure: OutputDynatraceOtlpBackpressureBehavior$outboundSchema
    .default("block"),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputDynatraceOtlpExtraHttpHeader$outboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputDynatraceOtlpResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputDynatraceOtlpTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputDynatraceOtlpPqCompressCompression$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputDynatraceOtlpQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputDynatraceOtlpMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputDynatraceOtlpPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlp$ {
  /** @deprecated use `OutputDynatraceOtlp$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlp$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlp$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOtlp$outboundSchema;
  /** @deprecated use `OutputDynatraceOtlp$Outbound` instead. */
  export type Outbound = OutputDynatraceOtlp$Outbound;
}

export function outputDynatraceOtlpToJSON(
  outputDynatraceOtlp: OutputDynatraceOtlp,
): string {
  return JSON.stringify(
    OutputDynatraceOtlp$outboundSchema.parse(outputDynatraceOtlp),
  );
}

export function outputDynatraceOtlpFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceOtlp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDynatraceOtlp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceOtlp' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceHttpType$inboundSchema: z.ZodType<
  OutputDynatraceHttpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceHttpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceHttpType$outboundSchema: z.ZodType<
  OutputDynatraceHttpType,
  z.ZodTypeDef,
  OutputDynatraceHttpType
> = z.union([
  z.nativeEnum(OutputDynatraceHttpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpType$ {
  /** @deprecated use `OutputDynatraceHttpType$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttpType$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpType$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceHttpType$outboundSchema;
}

/** @internal */
export const Method$inboundSchema: z.ZodType<Method, z.ZodTypeDef, unknown> = z
  .union([
    z.nativeEnum(Method),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Method$outboundSchema: z.ZodType<Method, z.ZodTypeDef, Method> = z
  .union([
    z.nativeEnum(Method),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Method$ {
  /** @deprecated use `Method$inboundSchema` instead. */
  export const inboundSchema = Method$inboundSchema;
  /** @deprecated use `Method$outboundSchema` instead. */
  export const outboundSchema = Method$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpExtraHttpHeader$inboundSchema: z.ZodType<
  OutputDynatraceHttpExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputDynatraceHttpExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputDynatraceHttpExtraHttpHeader$outboundSchema: z.ZodType<
  OutputDynatraceHttpExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputDynatraceHttpExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpExtraHttpHeader$ {
  /** @deprecated use `OutputDynatraceHttpExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttpExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceHttpExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputDynatraceHttpExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputDynatraceHttpExtraHttpHeader$Outbound;
}

export function outputDynatraceHttpExtraHttpHeaderToJSON(
  outputDynatraceHttpExtraHttpHeader: OutputDynatraceHttpExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputDynatraceHttpExtraHttpHeader$outboundSchema.parse(
      outputDynatraceHttpExtraHttpHeader,
    ),
  );
}

export function outputDynatraceHttpExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceHttpExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputDynatraceHttpExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceHttpExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceHttpFailedRequestLoggingMode$inboundSchema:
  z.ZodType<
    OutputDynatraceHttpFailedRequestLoggingMode,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputDynatraceHttpFailedRequestLoggingMode),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputDynatraceHttpFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputDynatraceHttpFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputDynatraceHttpFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputDynatraceHttpFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpFailedRequestLoggingMode$ {
  /** @deprecated use `OutputDynatraceHttpFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceHttpFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceHttpFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpResponseRetrySetting$inboundSchema: z.ZodType<
  OutputDynatraceHttpResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputDynatraceHttpResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputDynatraceHttpResponseRetrySetting$outboundSchema: z.ZodType<
  OutputDynatraceHttpResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputDynatraceHttpResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpResponseRetrySetting$ {
  /** @deprecated use `OutputDynatraceHttpResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceHttpResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceHttpResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputDynatraceHttpResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputDynatraceHttpResponseRetrySetting$Outbound;
}

export function outputDynatraceHttpResponseRetrySettingToJSON(
  outputDynatraceHttpResponseRetrySetting:
    OutputDynatraceHttpResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputDynatraceHttpResponseRetrySetting$outboundSchema.parse(
      outputDynatraceHttpResponseRetrySetting,
    ),
  );
}

export function outputDynatraceHttpResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputDynatraceHttpResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputDynatraceHttpResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputDynatraceHttpResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceHttpTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputDynatraceHttpTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputDynatraceHttpTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputDynatraceHttpTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputDynatraceHttpTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputDynatraceHttpTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpTimeoutRetrySettings$ {
  /** @deprecated use `OutputDynatraceHttpTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceHttpTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceHttpTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputDynatraceHttpTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputDynatraceHttpTimeoutRetrySettings$Outbound;
}

export function outputDynatraceHttpTimeoutRetrySettingsToJSON(
  outputDynatraceHttpTimeoutRetrySettings:
    OutputDynatraceHttpTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputDynatraceHttpTimeoutRetrySettings$outboundSchema.parse(
      outputDynatraceHttpTimeoutRetrySettings,
    ),
  );
}

export function outputDynatraceHttpTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputDynatraceHttpTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputDynatraceHttpTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputDynatraceHttpTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceHttpBackpressureBehavior$inboundSchema: z.ZodType<
  OutputDynatraceHttpBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceHttpBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceHttpBackpressureBehavior$outboundSchema: z.ZodType<
  OutputDynatraceHttpBackpressureBehavior,
  z.ZodTypeDef,
  OutputDynatraceHttpBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputDynatraceHttpBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpBackpressureBehavior$ {
  /** @deprecated use `OutputDynatraceHttpBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceHttpBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceHttpBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpAuthenticationType$inboundSchema: z.ZodType<
  OutputDynatraceHttpAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceHttpAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceHttpAuthenticationType$outboundSchema: z.ZodType<
  OutputDynatraceHttpAuthenticationType,
  z.ZodTypeDef,
  OutputDynatraceHttpAuthenticationType
> = z.union([
  z.nativeEnum(OutputDynatraceHttpAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpAuthenticationType$ {
  /** @deprecated use `OutputDynatraceHttpAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceHttpAuthenticationType$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceHttpAuthenticationType$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpFormat$inboundSchema: z.ZodType<
  OutputDynatraceHttpFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceHttpFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceHttpFormat$outboundSchema: z.ZodType<
  OutputDynatraceHttpFormat,
  z.ZodTypeDef,
  OutputDynatraceHttpFormat
> = z.union([
  z.nativeEnum(OutputDynatraceHttpFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpFormat$ {
  /** @deprecated use `OutputDynatraceHttpFormat$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttpFormat$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpFormat$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceHttpFormat$outboundSchema;
}

/** @internal */
export const Endpoint$inboundSchema: z.ZodType<
  Endpoint,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Endpoint),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Endpoint$outboundSchema: z.ZodType<
  Endpoint,
  z.ZodTypeDef,
  Endpoint
> = z.union([
  z.nativeEnum(Endpoint),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Endpoint$ {
  /** @deprecated use `Endpoint$inboundSchema` instead. */
  export const inboundSchema = Endpoint$inboundSchema;
  /** @deprecated use `Endpoint$outboundSchema` instead. */
  export const outboundSchema = Endpoint$outboundSchema;
}

/** @internal */
export const TelemetryType$inboundSchema: z.ZodType<
  TelemetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TelemetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TelemetryType$outboundSchema: z.ZodType<
  TelemetryType,
  z.ZodTypeDef,
  TelemetryType
> = z.union([
  z.nativeEnum(TelemetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TelemetryType$ {
  /** @deprecated use `TelemetryType$inboundSchema` instead. */
  export const inboundSchema = TelemetryType$inboundSchema;
  /** @deprecated use `TelemetryType$outboundSchema` instead. */
  export const outboundSchema = TelemetryType$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpCompression$inboundSchema: z.ZodType<
  OutputDynatraceHttpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceHttpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceHttpCompression$outboundSchema: z.ZodType<
  OutputDynatraceHttpCompression,
  z.ZodTypeDef,
  OutputDynatraceHttpCompression
> = z.union([
  z.nativeEnum(OutputDynatraceHttpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpCompression$ {
  /** @deprecated use `OutputDynatraceHttpCompression$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttpCompression$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpCompression$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceHttpCompression$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpQueueFullBehavior$inboundSchema: z.ZodType<
  OutputDynatraceHttpQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceHttpQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceHttpQueueFullBehavior$outboundSchema: z.ZodType<
  OutputDynatraceHttpQueueFullBehavior,
  z.ZodTypeDef,
  OutputDynatraceHttpQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputDynatraceHttpQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpQueueFullBehavior$ {
  /** @deprecated use `OutputDynatraceHttpQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputDynatraceHttpQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputDynatraceHttpQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpMode$inboundSchema: z.ZodType<
  OutputDynatraceHttpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDynatraceHttpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDynatraceHttpMode$outboundSchema: z.ZodType<
  OutputDynatraceHttpMode,
  z.ZodTypeDef,
  OutputDynatraceHttpMode
> = z.union([
  z.nativeEnum(OutputDynatraceHttpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpMode$ {
  /** @deprecated use `OutputDynatraceHttpMode$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttpMode$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpMode$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceHttpMode$outboundSchema;
}

/** @internal */
export const OutputDynatraceHttpPqControls$inboundSchema: z.ZodType<
  OutputDynatraceHttpPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputDynatraceHttpPqControls$Outbound = {};

/** @internal */
export const OutputDynatraceHttpPqControls$outboundSchema: z.ZodType<
  OutputDynatraceHttpPqControls$Outbound,
  z.ZodTypeDef,
  OutputDynatraceHttpPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttpPqControls$ {
  /** @deprecated use `OutputDynatraceHttpPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttpPqControls$inboundSchema;
  /** @deprecated use `OutputDynatraceHttpPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceHttpPqControls$outboundSchema;
  /** @deprecated use `OutputDynatraceHttpPqControls$Outbound` instead. */
  export type Outbound = OutputDynatraceHttpPqControls$Outbound;
}

export function outputDynatraceHttpPqControlsToJSON(
  outputDynatraceHttpPqControls: OutputDynatraceHttpPqControls,
): string {
  return JSON.stringify(
    OutputDynatraceHttpPqControls$outboundSchema.parse(
      outputDynatraceHttpPqControls,
    ),
  );
}

export function outputDynatraceHttpPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceHttpPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDynatraceHttpPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceHttpPqControls' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceHttp$inboundSchema: z.ZodType<
  OutputDynatraceHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputDynatraceHttpType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method$inboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputDynatraceHttpExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputDynatraceHttpFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputDynatraceHttpResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputDynatraceHttpTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputDynatraceHttpBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  authType: OutputDynatraceHttpAuthenticationType$inboundSchema.default(
    "token",
  ),
  format: OutputDynatraceHttpFormat$inboundSchema.default("json_array"),
  endpoint: Endpoint$inboundSchema.default("cloud"),
  telemetryType: TelemetryType$inboundSchema.default("logs"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputDynatraceHttpCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputDynatraceHttpQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputDynatraceHttpMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputDynatraceHttpPqControls$inboundSchema)
    .optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  environmentId: z.string().optional(),
  activeGateDomain: z.string().optional(),
  url: z.string().optional(),
});

/** @internal */
export type OutputDynatraceHttp$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputDynatraceHttpExtraHttpHeader$Outbound>
    | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputDynatraceHttpResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputDynatraceHttpTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  format: string;
  endpoint: string;
  telemetryType: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputDynatraceHttpPqControls$Outbound | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  environmentId?: string | undefined;
  activeGateDomain?: string | undefined;
  url?: string | undefined;
};

/** @internal */
export const OutputDynatraceHttp$outboundSchema: z.ZodType<
  OutputDynatraceHttp$Outbound,
  z.ZodTypeDef,
  OutputDynatraceHttp
> = z.object({
  id: z.string(),
  type: OutputDynatraceHttpType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method$outboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputDynatraceHttpExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputDynatraceHttpFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputDynatraceHttpResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputDynatraceHttpTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputDynatraceHttpBackpressureBehavior$outboundSchema
    .default("block"),
  authType: OutputDynatraceHttpAuthenticationType$outboundSchema.default(
    "token",
  ),
  format: OutputDynatraceHttpFormat$outboundSchema.default("json_array"),
  endpoint: Endpoint$outboundSchema.default("cloud"),
  telemetryType: TelemetryType$outboundSchema.default("logs"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputDynatraceHttpCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputDynatraceHttpQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputDynatraceHttpMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputDynatraceHttpPqControls$outboundSchema)
    .optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  environmentId: z.string().optional(),
  activeGateDomain: z.string().optional(),
  url: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttp$ {
  /** @deprecated use `OutputDynatraceHttp$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttp$inboundSchema;
  /** @deprecated use `OutputDynatraceHttp$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceHttp$outboundSchema;
  /** @deprecated use `OutputDynatraceHttp$Outbound` instead. */
  export type Outbound = OutputDynatraceHttp$Outbound;
}

export function outputDynatraceHttpToJSON(
  outputDynatraceHttp: OutputDynatraceHttp,
): string {
  return JSON.stringify(
    OutputDynatraceHttp$outboundSchema.parse(outputDynatraceHttp),
  );
}

export function outputDynatraceHttpFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDynatraceHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceHttp' from JSON`,
  );
}

/** @internal */
export const OutputNetflowType$inboundSchema: z.ZodType<
  OutputNetflowType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNetflowType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNetflowType$outboundSchema: z.ZodType<
  OutputNetflowType,
  z.ZodTypeDef,
  OutputNetflowType
> = z.union([
  z.nativeEnum(OutputNetflowType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNetflowType$ {
  /** @deprecated use `OutputNetflowType$inboundSchema` instead. */
  export const inboundSchema = OutputNetflowType$inboundSchema;
  /** @deprecated use `OutputNetflowType$outboundSchema` instead. */
  export const outboundSchema = OutputNetflowType$outboundSchema;
}

/** @internal */
export const OutputNetflowHost$inboundSchema: z.ZodType<
  OutputNetflowHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  port: z.number().default(2055),
});

/** @internal */
export type OutputNetflowHost$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const OutputNetflowHost$outboundSchema: z.ZodType<
  OutputNetflowHost$Outbound,
  z.ZodTypeDef,
  OutputNetflowHost
> = z.object({
  host: z.string(),
  port: z.number().default(2055),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNetflowHost$ {
  /** @deprecated use `OutputNetflowHost$inboundSchema` instead. */
  export const inboundSchema = OutputNetflowHost$inboundSchema;
  /** @deprecated use `OutputNetflowHost$outboundSchema` instead. */
  export const outboundSchema = OutputNetflowHost$outboundSchema;
  /** @deprecated use `OutputNetflowHost$Outbound` instead. */
  export type Outbound = OutputNetflowHost$Outbound;
}

export function outputNetflowHostToJSON(
  outputNetflowHost: OutputNetflowHost,
): string {
  return JSON.stringify(
    OutputNetflowHost$outboundSchema.parse(outputNetflowHost),
  );
}

export function outputNetflowHostFromJSON(
  jsonString: string,
): SafeParseResult<OutputNetflowHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNetflowHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNetflowHost' from JSON`,
  );
}

/** @internal */
export const OutputNetflow$inboundSchema: z.ZodType<
  OutputNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputNetflowType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => OutputNetflowHost$inboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/** @internal */
export type OutputNetflow$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  hosts: Array<OutputNetflowHost$Outbound>;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
};

/** @internal */
export const OutputNetflow$outboundSchema: z.ZodType<
  OutputNetflow$Outbound,
  z.ZodTypeDef,
  OutputNetflow
> = z.object({
  id: z.string(),
  type: OutputNetflowType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => OutputNetflowHost$outboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNetflow$ {
  /** @deprecated use `OutputNetflow$inboundSchema` instead. */
  export const inboundSchema = OutputNetflow$inboundSchema;
  /** @deprecated use `OutputNetflow$outboundSchema` instead. */
  export const outboundSchema = OutputNetflow$outboundSchema;
  /** @deprecated use `OutputNetflow$Outbound` instead. */
  export type Outbound = OutputNetflow$Outbound;
}

export function outputNetflowToJSON(outputNetflow: OutputNetflow): string {
  return JSON.stringify(OutputNetflow$outboundSchema.parse(outputNetflow));
}

export function outputNetflowFromJSON(
  jsonString: string,
): SafeParseResult<OutputNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNetflow' from JSON`,
  );
}

/** @internal */
export const OutputClickHouseType$inboundSchema: z.ZodType<
  OutputClickHouseType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseType$outboundSchema: z.ZodType<
  OutputClickHouseType,
  z.ZodTypeDef,
  OutputClickHouseType
> = z.union([
  z.nativeEnum(OutputClickHouseType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseType$ {
  /** @deprecated use `OutputClickHouseType$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseType$inboundSchema;
  /** @deprecated use `OutputClickHouseType$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouseType$outboundSchema;
}

/** @internal */
export const OutputClickHouseAuthenticationType$inboundSchema: z.ZodType<
  OutputClickHouseAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseAuthenticationType$outboundSchema: z.ZodType<
  OutputClickHouseAuthenticationType,
  z.ZodTypeDef,
  OutputClickHouseAuthenticationType
> = z.union([
  z.nativeEnum(OutputClickHouseAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseAuthenticationType$ {
  /** @deprecated use `OutputClickHouseAuthenticationType$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseAuthenticationType$inboundSchema;
  /** @deprecated use `OutputClickHouseAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseAuthenticationType$outboundSchema;
}

/** @internal */
export const OutputClickHouseFormat$inboundSchema: z.ZodType<
  OutputClickHouseFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseFormat$outboundSchema: z.ZodType<
  OutputClickHouseFormat,
  z.ZodTypeDef,
  OutputClickHouseFormat
> = z.union([
  z.nativeEnum(OutputClickHouseFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseFormat$ {
  /** @deprecated use `OutputClickHouseFormat$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseFormat$inboundSchema;
  /** @deprecated use `OutputClickHouseFormat$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouseFormat$outboundSchema;
}

/** @internal */
export const MappingType$inboundSchema: z.ZodType<
  MappingType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(MappingType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const MappingType$outboundSchema: z.ZodType<
  MappingType,
  z.ZodTypeDef,
  MappingType
> = z.union([
  z.nativeEnum(MappingType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MappingType$ {
  /** @deprecated use `MappingType$inboundSchema` instead. */
  export const inboundSchema = MappingType$inboundSchema;
  /** @deprecated use `MappingType$outboundSchema` instead. */
  export const outboundSchema = MappingType$outboundSchema;
}

/** @internal */
export const OutputClickHouseMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputClickHouseMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputClickHouseMinimumTLSVersion,
  z.ZodTypeDef,
  OutputClickHouseMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputClickHouseMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseMinimumTLSVersion$ {
  /** @deprecated use `OutputClickHouseMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputClickHouseMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputClickHouseMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputClickHouseMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputClickHouseMaximumTLSVersion,
  z.ZodTypeDef,
  OutputClickHouseMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputClickHouseMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseMaximumTLSVersion$ {
  /** @deprecated use `OutputClickHouseMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputClickHouseMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputClickHouseTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputClickHouseTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputClickHouseMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputClickHouseMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputClickHouseTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputClickHouseTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputClickHouseTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputClickHouseTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputClickHouseMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: OutputClickHouseMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseTLSSettingsClientSide$ {
  /** @deprecated use `OutputClickHouseTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputClickHouseTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputClickHouseTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputClickHouseTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputClickHouseTLSSettingsClientSide$Outbound;
}

export function outputClickHouseTLSSettingsClientSideToJSON(
  outputClickHouseTLSSettingsClientSide: OutputClickHouseTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputClickHouseTLSSettingsClientSide$outboundSchema.parse(
      outputClickHouseTLSSettingsClientSide,
    ),
  );
}

export function outputClickHouseTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouseTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputClickHouseTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouseTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputClickHouseExtraHttpHeader$inboundSchema: z.ZodType<
  OutputClickHouseExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputClickHouseExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputClickHouseExtraHttpHeader$outboundSchema: z.ZodType<
  OutputClickHouseExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputClickHouseExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseExtraHttpHeader$ {
  /** @deprecated use `OutputClickHouseExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputClickHouseExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouseExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputClickHouseExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputClickHouseExtraHttpHeader$Outbound;
}

export function outputClickHouseExtraHttpHeaderToJSON(
  outputClickHouseExtraHttpHeader: OutputClickHouseExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputClickHouseExtraHttpHeader$outboundSchema.parse(
      outputClickHouseExtraHttpHeader,
    ),
  );
}

export function outputClickHouseExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouseExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputClickHouseExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouseExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputClickHouseFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputClickHouseFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputClickHouseFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputClickHouseFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputClickHouseFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseFailedRequestLoggingMode$ {
  /** @deprecated use `OutputClickHouseFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputClickHouseFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputClickHouseFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputClickHouseResponseRetrySetting$inboundSchema: z.ZodType<
  OutputClickHouseResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputClickHouseResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputClickHouseResponseRetrySetting$outboundSchema: z.ZodType<
  OutputClickHouseResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputClickHouseResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseResponseRetrySetting$ {
  /** @deprecated use `OutputClickHouseResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputClickHouseResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputClickHouseResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputClickHouseResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputClickHouseResponseRetrySetting$Outbound;
}

export function outputClickHouseResponseRetrySettingToJSON(
  outputClickHouseResponseRetrySetting: OutputClickHouseResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputClickHouseResponseRetrySetting$outboundSchema.parse(
      outputClickHouseResponseRetrySetting,
    ),
  );
}

export function outputClickHouseResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouseResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputClickHouseResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouseResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputClickHouseTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputClickHouseTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputClickHouseTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputClickHouseTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputClickHouseTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputClickHouseTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseTimeoutRetrySettings$ {
  /** @deprecated use `OutputClickHouseTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputClickHouseTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputClickHouseTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputClickHouseTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputClickHouseTimeoutRetrySettings$Outbound;
}

export function outputClickHouseTimeoutRetrySettingsToJSON(
  outputClickHouseTimeoutRetrySettings: OutputClickHouseTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputClickHouseTimeoutRetrySettings$outboundSchema.parse(
      outputClickHouseTimeoutRetrySettings,
    ),
  );
}

export function outputClickHouseTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouseTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputClickHouseTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouseTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputClickHouseBackpressureBehavior$inboundSchema: z.ZodType<
  OutputClickHouseBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseBackpressureBehavior$outboundSchema: z.ZodType<
  OutputClickHouseBackpressureBehavior,
  z.ZodTypeDef,
  OutputClickHouseBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputClickHouseBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseBackpressureBehavior$ {
  /** @deprecated use `OutputClickHouseBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputClickHouseBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputClickHouseBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputClickHouseOauthParam$inboundSchema: z.ZodType<
  OutputClickHouseOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputClickHouseOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputClickHouseOauthParam$outboundSchema: z.ZodType<
  OutputClickHouseOauthParam$Outbound,
  z.ZodTypeDef,
  OutputClickHouseOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseOauthParam$ {
  /** @deprecated use `OutputClickHouseOauthParam$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseOauthParam$inboundSchema;
  /** @deprecated use `OutputClickHouseOauthParam$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouseOauthParam$outboundSchema;
  /** @deprecated use `OutputClickHouseOauthParam$Outbound` instead. */
  export type Outbound = OutputClickHouseOauthParam$Outbound;
}

export function outputClickHouseOauthParamToJSON(
  outputClickHouseOauthParam: OutputClickHouseOauthParam,
): string {
  return JSON.stringify(
    OutputClickHouseOauthParam$outboundSchema.parse(outputClickHouseOauthParam),
  );
}

export function outputClickHouseOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouseOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputClickHouseOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouseOauthParam' from JSON`,
  );
}

/** @internal */
export const OutputClickHouseOauthHeader$inboundSchema: z.ZodType<
  OutputClickHouseOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputClickHouseOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputClickHouseOauthHeader$outboundSchema: z.ZodType<
  OutputClickHouseOauthHeader$Outbound,
  z.ZodTypeDef,
  OutputClickHouseOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseOauthHeader$ {
  /** @deprecated use `OutputClickHouseOauthHeader$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseOauthHeader$inboundSchema;
  /** @deprecated use `OutputClickHouseOauthHeader$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouseOauthHeader$outboundSchema;
  /** @deprecated use `OutputClickHouseOauthHeader$Outbound` instead. */
  export type Outbound = OutputClickHouseOauthHeader$Outbound;
}

export function outputClickHouseOauthHeaderToJSON(
  outputClickHouseOauthHeader: OutputClickHouseOauthHeader,
): string {
  return JSON.stringify(
    OutputClickHouseOauthHeader$outboundSchema.parse(
      outputClickHouseOauthHeader,
    ),
  );
}

export function outputClickHouseOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouseOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputClickHouseOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouseOauthHeader' from JSON`,
  );
}

/** @internal */
export const ColumnMapping$inboundSchema: z.ZodType<
  ColumnMapping,
  z.ZodTypeDef,
  unknown
> = z.object({
  columnName: z.string(),
  columnType: z.string().optional(),
  columnValueExpression: z.string(),
});

/** @internal */
export type ColumnMapping$Outbound = {
  columnName: string;
  columnType?: string | undefined;
  columnValueExpression: string;
};

/** @internal */
export const ColumnMapping$outboundSchema: z.ZodType<
  ColumnMapping$Outbound,
  z.ZodTypeDef,
  ColumnMapping
> = z.object({
  columnName: z.string(),
  columnType: z.string().optional(),
  columnValueExpression: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ColumnMapping$ {
  /** @deprecated use `ColumnMapping$inboundSchema` instead. */
  export const inboundSchema = ColumnMapping$inboundSchema;
  /** @deprecated use `ColumnMapping$outboundSchema` instead. */
  export const outboundSchema = ColumnMapping$outboundSchema;
  /** @deprecated use `ColumnMapping$Outbound` instead. */
  export type Outbound = ColumnMapping$Outbound;
}

export function columnMappingToJSON(columnMapping: ColumnMapping): string {
  return JSON.stringify(ColumnMapping$outboundSchema.parse(columnMapping));
}

export function columnMappingFromJSON(
  jsonString: string,
): SafeParseResult<ColumnMapping, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ColumnMapping$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ColumnMapping' from JSON`,
  );
}

/** @internal */
export const OutputClickHouseCompression$inboundSchema: z.ZodType<
  OutputClickHouseCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseCompression$outboundSchema: z.ZodType<
  OutputClickHouseCompression,
  z.ZodTypeDef,
  OutputClickHouseCompression
> = z.union([
  z.nativeEnum(OutputClickHouseCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseCompression$ {
  /** @deprecated use `OutputClickHouseCompression$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseCompression$inboundSchema;
  /** @deprecated use `OutputClickHouseCompression$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouseCompression$outboundSchema;
}

/** @internal */
export const OutputClickHouseQueueFullBehavior$inboundSchema: z.ZodType<
  OutputClickHouseQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseQueueFullBehavior$outboundSchema: z.ZodType<
  OutputClickHouseQueueFullBehavior,
  z.ZodTypeDef,
  OutputClickHouseQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputClickHouseQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseQueueFullBehavior$ {
  /** @deprecated use `OutputClickHouseQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputClickHouseQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputClickHouseQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputClickHouseMode$inboundSchema: z.ZodType<
  OutputClickHouseMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputClickHouseMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputClickHouseMode$outboundSchema: z.ZodType<
  OutputClickHouseMode,
  z.ZodTypeDef,
  OutputClickHouseMode
> = z.union([
  z.nativeEnum(OutputClickHouseMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouseMode$ {
  /** @deprecated use `OutputClickHouseMode$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouseMode$inboundSchema;
  /** @deprecated use `OutputClickHouseMode$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouseMode$outboundSchema;
}

/** @internal */
export const OutputClickHousePqControls$inboundSchema: z.ZodType<
  OutputClickHousePqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputClickHousePqControls$Outbound = {};

/** @internal */
export const OutputClickHousePqControls$outboundSchema: z.ZodType<
  OutputClickHousePqControls$Outbound,
  z.ZodTypeDef,
  OutputClickHousePqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHousePqControls$ {
  /** @deprecated use `OutputClickHousePqControls$inboundSchema` instead. */
  export const inboundSchema = OutputClickHousePqControls$inboundSchema;
  /** @deprecated use `OutputClickHousePqControls$outboundSchema` instead. */
  export const outboundSchema = OutputClickHousePqControls$outboundSchema;
  /** @deprecated use `OutputClickHousePqControls$Outbound` instead. */
  export type Outbound = OutputClickHousePqControls$Outbound;
}

export function outputClickHousePqControlsToJSON(
  outputClickHousePqControls: OutputClickHousePqControls,
): string {
  return JSON.stringify(
    OutputClickHousePqControls$outboundSchema.parse(outputClickHousePqControls),
  );
}

export function outputClickHousePqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHousePqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputClickHousePqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHousePqControls' from JSON`,
  );
}

/** @internal */
export const OutputClickHouse$inboundSchema: z.ZodType<
  OutputClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputClickHouseType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  authType: OutputClickHouseAuthenticationType$inboundSchema.default("none"),
  database: z.string(),
  tableName: z.string(),
  format: OutputClickHouseFormat$inboundSchema.default(
    "json-compact-each-row-with-names",
  ),
  mappingType: MappingType$inboundSchema.default("automatic"),
  asyncInserts: z.boolean().default(false),
  tls: z.lazy(() => OutputClickHouseTLSSettingsClientSide$inboundSchema)
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputClickHouseExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputClickHouseFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputClickHouseResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputClickHouseTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  dumpFormatErrorsToDisk: z.boolean().default(false),
  onBackpressure: OutputClickHouseBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OutputClickHouseOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OutputClickHouseOauthHeader$inboundSchema))
    .optional(),
  sqlUsername: z.string().optional(),
  waitForAsyncInserts: z.boolean().default(true),
  excludeMappingFields: z.array(z.string()).optional(),
  describeTable: z.string().optional(),
  columnMappings: z.array(z.lazy(() => ColumnMapping$inboundSchema)).optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputClickHouseCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputClickHouseQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputClickHouseMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputClickHousePqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputClickHouse$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  authType: string;
  database: string;
  tableName: string;
  format: string;
  mappingType: string;
  asyncInserts: boolean;
  tls?: OutputClickHouseTLSSettingsClientSide$Outbound | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputClickHouseExtraHttpHeader$Outbound>
    | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputClickHouseResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputClickHouseTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  dumpFormatErrorsToDisk: boolean;
  onBackpressure: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OutputClickHouseOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<OutputClickHouseOauthHeader$Outbound> | undefined;
  sqlUsername?: string | undefined;
  waitForAsyncInserts: boolean;
  excludeMappingFields?: Array<string> | undefined;
  describeTable?: string | undefined;
  columnMappings?: Array<ColumnMapping$Outbound> | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputClickHousePqControls$Outbound | undefined;
};

/** @internal */
export const OutputClickHouse$outboundSchema: z.ZodType<
  OutputClickHouse$Outbound,
  z.ZodTypeDef,
  OutputClickHouse
> = z.object({
  id: z.string(),
  type: OutputClickHouseType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  authType: OutputClickHouseAuthenticationType$outboundSchema.default("none"),
  database: z.string(),
  tableName: z.string(),
  format: OutputClickHouseFormat$outboundSchema.default(
    "json-compact-each-row-with-names",
  ),
  mappingType: MappingType$outboundSchema.default("automatic"),
  asyncInserts: z.boolean().default(false),
  tls: z.lazy(() => OutputClickHouseTLSSettingsClientSide$outboundSchema)
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputClickHouseExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputClickHouseFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputClickHouseResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputClickHouseTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  dumpFormatErrorsToDisk: z.boolean().default(false),
  onBackpressure: OutputClickHouseBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OutputClickHouseOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => OutputClickHouseOauthHeader$outboundSchema),
  ).optional(),
  sqlUsername: z.string().optional(),
  waitForAsyncInserts: z.boolean().default(true),
  excludeMappingFields: z.array(z.string()).optional(),
  describeTable: z.string().optional(),
  columnMappings: z.array(z.lazy(() => ColumnMapping$outboundSchema))
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputClickHouseCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputClickHouseQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputClickHouseMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputClickHousePqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouse$ {
  /** @deprecated use `OutputClickHouse$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouse$inboundSchema;
  /** @deprecated use `OutputClickHouse$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouse$outboundSchema;
  /** @deprecated use `OutputClickHouse$Outbound` instead. */
  export type Outbound = OutputClickHouse$Outbound;
}

export function outputClickHouseToJSON(
  outputClickHouse: OutputClickHouse,
): string {
  return JSON.stringify(
    OutputClickHouse$outboundSchema.parse(outputClickHouse),
  );
}

export function outputClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouse' from JSON`,
  );
}

/** @internal */
export const OutputSecurityLakeType$inboundSchema: z.ZodType<
  OutputSecurityLakeType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeType$outboundSchema: z.ZodType<
  OutputSecurityLakeType,
  z.ZodTypeDef,
  OutputSecurityLakeType
> = z.union([
  z.nativeEnum(OutputSecurityLakeType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeType$ {
  /** @deprecated use `OutputSecurityLakeType$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLakeType$inboundSchema;
  /** @deprecated use `OutputSecurityLakeType$outboundSchema` instead. */
  export const outboundSchema = OutputSecurityLakeType$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeAuthenticationMethod$inboundSchema: z.ZodType<
  OutputSecurityLakeAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeAuthenticationMethod$outboundSchema: z.ZodType<
  OutputSecurityLakeAuthenticationMethod,
  z.ZodTypeDef,
  OutputSecurityLakeAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputSecurityLakeAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeAuthenticationMethod$ {
  /** @deprecated use `OutputSecurityLakeAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputSecurityLakeAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputSecurityLakeAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputSecurityLakeAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeSignatureVersion$inboundSchema: z.ZodType<
  OutputSecurityLakeSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeSignatureVersion$outboundSchema: z.ZodType<
  OutputSecurityLakeSignatureVersion,
  z.ZodTypeDef,
  OutputSecurityLakeSignatureVersion
> = z.union([
  z.nativeEnum(OutputSecurityLakeSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeSignatureVersion$ {
  /** @deprecated use `OutputSecurityLakeSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLakeSignatureVersion$inboundSchema;
  /** @deprecated use `OutputSecurityLakeSignatureVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputSecurityLakeSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeObjectACL$inboundSchema: z.ZodType<
  OutputSecurityLakeObjectACL,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeObjectACL),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeObjectACL$outboundSchema: z.ZodType<
  OutputSecurityLakeObjectACL,
  z.ZodTypeDef,
  OutputSecurityLakeObjectACL
> = z.union([
  z.nativeEnum(OutputSecurityLakeObjectACL),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeObjectACL$ {
  /** @deprecated use `OutputSecurityLakeObjectACL$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLakeObjectACL$inboundSchema;
  /** @deprecated use `OutputSecurityLakeObjectACL$outboundSchema` instead. */
  export const outboundSchema = OutputSecurityLakeObjectACL$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeStorageClass$inboundSchema: z.ZodType<
  OutputSecurityLakeStorageClass,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeStorageClass),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeStorageClass$outboundSchema: z.ZodType<
  OutputSecurityLakeStorageClass,
  z.ZodTypeDef,
  OutputSecurityLakeStorageClass
> = z.union([
  z.nativeEnum(OutputSecurityLakeStorageClass),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeStorageClass$ {
  /** @deprecated use `OutputSecurityLakeStorageClass$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLakeStorageClass$inboundSchema;
  /** @deprecated use `OutputSecurityLakeStorageClass$outboundSchema` instead. */
  export const outboundSchema = OutputSecurityLakeStorageClass$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeServerSideEncryptionForUploadedObjects$inboundSchema:
  z.ZodType<
    OutputSecurityLakeServerSideEncryptionForUploadedObjects,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputSecurityLakeServerSideEncryptionForUploadedObjects),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputSecurityLakeServerSideEncryptionForUploadedObjects$outboundSchema:
  z.ZodType<
    OutputSecurityLakeServerSideEncryptionForUploadedObjects,
    z.ZodTypeDef,
    OutputSecurityLakeServerSideEncryptionForUploadedObjects
  > = z.union([
    z.nativeEnum(OutputSecurityLakeServerSideEncryptionForUploadedObjects),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeServerSideEncryptionForUploadedObjects$ {
  /** @deprecated use `OutputSecurityLakeServerSideEncryptionForUploadedObjects$inboundSchema` instead. */
  export const inboundSchema =
    OutputSecurityLakeServerSideEncryptionForUploadedObjects$inboundSchema;
  /** @deprecated use `OutputSecurityLakeServerSideEncryptionForUploadedObjects$outboundSchema` instead. */
  export const outboundSchema =
    OutputSecurityLakeServerSideEncryptionForUploadedObjects$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSecurityLakeBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSecurityLakeBackpressureBehavior,
  z.ZodTypeDef,
  OutputSecurityLakeBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSecurityLakeBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeBackpressureBehavior$ {
  /** @deprecated use `OutputSecurityLakeBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputSecurityLakeBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSecurityLakeBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputSecurityLakeBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeDiskSpaceProtection$inboundSchema: z.ZodType<
  OutputSecurityLakeDiskSpaceProtection,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeDiskSpaceProtection),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeDiskSpaceProtection$outboundSchema: z.ZodType<
  OutputSecurityLakeDiskSpaceProtection,
  z.ZodTypeDef,
  OutputSecurityLakeDiskSpaceProtection
> = z.union([
  z.nativeEnum(OutputSecurityLakeDiskSpaceProtection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeDiskSpaceProtection$ {
  /** @deprecated use `OutputSecurityLakeDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema =
    OutputSecurityLakeDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputSecurityLakeDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema =
    OutputSecurityLakeDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeParquetVersion$inboundSchema: z.ZodType<
  OutputSecurityLakeParquetVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeParquetVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeParquetVersion$outboundSchema: z.ZodType<
  OutputSecurityLakeParquetVersion,
  z.ZodTypeDef,
  OutputSecurityLakeParquetVersion
> = z.union([
  z.nativeEnum(OutputSecurityLakeParquetVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeParquetVersion$ {
  /** @deprecated use `OutputSecurityLakeParquetVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLakeParquetVersion$inboundSchema;
  /** @deprecated use `OutputSecurityLakeParquetVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSecurityLakeParquetVersion$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeDataPageVersion$inboundSchema: z.ZodType<
  OutputSecurityLakeDataPageVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSecurityLakeDataPageVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSecurityLakeDataPageVersion$outboundSchema: z.ZodType<
  OutputSecurityLakeDataPageVersion,
  z.ZodTypeDef,
  OutputSecurityLakeDataPageVersion
> = z.union([
  z.nativeEnum(OutputSecurityLakeDataPageVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeDataPageVersion$ {
  /** @deprecated use `OutputSecurityLakeDataPageVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLakeDataPageVersion$inboundSchema;
  /** @deprecated use `OutputSecurityLakeDataPageVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputSecurityLakeDataPageVersion$outboundSchema;
}

/** @internal */
export const OutputSecurityLakeKeyValueMetadatum$inboundSchema: z.ZodType<
  OutputSecurityLakeKeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputSecurityLakeKeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputSecurityLakeKeyValueMetadatum$outboundSchema: z.ZodType<
  OutputSecurityLakeKeyValueMetadatum$Outbound,
  z.ZodTypeDef,
  OutputSecurityLakeKeyValueMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLakeKeyValueMetadatum$ {
  /** @deprecated use `OutputSecurityLakeKeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema =
    OutputSecurityLakeKeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputSecurityLakeKeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema =
    OutputSecurityLakeKeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputSecurityLakeKeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputSecurityLakeKeyValueMetadatum$Outbound;
}

export function outputSecurityLakeKeyValueMetadatumToJSON(
  outputSecurityLakeKeyValueMetadatum: OutputSecurityLakeKeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputSecurityLakeKeyValueMetadatum$outboundSchema.parse(
      outputSecurityLakeKeyValueMetadatum,
    ),
  );
}

export function outputSecurityLakeKeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputSecurityLakeKeyValueMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSecurityLakeKeyValueMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSecurityLakeKeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputSecurityLake$inboundSchema: z.ZodType<
  OutputSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSecurityLakeType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: OutputSecurityLakeAuthenticationMethod$inboundSchema
    .default("auto"),
  endpoint: z.string().optional(),
  signatureVersion: OutputSecurityLakeSignatureVersion$inboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  objectACL: OutputSecurityLakeObjectACL$inboundSchema.default("private"),
  storageClass: OutputSecurityLakeStorageClass$inboundSchema.optional(),
  serverSideEncryption:
    OutputSecurityLakeServerSideEncryptionForUploadedObjects$inboundSchema
      .optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  baseFileName: z.string().default("`CriblOut`"),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputSecurityLakeBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputSecurityLakeDiskSpaceProtection$inboundSchema
    .default("block"),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  accountId: z.string(),
  customSource: z.string(),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputSecurityLakeParquetVersion$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputSecurityLakeDataPageVersion$inboundSchema
    .default("DATA_PAGE_V2"),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputSecurityLakeKeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  parquetSchema: z.string().optional(),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputSecurityLake$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region: string;
  awsSecretKey?: string | undefined;
  awsAuthenticationMethod: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn: string;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  stagePath: string;
  addIdToStagePath: boolean;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  kmsKeyId?: string | undefined;
  removeEmptyDirs: boolean;
  baseFileName: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  verifyPermissions: boolean;
  maxClosingFilesToBackpressure: number;
  accountId: string;
  customSource: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<OutputSecurityLakeKeyValueMetadatum$Outbound>
    | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  emptyDirCleanupSec: number;
  parquetSchema?: string | undefined;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputSecurityLake$outboundSchema: z.ZodType<
  OutputSecurityLake$Outbound,
  z.ZodTypeDef,
  OutputSecurityLake
> = z.object({
  id: z.string(),
  type: OutputSecurityLakeType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: OutputSecurityLakeAuthenticationMethod$outboundSchema
    .default("auto"),
  endpoint: z.string().optional(),
  signatureVersion: OutputSecurityLakeSignatureVersion$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  objectACL: OutputSecurityLakeObjectACL$outboundSchema.default("private"),
  storageClass: OutputSecurityLakeStorageClass$outboundSchema.optional(),
  serverSideEncryption:
    OutputSecurityLakeServerSideEncryptionForUploadedObjects$outboundSchema
      .optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  baseFileName: z.string().default("`CriblOut`"),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputSecurityLakeBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputSecurityLakeDiskSpaceProtection$outboundSchema
    .default("block"),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  accountId: z.string(),
  customSource: z.string(),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputSecurityLakeParquetVersion$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputSecurityLakeDataPageVersion$outboundSchema
    .default("DATA_PAGE_V2"),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputSecurityLakeKeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  parquetSchema: z.string().optional(),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLake$ {
  /** @deprecated use `OutputSecurityLake$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLake$inboundSchema;
  /** @deprecated use `OutputSecurityLake$outboundSchema` instead. */
  export const outboundSchema = OutputSecurityLake$outboundSchema;
  /** @deprecated use `OutputSecurityLake$Outbound` instead. */
  export type Outbound = OutputSecurityLake$Outbound;
}

export function outputSecurityLakeToJSON(
  outputSecurityLake: OutputSecurityLake,
): string {
  return JSON.stringify(
    OutputSecurityLake$outboundSchema.parse(outputSecurityLake),
  );
}

export function outputSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<OutputSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSecurityLake' from JSON`,
  );
}

/** @internal */
export const OutputDlS3Type$inboundSchema: z.ZodType<
  OutputDlS3Type,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3Type),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3Type$outboundSchema: z.ZodType<
  OutputDlS3Type,
  z.ZodTypeDef,
  OutputDlS3Type
> = z.union([
  z.nativeEnum(OutputDlS3Type),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3Type$ {
  /** @deprecated use `OutputDlS3Type$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3Type$inboundSchema;
  /** @deprecated use `OutputDlS3Type$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3Type$outboundSchema;
}

/** @internal */
export const OutputDlS3AuthenticationMethod$inboundSchema: z.ZodType<
  OutputDlS3AuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3AuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3AuthenticationMethod$outboundSchema: z.ZodType<
  OutputDlS3AuthenticationMethod,
  z.ZodTypeDef,
  OutputDlS3AuthenticationMethod
> = z.union([
  z.nativeEnum(OutputDlS3AuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3AuthenticationMethod$ {
  /** @deprecated use `OutputDlS3AuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3AuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputDlS3AuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3AuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputDlS3SignatureVersion$inboundSchema: z.ZodType<
  OutputDlS3SignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3SignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3SignatureVersion$outboundSchema: z.ZodType<
  OutputDlS3SignatureVersion,
  z.ZodTypeDef,
  OutputDlS3SignatureVersion
> = z.union([
  z.nativeEnum(OutputDlS3SignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3SignatureVersion$ {
  /** @deprecated use `OutputDlS3SignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3SignatureVersion$inboundSchema;
  /** @deprecated use `OutputDlS3SignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3SignatureVersion$outboundSchema;
}

/** @internal */
export const OutputDlS3ObjectACL$inboundSchema: z.ZodType<
  OutputDlS3ObjectACL,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3ObjectACL),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3ObjectACL$outboundSchema: z.ZodType<
  OutputDlS3ObjectACL,
  z.ZodTypeDef,
  OutputDlS3ObjectACL
> = z.union([
  z.nativeEnum(OutputDlS3ObjectACL),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3ObjectACL$ {
  /** @deprecated use `OutputDlS3ObjectACL$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3ObjectACL$inboundSchema;
  /** @deprecated use `OutputDlS3ObjectACL$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3ObjectACL$outboundSchema;
}

/** @internal */
export const OutputDlS3StorageClass$inboundSchema: z.ZodType<
  OutputDlS3StorageClass,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3StorageClass),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3StorageClass$outboundSchema: z.ZodType<
  OutputDlS3StorageClass,
  z.ZodTypeDef,
  OutputDlS3StorageClass
> = z.union([
  z.nativeEnum(OutputDlS3StorageClass),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3StorageClass$ {
  /** @deprecated use `OutputDlS3StorageClass$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3StorageClass$inboundSchema;
  /** @deprecated use `OutputDlS3StorageClass$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3StorageClass$outboundSchema;
}

/** @internal */
export const OutputDlS3ServerSideEncryptionForUploadedObjects$inboundSchema:
  z.ZodType<
    OutputDlS3ServerSideEncryptionForUploadedObjects,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputDlS3ServerSideEncryptionForUploadedObjects),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputDlS3ServerSideEncryptionForUploadedObjects$outboundSchema:
  z.ZodType<
    OutputDlS3ServerSideEncryptionForUploadedObjects,
    z.ZodTypeDef,
    OutputDlS3ServerSideEncryptionForUploadedObjects
  > = z.union([
    z.nativeEnum(OutputDlS3ServerSideEncryptionForUploadedObjects),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3ServerSideEncryptionForUploadedObjects$ {
  /** @deprecated use `OutputDlS3ServerSideEncryptionForUploadedObjects$inboundSchema` instead. */
  export const inboundSchema =
    OutputDlS3ServerSideEncryptionForUploadedObjects$inboundSchema;
  /** @deprecated use `OutputDlS3ServerSideEncryptionForUploadedObjects$outboundSchema` instead. */
  export const outboundSchema =
    OutputDlS3ServerSideEncryptionForUploadedObjects$outboundSchema;
}

/** @internal */
export const OutputDlS3DataFormat$inboundSchema: z.ZodType<
  OutputDlS3DataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3DataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3DataFormat$outboundSchema: z.ZodType<
  OutputDlS3DataFormat,
  z.ZodTypeDef,
  OutputDlS3DataFormat
> = z.union([
  z.nativeEnum(OutputDlS3DataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3DataFormat$ {
  /** @deprecated use `OutputDlS3DataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3DataFormat$inboundSchema;
  /** @deprecated use `OutputDlS3DataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3DataFormat$outboundSchema;
}

/** @internal */
export const OutputDlS3BackpressureBehavior$inboundSchema: z.ZodType<
  OutputDlS3BackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3BackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3BackpressureBehavior$outboundSchema: z.ZodType<
  OutputDlS3BackpressureBehavior,
  z.ZodTypeDef,
  OutputDlS3BackpressureBehavior
> = z.union([
  z.nativeEnum(OutputDlS3BackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3BackpressureBehavior$ {
  /** @deprecated use `OutputDlS3BackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3BackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputDlS3BackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3BackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputDlS3DiskSpaceProtection$inboundSchema: z.ZodType<
  OutputDlS3DiskSpaceProtection,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3DiskSpaceProtection),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3DiskSpaceProtection$outboundSchema: z.ZodType<
  OutputDlS3DiskSpaceProtection,
  z.ZodTypeDef,
  OutputDlS3DiskSpaceProtection
> = z.union([
  z.nativeEnum(OutputDlS3DiskSpaceProtection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3DiskSpaceProtection$ {
  /** @deprecated use `OutputDlS3DiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3DiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputDlS3DiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3DiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputDlS3Compression$inboundSchema: z.ZodType<
  OutputDlS3Compression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3Compression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3Compression$outboundSchema: z.ZodType<
  OutputDlS3Compression,
  z.ZodTypeDef,
  OutputDlS3Compression
> = z.union([
  z.nativeEnum(OutputDlS3Compression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3Compression$ {
  /** @deprecated use `OutputDlS3Compression$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3Compression$inboundSchema;
  /** @deprecated use `OutputDlS3Compression$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3Compression$outboundSchema;
}

/** @internal */
export const OutputDlS3CompressionLevel$inboundSchema: z.ZodType<
  OutputDlS3CompressionLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3CompressionLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3CompressionLevel$outboundSchema: z.ZodType<
  OutputDlS3CompressionLevel,
  z.ZodTypeDef,
  OutputDlS3CompressionLevel
> = z.union([
  z.nativeEnum(OutputDlS3CompressionLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3CompressionLevel$ {
  /** @deprecated use `OutputDlS3CompressionLevel$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3CompressionLevel$inboundSchema;
  /** @deprecated use `OutputDlS3CompressionLevel$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3CompressionLevel$outboundSchema;
}

/** @internal */
export const OutputDlS3ParquetVersion$inboundSchema: z.ZodType<
  OutputDlS3ParquetVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3ParquetVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3ParquetVersion$outboundSchema: z.ZodType<
  OutputDlS3ParquetVersion,
  z.ZodTypeDef,
  OutputDlS3ParquetVersion
> = z.union([
  z.nativeEnum(OutputDlS3ParquetVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3ParquetVersion$ {
  /** @deprecated use `OutputDlS3ParquetVersion$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3ParquetVersion$inboundSchema;
  /** @deprecated use `OutputDlS3ParquetVersion$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3ParquetVersion$outboundSchema;
}

/** @internal */
export const OutputDlS3DataPageVersion$inboundSchema: z.ZodType<
  OutputDlS3DataPageVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDlS3DataPageVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDlS3DataPageVersion$outboundSchema: z.ZodType<
  OutputDlS3DataPageVersion,
  z.ZodTypeDef,
  OutputDlS3DataPageVersion
> = z.union([
  z.nativeEnum(OutputDlS3DataPageVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3DataPageVersion$ {
  /** @deprecated use `OutputDlS3DataPageVersion$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3DataPageVersion$inboundSchema;
  /** @deprecated use `OutputDlS3DataPageVersion$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3DataPageVersion$outboundSchema;
}

/** @internal */
export const OutputDlS3KeyValueMetadatum$inboundSchema: z.ZodType<
  OutputDlS3KeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputDlS3KeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputDlS3KeyValueMetadatum$outboundSchema: z.ZodType<
  OutputDlS3KeyValueMetadatum$Outbound,
  z.ZodTypeDef,
  OutputDlS3KeyValueMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3KeyValueMetadatum$ {
  /** @deprecated use `OutputDlS3KeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3KeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputDlS3KeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3KeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputDlS3KeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputDlS3KeyValueMetadatum$Outbound;
}

export function outputDlS3KeyValueMetadatumToJSON(
  outputDlS3KeyValueMetadatum: OutputDlS3KeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputDlS3KeyValueMetadatum$outboundSchema.parse(
      outputDlS3KeyValueMetadatum,
    ),
  );
}

export function outputDlS3KeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputDlS3KeyValueMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDlS3KeyValueMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDlS3KeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputDlS3$inboundSchema: z.ZodType<
  OutputDlS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputDlS3Type$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: OutputDlS3AuthenticationMethod$inboundSchema.default(
    "auto",
  ),
  endpoint: z.string().optional(),
  signatureVersion: OutputDlS3SignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: OutputDlS3ObjectACL$inboundSchema.default("private"),
  storageClass: OutputDlS3StorageClass$inboundSchema.optional(),
  serverSideEncryption:
    OutputDlS3ServerSideEncryptionForUploadedObjects$inboundSchema.optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  format: OutputDlS3DataFormat$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputDlS3BackpressureBehavior$inboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputDlS3DiskSpaceProtection$inboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  partitioningFields: z.array(z.string()).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputDlS3Compression$inboundSchema.default("gzip"),
  compressionLevel: OutputDlS3CompressionLevel$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputDlS3ParquetVersion$inboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: OutputDlS3DataPageVersion$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputDlS3KeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputDlS3$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region?: string | undefined;
  awsSecretKey?: string | undefined;
  awsAuthenticationMethod: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  stagePath: string;
  addIdToStagePath: boolean;
  destPath: string;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  kmsKeyId?: string | undefined;
  removeEmptyDirs: boolean;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  verifyPermissions: boolean;
  maxClosingFilesToBackpressure: number;
  partitioningFields?: Array<string> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<OutputDlS3KeyValueMetadatum$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputDlS3$outboundSchema: z.ZodType<
  OutputDlS3$Outbound,
  z.ZodTypeDef,
  OutputDlS3
> = z.object({
  id: z.string(),
  type: OutputDlS3Type$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: OutputDlS3AuthenticationMethod$outboundSchema
    .default("auto"),
  endpoint: z.string().optional(),
  signatureVersion: OutputDlS3SignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: OutputDlS3ObjectACL$outboundSchema.default("private"),
  storageClass: OutputDlS3StorageClass$outboundSchema.optional(),
  serverSideEncryption:
    OutputDlS3ServerSideEncryptionForUploadedObjects$outboundSchema.optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  format: OutputDlS3DataFormat$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputDlS3BackpressureBehavior$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputDlS3DiskSpaceProtection$outboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  partitioningFields: z.array(z.string()).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputDlS3Compression$outboundSchema.default("gzip"),
  compressionLevel: OutputDlS3CompressionLevel$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputDlS3ParquetVersion$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputDlS3DataPageVersion$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputDlS3KeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3$ {
  /** @deprecated use `OutputDlS3$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3$inboundSchema;
  /** @deprecated use `OutputDlS3$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3$outboundSchema;
  /** @deprecated use `OutputDlS3$Outbound` instead. */
  export type Outbound = OutputDlS3$Outbound;
}

export function outputDlS3ToJSON(outputDlS3: OutputDlS3): string {
  return JSON.stringify(OutputDlS3$outboundSchema.parse(outputDlS3));
}

export function outputDlS3FromJSON(
  jsonString: string,
): SafeParseResult<OutputDlS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDlS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDlS3' from JSON`,
  );
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemType$inboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemType$outboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemType,
  z.ZodTypeDef,
  OutputCrowdstrikeNextGenSiemType
> = z.union([
  z.nativeEnum(OutputCrowdstrikeNextGenSiemType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemType$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemType$inboundSchema` instead. */
  export const inboundSchema = OutputCrowdstrikeNextGenSiemType$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemType$outboundSchema` instead. */
  export const outboundSchema = OutputCrowdstrikeNextGenSiemType$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemExtraHttpHeader$inboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemExtraHttpHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string().optional(),
    value: z.string(),
  });

/** @internal */
export type OutputCrowdstrikeNextGenSiemExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputCrowdstrikeNextGenSiemExtraHttpHeader$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemExtraHttpHeader$Outbound,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemExtraHttpHeader
  > = z.object({
    name: z.string().optional(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemExtraHttpHeader$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputCrowdstrikeNextGenSiemExtraHttpHeader$Outbound;
}

export function outputCrowdstrikeNextGenSiemExtraHttpHeaderToJSON(
  outputCrowdstrikeNextGenSiemExtraHttpHeader:
    OutputCrowdstrikeNextGenSiemExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputCrowdstrikeNextGenSiemExtraHttpHeader$outboundSchema.parse(
      outputCrowdstrikeNextGenSiemExtraHttpHeader,
    ),
  );
}

export function outputCrowdstrikeNextGenSiemExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputCrowdstrikeNextGenSiemExtraHttpHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputCrowdstrikeNextGenSiemExtraHttpHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputCrowdstrikeNextGenSiemExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$inboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemRequestFormat$inboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemRequestFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemRequestFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemRequestFormat$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemRequestFormat,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemRequestFormat
  > = z.union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemRequestFormat),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemRequestFormat$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemRequestFormat$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemRequestFormat$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemRequestFormat$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemRequestFormat$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemAuthenticationMethod$inboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputCrowdstrikeNextGenSiemAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemAuthenticationMethod$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemAuthenticationMethod,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemAuthenticationMethod
  > = z.union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemAuthenticationMethod$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemResponseRetrySetting$inboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemResponseRetrySetting,
    z.ZodTypeDef,
    unknown
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/** @internal */
export type OutputCrowdstrikeNextGenSiemResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputCrowdstrikeNextGenSiemResponseRetrySetting$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemResponseRetrySetting$Outbound,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemResponseRetrySetting
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemResponseRetrySetting$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemResponseRetrySetting$Outbound` instead. */
  export type Outbound =
    OutputCrowdstrikeNextGenSiemResponseRetrySetting$Outbound;
}

export function outputCrowdstrikeNextGenSiemResponseRetrySettingToJSON(
  outputCrowdstrikeNextGenSiemResponseRetrySetting:
    OutputCrowdstrikeNextGenSiemResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputCrowdstrikeNextGenSiemResponseRetrySetting$outboundSchema.parse(
      outputCrowdstrikeNextGenSiemResponseRetrySetting,
    ),
  );
}

export function outputCrowdstrikeNextGenSiemResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputCrowdstrikeNextGenSiemResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputCrowdstrikeNextGenSiemResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputCrowdstrikeNextGenSiemResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$inboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/** @internal */
export type OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$Outbound,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$Outbound` instead. */
  export type Outbound =
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$Outbound;
}

export function outputCrowdstrikeNextGenSiemTimeoutRetrySettingsToJSON(
  outputCrowdstrikeNextGenSiemTimeoutRetrySettings:
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$outboundSchema.parse(
      outputCrowdstrikeNextGenSiemTimeoutRetrySettings,
    ),
  );
}

export function outputCrowdstrikeNextGenSiemTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputCrowdstrikeNextGenSiemTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputCrowdstrikeNextGenSiemTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemBackpressureBehavior$inboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemBackpressureBehavior,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputCrowdstrikeNextGenSiemBackpressureBehavior),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemBackpressureBehavior$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemBackpressureBehavior,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemBackpressureBehavior
  > = z.union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemBackpressureBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemBackpressureBehavior$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemCompression$inboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemCompression$outboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemCompression,
  z.ZodTypeDef,
  OutputCrowdstrikeNextGenSiemCompression
> = z.union([
  z.nativeEnum(OutputCrowdstrikeNextGenSiemCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemCompression$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemCompression$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemCompression$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemQueueFullBehavior$inboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemQueueFullBehavior,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputCrowdstrikeNextGenSiemQueueFullBehavior),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemQueueFullBehavior$outboundSchema:
  z.ZodType<
    OutputCrowdstrikeNextGenSiemQueueFullBehavior,
    z.ZodTypeDef,
    OutputCrowdstrikeNextGenSiemQueueFullBehavior
  > = z.union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemQueueFullBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemQueueFullBehavior$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemMode$inboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCrowdstrikeNextGenSiemMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCrowdstrikeNextGenSiemMode$outboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemMode,
  z.ZodTypeDef,
  OutputCrowdstrikeNextGenSiemMode
> = z.union([
  z.nativeEnum(OutputCrowdstrikeNextGenSiemMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemMode$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemMode$inboundSchema` instead. */
  export const inboundSchema = OutputCrowdstrikeNextGenSiemMode$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemMode$outboundSchema` instead. */
  export const outboundSchema = OutputCrowdstrikeNextGenSiemMode$outboundSchema;
}

/** @internal */
export const OutputCrowdstrikeNextGenSiemPqControls$inboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputCrowdstrikeNextGenSiemPqControls$Outbound = {};

/** @internal */
export const OutputCrowdstrikeNextGenSiemPqControls$outboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiemPqControls$Outbound,
  z.ZodTypeDef,
  OutputCrowdstrikeNextGenSiemPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiemPqControls$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiemPqControls$inboundSchema` instead. */
  export const inboundSchema =
    OutputCrowdstrikeNextGenSiemPqControls$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemPqControls$outboundSchema` instead. */
  export const outboundSchema =
    OutputCrowdstrikeNextGenSiemPqControls$outboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiemPqControls$Outbound` instead. */
  export type Outbound = OutputCrowdstrikeNextGenSiemPqControls$Outbound;
}

export function outputCrowdstrikeNextGenSiemPqControlsToJSON(
  outputCrowdstrikeNextGenSiemPqControls:
    OutputCrowdstrikeNextGenSiemPqControls,
): string {
  return JSON.stringify(
    OutputCrowdstrikeNextGenSiemPqControls$outboundSchema.parse(
      outputCrowdstrikeNextGenSiemPqControls,
    ),
  );
}

export function outputCrowdstrikeNextGenSiemPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputCrowdstrikeNextGenSiemPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputCrowdstrikeNextGenSiemPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputCrowdstrikeNextGenSiemPqControls' from JSON`,
  );
}

/** @internal */
export const OutputCrowdstrikeNextGenSiem$inboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputCrowdstrikeNextGenSiemType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputCrowdstrikeNextGenSiemExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode:
    OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$inboundSchema.default(
      "none",
    ),
  safeHeaders: z.array(z.string()).optional(),
  format: OutputCrowdstrikeNextGenSiemRequestFormat$inboundSchema.default(
    "raw",
  ),
  authType: OutputCrowdstrikeNextGenSiemAuthenticationMethod$inboundSchema
    .default("manual"),
  responseRetrySettings: z.array(
    z.lazy(() =>
      OutputCrowdstrikeNextGenSiemResponseRetrySetting$inboundSchema
    ),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputCrowdstrikeNextGenSiemBackpressureBehavior$inboundSchema
    .default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputCrowdstrikeNextGenSiemCompression$inboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputCrowdstrikeNextGenSiemQueueFullBehavior$inboundSchema
    .default("block"),
  pqMode: OutputCrowdstrikeNextGenSiemMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputCrowdstrikeNextGenSiemPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputCrowdstrikeNextGenSiem$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputCrowdstrikeNextGenSiemExtraHttpHeader$Outbound>
    | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  format: string;
  authType: string;
  responseRetrySettings?:
    | Array<OutputCrowdstrikeNextGenSiemResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputCrowdstrikeNextGenSiemPqControls$Outbound | undefined;
};

/** @internal */
export const OutputCrowdstrikeNextGenSiem$outboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiem$Outbound,
  z.ZodTypeDef,
  OutputCrowdstrikeNextGenSiem
> = z.object({
  id: z.string(),
  type: OutputCrowdstrikeNextGenSiemType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputCrowdstrikeNextGenSiemExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode:
    OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode$outboundSchema.default(
      "none",
    ),
  safeHeaders: z.array(z.string()).optional(),
  format: OutputCrowdstrikeNextGenSiemRequestFormat$outboundSchema.default(
    "raw",
  ),
  authType: OutputCrowdstrikeNextGenSiemAuthenticationMethod$outboundSchema
    .default("manual"),
  responseRetrySettings: z.array(
    z.lazy(() =>
      OutputCrowdstrikeNextGenSiemResponseRetrySetting$outboundSchema
    ),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputCrowdstrikeNextGenSiemTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure:
    OutputCrowdstrikeNextGenSiemBackpressureBehavior$outboundSchema.default(
      "block",
    ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputCrowdstrikeNextGenSiemCompression$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputCrowdstrikeNextGenSiemQueueFullBehavior$outboundSchema
    .default("block"),
  pqMode: OutputCrowdstrikeNextGenSiemMode$outboundSchema.default("error"),
  pqControls: z.lazy(() =>
    OutputCrowdstrikeNextGenSiemPqControls$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiem$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema = OutputCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema = OutputCrowdstrikeNextGenSiem$outboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiem$Outbound` instead. */
  export type Outbound = OutputCrowdstrikeNextGenSiem$Outbound;
}

export function outputCrowdstrikeNextGenSiemToJSON(
  outputCrowdstrikeNextGenSiem: OutputCrowdstrikeNextGenSiem,
): string {
  return JSON.stringify(
    OutputCrowdstrikeNextGenSiem$outboundSchema.parse(
      outputCrowdstrikeNextGenSiem,
    ),
  );
}

export function outputCrowdstrikeNextGenSiemFromJSON(
  jsonString: string,
): SafeParseResult<OutputCrowdstrikeNextGenSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputCrowdstrikeNextGenSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputCrowdstrikeNextGenSiem' from JSON`,
  );
}

/** @internal */
export const OutputHumioHecType$inboundSchema: z.ZodType<
  OutputHumioHecType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecType$outboundSchema: z.ZodType<
  OutputHumioHecType,
  z.ZodTypeDef,
  OutputHumioHecType
> = z.union([
  z.nativeEnum(OutputHumioHecType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecType$ {
  /** @deprecated use `OutputHumioHecType$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecType$inboundSchema;
  /** @deprecated use `OutputHumioHecType$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHecType$outboundSchema;
}

/** @internal */
export const OutputHumioHecExtraHttpHeader$inboundSchema: z.ZodType<
  OutputHumioHecExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputHumioHecExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputHumioHecExtraHttpHeader$outboundSchema: z.ZodType<
  OutputHumioHecExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputHumioHecExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecExtraHttpHeader$ {
  /** @deprecated use `OutputHumioHecExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputHumioHecExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHecExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputHumioHecExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputHumioHecExtraHttpHeader$Outbound;
}

export function outputHumioHecExtraHttpHeaderToJSON(
  outputHumioHecExtraHttpHeader: OutputHumioHecExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputHumioHecExtraHttpHeader$outboundSchema.parse(
      outputHumioHecExtraHttpHeader,
    ),
  );
}

export function outputHumioHecExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputHumioHecExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHumioHecExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHumioHecExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputHumioHecFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputHumioHecFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputHumioHecFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputHumioHecFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputHumioHecFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecFailedRequestLoggingMode$ {
  /** @deprecated use `OutputHumioHecFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputHumioHecFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputHumioHecFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputHumioHecFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputHumioHecRequestFormat$inboundSchema: z.ZodType<
  OutputHumioHecRequestFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecRequestFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecRequestFormat$outboundSchema: z.ZodType<
  OutputHumioHecRequestFormat,
  z.ZodTypeDef,
  OutputHumioHecRequestFormat
> = z.union([
  z.nativeEnum(OutputHumioHecRequestFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecRequestFormat$ {
  /** @deprecated use `OutputHumioHecRequestFormat$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecRequestFormat$inboundSchema;
  /** @deprecated use `OutputHumioHecRequestFormat$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHecRequestFormat$outboundSchema;
}

/** @internal */
export const OutputHumioHecAuthenticationMethod$inboundSchema: z.ZodType<
  OutputHumioHecAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecAuthenticationMethod$outboundSchema: z.ZodType<
  OutputHumioHecAuthenticationMethod,
  z.ZodTypeDef,
  OutputHumioHecAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputHumioHecAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecAuthenticationMethod$ {
  /** @deprecated use `OutputHumioHecAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputHumioHecAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputHumioHecAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputHumioHecResponseRetrySetting$inboundSchema: z.ZodType<
  OutputHumioHecResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputHumioHecResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputHumioHecResponseRetrySetting$outboundSchema: z.ZodType<
  OutputHumioHecResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputHumioHecResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecResponseRetrySetting$ {
  /** @deprecated use `OutputHumioHecResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputHumioHecResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputHumioHecResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputHumioHecResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputHumioHecResponseRetrySetting$Outbound;
}

export function outputHumioHecResponseRetrySettingToJSON(
  outputHumioHecResponseRetrySetting: OutputHumioHecResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputHumioHecResponseRetrySetting$outboundSchema.parse(
      outputHumioHecResponseRetrySetting,
    ),
  );
}

export function outputHumioHecResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputHumioHecResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputHumioHecResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHumioHecResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputHumioHecTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputHumioHecTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputHumioHecTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputHumioHecTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputHumioHecTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputHumioHecTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecTimeoutRetrySettings$ {
  /** @deprecated use `OutputHumioHecTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputHumioHecTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputHumioHecTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputHumioHecTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputHumioHecTimeoutRetrySettings$Outbound;
}

export function outputHumioHecTimeoutRetrySettingsToJSON(
  outputHumioHecTimeoutRetrySettings: OutputHumioHecTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputHumioHecTimeoutRetrySettings$outboundSchema.parse(
      outputHumioHecTimeoutRetrySettings,
    ),
  );
}

export function outputHumioHecTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputHumioHecTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputHumioHecTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHumioHecTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputHumioHecBackpressureBehavior$inboundSchema: z.ZodType<
  OutputHumioHecBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecBackpressureBehavior$outboundSchema: z.ZodType<
  OutputHumioHecBackpressureBehavior,
  z.ZodTypeDef,
  OutputHumioHecBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputHumioHecBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecBackpressureBehavior$ {
  /** @deprecated use `OutputHumioHecBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputHumioHecBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputHumioHecBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputHumioHecCompression$inboundSchema: z.ZodType<
  OutputHumioHecCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecCompression$outboundSchema: z.ZodType<
  OutputHumioHecCompression,
  z.ZodTypeDef,
  OutputHumioHecCompression
> = z.union([
  z.nativeEnum(OutputHumioHecCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecCompression$ {
  /** @deprecated use `OutputHumioHecCompression$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecCompression$inboundSchema;
  /** @deprecated use `OutputHumioHecCompression$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHecCompression$outboundSchema;
}

/** @internal */
export const OutputHumioHecQueueFullBehavior$inboundSchema: z.ZodType<
  OutputHumioHecQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecQueueFullBehavior$outboundSchema: z.ZodType<
  OutputHumioHecQueueFullBehavior,
  z.ZodTypeDef,
  OutputHumioHecQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputHumioHecQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecQueueFullBehavior$ {
  /** @deprecated use `OutputHumioHecQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputHumioHecQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHecQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputHumioHecMode$inboundSchema: z.ZodType<
  OutputHumioHecMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHumioHecMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHumioHecMode$outboundSchema: z.ZodType<
  OutputHumioHecMode,
  z.ZodTypeDef,
  OutputHumioHecMode
> = z.union([
  z.nativeEnum(OutputHumioHecMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecMode$ {
  /** @deprecated use `OutputHumioHecMode$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecMode$inboundSchema;
  /** @deprecated use `OutputHumioHecMode$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHecMode$outboundSchema;
}

/** @internal */
export const OutputHumioHecPqControls$inboundSchema: z.ZodType<
  OutputHumioHecPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputHumioHecPqControls$Outbound = {};

/** @internal */
export const OutputHumioHecPqControls$outboundSchema: z.ZodType<
  OutputHumioHecPqControls$Outbound,
  z.ZodTypeDef,
  OutputHumioHecPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHecPqControls$ {
  /** @deprecated use `OutputHumioHecPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHecPqControls$inboundSchema;
  /** @deprecated use `OutputHumioHecPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHecPqControls$outboundSchema;
  /** @deprecated use `OutputHumioHecPqControls$Outbound` instead. */
  export type Outbound = OutputHumioHecPqControls$Outbound;
}

export function outputHumioHecPqControlsToJSON(
  outputHumioHecPqControls: OutputHumioHecPqControls,
): string {
  return JSON.stringify(
    OutputHumioHecPqControls$outboundSchema.parse(outputHumioHecPqControls),
  );
}

export function outputHumioHecPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputHumioHecPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHumioHecPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHumioHecPqControls' from JSON`,
  );
}

/** @internal */
export const OutputHumioHec$inboundSchema: z.ZodType<
  OutputHumioHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputHumioHecType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string().default("https://cloud.us.humio.com/api/v1/ingest/hec"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputHumioHecExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode: OutputHumioHecFailedRequestLoggingMode$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  format: OutputHumioHecRequestFormat$inboundSchema.default("JSON"),
  authType: OutputHumioHecAuthenticationMethod$inboundSchema.default("manual"),
  responseRetrySettings: z.array(
    z.lazy(() => OutputHumioHecResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputHumioHecTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputHumioHecBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputHumioHecCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputHumioHecQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputHumioHecMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputHumioHecPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputHumioHec$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputHumioHecExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  format: string;
  authType: string;
  responseRetrySettings?:
    | Array<OutputHumioHecResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputHumioHecTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputHumioHecPqControls$Outbound | undefined;
};

/** @internal */
export const OutputHumioHec$outboundSchema: z.ZodType<
  OutputHumioHec$Outbound,
  z.ZodTypeDef,
  OutputHumioHec
> = z.object({
  id: z.string(),
  type: OutputHumioHecType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string().default("https://cloud.us.humio.com/api/v1/ingest/hec"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputHumioHecExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode:
    OutputHumioHecFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  format: OutputHumioHecRequestFormat$outboundSchema.default("JSON"),
  authType: OutputHumioHecAuthenticationMethod$outboundSchema.default("manual"),
  responseRetrySettings: z.array(
    z.lazy(() => OutputHumioHecResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputHumioHecTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputHumioHecBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputHumioHecCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputHumioHecQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputHumioHecMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputHumioHecPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHec$ {
  /** @deprecated use `OutputHumioHec$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHec$inboundSchema;
  /** @deprecated use `OutputHumioHec$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHec$outboundSchema;
  /** @deprecated use `OutputHumioHec$Outbound` instead. */
  export type Outbound = OutputHumioHec$Outbound;
}

export function outputHumioHecToJSON(outputHumioHec: OutputHumioHec): string {
  return JSON.stringify(OutputHumioHec$outboundSchema.parse(outputHumioHec));
}

export function outputHumioHecFromJSON(
  jsonString: string,
): SafeParseResult<OutputHumioHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHumioHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHumioHec' from JSON`,
  );
}

/** @internal */
export const OutputServiceNowType$inboundSchema: z.ZodType<
  OutputServiceNowType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowType$outboundSchema: z.ZodType<
  OutputServiceNowType,
  z.ZodTypeDef,
  OutputServiceNowType
> = z.union([
  z.nativeEnum(OutputServiceNowType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowType$ {
  /** @deprecated use `OutputServiceNowType$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowType$inboundSchema;
  /** @deprecated use `OutputServiceNowType$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNowType$outboundSchema;
}

/** @internal */
export const OutputServiceNowOTLPVersion$inboundSchema: z.ZodType<
  OutputServiceNowOTLPVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowOTLPVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowOTLPVersion$outboundSchema: z.ZodType<
  OutputServiceNowOTLPVersion,
  z.ZodTypeDef,
  OutputServiceNowOTLPVersion
> = z.union([
  z.nativeEnum(OutputServiceNowOTLPVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowOTLPVersion$ {
  /** @deprecated use `OutputServiceNowOTLPVersion$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowOTLPVersion$inboundSchema;
  /** @deprecated use `OutputServiceNowOTLPVersion$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNowOTLPVersion$outboundSchema;
}

/** @internal */
export const OutputServiceNowProtocol$inboundSchema: z.ZodType<
  OutputServiceNowProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowProtocol$outboundSchema: z.ZodType<
  OutputServiceNowProtocol,
  z.ZodTypeDef,
  OutputServiceNowProtocol
> = z.union([
  z.nativeEnum(OutputServiceNowProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowProtocol$ {
  /** @deprecated use `OutputServiceNowProtocol$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowProtocol$inboundSchema;
  /** @deprecated use `OutputServiceNowProtocol$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNowProtocol$outboundSchema;
}

/** @internal */
export const OutputServiceNowCompressCompression$inboundSchema: z.ZodType<
  OutputServiceNowCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowCompressCompression$outboundSchema: z.ZodType<
  OutputServiceNowCompressCompression,
  z.ZodTypeDef,
  OutputServiceNowCompressCompression
> = z.union([
  z.nativeEnum(OutputServiceNowCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowCompressCompression$ {
  /** @deprecated use `OutputServiceNowCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowCompressCompression$inboundSchema;
  /** @deprecated use `OutputServiceNowCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowCompressCompression$outboundSchema;
}

/** @internal */
export const OutputServiceNowHttpCompressCompression$inboundSchema: z.ZodType<
  OutputServiceNowHttpCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowHttpCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowHttpCompressCompression$outboundSchema: z.ZodType<
  OutputServiceNowHttpCompressCompression,
  z.ZodTypeDef,
  OutputServiceNowHttpCompressCompression
> = z.union([
  z.nativeEnum(OutputServiceNowHttpCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowHttpCompressCompression$ {
  /** @deprecated use `OutputServiceNowHttpCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowHttpCompressCompression$inboundSchema;
  /** @deprecated use `OutputServiceNowHttpCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowHttpCompressCompression$outboundSchema;
}

/** @internal */
export const OutputServiceNowMetadatum$inboundSchema: z.ZodType<
  OutputServiceNowMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputServiceNowMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputServiceNowMetadatum$outboundSchema: z.ZodType<
  OutputServiceNowMetadatum$Outbound,
  z.ZodTypeDef,
  OutputServiceNowMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowMetadatum$ {
  /** @deprecated use `OutputServiceNowMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowMetadatum$inboundSchema;
  /** @deprecated use `OutputServiceNowMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNowMetadatum$outboundSchema;
  /** @deprecated use `OutputServiceNowMetadatum$Outbound` instead. */
  export type Outbound = OutputServiceNowMetadatum$Outbound;
}

export function outputServiceNowMetadatumToJSON(
  outputServiceNowMetadatum: OutputServiceNowMetadatum,
): string {
  return JSON.stringify(
    OutputServiceNowMetadatum$outboundSchema.parse(outputServiceNowMetadatum),
  );
}

export function outputServiceNowMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNowMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputServiceNowMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNowMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputServiceNowFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputServiceNowFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputServiceNowFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputServiceNowFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputServiceNowFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowFailedRequestLoggingMode$ {
  /** @deprecated use `OutputServiceNowFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputServiceNowFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputServiceNowBackpressureBehavior$inboundSchema: z.ZodType<
  OutputServiceNowBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowBackpressureBehavior$outboundSchema: z.ZodType<
  OutputServiceNowBackpressureBehavior,
  z.ZodTypeDef,
  OutputServiceNowBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputServiceNowBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowBackpressureBehavior$ {
  /** @deprecated use `OutputServiceNowBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputServiceNowBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputServiceNowExtraHttpHeader$inboundSchema: z.ZodType<
  OutputServiceNowExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputServiceNowExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputServiceNowExtraHttpHeader$outboundSchema: z.ZodType<
  OutputServiceNowExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputServiceNowExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowExtraHttpHeader$ {
  /** @deprecated use `OutputServiceNowExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputServiceNowExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNowExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputServiceNowExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputServiceNowExtraHttpHeader$Outbound;
}

export function outputServiceNowExtraHttpHeaderToJSON(
  outputServiceNowExtraHttpHeader: OutputServiceNowExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputServiceNowExtraHttpHeader$outboundSchema.parse(
      outputServiceNowExtraHttpHeader,
    ),
  );
}

export function outputServiceNowExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNowExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputServiceNowExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNowExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputServiceNowResponseRetrySetting$inboundSchema: z.ZodType<
  OutputServiceNowResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputServiceNowResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputServiceNowResponseRetrySetting$outboundSchema: z.ZodType<
  OutputServiceNowResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputServiceNowResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowResponseRetrySetting$ {
  /** @deprecated use `OutputServiceNowResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputServiceNowResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputServiceNowResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputServiceNowResponseRetrySetting$Outbound;
}

export function outputServiceNowResponseRetrySettingToJSON(
  outputServiceNowResponseRetrySetting: OutputServiceNowResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputServiceNowResponseRetrySetting$outboundSchema.parse(
      outputServiceNowResponseRetrySetting,
    ),
  );
}

export function outputServiceNowResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNowResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputServiceNowResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNowResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputServiceNowTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputServiceNowTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputServiceNowTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputServiceNowTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputServiceNowTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputServiceNowTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowTimeoutRetrySettings$ {
  /** @deprecated use `OutputServiceNowTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputServiceNowTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputServiceNowTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputServiceNowTimeoutRetrySettings$Outbound;
}

export function outputServiceNowTimeoutRetrySettingsToJSON(
  outputServiceNowTimeoutRetrySettings: OutputServiceNowTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputServiceNowTimeoutRetrySettings$outboundSchema.parse(
      outputServiceNowTimeoutRetrySettings,
    ),
  );
}

export function outputServiceNowTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNowTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputServiceNowTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNowTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputServiceNowMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputServiceNowMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputServiceNowMinimumTLSVersion,
  z.ZodTypeDef,
  OutputServiceNowMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputServiceNowMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowMinimumTLSVersion$ {
  /** @deprecated use `OutputServiceNowMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputServiceNowMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputServiceNowMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputServiceNowMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputServiceNowMaximumTLSVersion,
  z.ZodTypeDef,
  OutputServiceNowMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputServiceNowMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowMaximumTLSVersion$ {
  /** @deprecated use `OutputServiceNowMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputServiceNowMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputServiceNowTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputServiceNowTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputServiceNowMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputServiceNowMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputServiceNowTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputServiceNowTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputServiceNowTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputServiceNowTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputServiceNowMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: OutputServiceNowMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowTLSSettingsClientSide$ {
  /** @deprecated use `OutputServiceNowTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputServiceNowTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputServiceNowTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputServiceNowTLSSettingsClientSide$Outbound;
}

export function outputServiceNowTLSSettingsClientSideToJSON(
  outputServiceNowTLSSettingsClientSide: OutputServiceNowTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputServiceNowTLSSettingsClientSide$outboundSchema.parse(
      outputServiceNowTLSSettingsClientSide,
    ),
  );
}

export function outputServiceNowTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNowTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputServiceNowTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNowTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputServiceNowPqCompressCompression$inboundSchema: z.ZodType<
  OutputServiceNowPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowPqCompressCompression$outboundSchema: z.ZodType<
  OutputServiceNowPqCompressCompression,
  z.ZodTypeDef,
  OutputServiceNowPqCompressCompression
> = z.union([
  z.nativeEnum(OutputServiceNowPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowPqCompressCompression$ {
  /** @deprecated use `OutputServiceNowPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputServiceNowPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputServiceNowPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputServiceNowQueueFullBehavior$inboundSchema: z.ZodType<
  OutputServiceNowQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowQueueFullBehavior$outboundSchema: z.ZodType<
  OutputServiceNowQueueFullBehavior,
  z.ZodTypeDef,
  OutputServiceNowQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputServiceNowQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowQueueFullBehavior$ {
  /** @deprecated use `OutputServiceNowQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputServiceNowQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputServiceNowQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputServiceNowMode$inboundSchema: z.ZodType<
  OutputServiceNowMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputServiceNowMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputServiceNowMode$outboundSchema: z.ZodType<
  OutputServiceNowMode,
  z.ZodTypeDef,
  OutputServiceNowMode
> = z.union([
  z.nativeEnum(OutputServiceNowMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowMode$ {
  /** @deprecated use `OutputServiceNowMode$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowMode$inboundSchema;
  /** @deprecated use `OutputServiceNowMode$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNowMode$outboundSchema;
}

/** @internal */
export const OutputServiceNowPqControls$inboundSchema: z.ZodType<
  OutputServiceNowPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputServiceNowPqControls$Outbound = {};

/** @internal */
export const OutputServiceNowPqControls$outboundSchema: z.ZodType<
  OutputServiceNowPqControls$Outbound,
  z.ZodTypeDef,
  OutputServiceNowPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNowPqControls$ {
  /** @deprecated use `OutputServiceNowPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNowPqControls$inboundSchema;
  /** @deprecated use `OutputServiceNowPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNowPqControls$outboundSchema;
  /** @deprecated use `OutputServiceNowPqControls$Outbound` instead. */
  export type Outbound = OutputServiceNowPqControls$Outbound;
}

export function outputServiceNowPqControlsToJSON(
  outputServiceNowPqControls: OutputServiceNowPqControls,
): string {
  return JSON.stringify(
    OutputServiceNowPqControls$outboundSchema.parse(outputServiceNowPqControls),
  );
}

export function outputServiceNowPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNowPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputServiceNowPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNowPqControls' from JSON`,
  );
}

/** @internal */
export const OutputServiceNow$inboundSchema: z.ZodType<
  OutputServiceNow,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputServiceNowType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string().default("ingest.lightstep.com:443"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("lightstep-access-token"),
  otlpVersion: OutputServiceNowOTLPVersion$inboundSchema.default("1.3.1"),
  maxPayloadSizeKB: z.number().default(2048),
  protocol: OutputServiceNowProtocol$inboundSchema.default("grpc"),
  compress: OutputServiceNowCompressCompression$inboundSchema.default("gzip"),
  httpCompress: OutputServiceNowHttpCompressCompression$inboundSchema.default(
    "gzip",
  ),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => OutputServiceNowMetadatum$inboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode:
    OutputServiceNowFailedRequestLoggingMode$inboundSchema.default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: OutputServiceNowBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputServiceNowExtraHttpHeader$inboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputServiceNowResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputServiceNowTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => OutputServiceNowTLSSettingsClientSide$inboundSchema)
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputServiceNowPqCompressCompression$inboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputServiceNowQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputServiceNowMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputServiceNowPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputServiceNow$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  endpoint: string;
  tokenSecret: string;
  authTokenName: string;
  otlpVersion: string;
  maxPayloadSizeKB: number;
  protocol: string;
  compress: string;
  httpCompress: string;
  httpTracesEndpointOverride?: string | undefined;
  httpMetricsEndpointOverride?: string | undefined;
  httpLogsEndpointOverride?: string | undefined;
  metadata?: Array<OutputServiceNowMetadatum$Outbound> | undefined;
  concurrency: number;
  timeoutSec: number;
  flushPeriodSec: number;
  failedRequestLoggingMode: string;
  connectionTimeout: number;
  keepAliveTime: number;
  keepAlive: boolean;
  onBackpressure: string;
  description?: string | undefined;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  extraHttpHeaders?:
    | Array<OutputServiceNowExtraHttpHeader$Outbound>
    | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputServiceNowResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputServiceNowTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  tls?: OutputServiceNowTLSSettingsClientSide$Outbound | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputServiceNowPqControls$Outbound | undefined;
};

/** @internal */
export const OutputServiceNow$outboundSchema: z.ZodType<
  OutputServiceNow$Outbound,
  z.ZodTypeDef,
  OutputServiceNow
> = z.object({
  id: z.string(),
  type: OutputServiceNowType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string().default("ingest.lightstep.com:443"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("lightstep-access-token"),
  otlpVersion: OutputServiceNowOTLPVersion$outboundSchema.default("1.3.1"),
  maxPayloadSizeKB: z.number().default(2048),
  protocol: OutputServiceNowProtocol$outboundSchema.default("grpc"),
  compress: OutputServiceNowCompressCompression$outboundSchema.default("gzip"),
  httpCompress: OutputServiceNowHttpCompressCompression$outboundSchema.default(
    "gzip",
  ),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => OutputServiceNowMetadatum$outboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode:
    OutputServiceNowFailedRequestLoggingMode$outboundSchema.default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: OutputServiceNowBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputServiceNowExtraHttpHeader$outboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputServiceNowResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputServiceNowTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => OutputServiceNowTLSSettingsClientSide$outboundSchema)
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputServiceNowPqCompressCompression$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputServiceNowQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputServiceNowMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputServiceNowPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNow$ {
  /** @deprecated use `OutputServiceNow$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNow$inboundSchema;
  /** @deprecated use `OutputServiceNow$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNow$outboundSchema;
  /** @deprecated use `OutputServiceNow$Outbound` instead. */
  export type Outbound = OutputServiceNow$Outbound;
}

export function outputServiceNowToJSON(
  outputServiceNow: OutputServiceNow,
): string {
  return JSON.stringify(
    OutputServiceNow$outboundSchema.parse(outputServiceNow),
  );
}

export function outputServiceNowFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputServiceNow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNow' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryType$inboundSchema: z.ZodType<
  OutputOpenTelemetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryType$outboundSchema: z.ZodType<
  OutputOpenTelemetryType,
  z.ZodTypeDef,
  OutputOpenTelemetryType
> = z.union([
  z.nativeEnum(OutputOpenTelemetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryType$ {
  /** @deprecated use `OutputOpenTelemetryType$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryType$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryType$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryType$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryProtocol$inboundSchema: z.ZodType<
  OutputOpenTelemetryProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryProtocol$outboundSchema: z.ZodType<
  OutputOpenTelemetryProtocol,
  z.ZodTypeDef,
  OutputOpenTelemetryProtocol
> = z.union([
  z.nativeEnum(OutputOpenTelemetryProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryProtocol$ {
  /** @deprecated use `OutputOpenTelemetryProtocol$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryProtocol$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryProtocol$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryProtocol$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryOTLPVersion$inboundSchema: z.ZodType<
  OutputOpenTelemetryOTLPVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryOTLPVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryOTLPVersion$outboundSchema: z.ZodType<
  OutputOpenTelemetryOTLPVersion,
  z.ZodTypeDef,
  OutputOpenTelemetryOTLPVersion
> = z.union([
  z.nativeEnum(OutputOpenTelemetryOTLPVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryOTLPVersion$ {
  /** @deprecated use `OutputOpenTelemetryOTLPVersion$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryOTLPVersion$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryOTLPVersion$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryOTLPVersion$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryCompressCompression$inboundSchema: z.ZodType<
  OutputOpenTelemetryCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryCompressCompression$outboundSchema: z.ZodType<
  OutputOpenTelemetryCompressCompression,
  z.ZodTypeDef,
  OutputOpenTelemetryCompressCompression
> = z.union([
  z.nativeEnum(OutputOpenTelemetryCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryCompressCompression$ {
  /** @deprecated use `OutputOpenTelemetryCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryCompressCompression$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryCompressCompression$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryHttpCompressCompression$inboundSchema:
  z.ZodType<OutputOpenTelemetryHttpCompressCompression, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(OutputOpenTelemetryHttpCompressCompression),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const OutputOpenTelemetryHttpCompressCompression$outboundSchema:
  z.ZodType<
    OutputOpenTelemetryHttpCompressCompression,
    z.ZodTypeDef,
    OutputOpenTelemetryHttpCompressCompression
  > = z.union([
    z.nativeEnum(OutputOpenTelemetryHttpCompressCompression),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryHttpCompressCompression$ {
  /** @deprecated use `OutputOpenTelemetryHttpCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryHttpCompressCompression$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryHttpCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryHttpCompressCompression$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryAuthenticationType$inboundSchema: z.ZodType<
  OutputOpenTelemetryAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryAuthenticationType$outboundSchema: z.ZodType<
  OutputOpenTelemetryAuthenticationType,
  z.ZodTypeDef,
  OutputOpenTelemetryAuthenticationType
> = z.union([
  z.nativeEnum(OutputOpenTelemetryAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryAuthenticationType$ {
  /** @deprecated use `OutputOpenTelemetryAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryAuthenticationType$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryAuthenticationType$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryMetadatum$inboundSchema: z.ZodType<
  OutputOpenTelemetryMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputOpenTelemetryMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputOpenTelemetryMetadatum$outboundSchema: z.ZodType<
  OutputOpenTelemetryMetadatum$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryMetadatum$ {
  /** @deprecated use `OutputOpenTelemetryMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryMetadatum$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryMetadatum$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryMetadatum$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryMetadatum$Outbound;
}

export function outputOpenTelemetryMetadatumToJSON(
  outputOpenTelemetryMetadatum: OutputOpenTelemetryMetadatum,
): string {
  return JSON.stringify(
    OutputOpenTelemetryMetadatum$outboundSchema.parse(
      outputOpenTelemetryMetadatum,
    ),
  );
}

export function outputOpenTelemetryMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputOpenTelemetryMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputOpenTelemetryMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputOpenTelemetryMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryFailedRequestLoggingMode$inboundSchema:
  z.ZodType<
    OutputOpenTelemetryFailedRequestLoggingMode,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputOpenTelemetryFailedRequestLoggingMode),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputOpenTelemetryFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputOpenTelemetryFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputOpenTelemetryFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputOpenTelemetryFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryFailedRequestLoggingMode$ {
  /** @deprecated use `OutputOpenTelemetryFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryBackpressureBehavior$inboundSchema: z.ZodType<
  OutputOpenTelemetryBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryBackpressureBehavior$outboundSchema: z.ZodType<
  OutputOpenTelemetryBackpressureBehavior,
  z.ZodTypeDef,
  OutputOpenTelemetryBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputOpenTelemetryBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryBackpressureBehavior$ {
  /** @deprecated use `OutputOpenTelemetryBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryOauthParam$inboundSchema: z.ZodType<
  OutputOpenTelemetryOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputOpenTelemetryOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputOpenTelemetryOauthParam$outboundSchema: z.ZodType<
  OutputOpenTelemetryOauthParam$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryOauthParam$ {
  /** @deprecated use `OutputOpenTelemetryOauthParam$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryOauthParam$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryOauthParam$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryOauthParam$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryOauthParam$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryOauthParam$Outbound;
}

export function outputOpenTelemetryOauthParamToJSON(
  outputOpenTelemetryOauthParam: OutputOpenTelemetryOauthParam,
): string {
  return JSON.stringify(
    OutputOpenTelemetryOauthParam$outboundSchema.parse(
      outputOpenTelemetryOauthParam,
    ),
  );
}

export function outputOpenTelemetryOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<OutputOpenTelemetryOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputOpenTelemetryOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputOpenTelemetryOauthParam' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryOauthHeader$inboundSchema: z.ZodType<
  OutputOpenTelemetryOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputOpenTelemetryOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputOpenTelemetryOauthHeader$outboundSchema: z.ZodType<
  OutputOpenTelemetryOauthHeader$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryOauthHeader$ {
  /** @deprecated use `OutputOpenTelemetryOauthHeader$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryOauthHeader$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryOauthHeader$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryOauthHeader$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryOauthHeader$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryOauthHeader$Outbound;
}

export function outputOpenTelemetryOauthHeaderToJSON(
  outputOpenTelemetryOauthHeader: OutputOpenTelemetryOauthHeader,
): string {
  return JSON.stringify(
    OutputOpenTelemetryOauthHeader$outboundSchema.parse(
      outputOpenTelemetryOauthHeader,
    ),
  );
}

export function outputOpenTelemetryOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputOpenTelemetryOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputOpenTelemetryOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputOpenTelemetryOauthHeader' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryExtraHttpHeader$inboundSchema: z.ZodType<
  OutputOpenTelemetryExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputOpenTelemetryExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputOpenTelemetryExtraHttpHeader$outboundSchema: z.ZodType<
  OutputOpenTelemetryExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryExtraHttpHeader$ {
  /** @deprecated use `OutputOpenTelemetryExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryExtraHttpHeader$Outbound;
}

export function outputOpenTelemetryExtraHttpHeaderToJSON(
  outputOpenTelemetryExtraHttpHeader: OutputOpenTelemetryExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputOpenTelemetryExtraHttpHeader$outboundSchema.parse(
      outputOpenTelemetryExtraHttpHeader,
    ),
  );
}

export function outputOpenTelemetryExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputOpenTelemetryExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputOpenTelemetryExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputOpenTelemetryExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryResponseRetrySetting$inboundSchema: z.ZodType<
  OutputOpenTelemetryResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputOpenTelemetryResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputOpenTelemetryResponseRetrySetting$outboundSchema: z.ZodType<
  OutputOpenTelemetryResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryResponseRetrySetting$ {
  /** @deprecated use `OutputOpenTelemetryResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryResponseRetrySetting$Outbound;
}

export function outputOpenTelemetryResponseRetrySettingToJSON(
  outputOpenTelemetryResponseRetrySetting:
    OutputOpenTelemetryResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputOpenTelemetryResponseRetrySetting$outboundSchema.parse(
      outputOpenTelemetryResponseRetrySetting,
    ),
  );
}

export function outputOpenTelemetryResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputOpenTelemetryResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputOpenTelemetryResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputOpenTelemetryResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputOpenTelemetryTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputOpenTelemetryTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputOpenTelemetryTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputOpenTelemetryTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryTimeoutRetrySettings$ {
  /** @deprecated use `OutputOpenTelemetryTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryTimeoutRetrySettings$Outbound;
}

export function outputOpenTelemetryTimeoutRetrySettingsToJSON(
  outputOpenTelemetryTimeoutRetrySettings:
    OutputOpenTelemetryTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputOpenTelemetryTimeoutRetrySettings$outboundSchema.parse(
      outputOpenTelemetryTimeoutRetrySettings,
    ),
  );
}

export function outputOpenTelemetryTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputOpenTelemetryTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputOpenTelemetryTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputOpenTelemetryTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputOpenTelemetryMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputOpenTelemetryMinimumTLSVersion,
  z.ZodTypeDef,
  OutputOpenTelemetryMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputOpenTelemetryMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryMinimumTLSVersion$ {
  /** @deprecated use `OutputOpenTelemetryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputOpenTelemetryMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputOpenTelemetryMaximumTLSVersion,
  z.ZodTypeDef,
  OutputOpenTelemetryMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputOpenTelemetryMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryMaximumTLSVersion$ {
  /** @deprecated use `OutputOpenTelemetryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputOpenTelemetryTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputOpenTelemetryMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputOpenTelemetryMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputOpenTelemetryTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputOpenTelemetryTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputOpenTelemetryTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputOpenTelemetryMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: OutputOpenTelemetryMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryTLSSettingsClientSide$ {
  /** @deprecated use `OutputOpenTelemetryTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryTLSSettingsClientSide$Outbound;
}

export function outputOpenTelemetryTLSSettingsClientSideToJSON(
  outputOpenTelemetryTLSSettingsClientSide:
    OutputOpenTelemetryTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputOpenTelemetryTLSSettingsClientSide$outboundSchema.parse(
      outputOpenTelemetryTLSSettingsClientSide,
    ),
  );
}

export function outputOpenTelemetryTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputOpenTelemetryTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputOpenTelemetryTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputOpenTelemetryTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetryPqCompressCompression$inboundSchema: z.ZodType<
  OutputOpenTelemetryPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryPqCompressCompression$outboundSchema: z.ZodType<
  OutputOpenTelemetryPqCompressCompression,
  z.ZodTypeDef,
  OutputOpenTelemetryPqCompressCompression
> = z.union([
  z.nativeEnum(OutputOpenTelemetryPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryPqCompressCompression$ {
  /** @deprecated use `OutputOpenTelemetryPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryQueueFullBehavior$inboundSchema: z.ZodType<
  OutputOpenTelemetryQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryQueueFullBehavior$outboundSchema: z.ZodType<
  OutputOpenTelemetryQueueFullBehavior,
  z.ZodTypeDef,
  OutputOpenTelemetryQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputOpenTelemetryQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryQueueFullBehavior$ {
  /** @deprecated use `OutputOpenTelemetryQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputOpenTelemetryQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputOpenTelemetryQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryMode$inboundSchema: z.ZodType<
  OutputOpenTelemetryMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputOpenTelemetryMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputOpenTelemetryMode$outboundSchema: z.ZodType<
  OutputOpenTelemetryMode,
  z.ZodTypeDef,
  OutputOpenTelemetryMode
> = z.union([
  z.nativeEnum(OutputOpenTelemetryMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryMode$ {
  /** @deprecated use `OutputOpenTelemetryMode$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryMode$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryMode$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryMode$outboundSchema;
}

/** @internal */
export const OutputOpenTelemetryPqControls$inboundSchema: z.ZodType<
  OutputOpenTelemetryPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputOpenTelemetryPqControls$Outbound = {};

/** @internal */
export const OutputOpenTelemetryPqControls$outboundSchema: z.ZodType<
  OutputOpenTelemetryPqControls$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetryPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetryPqControls$ {
  /** @deprecated use `OutputOpenTelemetryPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetryPqControls$inboundSchema;
  /** @deprecated use `OutputOpenTelemetryPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetryPqControls$outboundSchema;
  /** @deprecated use `OutputOpenTelemetryPqControls$Outbound` instead. */
  export type Outbound = OutputOpenTelemetryPqControls$Outbound;
}

export function outputOpenTelemetryPqControlsToJSON(
  outputOpenTelemetryPqControls: OutputOpenTelemetryPqControls,
): string {
  return JSON.stringify(
    OutputOpenTelemetryPqControls$outboundSchema.parse(
      outputOpenTelemetryPqControls,
    ),
  );
}

export function outputOpenTelemetryPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputOpenTelemetryPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputOpenTelemetryPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputOpenTelemetryPqControls' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetry$inboundSchema: z.ZodType<
  OutputOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputOpenTelemetryType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputOpenTelemetryProtocol$inboundSchema.default("grpc"),
  endpoint: z.string(),
  otlpVersion: OutputOpenTelemetryOTLPVersion$inboundSchema.default("0.10.0"),
  compress: OutputOpenTelemetryCompressCompression$inboundSchema.default(
    "gzip",
  ),
  httpCompress: OutputOpenTelemetryHttpCompressCompression$inboundSchema
    .default("gzip"),
  authType: OutputOpenTelemetryAuthenticationType$inboundSchema.default("none"),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => OutputOpenTelemetryMetadatum$inboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode:
    OutputOpenTelemetryFailedRequestLoggingMode$inboundSchema.default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: OutputOpenTelemetryBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => OutputOpenTelemetryOauthParam$inboundSchema),
  ).optional(),
  oauthHeaders: z.array(
    z.lazy(() => OutputOpenTelemetryOauthHeader$inboundSchema),
  ).optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputOpenTelemetryExtraHttpHeader$inboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputOpenTelemetryResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputOpenTelemetryTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => OutputOpenTelemetryTLSSettingsClientSide$inboundSchema)
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputOpenTelemetryPqCompressCompression$inboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputOpenTelemetryQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputOpenTelemetryMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputOpenTelemetryPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputOpenTelemetry$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  endpoint: string;
  otlpVersion: string;
  compress: string;
  httpCompress: string;
  authType: string;
  httpTracesEndpointOverride?: string | undefined;
  httpMetricsEndpointOverride?: string | undefined;
  httpLogsEndpointOverride?: string | undefined;
  metadata?: Array<OutputOpenTelemetryMetadatum$Outbound> | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  timeoutSec: number;
  flushPeriodSec: number;
  failedRequestLoggingMode: string;
  connectionTimeout: number;
  keepAliveTime: number;
  keepAlive: boolean;
  onBackpressure: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OutputOpenTelemetryOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<OutputOpenTelemetryOauthHeader$Outbound> | undefined;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  extraHttpHeaders?:
    | Array<OutputOpenTelemetryExtraHttpHeader$Outbound>
    | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputOpenTelemetryResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputOpenTelemetryTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  tls?: OutputOpenTelemetryTLSSettingsClientSide$Outbound | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputOpenTelemetryPqControls$Outbound | undefined;
};

/** @internal */
export const OutputOpenTelemetry$outboundSchema: z.ZodType<
  OutputOpenTelemetry$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetry
> = z.object({
  id: z.string(),
  type: OutputOpenTelemetryType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputOpenTelemetryProtocol$outboundSchema.default("grpc"),
  endpoint: z.string(),
  otlpVersion: OutputOpenTelemetryOTLPVersion$outboundSchema.default("0.10.0"),
  compress: OutputOpenTelemetryCompressCompression$outboundSchema.default(
    "gzip",
  ),
  httpCompress: OutputOpenTelemetryHttpCompressCompression$outboundSchema
    .default("gzip"),
  authType: OutputOpenTelemetryAuthenticationType$outboundSchema.default(
    "none",
  ),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => OutputOpenTelemetryMetadatum$outboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode:
    OutputOpenTelemetryFailedRequestLoggingMode$outboundSchema.default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: OutputOpenTelemetryBackpressureBehavior$outboundSchema
    .default("block"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => OutputOpenTelemetryOauthParam$outboundSchema),
  ).optional(),
  oauthHeaders: z.array(
    z.lazy(() => OutputOpenTelemetryOauthHeader$outboundSchema),
  ).optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputOpenTelemetryExtraHttpHeader$outboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputOpenTelemetryResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputOpenTelemetryTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => OutputOpenTelemetryTLSSettingsClientSide$outboundSchema)
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputOpenTelemetryPqCompressCompression$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputOpenTelemetryQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputOpenTelemetryMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputOpenTelemetryPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetry$ {
  /** @deprecated use `OutputOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetry$inboundSchema;
  /** @deprecated use `OutputOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetry$outboundSchema;
  /** @deprecated use `OutputOpenTelemetry$Outbound` instead. */
  export type Outbound = OutputOpenTelemetry$Outbound;
}

export function outputOpenTelemetryToJSON(
  outputOpenTelemetry: OutputOpenTelemetry,
): string {
  return JSON.stringify(
    OutputOpenTelemetry$outboundSchema.parse(outputOpenTelemetry),
  );
}

export function outputOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<OutputOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const OutputPrometheusType$inboundSchema: z.ZodType<
  OutputPrometheusType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputPrometheusType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputPrometheusType$outboundSchema: z.ZodType<
  OutputPrometheusType,
  z.ZodTypeDef,
  OutputPrometheusType
> = z.union([
  z.nativeEnum(OutputPrometheusType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusType$ {
  /** @deprecated use `OutputPrometheusType$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusType$inboundSchema;
  /** @deprecated use `OutputPrometheusType$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheusType$outboundSchema;
}

/** @internal */
export const OutputPrometheusExtraHttpHeader$inboundSchema: z.ZodType<
  OutputPrometheusExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputPrometheusExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputPrometheusExtraHttpHeader$outboundSchema: z.ZodType<
  OutputPrometheusExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputPrometheusExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusExtraHttpHeader$ {
  /** @deprecated use `OutputPrometheusExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputPrometheusExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheusExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputPrometheusExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputPrometheusExtraHttpHeader$Outbound;
}

export function outputPrometheusExtraHttpHeaderToJSON(
  outputPrometheusExtraHttpHeader: OutputPrometheusExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputPrometheusExtraHttpHeader$outboundSchema.parse(
      outputPrometheusExtraHttpHeader,
    ),
  );
}

export function outputPrometheusExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheusExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputPrometheusExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheusExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputPrometheusFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputPrometheusFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputPrometheusFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputPrometheusFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputPrometheusFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputPrometheusFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputPrometheusFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusFailedRequestLoggingMode$ {
  /** @deprecated use `OutputPrometheusFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputPrometheusFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputPrometheusFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputPrometheusFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputPrometheusResponseRetrySetting$inboundSchema: z.ZodType<
  OutputPrometheusResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputPrometheusResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputPrometheusResponseRetrySetting$outboundSchema: z.ZodType<
  OutputPrometheusResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputPrometheusResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusResponseRetrySetting$ {
  /** @deprecated use `OutputPrometheusResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputPrometheusResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputPrometheusResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputPrometheusResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputPrometheusResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputPrometheusResponseRetrySetting$Outbound;
}

export function outputPrometheusResponseRetrySettingToJSON(
  outputPrometheusResponseRetrySetting: OutputPrometheusResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputPrometheusResponseRetrySetting$outboundSchema.parse(
      outputPrometheusResponseRetrySetting,
    ),
  );
}

export function outputPrometheusResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheusResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputPrometheusResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheusResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputPrometheusTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputPrometheusTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputPrometheusTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputPrometheusTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputPrometheusTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputPrometheusTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusTimeoutRetrySettings$ {
  /** @deprecated use `OutputPrometheusTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputPrometheusTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputPrometheusTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputPrometheusTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputPrometheusTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputPrometheusTimeoutRetrySettings$Outbound;
}

export function outputPrometheusTimeoutRetrySettingsToJSON(
  outputPrometheusTimeoutRetrySettings: OutputPrometheusTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputPrometheusTimeoutRetrySettings$outboundSchema.parse(
      outputPrometheusTimeoutRetrySettings,
    ),
  );
}

export function outputPrometheusTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheusTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputPrometheusTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheusTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputPrometheusBackpressureBehavior$inboundSchema: z.ZodType<
  OutputPrometheusBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputPrometheusBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputPrometheusBackpressureBehavior$outboundSchema: z.ZodType<
  OutputPrometheusBackpressureBehavior,
  z.ZodTypeDef,
  OutputPrometheusBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputPrometheusBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusBackpressureBehavior$ {
  /** @deprecated use `OutputPrometheusBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputPrometheusBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputPrometheusBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputPrometheusBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputPrometheusAuthenticationType$inboundSchema: z.ZodType<
  OutputPrometheusAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputPrometheusAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputPrometheusAuthenticationType$outboundSchema: z.ZodType<
  OutputPrometheusAuthenticationType,
  z.ZodTypeDef,
  OutputPrometheusAuthenticationType
> = z.union([
  z.nativeEnum(OutputPrometheusAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusAuthenticationType$ {
  /** @deprecated use `OutputPrometheusAuthenticationType$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusAuthenticationType$inboundSchema;
  /** @deprecated use `OutputPrometheusAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    OutputPrometheusAuthenticationType$outboundSchema;
}

/** @internal */
export const OutputPrometheusCompression$inboundSchema: z.ZodType<
  OutputPrometheusCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputPrometheusCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputPrometheusCompression$outboundSchema: z.ZodType<
  OutputPrometheusCompression,
  z.ZodTypeDef,
  OutputPrometheusCompression
> = z.union([
  z.nativeEnum(OutputPrometheusCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusCompression$ {
  /** @deprecated use `OutputPrometheusCompression$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusCompression$inboundSchema;
  /** @deprecated use `OutputPrometheusCompression$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheusCompression$outboundSchema;
}

/** @internal */
export const OutputPrometheusQueueFullBehavior$inboundSchema: z.ZodType<
  OutputPrometheusQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputPrometheusQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputPrometheusQueueFullBehavior$outboundSchema: z.ZodType<
  OutputPrometheusQueueFullBehavior,
  z.ZodTypeDef,
  OutputPrometheusQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputPrometheusQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusQueueFullBehavior$ {
  /** @deprecated use `OutputPrometheusQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputPrometheusQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputPrometheusQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputPrometheusMode$inboundSchema: z.ZodType<
  OutputPrometheusMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputPrometheusMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputPrometheusMode$outboundSchema: z.ZodType<
  OutputPrometheusMode,
  z.ZodTypeDef,
  OutputPrometheusMode
> = z.union([
  z.nativeEnum(OutputPrometheusMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusMode$ {
  /** @deprecated use `OutputPrometheusMode$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusMode$inboundSchema;
  /** @deprecated use `OutputPrometheusMode$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheusMode$outboundSchema;
}

/** @internal */
export const OutputPrometheusPqControls$inboundSchema: z.ZodType<
  OutputPrometheusPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputPrometheusPqControls$Outbound = {};

/** @internal */
export const OutputPrometheusPqControls$outboundSchema: z.ZodType<
  OutputPrometheusPqControls$Outbound,
  z.ZodTypeDef,
  OutputPrometheusPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusPqControls$ {
  /** @deprecated use `OutputPrometheusPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusPqControls$inboundSchema;
  /** @deprecated use `OutputPrometheusPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheusPqControls$outboundSchema;
  /** @deprecated use `OutputPrometheusPqControls$Outbound` instead. */
  export type Outbound = OutputPrometheusPqControls$Outbound;
}

export function outputPrometheusPqControlsToJSON(
  outputPrometheusPqControls: OutputPrometheusPqControls,
): string {
  return JSON.stringify(
    OutputPrometheusPqControls$outboundSchema.parse(outputPrometheusPqControls),
  );
}

export function outputPrometheusPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheusPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputPrometheusPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheusPqControls' from JSON`,
  );
}

/** @internal */
export const OutputPrometheusOauthParam$inboundSchema: z.ZodType<
  OutputPrometheusOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputPrometheusOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputPrometheusOauthParam$outboundSchema: z.ZodType<
  OutputPrometheusOauthParam$Outbound,
  z.ZodTypeDef,
  OutputPrometheusOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusOauthParam$ {
  /** @deprecated use `OutputPrometheusOauthParam$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusOauthParam$inboundSchema;
  /** @deprecated use `OutputPrometheusOauthParam$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheusOauthParam$outboundSchema;
  /** @deprecated use `OutputPrometheusOauthParam$Outbound` instead. */
  export type Outbound = OutputPrometheusOauthParam$Outbound;
}

export function outputPrometheusOauthParamToJSON(
  outputPrometheusOauthParam: OutputPrometheusOauthParam,
): string {
  return JSON.stringify(
    OutputPrometheusOauthParam$outboundSchema.parse(outputPrometheusOauthParam),
  );
}

export function outputPrometheusOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheusOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputPrometheusOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheusOauthParam' from JSON`,
  );
}

/** @internal */
export const OutputPrometheusOauthHeader$inboundSchema: z.ZodType<
  OutputPrometheusOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputPrometheusOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputPrometheusOauthHeader$outboundSchema: z.ZodType<
  OutputPrometheusOauthHeader$Outbound,
  z.ZodTypeDef,
  OutputPrometheusOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheusOauthHeader$ {
  /** @deprecated use `OutputPrometheusOauthHeader$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheusOauthHeader$inboundSchema;
  /** @deprecated use `OutputPrometheusOauthHeader$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheusOauthHeader$outboundSchema;
  /** @deprecated use `OutputPrometheusOauthHeader$Outbound` instead. */
  export type Outbound = OutputPrometheusOauthHeader$Outbound;
}

export function outputPrometheusOauthHeaderToJSON(
  outputPrometheusOauthHeader: OutputPrometheusOauthHeader,
): string {
  return JSON.stringify(
    OutputPrometheusOauthHeader$outboundSchema.parse(
      outputPrometheusOauthHeader,
    ),
  );
}

export function outputPrometheusOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheusOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputPrometheusOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheusOauthHeader' from JSON`,
  );
}

/** @internal */
export const OutputPrometheus$inboundSchema: z.ZodType<
  OutputPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputPrometheusType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  metricRenameExpr: z.string().default("name.replace(/[^a-zA-Z0-9_]/g, '_')"),
  sendMetadata: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputPrometheusExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputPrometheusFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputPrometheusResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputPrometheusTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputPrometheusBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  authType: OutputPrometheusAuthenticationType$inboundSchema.default("none"),
  description: z.string().optional(),
  metricsFlushPeriodSec: z.number().default(60),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputPrometheusCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputPrometheusQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputPrometheusMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputPrometheusPqControls$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OutputPrometheusOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OutputPrometheusOauthHeader$inboundSchema))
    .optional(),
});

/** @internal */
export type OutputPrometheus$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  metricRenameExpr: string;
  sendMetadata: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputPrometheusExtraHttpHeader$Outbound>
    | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputPrometheusResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputPrometheusTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  metricsFlushPeriodSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputPrometheusPqControls$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OutputPrometheusOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<OutputPrometheusOauthHeader$Outbound> | undefined;
};

/** @internal */
export const OutputPrometheus$outboundSchema: z.ZodType<
  OutputPrometheus$Outbound,
  z.ZodTypeDef,
  OutputPrometheus
> = z.object({
  id: z.string(),
  type: OutputPrometheusType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  metricRenameExpr: z.string().default("name.replace(/[^a-zA-Z0-9_]/g, '_')"),
  sendMetadata: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputPrometheusExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputPrometheusFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputPrometheusResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputPrometheusTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputPrometheusBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  authType: OutputPrometheusAuthenticationType$outboundSchema.default("none"),
  description: z.string().optional(),
  metricsFlushPeriodSec: z.number().default(60),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputPrometheusCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputPrometheusQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputPrometheusMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputPrometheusPqControls$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OutputPrometheusOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => OutputPrometheusOauthHeader$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheus$ {
  /** @deprecated use `OutputPrometheus$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheus$inboundSchema;
  /** @deprecated use `OutputPrometheus$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheus$outboundSchema;
  /** @deprecated use `OutputPrometheus$Outbound` instead. */
  export type Outbound = OutputPrometheus$Outbound;
}

export function outputPrometheusToJSON(
  outputPrometheus: OutputPrometheus,
): string {
  return JSON.stringify(
    OutputPrometheus$outboundSchema.parse(outputPrometheus),
  );
}

export function outputPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheus' from JSON`,
  );
}

/** @internal */
export const OutputLokiType$inboundSchema: z.ZodType<
  OutputLokiType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputLokiType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputLokiType$outboundSchema: z.ZodType<
  OutputLokiType,
  z.ZodTypeDef,
  OutputLokiType
> = z.union([
  z.nativeEnum(OutputLokiType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiType$ {
  /** @deprecated use `OutputLokiType$inboundSchema` instead. */
  export const inboundSchema = OutputLokiType$inboundSchema;
  /** @deprecated use `OutputLokiType$outboundSchema` instead. */
  export const outboundSchema = OutputLokiType$outboundSchema;
}

/** @internal */
export const MessageFormat$inboundSchema: z.ZodType<
  MessageFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(MessageFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const MessageFormat$outboundSchema: z.ZodType<
  MessageFormat,
  z.ZodTypeDef,
  MessageFormat
> = z.union([
  z.nativeEnum(MessageFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageFormat$ {
  /** @deprecated use `MessageFormat$inboundSchema` instead. */
  export const inboundSchema = MessageFormat$inboundSchema;
  /** @deprecated use `MessageFormat$outboundSchema` instead. */
  export const outboundSchema = MessageFormat$outboundSchema;
}

/** @internal */
export const Label$inboundSchema: z.ZodType<Label, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string().default(""),
    value: z.string(),
  });

/** @internal */
export type Label$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const Label$outboundSchema: z.ZodType<
  Label$Outbound,
  z.ZodTypeDef,
  Label
> = z.object({
  name: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Label$ {
  /** @deprecated use `Label$inboundSchema` instead. */
  export const inboundSchema = Label$inboundSchema;
  /** @deprecated use `Label$outboundSchema` instead. */
  export const outboundSchema = Label$outboundSchema;
  /** @deprecated use `Label$Outbound` instead. */
  export type Outbound = Label$Outbound;
}

export function labelToJSON(label: Label): string {
  return JSON.stringify(Label$outboundSchema.parse(label));
}

export function labelFromJSON(
  jsonString: string,
): SafeParseResult<Label, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Label$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Label' from JSON`,
  );
}

/** @internal */
export const OutputLokiAuthenticationType$inboundSchema: z.ZodType<
  OutputLokiAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputLokiAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputLokiAuthenticationType$outboundSchema: z.ZodType<
  OutputLokiAuthenticationType,
  z.ZodTypeDef,
  OutputLokiAuthenticationType
> = z.union([
  z.nativeEnum(OutputLokiAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiAuthenticationType$ {
  /** @deprecated use `OutputLokiAuthenticationType$inboundSchema` instead. */
  export const inboundSchema = OutputLokiAuthenticationType$inboundSchema;
  /** @deprecated use `OutputLokiAuthenticationType$outboundSchema` instead. */
  export const outboundSchema = OutputLokiAuthenticationType$outboundSchema;
}

/** @internal */
export const OutputLokiExtraHttpHeader$inboundSchema: z.ZodType<
  OutputLokiExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputLokiExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputLokiExtraHttpHeader$outboundSchema: z.ZodType<
  OutputLokiExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputLokiExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiExtraHttpHeader$ {
  /** @deprecated use `OutputLokiExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputLokiExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputLokiExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputLokiExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputLokiExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputLokiExtraHttpHeader$Outbound;
}

export function outputLokiExtraHttpHeaderToJSON(
  outputLokiExtraHttpHeader: OutputLokiExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputLokiExtraHttpHeader$outboundSchema.parse(outputLokiExtraHttpHeader),
  );
}

export function outputLokiExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputLokiExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputLokiExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputLokiExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputLokiFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputLokiFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputLokiFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputLokiFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputLokiFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputLokiFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputLokiFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiFailedRequestLoggingMode$ {
  /** @deprecated use `OutputLokiFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema = OutputLokiFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputLokiFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputLokiFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputLokiResponseRetrySetting$inboundSchema: z.ZodType<
  OutputLokiResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputLokiResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputLokiResponseRetrySetting$outboundSchema: z.ZodType<
  OutputLokiResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputLokiResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiResponseRetrySetting$ {
  /** @deprecated use `OutputLokiResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema = OutputLokiResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputLokiResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema = OutputLokiResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputLokiResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputLokiResponseRetrySetting$Outbound;
}

export function outputLokiResponseRetrySettingToJSON(
  outputLokiResponseRetrySetting: OutputLokiResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputLokiResponseRetrySetting$outboundSchema.parse(
      outputLokiResponseRetrySetting,
    ),
  );
}

export function outputLokiResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputLokiResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputLokiResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputLokiResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputLokiTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputLokiTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputLokiTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputLokiTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputLokiTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputLokiTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiTimeoutRetrySettings$ {
  /** @deprecated use `OutputLokiTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema = OutputLokiTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputLokiTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema = OutputLokiTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputLokiTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputLokiTimeoutRetrySettings$Outbound;
}

export function outputLokiTimeoutRetrySettingsToJSON(
  outputLokiTimeoutRetrySettings: OutputLokiTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputLokiTimeoutRetrySettings$outboundSchema.parse(
      outputLokiTimeoutRetrySettings,
    ),
  );
}

export function outputLokiTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputLokiTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputLokiTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputLokiTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputLokiBackpressureBehavior$inboundSchema: z.ZodType<
  OutputLokiBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputLokiBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputLokiBackpressureBehavior$outboundSchema: z.ZodType<
  OutputLokiBackpressureBehavior,
  z.ZodTypeDef,
  OutputLokiBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputLokiBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiBackpressureBehavior$ {
  /** @deprecated use `OutputLokiBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputLokiBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputLokiBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputLokiBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputLokiCompression$inboundSchema: z.ZodType<
  OutputLokiCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputLokiCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputLokiCompression$outboundSchema: z.ZodType<
  OutputLokiCompression,
  z.ZodTypeDef,
  OutputLokiCompression
> = z.union([
  z.nativeEnum(OutputLokiCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiCompression$ {
  /** @deprecated use `OutputLokiCompression$inboundSchema` instead. */
  export const inboundSchema = OutputLokiCompression$inboundSchema;
  /** @deprecated use `OutputLokiCompression$outboundSchema` instead. */
  export const outboundSchema = OutputLokiCompression$outboundSchema;
}

/** @internal */
export const OutputLokiQueueFullBehavior$inboundSchema: z.ZodType<
  OutputLokiQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputLokiQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputLokiQueueFullBehavior$outboundSchema: z.ZodType<
  OutputLokiQueueFullBehavior,
  z.ZodTypeDef,
  OutputLokiQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputLokiQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiQueueFullBehavior$ {
  /** @deprecated use `OutputLokiQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputLokiQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputLokiQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputLokiQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputLokiMode$inboundSchema: z.ZodType<
  OutputLokiMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputLokiMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputLokiMode$outboundSchema: z.ZodType<
  OutputLokiMode,
  z.ZodTypeDef,
  OutputLokiMode
> = z.union([
  z.nativeEnum(OutputLokiMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiMode$ {
  /** @deprecated use `OutputLokiMode$inboundSchema` instead. */
  export const inboundSchema = OutputLokiMode$inboundSchema;
  /** @deprecated use `OutputLokiMode$outboundSchema` instead. */
  export const outboundSchema = OutputLokiMode$outboundSchema;
}

/** @internal */
export const OutputLokiPqControls$inboundSchema: z.ZodType<
  OutputLokiPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputLokiPqControls$Outbound = {};

/** @internal */
export const OutputLokiPqControls$outboundSchema: z.ZodType<
  OutputLokiPqControls$Outbound,
  z.ZodTypeDef,
  OutputLokiPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLokiPqControls$ {
  /** @deprecated use `OutputLokiPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputLokiPqControls$inboundSchema;
  /** @deprecated use `OutputLokiPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputLokiPqControls$outboundSchema;
  /** @deprecated use `OutputLokiPqControls$Outbound` instead. */
  export type Outbound = OutputLokiPqControls$Outbound;
}

export function outputLokiPqControlsToJSON(
  outputLokiPqControls: OutputLokiPqControls,
): string {
  return JSON.stringify(
    OutputLokiPqControls$outboundSchema.parse(outputLokiPqControls),
  );
}

export function outputLokiPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputLokiPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputLokiPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputLokiPqControls' from JSON`,
  );
}

/** @internal */
export const OutputLoki$inboundSchema: z.ZodType<
  OutputLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputLokiType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  message: z.string().optional(),
  messageFormat: MessageFormat$inboundSchema.default("protobuf"),
  labels: z.array(z.lazy(() => Label$inboundSchema)).optional(),
  authType: OutputLokiAuthenticationType$inboundSchema.default("none"),
  concurrency: z.number().default(1),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(15),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputLokiExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: OutputLokiFailedRequestLoggingMode$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputLokiResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputLokiTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputLokiBackpressureBehavior$inboundSchema.default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  compress: z.boolean().default(true),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputLokiCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputLokiQueueFullBehavior$inboundSchema.default("block"),
  pqMode: OutputLokiMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputLokiPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputLoki$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  message?: string | undefined;
  messageFormat: string;
  labels?: Array<Label$Outbound> | undefined;
  authType: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputLokiExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputLokiResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?: OutputLokiTimeoutRetrySettings$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  compress: boolean;
  token?: string | undefined;
  textSecret?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputLokiPqControls$Outbound | undefined;
};

/** @internal */
export const OutputLoki$outboundSchema: z.ZodType<
  OutputLoki$Outbound,
  z.ZodTypeDef,
  OutputLoki
> = z.object({
  id: z.string(),
  type: OutputLokiType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  message: z.string().optional(),
  messageFormat: MessageFormat$outboundSchema.default("protobuf"),
  labels: z.array(z.lazy(() => Label$outboundSchema)).optional(),
  authType: OutputLokiAuthenticationType$outboundSchema.default("none"),
  concurrency: z.number().default(1),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(15),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputLokiExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: OutputLokiFailedRequestLoggingMode$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputLokiResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputLokiTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputLokiBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  compress: z.boolean().default(true),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputLokiCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputLokiQueueFullBehavior$outboundSchema.default("block"),
  pqMode: OutputLokiMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputLokiPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLoki$ {
  /** @deprecated use `OutputLoki$inboundSchema` instead. */
  export const inboundSchema = OutputLoki$inboundSchema;
  /** @deprecated use `OutputLoki$outboundSchema` instead. */
  export const outboundSchema = OutputLoki$outboundSchema;
  /** @deprecated use `OutputLoki$Outbound` instead. */
  export type Outbound = OutputLoki$Outbound;
}

export function outputLokiToJSON(outputLoki: OutputLoki): string {
  return JSON.stringify(OutputLoki$outboundSchema.parse(outputLoki));
}

export function outputLokiFromJSON(
  jsonString: string,
): SafeParseResult<OutputLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputLoki' from JSON`,
  );
}

/** @internal */
export const OutputSumoLogicType$inboundSchema: z.ZodType<
  OutputSumoLogicType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSumoLogicType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSumoLogicType$outboundSchema: z.ZodType<
  OutputSumoLogicType,
  z.ZodTypeDef,
  OutputSumoLogicType
> = z.union([
  z.nativeEnum(OutputSumoLogicType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicType$ {
  /** @deprecated use `OutputSumoLogicType$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogicType$inboundSchema;
  /** @deprecated use `OutputSumoLogicType$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogicType$outboundSchema;
}

/** @internal */
export const OutputSumoLogicDataFormat$inboundSchema: z.ZodType<
  OutputSumoLogicDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSumoLogicDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSumoLogicDataFormat$outboundSchema: z.ZodType<
  OutputSumoLogicDataFormat,
  z.ZodTypeDef,
  OutputSumoLogicDataFormat
> = z.union([
  z.nativeEnum(OutputSumoLogicDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicDataFormat$ {
  /** @deprecated use `OutputSumoLogicDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogicDataFormat$inboundSchema;
  /** @deprecated use `OutputSumoLogicDataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogicDataFormat$outboundSchema;
}

/** @internal */
export const OutputSumoLogicExtraHttpHeader$inboundSchema: z.ZodType<
  OutputSumoLogicExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputSumoLogicExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputSumoLogicExtraHttpHeader$outboundSchema: z.ZodType<
  OutputSumoLogicExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputSumoLogicExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicExtraHttpHeader$ {
  /** @deprecated use `OutputSumoLogicExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogicExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputSumoLogicExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogicExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputSumoLogicExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputSumoLogicExtraHttpHeader$Outbound;
}

export function outputSumoLogicExtraHttpHeaderToJSON(
  outputSumoLogicExtraHttpHeader: OutputSumoLogicExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputSumoLogicExtraHttpHeader$outboundSchema.parse(
      outputSumoLogicExtraHttpHeader,
    ),
  );
}

export function outputSumoLogicExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputSumoLogicExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSumoLogicExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSumoLogicExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputSumoLogicFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputSumoLogicFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSumoLogicFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSumoLogicFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputSumoLogicFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputSumoLogicFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputSumoLogicFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicFailedRequestLoggingMode$ {
  /** @deprecated use `OutputSumoLogicFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputSumoLogicFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputSumoLogicFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputSumoLogicFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputSumoLogicResponseRetrySetting$inboundSchema: z.ZodType<
  OutputSumoLogicResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputSumoLogicResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSumoLogicResponseRetrySetting$outboundSchema: z.ZodType<
  OutputSumoLogicResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputSumoLogicResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicResponseRetrySetting$ {
  /** @deprecated use `OutputSumoLogicResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputSumoLogicResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputSumoLogicResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputSumoLogicResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputSumoLogicResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputSumoLogicResponseRetrySetting$Outbound;
}

export function outputSumoLogicResponseRetrySettingToJSON(
  outputSumoLogicResponseRetrySetting: OutputSumoLogicResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputSumoLogicResponseRetrySetting$outboundSchema.parse(
      outputSumoLogicResponseRetrySetting,
    ),
  );
}

export function outputSumoLogicResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputSumoLogicResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSumoLogicResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSumoLogicResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputSumoLogicTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputSumoLogicTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputSumoLogicTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSumoLogicTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputSumoLogicTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputSumoLogicTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicTimeoutRetrySettings$ {
  /** @deprecated use `OutputSumoLogicTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputSumoLogicTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputSumoLogicTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputSumoLogicTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputSumoLogicTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputSumoLogicTimeoutRetrySettings$Outbound;
}

export function outputSumoLogicTimeoutRetrySettingsToJSON(
  outputSumoLogicTimeoutRetrySettings: OutputSumoLogicTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputSumoLogicTimeoutRetrySettings$outboundSchema.parse(
      outputSumoLogicTimeoutRetrySettings,
    ),
  );
}

export function outputSumoLogicTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSumoLogicTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSumoLogicTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSumoLogicTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputSumoLogicBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSumoLogicBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSumoLogicBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSumoLogicBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSumoLogicBackpressureBehavior,
  z.ZodTypeDef,
  OutputSumoLogicBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSumoLogicBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicBackpressureBehavior$ {
  /** @deprecated use `OutputSumoLogicBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputSumoLogicBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSumoLogicBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputSumoLogicBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSumoLogicCompression$inboundSchema: z.ZodType<
  OutputSumoLogicCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSumoLogicCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSumoLogicCompression$outboundSchema: z.ZodType<
  OutputSumoLogicCompression,
  z.ZodTypeDef,
  OutputSumoLogicCompression
> = z.union([
  z.nativeEnum(OutputSumoLogicCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicCompression$ {
  /** @deprecated use `OutputSumoLogicCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogicCompression$inboundSchema;
  /** @deprecated use `OutputSumoLogicCompression$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogicCompression$outboundSchema;
}

/** @internal */
export const OutputSumoLogicQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSumoLogicQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSumoLogicQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSumoLogicQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSumoLogicQueueFullBehavior,
  z.ZodTypeDef,
  OutputSumoLogicQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSumoLogicQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicQueueFullBehavior$ {
  /** @deprecated use `OutputSumoLogicQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogicQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSumoLogicQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogicQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSumoLogicMode$inboundSchema: z.ZodType<
  OutputSumoLogicMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSumoLogicMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSumoLogicMode$outboundSchema: z.ZodType<
  OutputSumoLogicMode,
  z.ZodTypeDef,
  OutputSumoLogicMode
> = z.union([
  z.nativeEnum(OutputSumoLogicMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicMode$ {
  /** @deprecated use `OutputSumoLogicMode$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogicMode$inboundSchema;
  /** @deprecated use `OutputSumoLogicMode$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogicMode$outboundSchema;
}

/** @internal */
export const OutputSumoLogicPqControls$inboundSchema: z.ZodType<
  OutputSumoLogicPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSumoLogicPqControls$Outbound = {};

/** @internal */
export const OutputSumoLogicPqControls$outboundSchema: z.ZodType<
  OutputSumoLogicPqControls$Outbound,
  z.ZodTypeDef,
  OutputSumoLogicPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogicPqControls$ {
  /** @deprecated use `OutputSumoLogicPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogicPqControls$inboundSchema;
  /** @deprecated use `OutputSumoLogicPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogicPqControls$outboundSchema;
  /** @deprecated use `OutputSumoLogicPqControls$Outbound` instead. */
  export type Outbound = OutputSumoLogicPqControls$Outbound;
}

export function outputSumoLogicPqControlsToJSON(
  outputSumoLogicPqControls: OutputSumoLogicPqControls,
): string {
  return JSON.stringify(
    OutputSumoLogicPqControls$outboundSchema.parse(outputSumoLogicPqControls),
  );
}

export function outputSumoLogicPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSumoLogicPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSumoLogicPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSumoLogicPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSumoLogic$inboundSchema: z.ZodType<
  OutputSumoLogic,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSumoLogicType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  customSource: z.string().optional(),
  customCategory: z.string().optional(),
  format: OutputSumoLogicDataFormat$inboundSchema.default("json"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSumoLogicExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputSumoLogicFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSumoLogicResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSumoLogicTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSumoLogicBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSumoLogicCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSumoLogicQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputSumoLogicMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSumoLogicPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputSumoLogic$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  customSource?: string | undefined;
  customCategory?: string | undefined;
  format: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputSumoLogicExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputSumoLogicResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputSumoLogicTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSumoLogicPqControls$Outbound | undefined;
};

/** @internal */
export const OutputSumoLogic$outboundSchema: z.ZodType<
  OutputSumoLogic$Outbound,
  z.ZodTypeDef,
  OutputSumoLogic
> = z.object({
  id: z.string(),
  type: OutputSumoLogicType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  customSource: z.string().optional(),
  customCategory: z.string().optional(),
  format: OutputSumoLogicDataFormat$outboundSchema.default("json"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSumoLogicExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputSumoLogicFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSumoLogicResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSumoLogicTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSumoLogicBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSumoLogicCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputSumoLogicQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputSumoLogicMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSumoLogicPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogic$ {
  /** @deprecated use `OutputSumoLogic$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogic$inboundSchema;
  /** @deprecated use `OutputSumoLogic$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogic$outboundSchema;
  /** @deprecated use `OutputSumoLogic$Outbound` instead. */
  export type Outbound = OutputSumoLogic$Outbound;
}

export function outputSumoLogicToJSON(
  outputSumoLogic: OutputSumoLogic,
): string {
  return JSON.stringify(OutputSumoLogic$outboundSchema.parse(outputSumoLogic));
}

export function outputSumoLogicFromJSON(
  jsonString: string,
): SafeParseResult<OutputSumoLogic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSumoLogic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSumoLogic' from JSON`,
  );
}

/** @internal */
export const OutputSnmpType$inboundSchema: z.ZodType<
  OutputSnmpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnmpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnmpType$outboundSchema: z.ZodType<
  OutputSnmpType,
  z.ZodTypeDef,
  OutputSnmpType
> = z.union([
  z.nativeEnum(OutputSnmpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnmpType$ {
  /** @deprecated use `OutputSnmpType$inboundSchema` instead. */
  export const inboundSchema = OutputSnmpType$inboundSchema;
  /** @deprecated use `OutputSnmpType$outboundSchema` instead. */
  export const outboundSchema = OutputSnmpType$outboundSchema;
}

/** @internal */
export const OutputSnmpHost$inboundSchema: z.ZodType<
  OutputSnmpHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  port: z.number().default(162),
});

/** @internal */
export type OutputSnmpHost$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const OutputSnmpHost$outboundSchema: z.ZodType<
  OutputSnmpHost$Outbound,
  z.ZodTypeDef,
  OutputSnmpHost
> = z.object({
  host: z.string(),
  port: z.number().default(162),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnmpHost$ {
  /** @deprecated use `OutputSnmpHost$inboundSchema` instead. */
  export const inboundSchema = OutputSnmpHost$inboundSchema;
  /** @deprecated use `OutputSnmpHost$outboundSchema` instead. */
  export const outboundSchema = OutputSnmpHost$outboundSchema;
  /** @deprecated use `OutputSnmpHost$Outbound` instead. */
  export type Outbound = OutputSnmpHost$Outbound;
}

export function outputSnmpHostToJSON(outputSnmpHost: OutputSnmpHost): string {
  return JSON.stringify(OutputSnmpHost$outboundSchema.parse(outputSnmpHost));
}

export function outputSnmpHostFromJSON(
  jsonString: string,
): SafeParseResult<OutputSnmpHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSnmpHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSnmpHost' from JSON`,
  );
}

/** @internal */
export const OutputSnmp$inboundSchema: z.ZodType<
  OutputSnmp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSnmpType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => OutputSnmpHost$inboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/** @internal */
export type OutputSnmp$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  hosts: Array<OutputSnmpHost$Outbound>;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
};

/** @internal */
export const OutputSnmp$outboundSchema: z.ZodType<
  OutputSnmp$Outbound,
  z.ZodTypeDef,
  OutputSnmp
> = z.object({
  id: z.string(),
  type: OutputSnmpType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => OutputSnmpHost$outboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnmp$ {
  /** @deprecated use `OutputSnmp$inboundSchema` instead. */
  export const inboundSchema = OutputSnmp$inboundSchema;
  /** @deprecated use `OutputSnmp$outboundSchema` instead. */
  export const outboundSchema = OutputSnmp$outboundSchema;
  /** @deprecated use `OutputSnmp$Outbound` instead. */
  export type Outbound = OutputSnmp$Outbound;
}

export function outputSnmpToJSON(outputSnmp: OutputSnmp): string {
  return JSON.stringify(OutputSnmp$outboundSchema.parse(outputSnmp));
}

export function outputSnmpFromJSON(
  jsonString: string,
): SafeParseResult<OutputSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSnmp' from JSON`,
  );
}

/** @internal */
export const OutputSqsType$inboundSchema: z.ZodType<
  OutputSqsType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSqsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSqsType$outboundSchema: z.ZodType<
  OutputSqsType,
  z.ZodTypeDef,
  OutputSqsType
> = z.union([
  z.nativeEnum(OutputSqsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsType$ {
  /** @deprecated use `OutputSqsType$inboundSchema` instead. */
  export const inboundSchema = OutputSqsType$inboundSchema;
  /** @deprecated use `OutputSqsType$outboundSchema` instead. */
  export const outboundSchema = OutputSqsType$outboundSchema;
}

/** @internal */
export const CreateOutputQueueType$inboundSchema: z.ZodType<
  CreateOutputQueueType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateOutputQueueType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateOutputQueueType$outboundSchema: z.ZodType<
  CreateOutputQueueType,
  z.ZodTypeDef,
  CreateOutputQueueType
> = z.union([
  z.nativeEnum(CreateOutputQueueType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputQueueType$ {
  /** @deprecated use `CreateOutputQueueType$inboundSchema` instead. */
  export const inboundSchema = CreateOutputQueueType$inboundSchema;
  /** @deprecated use `CreateOutputQueueType$outboundSchema` instead. */
  export const outboundSchema = CreateOutputQueueType$outboundSchema;
}

/** @internal */
export const OutputSqsAuthenticationMethod$inboundSchema: z.ZodType<
  OutputSqsAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSqsAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSqsAuthenticationMethod$outboundSchema: z.ZodType<
  OutputSqsAuthenticationMethod,
  z.ZodTypeDef,
  OutputSqsAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputSqsAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsAuthenticationMethod$ {
  /** @deprecated use `OutputSqsAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputSqsAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputSqsAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputSqsAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputSqsSignatureVersion$inboundSchema: z.ZodType<
  OutputSqsSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSqsSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSqsSignatureVersion$outboundSchema: z.ZodType<
  OutputSqsSignatureVersion,
  z.ZodTypeDef,
  OutputSqsSignatureVersion
> = z.union([
  z.nativeEnum(OutputSqsSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsSignatureVersion$ {
  /** @deprecated use `OutputSqsSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSqsSignatureVersion$inboundSchema;
  /** @deprecated use `OutputSqsSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSqsSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputSqsBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSqsBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSqsBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSqsBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSqsBackpressureBehavior,
  z.ZodTypeDef,
  OutputSqsBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSqsBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsBackpressureBehavior$ {
  /** @deprecated use `OutputSqsBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSqsBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSqsBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSqsBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSqsCompression$inboundSchema: z.ZodType<
  OutputSqsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSqsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSqsCompression$outboundSchema: z.ZodType<
  OutputSqsCompression,
  z.ZodTypeDef,
  OutputSqsCompression
> = z.union([
  z.nativeEnum(OutputSqsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsCompression$ {
  /** @deprecated use `OutputSqsCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSqsCompression$inboundSchema;
  /** @deprecated use `OutputSqsCompression$outboundSchema` instead. */
  export const outboundSchema = OutputSqsCompression$outboundSchema;
}

/** @internal */
export const OutputSqsQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSqsQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSqsQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSqsQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSqsQueueFullBehavior,
  z.ZodTypeDef,
  OutputSqsQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSqsQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsQueueFullBehavior$ {
  /** @deprecated use `OutputSqsQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSqsQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSqsQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSqsQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSqsMode$inboundSchema: z.ZodType<
  OutputSqsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSqsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSqsMode$outboundSchema: z.ZodType<
  OutputSqsMode,
  z.ZodTypeDef,
  OutputSqsMode
> = z.union([
  z.nativeEnum(OutputSqsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsMode$ {
  /** @deprecated use `OutputSqsMode$inboundSchema` instead. */
  export const inboundSchema = OutputSqsMode$inboundSchema;
  /** @deprecated use `OutputSqsMode$outboundSchema` instead. */
  export const outboundSchema = OutputSqsMode$outboundSchema;
}

/** @internal */
export const OutputSqsPqControls$inboundSchema: z.ZodType<
  OutputSqsPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSqsPqControls$Outbound = {};

/** @internal */
export const OutputSqsPqControls$outboundSchema: z.ZodType<
  OutputSqsPqControls$Outbound,
  z.ZodTypeDef,
  OutputSqsPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqsPqControls$ {
  /** @deprecated use `OutputSqsPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSqsPqControls$inboundSchema;
  /** @deprecated use `OutputSqsPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputSqsPqControls$outboundSchema;
  /** @deprecated use `OutputSqsPqControls$Outbound` instead. */
  export type Outbound = OutputSqsPqControls$Outbound;
}

export function outputSqsPqControlsToJSON(
  outputSqsPqControls: OutputSqsPqControls,
): string {
  return JSON.stringify(
    OutputSqsPqControls$outboundSchema.parse(outputSqsPqControls),
  );
}

export function outputSqsPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSqsPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSqsPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSqsPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSqs$inboundSchema: z.ZodType<
  OutputSqs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSqsType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  queueName: z.string(),
  queueType: CreateOutputQueueType$inboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  messageGroupId: z.string().default("cribl"),
  createQueue: z.boolean().default(true),
  awsAuthenticationMethod: OutputSqsAuthenticationMethod$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: OutputSqsSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.number().default(1),
  maxInProgress: z.number().default(10),
  onBackpressure: OutputSqsBackpressureBehavior$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSqsCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSqsQueueFullBehavior$inboundSchema.default("block"),
  pqMode: OutputSqsMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSqsPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputSqs$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  messageGroupId: string;
  createQueue: boolean;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  maxQueueSize: number;
  maxRecordSizeKB: number;
  flushPeriodSec: number;
  maxInProgress: number;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSqsPqControls$Outbound | undefined;
};

/** @internal */
export const OutputSqs$outboundSchema: z.ZodType<
  OutputSqs$Outbound,
  z.ZodTypeDef,
  OutputSqs
> = z.object({
  id: z.string(),
  type: OutputSqsType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  queueName: z.string(),
  queueType: CreateOutputQueueType$outboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  messageGroupId: z.string().default("cribl"),
  createQueue: z.boolean().default(true),
  awsAuthenticationMethod: OutputSqsAuthenticationMethod$outboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: OutputSqsSignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.number().default(1),
  maxInProgress: z.number().default(10),
  onBackpressure: OutputSqsBackpressureBehavior$outboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSqsCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputSqsQueueFullBehavior$outboundSchema.default("block"),
  pqMode: OutputSqsMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSqsPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqs$ {
  /** @deprecated use `OutputSqs$inboundSchema` instead. */
  export const inboundSchema = OutputSqs$inboundSchema;
  /** @deprecated use `OutputSqs$outboundSchema` instead. */
  export const outboundSchema = OutputSqs$outboundSchema;
  /** @deprecated use `OutputSqs$Outbound` instead. */
  export type Outbound = OutputSqs$Outbound;
}

export function outputSqsToJSON(outputSqs: OutputSqs): string {
  return JSON.stringify(OutputSqs$outboundSchema.parse(outputSqs));
}

export function outputSqsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSqs' from JSON`,
  );
}

/** @internal */
export const OutputSnsType$inboundSchema: z.ZodType<
  OutputSnsType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnsType$outboundSchema: z.ZodType<
  OutputSnsType,
  z.ZodTypeDef,
  OutputSnsType
> = z.union([
  z.nativeEnum(OutputSnsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsType$ {
  /** @deprecated use `OutputSnsType$inboundSchema` instead. */
  export const inboundSchema = OutputSnsType$inboundSchema;
  /** @deprecated use `OutputSnsType$outboundSchema` instead. */
  export const outboundSchema = OutputSnsType$outboundSchema;
}

/** @internal */
export const OutputSnsAuthenticationMethod$inboundSchema: z.ZodType<
  OutputSnsAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnsAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnsAuthenticationMethod$outboundSchema: z.ZodType<
  OutputSnsAuthenticationMethod,
  z.ZodTypeDef,
  OutputSnsAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputSnsAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsAuthenticationMethod$ {
  /** @deprecated use `OutputSnsAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputSnsAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputSnsAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputSnsAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputSnsSignatureVersion$inboundSchema: z.ZodType<
  OutputSnsSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnsSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnsSignatureVersion$outboundSchema: z.ZodType<
  OutputSnsSignatureVersion,
  z.ZodTypeDef,
  OutputSnsSignatureVersion
> = z.union([
  z.nativeEnum(OutputSnsSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsSignatureVersion$ {
  /** @deprecated use `OutputSnsSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSnsSignatureVersion$inboundSchema;
  /** @deprecated use `OutputSnsSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSnsSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputSnsBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSnsBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnsBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnsBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSnsBackpressureBehavior,
  z.ZodTypeDef,
  OutputSnsBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSnsBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsBackpressureBehavior$ {
  /** @deprecated use `OutputSnsBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSnsBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSnsBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSnsBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSnsCompression$inboundSchema: z.ZodType<
  OutputSnsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnsCompression$outboundSchema: z.ZodType<
  OutputSnsCompression,
  z.ZodTypeDef,
  OutputSnsCompression
> = z.union([
  z.nativeEnum(OutputSnsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsCompression$ {
  /** @deprecated use `OutputSnsCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSnsCompression$inboundSchema;
  /** @deprecated use `OutputSnsCompression$outboundSchema` instead. */
  export const outboundSchema = OutputSnsCompression$outboundSchema;
}

/** @internal */
export const OutputSnsQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSnsQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnsQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnsQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSnsQueueFullBehavior,
  z.ZodTypeDef,
  OutputSnsQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSnsQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsQueueFullBehavior$ {
  /** @deprecated use `OutputSnsQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSnsQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSnsQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSnsQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSnsMode$inboundSchema: z.ZodType<
  OutputSnsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSnsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSnsMode$outboundSchema: z.ZodType<
  OutputSnsMode,
  z.ZodTypeDef,
  OutputSnsMode
> = z.union([
  z.nativeEnum(OutputSnsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsMode$ {
  /** @deprecated use `OutputSnsMode$inboundSchema` instead. */
  export const inboundSchema = OutputSnsMode$inboundSchema;
  /** @deprecated use `OutputSnsMode$outboundSchema` instead. */
  export const outboundSchema = OutputSnsMode$outboundSchema;
}

/** @internal */
export const OutputSnsPqControls$inboundSchema: z.ZodType<
  OutputSnsPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSnsPqControls$Outbound = {};

/** @internal */
export const OutputSnsPqControls$outboundSchema: z.ZodType<
  OutputSnsPqControls$Outbound,
  z.ZodTypeDef,
  OutputSnsPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnsPqControls$ {
  /** @deprecated use `OutputSnsPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSnsPqControls$inboundSchema;
  /** @deprecated use `OutputSnsPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputSnsPqControls$outboundSchema;
  /** @deprecated use `OutputSnsPqControls$Outbound` instead. */
  export type Outbound = OutputSnsPqControls$Outbound;
}

export function outputSnsPqControlsToJSON(
  outputSnsPqControls: OutputSnsPqControls,
): string {
  return JSON.stringify(
    OutputSnsPqControls$outboundSchema.parse(outputSnsPqControls),
  );
}

export function outputSnsPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSnsPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSnsPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSnsPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSns$inboundSchema: z.ZodType<
  OutputSns,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSnsType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicArn: z.string(),
  messageGroupId: z.string(),
  maxRetries: z.number().optional(),
  awsAuthenticationMethod: OutputSnsAuthenticationMethod$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: OutputSnsSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  onBackpressure: OutputSnsBackpressureBehavior$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSnsCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSnsQueueFullBehavior$inboundSchema.default("block"),
  pqMode: OutputSnsMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSnsPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputSns$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  topicArn: string;
  messageGroupId: string;
  maxRetries?: number | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSnsPqControls$Outbound | undefined;
};

/** @internal */
export const OutputSns$outboundSchema: z.ZodType<
  OutputSns$Outbound,
  z.ZodTypeDef,
  OutputSns
> = z.object({
  id: z.string(),
  type: OutputSnsType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicArn: z.string(),
  messageGroupId: z.string(),
  maxRetries: z.number().optional(),
  awsAuthenticationMethod: OutputSnsAuthenticationMethod$outboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: OutputSnsSignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  onBackpressure: OutputSnsBackpressureBehavior$outboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSnsCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputSnsQueueFullBehavior$outboundSchema.default("block"),
  pqMode: OutputSnsMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSnsPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSns$ {
  /** @deprecated use `OutputSns$inboundSchema` instead. */
  export const inboundSchema = OutputSns$inboundSchema;
  /** @deprecated use `OutputSns$outboundSchema` instead. */
  export const outboundSchema = OutputSns$outboundSchema;
  /** @deprecated use `OutputSns$Outbound` instead. */
  export type Outbound = OutputSns$Outbound;
}

export function outputSnsToJSON(outputSns: OutputSns): string {
  return JSON.stringify(OutputSns$outboundSchema.parse(outputSns));
}

export function outputSnsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSns' from JSON`,
  );
}

/** @internal */
export const OutputRouterType$inboundSchema: z.ZodType<
  OutputRouterType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputRouterType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputRouterType$outboundSchema: z.ZodType<
  OutputRouterType,
  z.ZodTypeDef,
  OutputRouterType
> = z.union([
  z.nativeEnum(OutputRouterType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputRouterType$ {
  /** @deprecated use `OutputRouterType$inboundSchema` instead. */
  export const inboundSchema = OutputRouterType$inboundSchema;
  /** @deprecated use `OutputRouterType$outboundSchema` instead. */
  export const outboundSchema = OutputRouterType$outboundSchema;
}

/** @internal */
export const CreateOutputRule$inboundSchema: z.ZodType<
  CreateOutputRule,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  output: z.string(),
  description: z.string().optional(),
  final: z.boolean().default(true),
});

/** @internal */
export type CreateOutputRule$Outbound = {
  filter: string;
  output: string;
  description?: string | undefined;
  final: boolean;
};

/** @internal */
export const CreateOutputRule$outboundSchema: z.ZodType<
  CreateOutputRule$Outbound,
  z.ZodTypeDef,
  CreateOutputRule
> = z.object({
  filter: z.string(),
  output: z.string(),
  description: z.string().optional(),
  final: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputRule$ {
  /** @deprecated use `CreateOutputRule$inboundSchema` instead. */
  export const inboundSchema = CreateOutputRule$inboundSchema;
  /** @deprecated use `CreateOutputRule$outboundSchema` instead. */
  export const outboundSchema = CreateOutputRule$outboundSchema;
  /** @deprecated use `CreateOutputRule$Outbound` instead. */
  export type Outbound = CreateOutputRule$Outbound;
}

export function createOutputRuleToJSON(
  createOutputRule: CreateOutputRule,
): string {
  return JSON.stringify(
    CreateOutputRule$outboundSchema.parse(createOutputRule),
  );
}

export function createOutputRuleFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputRule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputRule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputRule' from JSON`,
  );
}

/** @internal */
export const OutputRouter$inboundSchema: z.ZodType<
  OutputRouter,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputRouterType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  rules: z.array(z.lazy(() => CreateOutputRule$inboundSchema)),
  description: z.string().optional(),
});

/** @internal */
export type OutputRouter$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  rules: Array<CreateOutputRule$Outbound>;
  description?: string | undefined;
};

/** @internal */
export const OutputRouter$outboundSchema: z.ZodType<
  OutputRouter$Outbound,
  z.ZodTypeDef,
  OutputRouter
> = z.object({
  id: z.string(),
  type: OutputRouterType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  rules: z.array(z.lazy(() => CreateOutputRule$outboundSchema)),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputRouter$ {
  /** @deprecated use `OutputRouter$inboundSchema` instead. */
  export const inboundSchema = OutputRouter$inboundSchema;
  /** @deprecated use `OutputRouter$outboundSchema` instead. */
  export const outboundSchema = OutputRouter$outboundSchema;
  /** @deprecated use `OutputRouter$Outbound` instead. */
  export type Outbound = OutputRouter$Outbound;
}

export function outputRouterToJSON(outputRouter: OutputRouter): string {
  return JSON.stringify(OutputRouter$outboundSchema.parse(outputRouter));
}

export function outputRouterFromJSON(
  jsonString: string,
): SafeParseResult<OutputRouter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputRouter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputRouter' from JSON`,
  );
}

/** @internal */
export const OutputGraphiteType$inboundSchema: z.ZodType<
  OutputGraphiteType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGraphiteType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGraphiteType$outboundSchema: z.ZodType<
  OutputGraphiteType,
  z.ZodTypeDef,
  OutputGraphiteType
> = z.union([
  z.nativeEnum(OutputGraphiteType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphiteType$ {
  /** @deprecated use `OutputGraphiteType$inboundSchema` instead. */
  export const inboundSchema = OutputGraphiteType$inboundSchema;
  /** @deprecated use `OutputGraphiteType$outboundSchema` instead. */
  export const outboundSchema = OutputGraphiteType$outboundSchema;
}

/** @internal */
export const OutputGraphiteDestinationProtocol$inboundSchema: z.ZodType<
  OutputGraphiteDestinationProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGraphiteDestinationProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGraphiteDestinationProtocol$outboundSchema: z.ZodType<
  OutputGraphiteDestinationProtocol,
  z.ZodTypeDef,
  OutputGraphiteDestinationProtocol
> = z.union([
  z.nativeEnum(OutputGraphiteDestinationProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphiteDestinationProtocol$ {
  /** @deprecated use `OutputGraphiteDestinationProtocol$inboundSchema` instead. */
  export const inboundSchema = OutputGraphiteDestinationProtocol$inboundSchema;
  /** @deprecated use `OutputGraphiteDestinationProtocol$outboundSchema` instead. */
  export const outboundSchema =
    OutputGraphiteDestinationProtocol$outboundSchema;
}

/** @internal */
export const OutputGraphiteBackpressureBehavior$inboundSchema: z.ZodType<
  OutputGraphiteBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGraphiteBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGraphiteBackpressureBehavior$outboundSchema: z.ZodType<
  OutputGraphiteBackpressureBehavior,
  z.ZodTypeDef,
  OutputGraphiteBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputGraphiteBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphiteBackpressureBehavior$ {
  /** @deprecated use `OutputGraphiteBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputGraphiteBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputGraphiteBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGraphiteBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputGraphiteCompression$inboundSchema: z.ZodType<
  OutputGraphiteCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGraphiteCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGraphiteCompression$outboundSchema: z.ZodType<
  OutputGraphiteCompression,
  z.ZodTypeDef,
  OutputGraphiteCompression
> = z.union([
  z.nativeEnum(OutputGraphiteCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphiteCompression$ {
  /** @deprecated use `OutputGraphiteCompression$inboundSchema` instead. */
  export const inboundSchema = OutputGraphiteCompression$inboundSchema;
  /** @deprecated use `OutputGraphiteCompression$outboundSchema` instead. */
  export const outboundSchema = OutputGraphiteCompression$outboundSchema;
}

/** @internal */
export const OutputGraphiteQueueFullBehavior$inboundSchema: z.ZodType<
  OutputGraphiteQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGraphiteQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGraphiteQueueFullBehavior$outboundSchema: z.ZodType<
  OutputGraphiteQueueFullBehavior,
  z.ZodTypeDef,
  OutputGraphiteQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputGraphiteQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphiteQueueFullBehavior$ {
  /** @deprecated use `OutputGraphiteQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputGraphiteQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputGraphiteQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputGraphiteQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputGraphiteMode$inboundSchema: z.ZodType<
  OutputGraphiteMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGraphiteMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGraphiteMode$outboundSchema: z.ZodType<
  OutputGraphiteMode,
  z.ZodTypeDef,
  OutputGraphiteMode
> = z.union([
  z.nativeEnum(OutputGraphiteMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphiteMode$ {
  /** @deprecated use `OutputGraphiteMode$inboundSchema` instead. */
  export const inboundSchema = OutputGraphiteMode$inboundSchema;
  /** @deprecated use `OutputGraphiteMode$outboundSchema` instead. */
  export const outboundSchema = OutputGraphiteMode$outboundSchema;
}

/** @internal */
export const OutputGraphitePqControls$inboundSchema: z.ZodType<
  OutputGraphitePqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputGraphitePqControls$Outbound = {};

/** @internal */
export const OutputGraphitePqControls$outboundSchema: z.ZodType<
  OutputGraphitePqControls$Outbound,
  z.ZodTypeDef,
  OutputGraphitePqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphitePqControls$ {
  /** @deprecated use `OutputGraphitePqControls$inboundSchema` instead. */
  export const inboundSchema = OutputGraphitePqControls$inboundSchema;
  /** @deprecated use `OutputGraphitePqControls$outboundSchema` instead. */
  export const outboundSchema = OutputGraphitePqControls$outboundSchema;
  /** @deprecated use `OutputGraphitePqControls$Outbound` instead. */
  export type Outbound = OutputGraphitePqControls$Outbound;
}

export function outputGraphitePqControlsToJSON(
  outputGraphitePqControls: OutputGraphitePqControls,
): string {
  return JSON.stringify(
    OutputGraphitePqControls$outboundSchema.parse(outputGraphitePqControls),
  );
}

export function outputGraphitePqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputGraphitePqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGraphitePqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGraphitePqControls' from JSON`,
  );
}

/** @internal */
export const OutputGraphite$inboundSchema: z.ZodType<
  OutputGraphite,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputGraphiteType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputGraphiteDestinationProtocol$inboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: OutputGraphiteBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGraphiteCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputGraphiteQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputGraphiteMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGraphitePqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputGraphite$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  host: string;
  port: number;
  mtu: number;
  flushPeriodSec: number;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  onBackpressure: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputGraphitePqControls$Outbound | undefined;
};

/** @internal */
export const OutputGraphite$outboundSchema: z.ZodType<
  OutputGraphite$Outbound,
  z.ZodTypeDef,
  OutputGraphite
> = z.object({
  id: z.string(),
  type: OutputGraphiteType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputGraphiteDestinationProtocol$outboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: OutputGraphiteBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGraphiteCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputGraphiteQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputGraphiteMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGraphitePqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphite$ {
  /** @deprecated use `OutputGraphite$inboundSchema` instead. */
  export const inboundSchema = OutputGraphite$inboundSchema;
  /** @deprecated use `OutputGraphite$outboundSchema` instead. */
  export const outboundSchema = OutputGraphite$outboundSchema;
  /** @deprecated use `OutputGraphite$Outbound` instead. */
  export type Outbound = OutputGraphite$Outbound;
}

export function outputGraphiteToJSON(outputGraphite: OutputGraphite): string {
  return JSON.stringify(OutputGraphite$outboundSchema.parse(outputGraphite));
}

export function outputGraphiteFromJSON(
  jsonString: string,
): SafeParseResult<OutputGraphite, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGraphite$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGraphite' from JSON`,
  );
}

/** @internal */
export const OutputStatsdExtType$inboundSchema: z.ZodType<
  OutputStatsdExtType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdExtType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdExtType$outboundSchema: z.ZodType<
  OutputStatsdExtType,
  z.ZodTypeDef,
  OutputStatsdExtType
> = z.union([
  z.nativeEnum(OutputStatsdExtType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExtType$ {
  /** @deprecated use `OutputStatsdExtType$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExtType$inboundSchema;
  /** @deprecated use `OutputStatsdExtType$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdExtType$outboundSchema;
}

/** @internal */
export const OutputStatsdExtDestinationProtocol$inboundSchema: z.ZodType<
  OutputStatsdExtDestinationProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdExtDestinationProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdExtDestinationProtocol$outboundSchema: z.ZodType<
  OutputStatsdExtDestinationProtocol,
  z.ZodTypeDef,
  OutputStatsdExtDestinationProtocol
> = z.union([
  z.nativeEnum(OutputStatsdExtDestinationProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExtDestinationProtocol$ {
  /** @deprecated use `OutputStatsdExtDestinationProtocol$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExtDestinationProtocol$inboundSchema;
  /** @deprecated use `OutputStatsdExtDestinationProtocol$outboundSchema` instead. */
  export const outboundSchema =
    OutputStatsdExtDestinationProtocol$outboundSchema;
}

/** @internal */
export const OutputStatsdExtBackpressureBehavior$inboundSchema: z.ZodType<
  OutputStatsdExtBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdExtBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdExtBackpressureBehavior$outboundSchema: z.ZodType<
  OutputStatsdExtBackpressureBehavior,
  z.ZodTypeDef,
  OutputStatsdExtBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputStatsdExtBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExtBackpressureBehavior$ {
  /** @deprecated use `OutputStatsdExtBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputStatsdExtBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputStatsdExtBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputStatsdExtBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputStatsdExtCompression$inboundSchema: z.ZodType<
  OutputStatsdExtCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdExtCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdExtCompression$outboundSchema: z.ZodType<
  OutputStatsdExtCompression,
  z.ZodTypeDef,
  OutputStatsdExtCompression
> = z.union([
  z.nativeEnum(OutputStatsdExtCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExtCompression$ {
  /** @deprecated use `OutputStatsdExtCompression$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExtCompression$inboundSchema;
  /** @deprecated use `OutputStatsdExtCompression$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdExtCompression$outboundSchema;
}

/** @internal */
export const OutputStatsdExtQueueFullBehavior$inboundSchema: z.ZodType<
  OutputStatsdExtQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdExtQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdExtQueueFullBehavior$outboundSchema: z.ZodType<
  OutputStatsdExtQueueFullBehavior,
  z.ZodTypeDef,
  OutputStatsdExtQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputStatsdExtQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExtQueueFullBehavior$ {
  /** @deprecated use `OutputStatsdExtQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExtQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputStatsdExtQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdExtQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputStatsdExtMode$inboundSchema: z.ZodType<
  OutputStatsdExtMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdExtMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdExtMode$outboundSchema: z.ZodType<
  OutputStatsdExtMode,
  z.ZodTypeDef,
  OutputStatsdExtMode
> = z.union([
  z.nativeEnum(OutputStatsdExtMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExtMode$ {
  /** @deprecated use `OutputStatsdExtMode$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExtMode$inboundSchema;
  /** @deprecated use `OutputStatsdExtMode$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdExtMode$outboundSchema;
}

/** @internal */
export const OutputStatsdExtPqControls$inboundSchema: z.ZodType<
  OutputStatsdExtPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputStatsdExtPqControls$Outbound = {};

/** @internal */
export const OutputStatsdExtPqControls$outboundSchema: z.ZodType<
  OutputStatsdExtPqControls$Outbound,
  z.ZodTypeDef,
  OutputStatsdExtPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExtPqControls$ {
  /** @deprecated use `OutputStatsdExtPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExtPqControls$inboundSchema;
  /** @deprecated use `OutputStatsdExtPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdExtPqControls$outboundSchema;
  /** @deprecated use `OutputStatsdExtPqControls$Outbound` instead. */
  export type Outbound = OutputStatsdExtPqControls$Outbound;
}

export function outputStatsdExtPqControlsToJSON(
  outputStatsdExtPqControls: OutputStatsdExtPqControls,
): string {
  return JSON.stringify(
    OutputStatsdExtPqControls$outboundSchema.parse(outputStatsdExtPqControls),
  );
}

export function outputStatsdExtPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputStatsdExtPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputStatsdExtPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputStatsdExtPqControls' from JSON`,
  );
}

/** @internal */
export const OutputStatsdExt$inboundSchema: z.ZodType<
  OutputStatsdExt,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputStatsdExtType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputStatsdExtDestinationProtocol$inboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: OutputStatsdExtBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputStatsdExtCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputStatsdExtQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputStatsdExtMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputStatsdExtPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputStatsdExt$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  host: string;
  port: number;
  mtu: number;
  flushPeriodSec: number;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  onBackpressure: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputStatsdExtPqControls$Outbound | undefined;
};

/** @internal */
export const OutputStatsdExt$outboundSchema: z.ZodType<
  OutputStatsdExt$Outbound,
  z.ZodTypeDef,
  OutputStatsdExt
> = z.object({
  id: z.string(),
  type: OutputStatsdExtType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputStatsdExtDestinationProtocol$outboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: OutputStatsdExtBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputStatsdExtCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputStatsdExtQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputStatsdExtMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputStatsdExtPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExt$ {
  /** @deprecated use `OutputStatsdExt$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExt$inboundSchema;
  /** @deprecated use `OutputStatsdExt$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdExt$outboundSchema;
  /** @deprecated use `OutputStatsdExt$Outbound` instead. */
  export type Outbound = OutputStatsdExt$Outbound;
}

export function outputStatsdExtToJSON(
  outputStatsdExt: OutputStatsdExt,
): string {
  return JSON.stringify(OutputStatsdExt$outboundSchema.parse(outputStatsdExt));
}

export function outputStatsdExtFromJSON(
  jsonString: string,
): SafeParseResult<OutputStatsdExt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputStatsdExt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputStatsdExt' from JSON`,
  );
}

/** @internal */
export const OutputStatsdType$inboundSchema: z.ZodType<
  OutputStatsdType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdType$outboundSchema: z.ZodType<
  OutputStatsdType,
  z.ZodTypeDef,
  OutputStatsdType
> = z.union([
  z.nativeEnum(OutputStatsdType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdType$ {
  /** @deprecated use `OutputStatsdType$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdType$inboundSchema;
  /** @deprecated use `OutputStatsdType$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdType$outboundSchema;
}

/** @internal */
export const OutputStatsdDestinationProtocol$inboundSchema: z.ZodType<
  OutputStatsdDestinationProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdDestinationProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdDestinationProtocol$outboundSchema: z.ZodType<
  OutputStatsdDestinationProtocol,
  z.ZodTypeDef,
  OutputStatsdDestinationProtocol
> = z.union([
  z.nativeEnum(OutputStatsdDestinationProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdDestinationProtocol$ {
  /** @deprecated use `OutputStatsdDestinationProtocol$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdDestinationProtocol$inboundSchema;
  /** @deprecated use `OutputStatsdDestinationProtocol$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdDestinationProtocol$outboundSchema;
}

/** @internal */
export const OutputStatsdBackpressureBehavior$inboundSchema: z.ZodType<
  OutputStatsdBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdBackpressureBehavior$outboundSchema: z.ZodType<
  OutputStatsdBackpressureBehavior,
  z.ZodTypeDef,
  OutputStatsdBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputStatsdBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdBackpressureBehavior$ {
  /** @deprecated use `OutputStatsdBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputStatsdBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputStatsdCompression$inboundSchema: z.ZodType<
  OutputStatsdCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdCompression$outboundSchema: z.ZodType<
  OutputStatsdCompression,
  z.ZodTypeDef,
  OutputStatsdCompression
> = z.union([
  z.nativeEnum(OutputStatsdCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdCompression$ {
  /** @deprecated use `OutputStatsdCompression$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdCompression$inboundSchema;
  /** @deprecated use `OutputStatsdCompression$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdCompression$outboundSchema;
}

/** @internal */
export const OutputStatsdQueueFullBehavior$inboundSchema: z.ZodType<
  OutputStatsdQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdQueueFullBehavior$outboundSchema: z.ZodType<
  OutputStatsdQueueFullBehavior,
  z.ZodTypeDef,
  OutputStatsdQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputStatsdQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdQueueFullBehavior$ {
  /** @deprecated use `OutputStatsdQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputStatsdQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputStatsdMode$inboundSchema: z.ZodType<
  OutputStatsdMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputStatsdMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputStatsdMode$outboundSchema: z.ZodType<
  OutputStatsdMode,
  z.ZodTypeDef,
  OutputStatsdMode
> = z.union([
  z.nativeEnum(OutputStatsdMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdMode$ {
  /** @deprecated use `OutputStatsdMode$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdMode$inboundSchema;
  /** @deprecated use `OutputStatsdMode$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdMode$outboundSchema;
}

/** @internal */
export const OutputStatsdPqControls$inboundSchema: z.ZodType<
  OutputStatsdPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputStatsdPqControls$Outbound = {};

/** @internal */
export const OutputStatsdPqControls$outboundSchema: z.ZodType<
  OutputStatsdPqControls$Outbound,
  z.ZodTypeDef,
  OutputStatsdPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdPqControls$ {
  /** @deprecated use `OutputStatsdPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdPqControls$inboundSchema;
  /** @deprecated use `OutputStatsdPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdPqControls$outboundSchema;
  /** @deprecated use `OutputStatsdPqControls$Outbound` instead. */
  export type Outbound = OutputStatsdPqControls$Outbound;
}

export function outputStatsdPqControlsToJSON(
  outputStatsdPqControls: OutputStatsdPqControls,
): string {
  return JSON.stringify(
    OutputStatsdPqControls$outboundSchema.parse(outputStatsdPqControls),
  );
}

export function outputStatsdPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputStatsdPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputStatsdPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputStatsdPqControls' from JSON`,
  );
}

/** @internal */
export const OutputStatsd$inboundSchema: z.ZodType<
  OutputStatsd,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputStatsdType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputStatsdDestinationProtocol$inboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: OutputStatsdBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputStatsdCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputStatsdQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputStatsdMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputStatsdPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputStatsd$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  host: string;
  port: number;
  mtu: number;
  flushPeriodSec: number;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  onBackpressure: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputStatsdPqControls$Outbound | undefined;
};

/** @internal */
export const OutputStatsd$outboundSchema: z.ZodType<
  OutputStatsd$Outbound,
  z.ZodTypeDef,
  OutputStatsd
> = z.object({
  id: z.string(),
  type: OutputStatsdType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: OutputStatsdDestinationProtocol$outboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: OutputStatsdBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputStatsdCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputStatsdQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputStatsdMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputStatsdPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsd$ {
  /** @deprecated use `OutputStatsd$inboundSchema` instead. */
  export const inboundSchema = OutputStatsd$inboundSchema;
  /** @deprecated use `OutputStatsd$outboundSchema` instead. */
  export const outboundSchema = OutputStatsd$outboundSchema;
  /** @deprecated use `OutputStatsd$Outbound` instead. */
  export type Outbound = OutputStatsd$Outbound;
}

export function outputStatsdToJSON(outputStatsd: OutputStatsd): string {
  return JSON.stringify(OutputStatsd$outboundSchema.parse(outputStatsd));
}

export function outputStatsdFromJSON(
  jsonString: string,
): SafeParseResult<OutputStatsd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputStatsd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputStatsd' from JSON`,
  );
}

/** @internal */
export const OutputMinioType$inboundSchema: z.ZodType<
  OutputMinioType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioType$outboundSchema: z.ZodType<
  OutputMinioType,
  z.ZodTypeDef,
  OutputMinioType
> = z.union([
  z.nativeEnum(OutputMinioType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioType$ {
  /** @deprecated use `OutputMinioType$inboundSchema` instead. */
  export const inboundSchema = OutputMinioType$inboundSchema;
  /** @deprecated use `OutputMinioType$outboundSchema` instead. */
  export const outboundSchema = OutputMinioType$outboundSchema;
}

/** @internal */
export const OutputMinioAuthenticationMethod$inboundSchema: z.ZodType<
  OutputMinioAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioAuthenticationMethod$outboundSchema: z.ZodType<
  OutputMinioAuthenticationMethod,
  z.ZodTypeDef,
  OutputMinioAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputMinioAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioAuthenticationMethod$ {
  /** @deprecated use `OutputMinioAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputMinioAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputMinioAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputMinioAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputMinioSignatureVersion$inboundSchema: z.ZodType<
  OutputMinioSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioSignatureVersion$outboundSchema: z.ZodType<
  OutputMinioSignatureVersion,
  z.ZodTypeDef,
  OutputMinioSignatureVersion
> = z.union([
  z.nativeEnum(OutputMinioSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioSignatureVersion$ {
  /** @deprecated use `OutputMinioSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMinioSignatureVersion$inboundSchema;
  /** @deprecated use `OutputMinioSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMinioSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputMinioObjectACL$inboundSchema: z.ZodType<
  OutputMinioObjectACL,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioObjectACL),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioObjectACL$outboundSchema: z.ZodType<
  OutputMinioObjectACL,
  z.ZodTypeDef,
  OutputMinioObjectACL
> = z.union([
  z.nativeEnum(OutputMinioObjectACL),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioObjectACL$ {
  /** @deprecated use `OutputMinioObjectACL$inboundSchema` instead. */
  export const inboundSchema = OutputMinioObjectACL$inboundSchema;
  /** @deprecated use `OutputMinioObjectACL$outboundSchema` instead. */
  export const outboundSchema = OutputMinioObjectACL$outboundSchema;
}

/** @internal */
export const OutputMinioStorageClass$inboundSchema: z.ZodType<
  OutputMinioStorageClass,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioStorageClass),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioStorageClass$outboundSchema: z.ZodType<
  OutputMinioStorageClass,
  z.ZodTypeDef,
  OutputMinioStorageClass
> = z.union([
  z.nativeEnum(OutputMinioStorageClass),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioStorageClass$ {
  /** @deprecated use `OutputMinioStorageClass$inboundSchema` instead. */
  export const inboundSchema = OutputMinioStorageClass$inboundSchema;
  /** @deprecated use `OutputMinioStorageClass$outboundSchema` instead. */
  export const outboundSchema = OutputMinioStorageClass$outboundSchema;
}

/** @internal */
export const ServerSideEncryption$inboundSchema: z.ZodType<
  ServerSideEncryption,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ServerSideEncryption),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ServerSideEncryption$outboundSchema: z.ZodType<
  ServerSideEncryption,
  z.ZodTypeDef,
  ServerSideEncryption
> = z.union([
  z.nativeEnum(ServerSideEncryption),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServerSideEncryption$ {
  /** @deprecated use `ServerSideEncryption$inboundSchema` instead. */
  export const inboundSchema = ServerSideEncryption$inboundSchema;
  /** @deprecated use `ServerSideEncryption$outboundSchema` instead. */
  export const outboundSchema = ServerSideEncryption$outboundSchema;
}

/** @internal */
export const OutputMinioDataFormat$inboundSchema: z.ZodType<
  OutputMinioDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioDataFormat$outboundSchema: z.ZodType<
  OutputMinioDataFormat,
  z.ZodTypeDef,
  OutputMinioDataFormat
> = z.union([
  z.nativeEnum(OutputMinioDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioDataFormat$ {
  /** @deprecated use `OutputMinioDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputMinioDataFormat$inboundSchema;
  /** @deprecated use `OutputMinioDataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputMinioDataFormat$outboundSchema;
}

/** @internal */
export const OutputMinioBackpressureBehavior$inboundSchema: z.ZodType<
  OutputMinioBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioBackpressureBehavior$outboundSchema: z.ZodType<
  OutputMinioBackpressureBehavior,
  z.ZodTypeDef,
  OutputMinioBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputMinioBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioBackpressureBehavior$ {
  /** @deprecated use `OutputMinioBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputMinioBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputMinioBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputMinioBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputMinioDiskSpaceProtection$inboundSchema: z.ZodType<
  OutputMinioDiskSpaceProtection,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioDiskSpaceProtection),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioDiskSpaceProtection$outboundSchema: z.ZodType<
  OutputMinioDiskSpaceProtection,
  z.ZodTypeDef,
  OutputMinioDiskSpaceProtection
> = z.union([
  z.nativeEnum(OutputMinioDiskSpaceProtection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioDiskSpaceProtection$ {
  /** @deprecated use `OutputMinioDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema = OutputMinioDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputMinioDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema = OutputMinioDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputMinioCompression$inboundSchema: z.ZodType<
  OutputMinioCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioCompression$outboundSchema: z.ZodType<
  OutputMinioCompression,
  z.ZodTypeDef,
  OutputMinioCompression
> = z.union([
  z.nativeEnum(OutputMinioCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioCompression$ {
  /** @deprecated use `OutputMinioCompression$inboundSchema` instead. */
  export const inboundSchema = OutputMinioCompression$inboundSchema;
  /** @deprecated use `OutputMinioCompression$outboundSchema` instead. */
  export const outboundSchema = OutputMinioCompression$outboundSchema;
}

/** @internal */
export const OutputMinioCompressionLevel$inboundSchema: z.ZodType<
  OutputMinioCompressionLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioCompressionLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioCompressionLevel$outboundSchema: z.ZodType<
  OutputMinioCompressionLevel,
  z.ZodTypeDef,
  OutputMinioCompressionLevel
> = z.union([
  z.nativeEnum(OutputMinioCompressionLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioCompressionLevel$ {
  /** @deprecated use `OutputMinioCompressionLevel$inboundSchema` instead. */
  export const inboundSchema = OutputMinioCompressionLevel$inboundSchema;
  /** @deprecated use `OutputMinioCompressionLevel$outboundSchema` instead. */
  export const outboundSchema = OutputMinioCompressionLevel$outboundSchema;
}

/** @internal */
export const OutputMinioParquetVersion$inboundSchema: z.ZodType<
  OutputMinioParquetVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioParquetVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioParquetVersion$outboundSchema: z.ZodType<
  OutputMinioParquetVersion,
  z.ZodTypeDef,
  OutputMinioParquetVersion
> = z.union([
  z.nativeEnum(OutputMinioParquetVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioParquetVersion$ {
  /** @deprecated use `OutputMinioParquetVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMinioParquetVersion$inboundSchema;
  /** @deprecated use `OutputMinioParquetVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMinioParquetVersion$outboundSchema;
}

/** @internal */
export const OutputMinioDataPageVersion$inboundSchema: z.ZodType<
  OutputMinioDataPageVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMinioDataPageVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMinioDataPageVersion$outboundSchema: z.ZodType<
  OutputMinioDataPageVersion,
  z.ZodTypeDef,
  OutputMinioDataPageVersion
> = z.union([
  z.nativeEnum(OutputMinioDataPageVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioDataPageVersion$ {
  /** @deprecated use `OutputMinioDataPageVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMinioDataPageVersion$inboundSchema;
  /** @deprecated use `OutputMinioDataPageVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMinioDataPageVersion$outboundSchema;
}

/** @internal */
export const OutputMinioKeyValueMetadatum$inboundSchema: z.ZodType<
  OutputMinioKeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputMinioKeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputMinioKeyValueMetadatum$outboundSchema: z.ZodType<
  OutputMinioKeyValueMetadatum$Outbound,
  z.ZodTypeDef,
  OutputMinioKeyValueMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioKeyValueMetadatum$ {
  /** @deprecated use `OutputMinioKeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputMinioKeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputMinioKeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputMinioKeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputMinioKeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputMinioKeyValueMetadatum$Outbound;
}

export function outputMinioKeyValueMetadatumToJSON(
  outputMinioKeyValueMetadatum: OutputMinioKeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputMinioKeyValueMetadatum$outboundSchema.parse(
      outputMinioKeyValueMetadatum,
    ),
  );
}

export function outputMinioKeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputMinioKeyValueMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMinioKeyValueMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMinioKeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputMinio$inboundSchema: z.ZodType<
  OutputMinio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputMinioType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string(),
  bucket: z.string(),
  awsAuthenticationMethod: OutputMinioAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().optional(),
  signatureVersion: OutputMinioSignatureVersion$inboundSchema.default("v4"),
  objectACL: OutputMinioObjectACL$inboundSchema.default("private"),
  storageClass: OutputMinioStorageClass$inboundSchema.optional(),
  serverSideEncryption: ServerSideEncryption$inboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  verifyPermissions: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputMinioDataFormat$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputMinioBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputMinioDiskSpaceProtection$inboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputMinioCompression$inboundSchema.default("gzip"),
  compressionLevel: OutputMinioCompressionLevel$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputMinioParquetVersion$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputMinioDataPageVersion$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputMinioKeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputMinio$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  endpoint: string;
  bucket: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  stagePath: string;
  addIdToStagePath: boolean;
  destPath?: string | undefined;
  signatureVersion: string;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  verifyPermissions: boolean;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<OutputMinioKeyValueMetadatum$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputMinio$outboundSchema: z.ZodType<
  OutputMinio$Outbound,
  z.ZodTypeDef,
  OutputMinio
> = z.object({
  id: z.string(),
  type: OutputMinioType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string(),
  bucket: z.string(),
  awsAuthenticationMethod: OutputMinioAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().optional(),
  signatureVersion: OutputMinioSignatureVersion$outboundSchema.default("v4"),
  objectACL: OutputMinioObjectACL$outboundSchema.default("private"),
  storageClass: OutputMinioStorageClass$outboundSchema.optional(),
  serverSideEncryption: ServerSideEncryption$outboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  verifyPermissions: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputMinioDataFormat$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputMinioBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputMinioDiskSpaceProtection$outboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputMinioCompression$outboundSchema.default("gzip"),
  compressionLevel: OutputMinioCompressionLevel$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputMinioParquetVersion$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputMinioDataPageVersion$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputMinioKeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinio$ {
  /** @deprecated use `OutputMinio$inboundSchema` instead. */
  export const inboundSchema = OutputMinio$inboundSchema;
  /** @deprecated use `OutputMinio$outboundSchema` instead. */
  export const outboundSchema = OutputMinio$outboundSchema;
  /** @deprecated use `OutputMinio$Outbound` instead. */
  export type Outbound = OutputMinio$Outbound;
}

export function outputMinioToJSON(outputMinio: OutputMinio): string {
  return JSON.stringify(OutputMinio$outboundSchema.parse(outputMinio));
}

export function outputMinioFromJSON(
  jsonString: string,
): SafeParseResult<OutputMinio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMinio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMinio' from JSON`,
  );
}

/** @internal */
export const OutputCloudwatchType$inboundSchema: z.ZodType<
  OutputCloudwatchType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCloudwatchType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCloudwatchType$outboundSchema: z.ZodType<
  OutputCloudwatchType,
  z.ZodTypeDef,
  OutputCloudwatchType
> = z.union([
  z.nativeEnum(OutputCloudwatchType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatchType$ {
  /** @deprecated use `OutputCloudwatchType$inboundSchema` instead. */
  export const inboundSchema = OutputCloudwatchType$inboundSchema;
  /** @deprecated use `OutputCloudwatchType$outboundSchema` instead. */
  export const outboundSchema = OutputCloudwatchType$outboundSchema;
}

/** @internal */
export const OutputCloudwatchAuthenticationMethod$inboundSchema: z.ZodType<
  OutputCloudwatchAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCloudwatchAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCloudwatchAuthenticationMethod$outboundSchema: z.ZodType<
  OutputCloudwatchAuthenticationMethod,
  z.ZodTypeDef,
  OutputCloudwatchAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputCloudwatchAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatchAuthenticationMethod$ {
  /** @deprecated use `OutputCloudwatchAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputCloudwatchAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputCloudwatchAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputCloudwatchAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputCloudwatchBackpressureBehavior$inboundSchema: z.ZodType<
  OutputCloudwatchBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCloudwatchBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCloudwatchBackpressureBehavior$outboundSchema: z.ZodType<
  OutputCloudwatchBackpressureBehavior,
  z.ZodTypeDef,
  OutputCloudwatchBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputCloudwatchBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatchBackpressureBehavior$ {
  /** @deprecated use `OutputCloudwatchBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputCloudwatchBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputCloudwatchBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputCloudwatchBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputCloudwatchCompression$inboundSchema: z.ZodType<
  OutputCloudwatchCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCloudwatchCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCloudwatchCompression$outboundSchema: z.ZodType<
  OutputCloudwatchCompression,
  z.ZodTypeDef,
  OutputCloudwatchCompression
> = z.union([
  z.nativeEnum(OutputCloudwatchCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatchCompression$ {
  /** @deprecated use `OutputCloudwatchCompression$inboundSchema` instead. */
  export const inboundSchema = OutputCloudwatchCompression$inboundSchema;
  /** @deprecated use `OutputCloudwatchCompression$outboundSchema` instead. */
  export const outboundSchema = OutputCloudwatchCompression$outboundSchema;
}

/** @internal */
export const OutputCloudwatchQueueFullBehavior$inboundSchema: z.ZodType<
  OutputCloudwatchQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCloudwatchQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCloudwatchQueueFullBehavior$outboundSchema: z.ZodType<
  OutputCloudwatchQueueFullBehavior,
  z.ZodTypeDef,
  OutputCloudwatchQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputCloudwatchQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatchQueueFullBehavior$ {
  /** @deprecated use `OutputCloudwatchQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputCloudwatchQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputCloudwatchQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputCloudwatchQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputCloudwatchMode$inboundSchema: z.ZodType<
  OutputCloudwatchMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputCloudwatchMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputCloudwatchMode$outboundSchema: z.ZodType<
  OutputCloudwatchMode,
  z.ZodTypeDef,
  OutputCloudwatchMode
> = z.union([
  z.nativeEnum(OutputCloudwatchMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatchMode$ {
  /** @deprecated use `OutputCloudwatchMode$inboundSchema` instead. */
  export const inboundSchema = OutputCloudwatchMode$inboundSchema;
  /** @deprecated use `OutputCloudwatchMode$outboundSchema` instead. */
  export const outboundSchema = OutputCloudwatchMode$outboundSchema;
}

/** @internal */
export const OutputCloudwatchPqControls$inboundSchema: z.ZodType<
  OutputCloudwatchPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputCloudwatchPqControls$Outbound = {};

/** @internal */
export const OutputCloudwatchPqControls$outboundSchema: z.ZodType<
  OutputCloudwatchPqControls$Outbound,
  z.ZodTypeDef,
  OutputCloudwatchPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatchPqControls$ {
  /** @deprecated use `OutputCloudwatchPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputCloudwatchPqControls$inboundSchema;
  /** @deprecated use `OutputCloudwatchPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputCloudwatchPqControls$outboundSchema;
  /** @deprecated use `OutputCloudwatchPqControls$Outbound` instead. */
  export type Outbound = OutputCloudwatchPqControls$Outbound;
}

export function outputCloudwatchPqControlsToJSON(
  outputCloudwatchPqControls: OutputCloudwatchPqControls,
): string {
  return JSON.stringify(
    OutputCloudwatchPqControls$outboundSchema.parse(outputCloudwatchPqControls),
  );
}

export function outputCloudwatchPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputCloudwatchPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputCloudwatchPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputCloudwatchPqControls' from JSON`,
  );
}

/** @internal */
export const OutputCloudwatch$inboundSchema: z.ZodType<
  OutputCloudwatch,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputCloudwatchType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logGroupName: z.string(),
  logStreamName: z.string(),
  awsAuthenticationMethod: OutputCloudwatchAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  onBackpressure: OutputCloudwatchBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputCloudwatchCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputCloudwatchQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputCloudwatchMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputCloudwatchPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputCloudwatch$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  logGroupName: string;
  logStreamName: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  maxQueueSize: number;
  maxRecordSizeKB: number;
  flushPeriodSec: number;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputCloudwatchPqControls$Outbound | undefined;
};

/** @internal */
export const OutputCloudwatch$outboundSchema: z.ZodType<
  OutputCloudwatch$Outbound,
  z.ZodTypeDef,
  OutputCloudwatch
> = z.object({
  id: z.string(),
  type: OutputCloudwatchType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logGroupName: z.string(),
  logStreamName: z.string(),
  awsAuthenticationMethod: OutputCloudwatchAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  onBackpressure: OutputCloudwatchBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputCloudwatchCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputCloudwatchQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputCloudwatchMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputCloudwatchPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatch$ {
  /** @deprecated use `OutputCloudwatch$inboundSchema` instead. */
  export const inboundSchema = OutputCloudwatch$inboundSchema;
  /** @deprecated use `OutputCloudwatch$outboundSchema` instead. */
  export const outboundSchema = OutputCloudwatch$outboundSchema;
  /** @deprecated use `OutputCloudwatch$Outbound` instead. */
  export type Outbound = OutputCloudwatch$Outbound;
}

export function outputCloudwatchToJSON(
  outputCloudwatch: OutputCloudwatch,
): string {
  return JSON.stringify(
    OutputCloudwatch$outboundSchema.parse(outputCloudwatch),
  );
}

export function outputCloudwatchFromJSON(
  jsonString: string,
): SafeParseResult<OutputCloudwatch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputCloudwatch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputCloudwatch' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType$inboundSchema: z.ZodType<
  OutputInfluxdbType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputInfluxdbType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputInfluxdbType$outboundSchema: z.ZodType<
  OutputInfluxdbType,
  z.ZodTypeDef,
  OutputInfluxdbType
> = z.union([
  z.nativeEnum(OutputInfluxdbType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbType$ {
  /** @deprecated use `OutputInfluxdbType$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbType$inboundSchema;
  /** @deprecated use `OutputInfluxdbType$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbType$outboundSchema;
}

/** @internal */
export const TimestampPrecision$inboundSchema: z.ZodType<
  TimestampPrecision,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TimestampPrecision$outboundSchema: z.ZodType<
  TimestampPrecision,
  z.ZodTypeDef,
  TimestampPrecision
> = z.union([
  z.nativeEnum(TimestampPrecision),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimestampPrecision$ {
  /** @deprecated use `TimestampPrecision$inboundSchema` instead. */
  export const inboundSchema = TimestampPrecision$inboundSchema;
  /** @deprecated use `TimestampPrecision$outboundSchema` instead. */
  export const outboundSchema = TimestampPrecision$outboundSchema;
}

/** @internal */
export const OutputInfluxdbExtraHttpHeader$inboundSchema: z.ZodType<
  OutputInfluxdbExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputInfluxdbExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputInfluxdbExtraHttpHeader$outboundSchema: z.ZodType<
  OutputInfluxdbExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbExtraHttpHeader$ {
  /** @deprecated use `OutputInfluxdbExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputInfluxdbExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputInfluxdbExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputInfluxdbExtraHttpHeader$Outbound;
}

export function outputInfluxdbExtraHttpHeaderToJSON(
  outputInfluxdbExtraHttpHeader: OutputInfluxdbExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputInfluxdbExtraHttpHeader$outboundSchema.parse(
      outputInfluxdbExtraHttpHeader,
    ),
  );
}

export function outputInfluxdbExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputInfluxdbFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputInfluxdbFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputInfluxdbFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputInfluxdbFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputInfluxdbFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputInfluxdbFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbFailedRequestLoggingMode$ {
  /** @deprecated use `OutputInfluxdbFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputInfluxdbFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputInfluxdbFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputInfluxdbFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputInfluxdbResponseRetrySetting$inboundSchema: z.ZodType<
  OutputInfluxdbResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputInfluxdbResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputInfluxdbResponseRetrySetting$outboundSchema: z.ZodType<
  OutputInfluxdbResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbResponseRetrySetting$ {
  /** @deprecated use `OutputInfluxdbResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputInfluxdbResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputInfluxdbResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputInfluxdbResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputInfluxdbResponseRetrySetting$Outbound;
}

export function outputInfluxdbResponseRetrySettingToJSON(
  outputInfluxdbResponseRetrySetting: OutputInfluxdbResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputInfluxdbResponseRetrySetting$outboundSchema.parse(
      outputInfluxdbResponseRetrySetting,
    ),
  );
}

export function outputInfluxdbResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputInfluxdbResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputInfluxdbTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputInfluxdbTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputInfluxdbTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputInfluxdbTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbTimeoutRetrySettings$ {
  /** @deprecated use `OutputInfluxdbTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputInfluxdbTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputInfluxdbTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputInfluxdbTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputInfluxdbTimeoutRetrySettings$Outbound;
}

export function outputInfluxdbTimeoutRetrySettingsToJSON(
  outputInfluxdbTimeoutRetrySettings: OutputInfluxdbTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputInfluxdbTimeoutRetrySettings$outboundSchema.parse(
      outputInfluxdbTimeoutRetrySettings,
    ),
  );
}

export function outputInfluxdbTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputInfluxdbTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbBackpressureBehavior$inboundSchema: z.ZodType<
  OutputInfluxdbBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputInfluxdbBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputInfluxdbBackpressureBehavior$outboundSchema: z.ZodType<
  OutputInfluxdbBackpressureBehavior,
  z.ZodTypeDef,
  OutputInfluxdbBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputInfluxdbBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbBackpressureBehavior$ {
  /** @deprecated use `OutputInfluxdbBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputInfluxdbBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputInfluxdbBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputInfluxdbAuthenticationType$inboundSchema: z.ZodType<
  OutputInfluxdbAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputInfluxdbAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputInfluxdbAuthenticationType$outboundSchema: z.ZodType<
  OutputInfluxdbAuthenticationType,
  z.ZodTypeDef,
  OutputInfluxdbAuthenticationType
> = z.union([
  z.nativeEnum(OutputInfluxdbAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbAuthenticationType$ {
  /** @deprecated use `OutputInfluxdbAuthenticationType$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbAuthenticationType$inboundSchema;
  /** @deprecated use `OutputInfluxdbAuthenticationType$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbAuthenticationType$outboundSchema;
}

/** @internal */
export const OutputInfluxdbCompression$inboundSchema: z.ZodType<
  OutputInfluxdbCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputInfluxdbCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputInfluxdbCompression$outboundSchema: z.ZodType<
  OutputInfluxdbCompression,
  z.ZodTypeDef,
  OutputInfluxdbCompression
> = z.union([
  z.nativeEnum(OutputInfluxdbCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbCompression$ {
  /** @deprecated use `OutputInfluxdbCompression$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbCompression$inboundSchema;
  /** @deprecated use `OutputInfluxdbCompression$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbCompression$outboundSchema;
}

/** @internal */
export const OutputInfluxdbQueueFullBehavior$inboundSchema: z.ZodType<
  OutputInfluxdbQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputInfluxdbQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputInfluxdbQueueFullBehavior$outboundSchema: z.ZodType<
  OutputInfluxdbQueueFullBehavior,
  z.ZodTypeDef,
  OutputInfluxdbQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputInfluxdbQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbQueueFullBehavior$ {
  /** @deprecated use `OutputInfluxdbQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputInfluxdbQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputInfluxdbMode$inboundSchema: z.ZodType<
  OutputInfluxdbMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputInfluxdbMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputInfluxdbMode$outboundSchema: z.ZodType<
  OutputInfluxdbMode,
  z.ZodTypeDef,
  OutputInfluxdbMode
> = z.union([
  z.nativeEnum(OutputInfluxdbMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbMode$ {
  /** @deprecated use `OutputInfluxdbMode$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbMode$inboundSchema;
  /** @deprecated use `OutputInfluxdbMode$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbMode$outboundSchema;
}

/** @internal */
export const OutputInfluxdbPqControls$inboundSchema: z.ZodType<
  OutputInfluxdbPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputInfluxdbPqControls$Outbound = {};

/** @internal */
export const OutputInfluxdbPqControls$outboundSchema: z.ZodType<
  OutputInfluxdbPqControls$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbPqControls$ {
  /** @deprecated use `OutputInfluxdbPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbPqControls$inboundSchema;
  /** @deprecated use `OutputInfluxdbPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbPqControls$outboundSchema;
  /** @deprecated use `OutputInfluxdbPqControls$Outbound` instead. */
  export type Outbound = OutputInfluxdbPqControls$Outbound;
}

export function outputInfluxdbPqControlsToJSON(
  outputInfluxdbPqControls: OutputInfluxdbPqControls,
): string {
  return JSON.stringify(
    OutputInfluxdbPqControls$outboundSchema.parse(outputInfluxdbPqControls),
  );
}

export function outputInfluxdbPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbPqControls' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbOauthParam$inboundSchema: z.ZodType<
  OutputInfluxdbOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputInfluxdbOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputInfluxdbOauthParam$outboundSchema: z.ZodType<
  OutputInfluxdbOauthParam$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbOauthParam$ {
  /** @deprecated use `OutputInfluxdbOauthParam$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbOauthParam$inboundSchema;
  /** @deprecated use `OutputInfluxdbOauthParam$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbOauthParam$outboundSchema;
  /** @deprecated use `OutputInfluxdbOauthParam$Outbound` instead. */
  export type Outbound = OutputInfluxdbOauthParam$Outbound;
}

export function outputInfluxdbOauthParamToJSON(
  outputInfluxdbOauthParam: OutputInfluxdbOauthParam,
): string {
  return JSON.stringify(
    OutputInfluxdbOauthParam$outboundSchema.parse(outputInfluxdbOauthParam),
  );
}

export function outputInfluxdbOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbOauthParam' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbOauthHeader$inboundSchema: z.ZodType<
  OutputInfluxdbOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputInfluxdbOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputInfluxdbOauthHeader$outboundSchema: z.ZodType<
  OutputInfluxdbOauthHeader$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdbOauthHeader$ {
  /** @deprecated use `OutputInfluxdbOauthHeader$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdbOauthHeader$inboundSchema;
  /** @deprecated use `OutputInfluxdbOauthHeader$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdbOauthHeader$outboundSchema;
  /** @deprecated use `OutputInfluxdbOauthHeader$Outbound` instead. */
  export type Outbound = OutputInfluxdbOauthHeader$Outbound;
}

export function outputInfluxdbOauthHeaderToJSON(
  outputInfluxdbOauthHeader: OutputInfluxdbOauthHeader,
): string {
  return JSON.stringify(
    OutputInfluxdbOauthHeader$outboundSchema.parse(outputInfluxdbOauthHeader),
  );
}

export function outputInfluxdbOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbOauthHeader' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdb$inboundSchema: z.ZodType<
  OutputInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputInfluxdbType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputInfluxdbExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: OutputInfluxdbFailedRequestLoggingMode$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputInfluxdbResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputInfluxdbTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputInfluxdbBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  authType: OutputInfluxdbAuthenticationType$inboundSchema.default("none"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputInfluxdbCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputInfluxdbQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputInfluxdbMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputInfluxdbPqControls$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OutputInfluxdbOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OutputInfluxdbOauthHeader$inboundSchema))
    .optional(),
});

/** @internal */
export type OutputInfluxdb$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputInfluxdbExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputInfluxdbResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputInfluxdbTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputInfluxdbPqControls$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OutputInfluxdbOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<OutputInfluxdbOauthHeader$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdb$outboundSchema: z.ZodType<
  OutputInfluxdb$Outbound,
  z.ZodTypeDef,
  OutputInfluxdb
> = z.object({
  id: z.string(),
  type: OutputInfluxdbType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputInfluxdbExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputInfluxdbFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputInfluxdbResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputInfluxdbTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputInfluxdbBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  authType: OutputInfluxdbAuthenticationType$outboundSchema.default("none"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputInfluxdbCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputInfluxdbQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputInfluxdbMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputInfluxdbPqControls$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OutputInfluxdbOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OutputInfluxdbOauthHeader$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdb$ {
  /** @deprecated use `OutputInfluxdb$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdb$inboundSchema;
  /** @deprecated use `OutputInfluxdb$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdb$outboundSchema;
  /** @deprecated use `OutputInfluxdb$Outbound` instead. */
  export type Outbound = OutputInfluxdb$Outbound;
}

export function outputInfluxdbToJSON(outputInfluxdb: OutputInfluxdb): string {
  return JSON.stringify(OutputInfluxdb$outboundSchema.parse(outputInfluxdb));
}

export function outputInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdb' from JSON`,
  );
}

/** @internal */
export const OutputNewrelicEventsType$inboundSchema: z.ZodType<
  OutputNewrelicEventsType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNewrelicEventsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNewrelicEventsType$outboundSchema: z.ZodType<
  OutputNewrelicEventsType,
  z.ZodTypeDef,
  OutputNewrelicEventsType
> = z.union([
  z.nativeEnum(OutputNewrelicEventsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsType$ {
  /** @deprecated use `OutputNewrelicEventsType$inboundSchema` instead. */
  export const inboundSchema = OutputNewrelicEventsType$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsType$outboundSchema` instead. */
  export const outboundSchema = OutputNewrelicEventsType$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsRegion$inboundSchema: z.ZodType<
  OutputNewrelicEventsRegion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNewrelicEventsRegion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNewrelicEventsRegion$outboundSchema: z.ZodType<
  OutputNewrelicEventsRegion,
  z.ZodTypeDef,
  OutputNewrelicEventsRegion
> = z.union([
  z.nativeEnum(OutputNewrelicEventsRegion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsRegion$ {
  /** @deprecated use `OutputNewrelicEventsRegion$inboundSchema` instead. */
  export const inboundSchema = OutputNewrelicEventsRegion$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsRegion$outboundSchema` instead. */
  export const outboundSchema = OutputNewrelicEventsRegion$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsExtraHttpHeader$inboundSchema: z.ZodType<
  OutputNewrelicEventsExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputNewrelicEventsExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputNewrelicEventsExtraHttpHeader$outboundSchema: z.ZodType<
  OutputNewrelicEventsExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputNewrelicEventsExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsExtraHttpHeader$ {
  /** @deprecated use `OutputNewrelicEventsExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema =
    OutputNewrelicEventsExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputNewrelicEventsExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputNewrelicEventsExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputNewrelicEventsExtraHttpHeader$Outbound;
}

export function outputNewrelicEventsExtraHttpHeaderToJSON(
  outputNewrelicEventsExtraHttpHeader: OutputNewrelicEventsExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputNewrelicEventsExtraHttpHeader$outboundSchema.parse(
      outputNewrelicEventsExtraHttpHeader,
    ),
  );
}

export function outputNewrelicEventsExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputNewrelicEventsExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputNewrelicEventsExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNewrelicEventsExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputNewrelicEventsFailedRequestLoggingMode$inboundSchema:
  z.ZodType<
    OutputNewrelicEventsFailedRequestLoggingMode,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputNewrelicEventsFailedRequestLoggingMode),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputNewrelicEventsFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputNewrelicEventsFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputNewrelicEventsFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputNewrelicEventsFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsFailedRequestLoggingMode$ {
  /** @deprecated use `OutputNewrelicEventsFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputNewrelicEventsFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputNewrelicEventsFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsResponseRetrySetting$inboundSchema: z.ZodType<
  OutputNewrelicEventsResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputNewrelicEventsResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputNewrelicEventsResponseRetrySetting$outboundSchema: z.ZodType<
  OutputNewrelicEventsResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputNewrelicEventsResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsResponseRetrySetting$ {
  /** @deprecated use `OutputNewrelicEventsResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputNewrelicEventsResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputNewrelicEventsResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputNewrelicEventsResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputNewrelicEventsResponseRetrySetting$Outbound;
}

export function outputNewrelicEventsResponseRetrySettingToJSON(
  outputNewrelicEventsResponseRetrySetting:
    OutputNewrelicEventsResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputNewrelicEventsResponseRetrySetting$outboundSchema.parse(
      outputNewrelicEventsResponseRetrySetting,
    ),
  );
}

export function outputNewrelicEventsResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputNewrelicEventsResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputNewrelicEventsResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputNewrelicEventsResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputNewrelicEventsTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputNewrelicEventsTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputNewrelicEventsTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputNewrelicEventsTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputNewrelicEventsTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputNewrelicEventsTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsTimeoutRetrySettings$ {
  /** @deprecated use `OutputNewrelicEventsTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputNewrelicEventsTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputNewrelicEventsTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputNewrelicEventsTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputNewrelicEventsTimeoutRetrySettings$Outbound;
}

export function outputNewrelicEventsTimeoutRetrySettingsToJSON(
  outputNewrelicEventsTimeoutRetrySettings:
    OutputNewrelicEventsTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputNewrelicEventsTimeoutRetrySettings$outboundSchema.parse(
      outputNewrelicEventsTimeoutRetrySettings,
    ),
  );
}

export function outputNewrelicEventsTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputNewrelicEventsTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputNewrelicEventsTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputNewrelicEventsTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputNewrelicEventsBackpressureBehavior$inboundSchema: z.ZodType<
  OutputNewrelicEventsBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNewrelicEventsBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNewrelicEventsBackpressureBehavior$outboundSchema: z.ZodType<
  OutputNewrelicEventsBackpressureBehavior,
  z.ZodTypeDef,
  OutputNewrelicEventsBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputNewrelicEventsBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsBackpressureBehavior$ {
  /** @deprecated use `OutputNewrelicEventsBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputNewrelicEventsBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputNewrelicEventsBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsAuthenticationMethod$inboundSchema: z.ZodType<
  OutputNewrelicEventsAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNewrelicEventsAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNewrelicEventsAuthenticationMethod$outboundSchema: z.ZodType<
  OutputNewrelicEventsAuthenticationMethod,
  z.ZodTypeDef,
  OutputNewrelicEventsAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputNewrelicEventsAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsAuthenticationMethod$ {
  /** @deprecated use `OutputNewrelicEventsAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputNewrelicEventsAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputNewrelicEventsAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsCompression$inboundSchema: z.ZodType<
  OutputNewrelicEventsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNewrelicEventsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNewrelicEventsCompression$outboundSchema: z.ZodType<
  OutputNewrelicEventsCompression,
  z.ZodTypeDef,
  OutputNewrelicEventsCompression
> = z.union([
  z.nativeEnum(OutputNewrelicEventsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsCompression$ {
  /** @deprecated use `OutputNewrelicEventsCompression$inboundSchema` instead. */
  export const inboundSchema = OutputNewrelicEventsCompression$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsCompression$outboundSchema` instead. */
  export const outboundSchema = OutputNewrelicEventsCompression$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsQueueFullBehavior$inboundSchema: z.ZodType<
  OutputNewrelicEventsQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNewrelicEventsQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNewrelicEventsQueueFullBehavior$outboundSchema: z.ZodType<
  OutputNewrelicEventsQueueFullBehavior,
  z.ZodTypeDef,
  OutputNewrelicEventsQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputNewrelicEventsQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsQueueFullBehavior$ {
  /** @deprecated use `OutputNewrelicEventsQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputNewrelicEventsQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputNewrelicEventsQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsMode$inboundSchema: z.ZodType<
  OutputNewrelicEventsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputNewrelicEventsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputNewrelicEventsMode$outboundSchema: z.ZodType<
  OutputNewrelicEventsMode,
  z.ZodTypeDef,
  OutputNewrelicEventsMode
> = z.union([
  z.nativeEnum(OutputNewrelicEventsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsMode$ {
  /** @deprecated use `OutputNewrelicEventsMode$inboundSchema` instead. */
  export const inboundSchema = OutputNewrelicEventsMode$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsMode$outboundSchema` instead. */
  export const outboundSchema = OutputNewrelicEventsMode$outboundSchema;
}

/** @internal */
export const OutputNewrelicEventsPqControls$inboundSchema: z.ZodType<
  OutputNewrelicEventsPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputNewrelicEventsPqControls$Outbound = {};

/** @internal */
export const OutputNewrelicEventsPqControls$outboundSchema: z.ZodType<
  OutputNewrelicEventsPqControls$Outbound,
  z.ZodTypeDef,
  OutputNewrelicEventsPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEventsPqControls$ {
  /** @deprecated use `OutputNewrelicEventsPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputNewrelicEventsPqControls$inboundSchema;
  /** @deprecated use `OutputNewrelicEventsPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputNewrelicEventsPqControls$outboundSchema;
  /** @deprecated use `OutputNewrelicEventsPqControls$Outbound` instead. */
  export type Outbound = OutputNewrelicEventsPqControls$Outbound;
}

export function outputNewrelicEventsPqControlsToJSON(
  outputNewrelicEventsPqControls: OutputNewrelicEventsPqControls,
): string {
  return JSON.stringify(
    OutputNewrelicEventsPqControls$outboundSchema.parse(
      outputNewrelicEventsPqControls,
    ),
  );
}

export function outputNewrelicEventsPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputNewrelicEventsPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNewrelicEventsPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNewrelicEventsPqControls' from JSON`,
  );
}

/** @internal */
export const OutputNewrelicEvents$inboundSchema: z.ZodType<
  OutputNewrelicEvents,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputNewrelicEventsType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: OutputNewrelicEventsRegion$inboundSchema.default("US"),
  accountId: z.string(),
  eventType: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputNewrelicEventsExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputNewrelicEventsFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputNewrelicEventsResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputNewrelicEventsTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputNewrelicEventsBackpressureBehavior$inboundSchema
    .default("block"),
  authType: OutputNewrelicEventsAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  customUrl: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputNewrelicEventsCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputNewrelicEventsQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputNewrelicEventsMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputNewrelicEventsPqControls$inboundSchema)
    .optional(),
  apiKey: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputNewrelicEvents$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  region: string;
  accountId: string;
  eventType: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputNewrelicEventsExtraHttpHeader$Outbound>
    | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputNewrelicEventsResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputNewrelicEventsTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  customUrl?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputNewrelicEventsPqControls$Outbound | undefined;
  apiKey?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputNewrelicEvents$outboundSchema: z.ZodType<
  OutputNewrelicEvents$Outbound,
  z.ZodTypeDef,
  OutputNewrelicEvents
> = z.object({
  id: z.string(),
  type: OutputNewrelicEventsType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: OutputNewrelicEventsRegion$outboundSchema.default("US"),
  accountId: z.string(),
  eventType: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputNewrelicEventsExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputNewrelicEventsFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputNewrelicEventsResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputNewrelicEventsTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputNewrelicEventsBackpressureBehavior$outboundSchema
    .default("block"),
  authType: OutputNewrelicEventsAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  customUrl: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputNewrelicEventsCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputNewrelicEventsQueueFullBehavior$outboundSchema
    .default("block"),
  pqMode: OutputNewrelicEventsMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputNewrelicEventsPqControls$outboundSchema)
    .optional(),
  apiKey: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEvents$ {
  /** @deprecated use `OutputNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = OutputNewrelicEvents$inboundSchema;
  /** @deprecated use `OutputNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = OutputNewrelicEvents$outboundSchema;
  /** @deprecated use `OutputNewrelicEvents$Outbound` instead. */
  export type Outbound = OutputNewrelicEvents$Outbound;
}

export function outputNewrelicEventsToJSON(
  outputNewrelicEvents: OutputNewrelicEvents,
): string {
  return JSON.stringify(
    OutputNewrelicEvents$outboundSchema.parse(outputNewrelicEvents),
  );
}

export function outputNewrelicEventsFromJSON(
  jsonString: string,
): SafeParseResult<OutputNewrelicEvents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNewrelicEvents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNewrelicEvents' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloudType$inboundSchema: z.ZodType<
  OutputElasticCloudType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticCloudType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticCloudType$outboundSchema: z.ZodType<
  OutputElasticCloudType,
  z.ZodTypeDef,
  OutputElasticCloudType
> = z.union([
  z.nativeEnum(OutputElasticCloudType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudType$ {
  /** @deprecated use `OutputElasticCloudType$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloudType$inboundSchema;
  /** @deprecated use `OutputElasticCloudType$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloudType$outboundSchema;
}

/** @internal */
export const OutputElasticCloudExtraHttpHeader$inboundSchema: z.ZodType<
  OutputElasticCloudExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputElasticCloudExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputElasticCloudExtraHttpHeader$outboundSchema: z.ZodType<
  OutputElasticCloudExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputElasticCloudExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudExtraHttpHeader$ {
  /** @deprecated use `OutputElasticCloudExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloudExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputElasticCloudExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticCloudExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputElasticCloudExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputElasticCloudExtraHttpHeader$Outbound;
}

export function outputElasticCloudExtraHttpHeaderToJSON(
  outputElasticCloudExtraHttpHeader: OutputElasticCloudExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputElasticCloudExtraHttpHeader$outboundSchema.parse(
      outputElasticCloudExtraHttpHeader,
    ),
  );
}

export function outputElasticCloudExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloudExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticCloudExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloudExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloudFailedRequestLoggingMode$inboundSchema:
  z.ZodType<OutputElasticCloudFailedRequestLoggingMode, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(OutputElasticCloudFailedRequestLoggingMode),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const OutputElasticCloudFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputElasticCloudFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputElasticCloudFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputElasticCloudFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudFailedRequestLoggingMode$ {
  /** @deprecated use `OutputElasticCloudFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputElasticCloudFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputElasticCloudFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticCloudFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputElasticCloudExtraParam$inboundSchema: z.ZodType<
  OutputElasticCloudExtraParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputElasticCloudExtraParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputElasticCloudExtraParam$outboundSchema: z.ZodType<
  OutputElasticCloudExtraParam$Outbound,
  z.ZodTypeDef,
  OutputElasticCloudExtraParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudExtraParam$ {
  /** @deprecated use `OutputElasticCloudExtraParam$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloudExtraParam$inboundSchema;
  /** @deprecated use `OutputElasticCloudExtraParam$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloudExtraParam$outboundSchema;
  /** @deprecated use `OutputElasticCloudExtraParam$Outbound` instead. */
  export type Outbound = OutputElasticCloudExtraParam$Outbound;
}

export function outputElasticCloudExtraParamToJSON(
  outputElasticCloudExtraParam: OutputElasticCloudExtraParam,
): string {
  return JSON.stringify(
    OutputElasticCloudExtraParam$outboundSchema.parse(
      outputElasticCloudExtraParam,
    ),
  );
}

export function outputElasticCloudExtraParamFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloudExtraParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticCloudExtraParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloudExtraParam' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloudAuthenticationMethod$inboundSchema: z.ZodType<
  OutputElasticCloudAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticCloudAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticCloudAuthenticationMethod$outboundSchema: z.ZodType<
  OutputElasticCloudAuthenticationMethod,
  z.ZodTypeDef,
  OutputElasticCloudAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputElasticCloudAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudAuthenticationMethod$ {
  /** @deprecated use `OutputElasticCloudAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputElasticCloudAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputElasticCloudAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticCloudAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputElasticCloudAuth$inboundSchema: z.ZodType<
  OutputElasticCloudAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  authType: OutputElasticCloudAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
});

/** @internal */
export type OutputElasticCloudAuth$Outbound = {
  disabled: boolean;
  authType: string;
};

/** @internal */
export const OutputElasticCloudAuth$outboundSchema: z.ZodType<
  OutputElasticCloudAuth$Outbound,
  z.ZodTypeDef,
  OutputElasticCloudAuth
> = z.object({
  disabled: z.boolean().default(false),
  authType: OutputElasticCloudAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudAuth$ {
  /** @deprecated use `OutputElasticCloudAuth$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloudAuth$inboundSchema;
  /** @deprecated use `OutputElasticCloudAuth$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloudAuth$outboundSchema;
  /** @deprecated use `OutputElasticCloudAuth$Outbound` instead. */
  export type Outbound = OutputElasticCloudAuth$Outbound;
}

export function outputElasticCloudAuthToJSON(
  outputElasticCloudAuth: OutputElasticCloudAuth,
): string {
  return JSON.stringify(
    OutputElasticCloudAuth$outboundSchema.parse(outputElasticCloudAuth),
  );
}

export function outputElasticCloudAuthFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloudAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticCloudAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloudAuth' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloudResponseRetrySetting$inboundSchema: z.ZodType<
  OutputElasticCloudResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputElasticCloudResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputElasticCloudResponseRetrySetting$outboundSchema: z.ZodType<
  OutputElasticCloudResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputElasticCloudResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudResponseRetrySetting$ {
  /** @deprecated use `OutputElasticCloudResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputElasticCloudResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputElasticCloudResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticCloudResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputElasticCloudResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputElasticCloudResponseRetrySetting$Outbound;
}

export function outputElasticCloudResponseRetrySettingToJSON(
  outputElasticCloudResponseRetrySetting:
    OutputElasticCloudResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputElasticCloudResponseRetrySetting$outboundSchema.parse(
      outputElasticCloudResponseRetrySetting,
    ),
  );
}

export function outputElasticCloudResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloudResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputElasticCloudResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloudResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloudTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputElasticCloudTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputElasticCloudTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputElasticCloudTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputElasticCloudTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputElasticCloudTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudTimeoutRetrySettings$ {
  /** @deprecated use `OutputElasticCloudTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputElasticCloudTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputElasticCloudTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticCloudTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputElasticCloudTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputElasticCloudTimeoutRetrySettings$Outbound;
}

export function outputElasticCloudTimeoutRetrySettingsToJSON(
  outputElasticCloudTimeoutRetrySettings:
    OutputElasticCloudTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputElasticCloudTimeoutRetrySettings$outboundSchema.parse(
      outputElasticCloudTimeoutRetrySettings,
    ),
  );
}

export function outputElasticCloudTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloudTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputElasticCloudTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloudTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloudBackpressureBehavior$inboundSchema: z.ZodType<
  OutputElasticCloudBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticCloudBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticCloudBackpressureBehavior$outboundSchema: z.ZodType<
  OutputElasticCloudBackpressureBehavior,
  z.ZodTypeDef,
  OutputElasticCloudBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputElasticCloudBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudBackpressureBehavior$ {
  /** @deprecated use `OutputElasticCloudBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputElasticCloudBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputElasticCloudBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticCloudBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputElasticCloudCompression$inboundSchema: z.ZodType<
  OutputElasticCloudCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticCloudCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticCloudCompression$outboundSchema: z.ZodType<
  OutputElasticCloudCompression,
  z.ZodTypeDef,
  OutputElasticCloudCompression
> = z.union([
  z.nativeEnum(OutputElasticCloudCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudCompression$ {
  /** @deprecated use `OutputElasticCloudCompression$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloudCompression$inboundSchema;
  /** @deprecated use `OutputElasticCloudCompression$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloudCompression$outboundSchema;
}

/** @internal */
export const OutputElasticCloudQueueFullBehavior$inboundSchema: z.ZodType<
  OutputElasticCloudQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticCloudQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticCloudQueueFullBehavior$outboundSchema: z.ZodType<
  OutputElasticCloudQueueFullBehavior,
  z.ZodTypeDef,
  OutputElasticCloudQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputElasticCloudQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudQueueFullBehavior$ {
  /** @deprecated use `OutputElasticCloudQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputElasticCloudQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputElasticCloudQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticCloudQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputElasticCloudMode$inboundSchema: z.ZodType<
  OutputElasticCloudMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticCloudMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticCloudMode$outboundSchema: z.ZodType<
  OutputElasticCloudMode,
  z.ZodTypeDef,
  OutputElasticCloudMode
> = z.union([
  z.nativeEnum(OutputElasticCloudMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudMode$ {
  /** @deprecated use `OutputElasticCloudMode$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloudMode$inboundSchema;
  /** @deprecated use `OutputElasticCloudMode$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloudMode$outboundSchema;
}

/** @internal */
export const OutputElasticCloudPqControls$inboundSchema: z.ZodType<
  OutputElasticCloudPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputElasticCloudPqControls$Outbound = {};

/** @internal */
export const OutputElasticCloudPqControls$outboundSchema: z.ZodType<
  OutputElasticCloudPqControls$Outbound,
  z.ZodTypeDef,
  OutputElasticCloudPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloudPqControls$ {
  /** @deprecated use `OutputElasticCloudPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloudPqControls$inboundSchema;
  /** @deprecated use `OutputElasticCloudPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloudPqControls$outboundSchema;
  /** @deprecated use `OutputElasticCloudPqControls$Outbound` instead. */
  export type Outbound = OutputElasticCloudPqControls$Outbound;
}

export function outputElasticCloudPqControlsToJSON(
  outputElasticCloudPqControls: OutputElasticCloudPqControls,
): string {
  return JSON.stringify(
    OutputElasticCloudPqControls$outboundSchema.parse(
      outputElasticCloudPqControls,
    ),
  );
}

export function outputElasticCloudPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloudPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticCloudPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloudPqControls' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloud$inboundSchema: z.ZodType<
  OutputElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputElasticCloudType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  index: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputElasticCloudExtraHttpHeader$inboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    OutputElasticCloudFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  extraParams: z.array(z.lazy(() => OutputElasticCloudExtraParam$inboundSchema))
    .optional(),
  auth: z.lazy(() => OutputElasticCloudAuth$inboundSchema).optional(),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(true),
  responseRetrySettings: z.array(
    z.lazy(() => OutputElasticCloudResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputElasticCloudTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputElasticCloudBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputElasticCloudCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputElasticCloudQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputElasticCloudMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputElasticCloudPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputElasticCloud$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  index: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputElasticCloudExtraHttpHeader$Outbound>
    | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  extraParams?: Array<OutputElasticCloudExtraParam$Outbound> | undefined;
  auth?: OutputElasticCloudAuth$Outbound | undefined;
  elasticPipeline?: string | undefined;
  includeDocId: boolean;
  responseRetrySettings?:
    | Array<OutputElasticCloudResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputElasticCloudTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputElasticCloudPqControls$Outbound | undefined;
};

/** @internal */
export const OutputElasticCloud$outboundSchema: z.ZodType<
  OutputElasticCloud$Outbound,
  z.ZodTypeDef,
  OutputElasticCloud
> = z.object({
  id: z.string(),
  type: OutputElasticCloudType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  index: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputElasticCloudExtraHttpHeader$outboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    OutputElasticCloudFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  extraParams: z.array(
    z.lazy(() => OutputElasticCloudExtraParam$outboundSchema),
  ).optional(),
  auth: z.lazy(() => OutputElasticCloudAuth$outboundSchema).optional(),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(true),
  responseRetrySettings: z.array(
    z.lazy(() => OutputElasticCloudResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputElasticCloudTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputElasticCloudBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputElasticCloudCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputElasticCloudQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputElasticCloudMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputElasticCloudPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloud$ {
  /** @deprecated use `OutputElasticCloud$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloud$inboundSchema;
  /** @deprecated use `OutputElasticCloud$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloud$outboundSchema;
  /** @deprecated use `OutputElasticCloud$Outbound` instead. */
  export type Outbound = OutputElasticCloud$Outbound;
}

export function outputElasticCloudToJSON(
  outputElasticCloud: OutputElasticCloud,
): string {
  return JSON.stringify(
    OutputElasticCloud$outboundSchema.parse(outputElasticCloud),
  );
}

export function outputElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloud' from JSON`,
  );
}

/** @internal */
export const OutputElasticType$inboundSchema: z.ZodType<
  OutputElasticType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticType$outboundSchema: z.ZodType<
  OutputElasticType,
  z.ZodTypeDef,
  OutputElasticType
> = z.union([
  z.nativeEnum(OutputElasticType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticType$ {
  /** @deprecated use `OutputElasticType$inboundSchema` instead. */
  export const inboundSchema = OutputElasticType$inboundSchema;
  /** @deprecated use `OutputElasticType$outboundSchema` instead. */
  export const outboundSchema = OutputElasticType$outboundSchema;
}

/** @internal */
export const OutputElasticExtraHttpHeader$inboundSchema: z.ZodType<
  OutputElasticExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputElasticExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputElasticExtraHttpHeader$outboundSchema: z.ZodType<
  OutputElasticExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputElasticExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticExtraHttpHeader$ {
  /** @deprecated use `OutputElasticExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputElasticExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputElasticExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputElasticExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputElasticExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputElasticExtraHttpHeader$Outbound;
}

export function outputElasticExtraHttpHeaderToJSON(
  outputElasticExtraHttpHeader: OutputElasticExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputElasticExtraHttpHeader$outboundSchema.parse(
      outputElasticExtraHttpHeader,
    ),
  );
}

export function outputElasticExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputElasticFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputElasticFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputElasticFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputElasticFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputElasticFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticFailedRequestLoggingMode$ {
  /** @deprecated use `OutputElasticFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputElasticFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputElasticFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputElasticResponseRetrySetting$inboundSchema: z.ZodType<
  OutputElasticResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputElasticResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputElasticResponseRetrySetting$outboundSchema: z.ZodType<
  OutputElasticResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputElasticResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticResponseRetrySetting$ {
  /** @deprecated use `OutputElasticResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema = OutputElasticResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputElasticResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputElasticResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputElasticResponseRetrySetting$Outbound;
}

export function outputElasticResponseRetrySettingToJSON(
  outputElasticResponseRetrySetting: OutputElasticResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputElasticResponseRetrySetting$outboundSchema.parse(
      outputElasticResponseRetrySetting,
    ),
  );
}

export function outputElasticResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputElasticTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputElasticTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputElasticTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputElasticTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputElasticTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputElasticTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticTimeoutRetrySettings$ {
  /** @deprecated use `OutputElasticTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema = OutputElasticTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputElasticTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputElasticTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputElasticTimeoutRetrySettings$Outbound;
}

export function outputElasticTimeoutRetrySettingsToJSON(
  outputElasticTimeoutRetrySettings: OutputElasticTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputElasticTimeoutRetrySettings$outboundSchema.parse(
      outputElasticTimeoutRetrySettings,
    ),
  );
}

export function outputElasticTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputElasticExtraParam$inboundSchema: z.ZodType<
  OutputElasticExtraParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OutputElasticExtraParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OutputElasticExtraParam$outboundSchema: z.ZodType<
  OutputElasticExtraParam$Outbound,
  z.ZodTypeDef,
  OutputElasticExtraParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticExtraParam$ {
  /** @deprecated use `OutputElasticExtraParam$inboundSchema` instead. */
  export const inboundSchema = OutputElasticExtraParam$inboundSchema;
  /** @deprecated use `OutputElasticExtraParam$outboundSchema` instead. */
  export const outboundSchema = OutputElasticExtraParam$outboundSchema;
  /** @deprecated use `OutputElasticExtraParam$Outbound` instead. */
  export type Outbound = OutputElasticExtraParam$Outbound;
}

export function outputElasticExtraParamToJSON(
  outputElasticExtraParam: OutputElasticExtraParam,
): string {
  return JSON.stringify(
    OutputElasticExtraParam$outboundSchema.parse(outputElasticExtraParam),
  );
}

export function outputElasticExtraParamFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticExtraParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticExtraParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticExtraParam' from JSON`,
  );
}

/** @internal */
export const OutputElasticAuthenticationMethod$inboundSchema: z.ZodType<
  OutputElasticAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticAuthenticationMethod$outboundSchema: z.ZodType<
  OutputElasticAuthenticationMethod,
  z.ZodTypeDef,
  OutputElasticAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputElasticAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticAuthenticationMethod$ {
  /** @deprecated use `OutputElasticAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputElasticAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputElasticAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputElasticAuth$inboundSchema: z.ZodType<
  OutputElasticAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  authType: OutputElasticAuthenticationMethod$inboundSchema.default("manual"),
});

/** @internal */
export type OutputElasticAuth$Outbound = {
  disabled: boolean;
  authType: string;
};

/** @internal */
export const OutputElasticAuth$outboundSchema: z.ZodType<
  OutputElasticAuth$Outbound,
  z.ZodTypeDef,
  OutputElasticAuth
> = z.object({
  disabled: z.boolean().default(true),
  authType: OutputElasticAuthenticationMethod$outboundSchema.default("manual"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticAuth$ {
  /** @deprecated use `OutputElasticAuth$inboundSchema` instead. */
  export const inboundSchema = OutputElasticAuth$inboundSchema;
  /** @deprecated use `OutputElasticAuth$outboundSchema` instead. */
  export const outboundSchema = OutputElasticAuth$outboundSchema;
  /** @deprecated use `OutputElasticAuth$Outbound` instead. */
  export type Outbound = OutputElasticAuth$Outbound;
}

export function outputElasticAuthToJSON(
  outputElasticAuth: OutputElasticAuth,
): string {
  return JSON.stringify(
    OutputElasticAuth$outboundSchema.parse(outputElasticAuth),
  );
}

export function outputElasticAuthFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticAuth' from JSON`,
  );
}

/** @internal */
export const ElasticVersion$inboundSchema: z.ZodType<
  ElasticVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ElasticVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ElasticVersion$outboundSchema: z.ZodType<
  ElasticVersion,
  z.ZodTypeDef,
  ElasticVersion
> = z.union([
  z.nativeEnum(ElasticVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ElasticVersion$ {
  /** @deprecated use `ElasticVersion$inboundSchema` instead. */
  export const inboundSchema = ElasticVersion$inboundSchema;
  /** @deprecated use `ElasticVersion$outboundSchema` instead. */
  export const outboundSchema = ElasticVersion$outboundSchema;
}

/** @internal */
export const WriteAction$inboundSchema: z.ZodType<
  WriteAction,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(WriteAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const WriteAction$outboundSchema: z.ZodType<
  WriteAction,
  z.ZodTypeDef,
  WriteAction
> = z.union([
  z.nativeEnum(WriteAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WriteAction$ {
  /** @deprecated use `WriteAction$inboundSchema` instead. */
  export const inboundSchema = WriteAction$inboundSchema;
  /** @deprecated use `WriteAction$outboundSchema` instead. */
  export const outboundSchema = WriteAction$outboundSchema;
}

/** @internal */
export const OutputElasticBackpressureBehavior$inboundSchema: z.ZodType<
  OutputElasticBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticBackpressureBehavior$outboundSchema: z.ZodType<
  OutputElasticBackpressureBehavior,
  z.ZodTypeDef,
  OutputElasticBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputElasticBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticBackpressureBehavior$ {
  /** @deprecated use `OutputElasticBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputElasticBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputElasticBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputElasticBackpressureBehavior$outboundSchema;
}

/** @internal */
export const Url$inboundSchema: z.ZodType<Url, z.ZodTypeDef, unknown> = z
  .object({
    url: z.string(),
    weight: z.number().default(1),
  });

/** @internal */
export type Url$Outbound = {
  url: string;
  weight: number;
};

/** @internal */
export const Url$outboundSchema: z.ZodType<Url$Outbound, z.ZodTypeDef, Url> = z
  .object({
    url: z.string(),
    weight: z.number().default(1),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Url$ {
  /** @deprecated use `Url$inboundSchema` instead. */
  export const inboundSchema = Url$inboundSchema;
  /** @deprecated use `Url$outboundSchema` instead. */
  export const outboundSchema = Url$outboundSchema;
  /** @deprecated use `Url$Outbound` instead. */
  export type Outbound = Url$Outbound;
}

export function urlToJSON(url: Url): string {
  return JSON.stringify(Url$outboundSchema.parse(url));
}

export function urlFromJSON(
  jsonString: string,
): SafeParseResult<Url, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Url$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Url' from JSON`,
  );
}

/** @internal */
export const OutputElasticCompression$inboundSchema: z.ZodType<
  OutputElasticCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticCompression$outboundSchema: z.ZodType<
  OutputElasticCompression,
  z.ZodTypeDef,
  OutputElasticCompression
> = z.union([
  z.nativeEnum(OutputElasticCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCompression$ {
  /** @deprecated use `OutputElasticCompression$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCompression$inboundSchema;
  /** @deprecated use `OutputElasticCompression$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCompression$outboundSchema;
}

/** @internal */
export const OutputElasticQueueFullBehavior$inboundSchema: z.ZodType<
  OutputElasticQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticQueueFullBehavior$outboundSchema: z.ZodType<
  OutputElasticQueueFullBehavior,
  z.ZodTypeDef,
  OutputElasticQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputElasticQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticQueueFullBehavior$ {
  /** @deprecated use `OutputElasticQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputElasticQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputElasticQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputElasticQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputElasticMode$inboundSchema: z.ZodType<
  OutputElasticMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputElasticMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputElasticMode$outboundSchema: z.ZodType<
  OutputElasticMode,
  z.ZodTypeDef,
  OutputElasticMode
> = z.union([
  z.nativeEnum(OutputElasticMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticMode$ {
  /** @deprecated use `OutputElasticMode$inboundSchema` instead. */
  export const inboundSchema = OutputElasticMode$inboundSchema;
  /** @deprecated use `OutputElasticMode$outboundSchema` instead. */
  export const outboundSchema = OutputElasticMode$outboundSchema;
}

/** @internal */
export const OutputElasticPqControls$inboundSchema: z.ZodType<
  OutputElasticPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputElasticPqControls$Outbound = {};

/** @internal */
export const OutputElasticPqControls$outboundSchema: z.ZodType<
  OutputElasticPqControls$Outbound,
  z.ZodTypeDef,
  OutputElasticPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticPqControls$ {
  /** @deprecated use `OutputElasticPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputElasticPqControls$inboundSchema;
  /** @deprecated use `OutputElasticPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputElasticPqControls$outboundSchema;
  /** @deprecated use `OutputElasticPqControls$Outbound` instead. */
  export type Outbound = OutputElasticPqControls$Outbound;
}

export function outputElasticPqControlsToJSON(
  outputElasticPqControls: OutputElasticPqControls,
): string {
  return JSON.stringify(
    OutputElasticPqControls$outboundSchema.parse(outputElasticPqControls),
  );
}

export function outputElasticPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticPqControls' from JSON`,
  );
}

/** @internal */
export const OutputElastic$inboundSchema: z.ZodType<
  OutputElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputElasticType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().default(true),
  index: z.string(),
  docType: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputElasticExtraHttpHeader$inboundSchema),
  ).optional(),
  failedRequestLoggingMode: OutputElasticFailedRequestLoggingMode$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputElasticResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputElasticTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  extraParams: z.array(z.lazy(() => OutputElasticExtraParam$inboundSchema))
    .optional(),
  auth: z.lazy(() => OutputElasticAuth$inboundSchema).optional(),
  elasticVersion: ElasticVersion$inboundSchema.default("auto"),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(false),
  writeAction: WriteAction$inboundSchema.default("create"),
  retryPartialErrors: z.boolean().default(false),
  onBackpressure: OutputElasticBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  url: z.string().optional(),
  useRoundRobinDns: z.boolean().default(false),
  excludeSelf: z.boolean().default(false),
  urls: z.array(z.lazy(() => Url$inboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputElasticCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputElasticQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputElasticMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputElasticPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputElastic$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  loadBalanced: boolean;
  index: string;
  docType?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputElasticExtraHttpHeader$Outbound> | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputElasticResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?: OutputElasticTimeoutRetrySettings$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  extraParams?: Array<OutputElasticExtraParam$Outbound> | undefined;
  auth?: OutputElasticAuth$Outbound | undefined;
  elasticVersion: string;
  elasticPipeline?: string | undefined;
  includeDocId: boolean;
  writeAction: string;
  retryPartialErrors: boolean;
  onBackpressure: string;
  description?: string | undefined;
  url?: string | undefined;
  useRoundRobinDns: boolean;
  excludeSelf: boolean;
  urls?: Array<Url$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputElasticPqControls$Outbound | undefined;
};

/** @internal */
export const OutputElastic$outboundSchema: z.ZodType<
  OutputElastic$Outbound,
  z.ZodTypeDef,
  OutputElastic
> = z.object({
  id: z.string(),
  type: OutputElasticType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().default(true),
  index: z.string(),
  docType: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputElasticExtraHttpHeader$outboundSchema),
  ).optional(),
  failedRequestLoggingMode: OutputElasticFailedRequestLoggingMode$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputElasticResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputElasticTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  extraParams: z.array(z.lazy(() => OutputElasticExtraParam$outboundSchema))
    .optional(),
  auth: z.lazy(() => OutputElasticAuth$outboundSchema).optional(),
  elasticVersion: ElasticVersion$outboundSchema.default("auto"),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(false),
  writeAction: WriteAction$outboundSchema.default("create"),
  retryPartialErrors: z.boolean().default(false),
  onBackpressure: OutputElasticBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  url: z.string().optional(),
  useRoundRobinDns: z.boolean().default(false),
  excludeSelf: z.boolean().default(false),
  urls: z.array(z.lazy(() => Url$outboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputElasticCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputElasticQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputElasticMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputElasticPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElastic$ {
  /** @deprecated use `OutputElastic$inboundSchema` instead. */
  export const inboundSchema = OutputElastic$inboundSchema;
  /** @deprecated use `OutputElastic$outboundSchema` instead. */
  export const outboundSchema = OutputElastic$outboundSchema;
  /** @deprecated use `OutputElastic$Outbound` instead. */
  export type Outbound = OutputElastic$Outbound;
}

export function outputElasticToJSON(outputElastic: OutputElastic): string {
  return JSON.stringify(OutputElastic$outboundSchema.parse(outputElastic));
}

export function outputElasticFromJSON(
  jsonString: string,
): SafeParseResult<OutputElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElastic' from JSON`,
  );
}

/** @internal */
export const OutputMskType$inboundSchema: z.ZodType<
  OutputMskType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskType$outboundSchema: z.ZodType<
  OutputMskType,
  z.ZodTypeDef,
  OutputMskType
> = z.union([
  z.nativeEnum(OutputMskType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskType$ {
  /** @deprecated use `OutputMskType$inboundSchema` instead. */
  export const inboundSchema = OutputMskType$inboundSchema;
  /** @deprecated use `OutputMskType$outboundSchema` instead. */
  export const outboundSchema = OutputMskType$outboundSchema;
}

/** @internal */
export const OutputMskAcknowledgments$inboundSchema: z.ZodType<
  OutputMskAcknowledgments,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskAcknowledgments),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskAcknowledgments$outboundSchema: z.ZodType<
  OutputMskAcknowledgments,
  z.ZodTypeDef,
  OutputMskAcknowledgments
> = z.union([
  z.nativeEnum(OutputMskAcknowledgments),
  z.number().and(z.custom<Unrecognized<number>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskAcknowledgments$ {
  /** @deprecated use `OutputMskAcknowledgments$inboundSchema` instead. */
  export const inboundSchema = OutputMskAcknowledgments$inboundSchema;
  /** @deprecated use `OutputMskAcknowledgments$outboundSchema` instead. */
  export const outboundSchema = OutputMskAcknowledgments$outboundSchema;
}

/** @internal */
export const OutputMskRecordDataFormat$inboundSchema: z.ZodType<
  OutputMskRecordDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskRecordDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskRecordDataFormat$outboundSchema: z.ZodType<
  OutputMskRecordDataFormat,
  z.ZodTypeDef,
  OutputMskRecordDataFormat
> = z.union([
  z.nativeEnum(OutputMskRecordDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskRecordDataFormat$ {
  /** @deprecated use `OutputMskRecordDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputMskRecordDataFormat$inboundSchema;
  /** @deprecated use `OutputMskRecordDataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputMskRecordDataFormat$outboundSchema;
}

/** @internal */
export const OutputMskCompression$inboundSchema: z.ZodType<
  OutputMskCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskCompression$outboundSchema: z.ZodType<
  OutputMskCompression,
  z.ZodTypeDef,
  OutputMskCompression
> = z.union([
  z.nativeEnum(OutputMskCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskCompression$ {
  /** @deprecated use `OutputMskCompression$inboundSchema` instead. */
  export const inboundSchema = OutputMskCompression$inboundSchema;
  /** @deprecated use `OutputMskCompression$outboundSchema` instead. */
  export const outboundSchema = OutputMskCompression$outboundSchema;
}

/** @internal */
export const OutputMskAuth$inboundSchema: z.ZodType<
  OutputMskAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type OutputMskAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const OutputMskAuth$outboundSchema: z.ZodType<
  OutputMskAuth$Outbound,
  z.ZodTypeDef,
  OutputMskAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskAuth$ {
  /** @deprecated use `OutputMskAuth$inboundSchema` instead. */
  export const inboundSchema = OutputMskAuth$inboundSchema;
  /** @deprecated use `OutputMskAuth$outboundSchema` instead. */
  export const outboundSchema = OutputMskAuth$outboundSchema;
  /** @deprecated use `OutputMskAuth$Outbound` instead. */
  export type Outbound = OutputMskAuth$Outbound;
}

export function outputMskAuthToJSON(outputMskAuth: OutputMskAuth): string {
  return JSON.stringify(OutputMskAuth$outboundSchema.parse(outputMskAuth));
}

export function outputMskAuthFromJSON(
  jsonString: string,
): SafeParseResult<OutputMskAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMskAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMskAuth' from JSON`,
  );
}

/** @internal */
export const OutputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema:
  z.ZodType<
    OutputMskKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputMskKafkaSchemaRegistryMinimumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema:
  z.ZodType<
    OutputMskKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    OutputMskKafkaSchemaRegistryMinimumTLSVersion
  > = z.union([
    z.nativeEnum(OutputMskKafkaSchemaRegistryMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskKafkaSchemaRegistryMinimumTLSVersion$ {
  /** @deprecated use `OutputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema:
  z.ZodType<
    OutputMskKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputMskKafkaSchemaRegistryMaximumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema:
  z.ZodType<
    OutputMskKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    OutputMskKafkaSchemaRegistryMaximumTLSVersion
  > = z.union([
    z.nativeEnum(OutputMskKafkaSchemaRegistryMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskKafkaSchemaRegistryMaximumTLSVersion$ {
  /** @deprecated use `OutputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: OutputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema
      .optional(),
    maxVersion: OutputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema
      .optional(),
  });

/** @internal */
export type OutputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: OutputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema
      .optional(),
    maxVersion: OutputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskKafkaSchemaRegistryTLSSettingsClientSide$ {
  /** @deprecated use `OutputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound` instead. */
  export type Outbound =
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound;
}

export function outputMskKafkaSchemaRegistryTLSSettingsClientSideToJSON(
  outputMskKafkaSchemaRegistryTLSSettingsClientSide:
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema.parse(
      outputMskKafkaSchemaRegistryTLSSettingsClientSide,
    ),
  );
}

export function outputMskKafkaSchemaRegistryTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputMskKafkaSchemaRegistryTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputMskKafkaSchemaRegistryTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputMskKafkaSchemaRegistryAuthentication$inboundSchema:
  z.ZodType<OutputMskKafkaSchemaRegistryAuthentication, z.ZodTypeDef, unknown> =
    z.object({
      disabled: z.boolean().default(true),
      schemaRegistryURL: z.string().default("http://localhost:8081"),
      connectionTimeout: z.number().default(30000),
      requestTimeout: z.number().default(30000),
      maxRetries: z.number().default(1),
      auth: z.lazy(() => OutputMskAuth$inboundSchema).optional(),
      tls: z.lazy(() =>
        OutputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
      ).optional(),
      defaultKeySchemaId: z.number().optional(),
      defaultValueSchemaId: z.number().optional(),
    });

/** @internal */
export type OutputMskKafkaSchemaRegistryAuthentication$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: OutputMskAuth$Outbound | undefined;
  tls?: OutputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound | undefined;
  defaultKeySchemaId?: number | undefined;
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const OutputMskKafkaSchemaRegistryAuthentication$outboundSchema:
  z.ZodType<
    OutputMskKafkaSchemaRegistryAuthentication$Outbound,
    z.ZodTypeDef,
    OutputMskKafkaSchemaRegistryAuthentication
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => OutputMskAuth$outboundSchema).optional(),
    tls: z.lazy(() =>
      OutputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskKafkaSchemaRegistryAuthentication$ {
  /** @deprecated use `OutputMskKafkaSchemaRegistryAuthentication$inboundSchema` instead. */
  export const inboundSchema =
    OutputMskKafkaSchemaRegistryAuthentication$inboundSchema;
  /** @deprecated use `OutputMskKafkaSchemaRegistryAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    OutputMskKafkaSchemaRegistryAuthentication$outboundSchema;
  /** @deprecated use `OutputMskKafkaSchemaRegistryAuthentication$Outbound` instead. */
  export type Outbound = OutputMskKafkaSchemaRegistryAuthentication$Outbound;
}

export function outputMskKafkaSchemaRegistryAuthenticationToJSON(
  outputMskKafkaSchemaRegistryAuthentication:
    OutputMskKafkaSchemaRegistryAuthentication,
): string {
  return JSON.stringify(
    OutputMskKafkaSchemaRegistryAuthentication$outboundSchema.parse(
      outputMskKafkaSchemaRegistryAuthentication,
    ),
  );
}

export function outputMskKafkaSchemaRegistryAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputMskKafkaSchemaRegistryAuthentication,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputMskKafkaSchemaRegistryAuthentication$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputMskKafkaSchemaRegistryAuthentication' from JSON`,
  );
}

/** @internal */
export const OutputMskAuthenticationMethod$inboundSchema: z.ZodType<
  OutputMskAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskAuthenticationMethod$outboundSchema: z.ZodType<
  OutputMskAuthenticationMethod,
  z.ZodTypeDef,
  OutputMskAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputMskAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskAuthenticationMethod$ {
  /** @deprecated use `OutputMskAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputMskAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputMskAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputMskAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputMskSignatureVersion$inboundSchema: z.ZodType<
  OutputMskSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskSignatureVersion$outboundSchema: z.ZodType<
  OutputMskSignatureVersion,
  z.ZodTypeDef,
  OutputMskSignatureVersion
> = z.union([
  z.nativeEnum(OutputMskSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskSignatureVersion$ {
  /** @deprecated use `OutputMskSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMskSignatureVersion$inboundSchema;
  /** @deprecated use `OutputMskSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMskSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputMskMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputMskMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputMskMinimumTLSVersion,
  z.ZodTypeDef,
  OutputMskMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputMskMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskMinimumTLSVersion$ {
  /** @deprecated use `OutputMskMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMskMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputMskMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMskMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputMskMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputMskMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputMskMaximumTLSVersion,
  z.ZodTypeDef,
  OutputMskMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputMskMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskMaximumTLSVersion$ {
  /** @deprecated use `OutputMskMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMskMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputMskMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMskMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputMskTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputMskTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputMskMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputMskMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputMskTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputMskTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputMskTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputMskTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputMskMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: OutputMskMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskTLSSettingsClientSide$ {
  /** @deprecated use `OutputMskTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema = OutputMskTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputMskTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema = OutputMskTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputMskTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputMskTLSSettingsClientSide$Outbound;
}

export function outputMskTLSSettingsClientSideToJSON(
  outputMskTLSSettingsClientSide: OutputMskTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputMskTLSSettingsClientSide$outboundSchema.parse(
      outputMskTLSSettingsClientSide,
    ),
  );
}

export function outputMskTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<OutputMskTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMskTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMskTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputMskBackpressureBehavior$inboundSchema: z.ZodType<
  OutputMskBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskBackpressureBehavior$outboundSchema: z.ZodType<
  OutputMskBackpressureBehavior,
  z.ZodTypeDef,
  OutputMskBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputMskBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskBackpressureBehavior$ {
  /** @deprecated use `OutputMskBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputMskBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputMskBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputMskBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputMskPqCompressCompression$inboundSchema: z.ZodType<
  OutputMskPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskPqCompressCompression$outboundSchema: z.ZodType<
  OutputMskPqCompressCompression,
  z.ZodTypeDef,
  OutputMskPqCompressCompression
> = z.union([
  z.nativeEnum(OutputMskPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskPqCompressCompression$ {
  /** @deprecated use `OutputMskPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema = OutputMskPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputMskPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema = OutputMskPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputMskQueueFullBehavior$inboundSchema: z.ZodType<
  OutputMskQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskQueueFullBehavior$outboundSchema: z.ZodType<
  OutputMskQueueFullBehavior,
  z.ZodTypeDef,
  OutputMskQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputMskQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskQueueFullBehavior$ {
  /** @deprecated use `OutputMskQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputMskQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputMskQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputMskQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputMskMode$inboundSchema: z.ZodType<
  OutputMskMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMskMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMskMode$outboundSchema: z.ZodType<
  OutputMskMode,
  z.ZodTypeDef,
  OutputMskMode
> = z.union([
  z.nativeEnum(OutputMskMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskMode$ {
  /** @deprecated use `OutputMskMode$inboundSchema` instead. */
  export const inboundSchema = OutputMskMode$inboundSchema;
  /** @deprecated use `OutputMskMode$outboundSchema` instead. */
  export const outboundSchema = OutputMskMode$outboundSchema;
}

/** @internal */
export const OutputMskPqControls$inboundSchema: z.ZodType<
  OutputMskPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputMskPqControls$Outbound = {};

/** @internal */
export const OutputMskPqControls$outboundSchema: z.ZodType<
  OutputMskPqControls$Outbound,
  z.ZodTypeDef,
  OutputMskPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMskPqControls$ {
  /** @deprecated use `OutputMskPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputMskPqControls$inboundSchema;
  /** @deprecated use `OutputMskPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputMskPqControls$outboundSchema;
  /** @deprecated use `OutputMskPqControls$Outbound` instead. */
  export type Outbound = OutputMskPqControls$Outbound;
}

export function outputMskPqControlsToJSON(
  outputMskPqControls: OutputMskPqControls,
): string {
  return JSON.stringify(
    OutputMskPqControls$outboundSchema.parse(outputMskPqControls),
  );
}

export function outputMskPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputMskPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMskPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMskPqControls' from JSON`,
  );
}

/** @internal */
export const OutputMsk$inboundSchema: z.ZodType<
  OutputMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputMskType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: OutputMskAcknowledgments$inboundSchema.default(1),
  format: OutputMskRecordDataFormat$inboundSchema.default("json"),
  compression: OutputMskCompression$inboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    OutputMskKafkaSchemaRegistryAuthentication$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: OutputMskAuthenticationMethod$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: OutputMskSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => OutputMskTLSSettingsClientSide$inboundSchema).optional(),
  onBackpressure: OutputMskBackpressureBehavior$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputMskPqCompressCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputMskQueueFullBehavior$inboundSchema.default("block"),
  pqMode: OutputMskMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputMskPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputMsk$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  topic: string;
  ack: number;
  format: string;
  compression: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  kafkaSchemaRegistry?:
    | OutputMskKafkaSchemaRegistryAuthentication$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  tls?: OutputMskTLSSettingsClientSide$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  protobufLibraryId?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputMskPqControls$Outbound | undefined;
};

/** @internal */
export const OutputMsk$outboundSchema: z.ZodType<
  OutputMsk$Outbound,
  z.ZodTypeDef,
  OutputMsk
> = z.object({
  id: z.string(),
  type: OutputMskType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: OutputMskAcknowledgments$outboundSchema.default(1),
  format: OutputMskRecordDataFormat$outboundSchema.default("json"),
  compression: OutputMskCompression$outboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    OutputMskKafkaSchemaRegistryAuthentication$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: OutputMskAuthenticationMethod$outboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: OutputMskSignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => OutputMskTLSSettingsClientSide$outboundSchema).optional(),
  onBackpressure: OutputMskBackpressureBehavior$outboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputMskPqCompressCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputMskQueueFullBehavior$outboundSchema.default("block"),
  pqMode: OutputMskMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputMskPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMsk$ {
  /** @deprecated use `OutputMsk$inboundSchema` instead. */
  export const inboundSchema = OutputMsk$inboundSchema;
  /** @deprecated use `OutputMsk$outboundSchema` instead. */
  export const outboundSchema = OutputMsk$outboundSchema;
  /** @deprecated use `OutputMsk$Outbound` instead. */
  export type Outbound = OutputMsk$Outbound;
}

export function outputMskToJSON(outputMsk: OutputMsk): string {
  return JSON.stringify(OutputMsk$outboundSchema.parse(outputMsk));
}

export function outputMskFromJSON(
  jsonString: string,
): SafeParseResult<OutputMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMsk' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloudType$inboundSchema: z.ZodType<
  OutputConfluentCloudType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudType$outboundSchema: z.ZodType<
  OutputConfluentCloudType,
  z.ZodTypeDef,
  OutputConfluentCloudType
> = z.union([
  z.nativeEnum(OutputConfluentCloudType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudType$ {
  /** @deprecated use `OutputConfluentCloudType$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloudType$inboundSchema;
  /** @deprecated use `OutputConfluentCloudType$outboundSchema` instead. */
  export const outboundSchema = OutputConfluentCloudType$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputConfluentCloudMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputConfluentCloudMinimumTLSVersion,
  z.ZodTypeDef,
  OutputConfluentCloudMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputConfluentCloudMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudMinimumTLSVersion$ {
  /** @deprecated use `OutputConfluentCloudMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputConfluentCloudMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputConfluentCloudMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputConfluentCloudMaximumTLSVersion,
  z.ZodTypeDef,
  OutputConfluentCloudMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputConfluentCloudMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudMaximumTLSVersion$ {
  /** @deprecated use `OutputConfluentCloudMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputConfluentCloudMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputConfluentCloudTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputConfluentCloudMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputConfluentCloudMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputConfluentCloudTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputConfluentCloudTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    OutputConfluentCloudTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    OutputConfluentCloudTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(false),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: OutputConfluentCloudMinimumTLSVersion$outboundSchema.optional(),
    maxVersion: OutputConfluentCloudMaximumTLSVersion$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudTLSSettingsClientSide$ {
  /** @deprecated use `OutputConfluentCloudTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputConfluentCloudTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputConfluentCloudTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputConfluentCloudTLSSettingsClientSide$Outbound;
}

export function outputConfluentCloudTLSSettingsClientSideToJSON(
  outputConfluentCloudTLSSettingsClientSide:
    OutputConfluentCloudTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputConfluentCloudTLSSettingsClientSide$outboundSchema.parse(
      outputConfluentCloudTLSSettingsClientSide,
    ),
  );
}

export function outputConfluentCloudTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputConfluentCloudTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputConfluentCloudTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputConfluentCloudTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloudAcknowledgments$inboundSchema: z.ZodType<
  OutputConfluentCloudAcknowledgments,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudAcknowledgments),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudAcknowledgments$outboundSchema: z.ZodType<
  OutputConfluentCloudAcknowledgments,
  z.ZodTypeDef,
  OutputConfluentCloudAcknowledgments
> = z.union([
  z.nativeEnum(OutputConfluentCloudAcknowledgments),
  z.number().and(z.custom<Unrecognized<number>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudAcknowledgments$ {
  /** @deprecated use `OutputConfluentCloudAcknowledgments$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudAcknowledgments$inboundSchema;
  /** @deprecated use `OutputConfluentCloudAcknowledgments$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudAcknowledgments$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudRecordDataFormat$inboundSchema: z.ZodType<
  OutputConfluentCloudRecordDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudRecordDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudRecordDataFormat$outboundSchema: z.ZodType<
  OutputConfluentCloudRecordDataFormat,
  z.ZodTypeDef,
  OutputConfluentCloudRecordDataFormat
> = z.union([
  z.nativeEnum(OutputConfluentCloudRecordDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudRecordDataFormat$ {
  /** @deprecated use `OutputConfluentCloudRecordDataFormat$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudRecordDataFormat$inboundSchema;
  /** @deprecated use `OutputConfluentCloudRecordDataFormat$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudRecordDataFormat$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudCompression$inboundSchema: z.ZodType<
  OutputConfluentCloudCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudCompression$outboundSchema: z.ZodType<
  OutputConfluentCloudCompression,
  z.ZodTypeDef,
  OutputConfluentCloudCompression
> = z.union([
  z.nativeEnum(OutputConfluentCloudCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudCompression$ {
  /** @deprecated use `OutputConfluentCloudCompression$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloudCompression$inboundSchema;
  /** @deprecated use `OutputConfluentCloudCompression$outboundSchema` instead. */
  export const outboundSchema = OutputConfluentCloudCompression$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudAuth$inboundSchema: z.ZodType<
  OutputConfluentCloudAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type OutputConfluentCloudAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const OutputConfluentCloudAuth$outboundSchema: z.ZodType<
  OutputConfluentCloudAuth$Outbound,
  z.ZodTypeDef,
  OutputConfluentCloudAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudAuth$ {
  /** @deprecated use `OutputConfluentCloudAuth$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloudAuth$inboundSchema;
  /** @deprecated use `OutputConfluentCloudAuth$outboundSchema` instead. */
  export const outboundSchema = OutputConfluentCloudAuth$outboundSchema;
  /** @deprecated use `OutputConfluentCloudAuth$Outbound` instead. */
  export type Outbound = OutputConfluentCloudAuth$Outbound;
}

export function outputConfluentCloudAuthToJSON(
  outputConfluentCloudAuth: OutputConfluentCloudAuth,
): string {
  return JSON.stringify(
    OutputConfluentCloudAuth$outboundSchema.parse(outputConfluentCloudAuth),
  );
}

export function outputConfluentCloudAuthFromJSON(
  jsonString: string,
): SafeParseResult<OutputConfluentCloudAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputConfluentCloudAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputConfluentCloudAuth' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion
  > = z.union([
    z.nativeEnum(OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$ {
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion
  > = z.union([
    z.nativeEnum(OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$ {
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema
        .optional(),
    maxVersion:
      OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema
        .optional(),
  });

/** @internal */
export type OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound =
  {
    disabled: boolean;
    rejectUnauthorized: boolean;
    servername?: string | undefined;
    certificateName?: string | undefined;
    caPath?: string | undefined;
    privKeyPath?: string | undefined;
    certPath?: string | undefined;
    passphrase?: string | undefined;
    minVersion?: string | undefined;
    maxVersion?: string | undefined;
  };

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      OutputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema
        .optional(),
    maxVersion:
      OutputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$ {
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound` instead. */
  export type Outbound =
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound;
}

export function outputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSideToJSON(
  outputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide:
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
      .parse(outputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide),
  );
}

export function outputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryAuthentication,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => OutputConfluentCloudAuth$inboundSchema).optional(),
    tls: z.lazy(() =>
      OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/** @internal */
export type OutputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: OutputConfluentCloudAuth$Outbound | undefined;
  tls?:
    | OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound
    | undefined;
  defaultKeySchemaId?: number | undefined;
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const OutputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema:
  z.ZodType<
    OutputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound,
    z.ZodTypeDef,
    OutputConfluentCloudKafkaSchemaRegistryAuthentication
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => OutputConfluentCloudAuth$outboundSchema).optional(),
    tls: z.lazy(() =>
      OutputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudKafkaSchemaRegistryAuthentication$ {
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema;
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema;
  /** @deprecated use `OutputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound` instead. */
  export type Outbound =
    OutputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound;
}

export function outputConfluentCloudKafkaSchemaRegistryAuthenticationToJSON(
  outputConfluentCloudKafkaSchemaRegistryAuthentication:
    OutputConfluentCloudKafkaSchemaRegistryAuthentication,
): string {
  return JSON.stringify(
    OutputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema.parse(
      outputConfluentCloudKafkaSchemaRegistryAuthentication,
    ),
  );
}

export function outputConfluentCloudKafkaSchemaRegistryAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputConfluentCloudKafkaSchemaRegistryAuthentication,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputConfluentCloudKafkaSchemaRegistryAuthentication' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloudSASLMechanism$inboundSchema: z.ZodType<
  OutputConfluentCloudSASLMechanism,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudSASLMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudSASLMechanism$outboundSchema: z.ZodType<
  OutputConfluentCloudSASLMechanism,
  z.ZodTypeDef,
  OutputConfluentCloudSASLMechanism
> = z.union([
  z.nativeEnum(OutputConfluentCloudSASLMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudSASLMechanism$ {
  /** @deprecated use `OutputConfluentCloudSASLMechanism$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloudSASLMechanism$inboundSchema;
  /** @deprecated use `OutputConfluentCloudSASLMechanism$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudSASLMechanism$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudAuthentication$inboundSchema: z.ZodType<
  OutputConfluentCloudAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: OutputConfluentCloudSASLMechanism$inboundSchema.default("plain"),
});

/** @internal */
export type OutputConfluentCloudAuthentication$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const OutputConfluentCloudAuthentication$outboundSchema: z.ZodType<
  OutputConfluentCloudAuthentication$Outbound,
  z.ZodTypeDef,
  OutputConfluentCloudAuthentication
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: OutputConfluentCloudSASLMechanism$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudAuthentication$ {
  /** @deprecated use `OutputConfluentCloudAuthentication$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloudAuthentication$inboundSchema;
  /** @deprecated use `OutputConfluentCloudAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudAuthentication$outboundSchema;
  /** @deprecated use `OutputConfluentCloudAuthentication$Outbound` instead. */
  export type Outbound = OutputConfluentCloudAuthentication$Outbound;
}

export function outputConfluentCloudAuthenticationToJSON(
  outputConfluentCloudAuthentication: OutputConfluentCloudAuthentication,
): string {
  return JSON.stringify(
    OutputConfluentCloudAuthentication$outboundSchema.parse(
      outputConfluentCloudAuthentication,
    ),
  );
}

export function outputConfluentCloudAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<OutputConfluentCloudAuthentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputConfluentCloudAuthentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputConfluentCloudAuthentication' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloudBackpressureBehavior$inboundSchema: z.ZodType<
  OutputConfluentCloudBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudBackpressureBehavior$outboundSchema: z.ZodType<
  OutputConfluentCloudBackpressureBehavior,
  z.ZodTypeDef,
  OutputConfluentCloudBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputConfluentCloudBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudBackpressureBehavior$ {
  /** @deprecated use `OutputConfluentCloudBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputConfluentCloudBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudPqCompressCompression$inboundSchema: z.ZodType<
  OutputConfluentCloudPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudPqCompressCompression$outboundSchema:
  z.ZodType<
    OutputConfluentCloudPqCompressCompression,
    z.ZodTypeDef,
    OutputConfluentCloudPqCompressCompression
  > = z.union([
    z.nativeEnum(OutputConfluentCloudPqCompressCompression),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudPqCompressCompression$ {
  /** @deprecated use `OutputConfluentCloudPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputConfluentCloudPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudQueueFullBehavior$inboundSchema: z.ZodType<
  OutputConfluentCloudQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudQueueFullBehavior$outboundSchema: z.ZodType<
  OutputConfluentCloudQueueFullBehavior,
  z.ZodTypeDef,
  OutputConfluentCloudQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputConfluentCloudQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudQueueFullBehavior$ {
  /** @deprecated use `OutputConfluentCloudQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputConfluentCloudQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputConfluentCloudQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputConfluentCloudQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudMode$inboundSchema: z.ZodType<
  OutputConfluentCloudMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputConfluentCloudMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputConfluentCloudMode$outboundSchema: z.ZodType<
  OutputConfluentCloudMode,
  z.ZodTypeDef,
  OutputConfluentCloudMode
> = z.union([
  z.nativeEnum(OutputConfluentCloudMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudMode$ {
  /** @deprecated use `OutputConfluentCloudMode$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloudMode$inboundSchema;
  /** @deprecated use `OutputConfluentCloudMode$outboundSchema` instead. */
  export const outboundSchema = OutputConfluentCloudMode$outboundSchema;
}

/** @internal */
export const OutputConfluentCloudPqControls$inboundSchema: z.ZodType<
  OutputConfluentCloudPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputConfluentCloudPqControls$Outbound = {};

/** @internal */
export const OutputConfluentCloudPqControls$outboundSchema: z.ZodType<
  OutputConfluentCloudPqControls$Outbound,
  z.ZodTypeDef,
  OutputConfluentCloudPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloudPqControls$ {
  /** @deprecated use `OutputConfluentCloudPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloudPqControls$inboundSchema;
  /** @deprecated use `OutputConfluentCloudPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputConfluentCloudPqControls$outboundSchema;
  /** @deprecated use `OutputConfluentCloudPqControls$Outbound` instead. */
  export type Outbound = OutputConfluentCloudPqControls$Outbound;
}

export function outputConfluentCloudPqControlsToJSON(
  outputConfluentCloudPqControls: OutputConfluentCloudPqControls,
): string {
  return JSON.stringify(
    OutputConfluentCloudPqControls$outboundSchema.parse(
      outputConfluentCloudPqControls,
    ),
  );
}

export function outputConfluentCloudPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputConfluentCloudPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputConfluentCloudPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputConfluentCloudPqControls' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloud$inboundSchema: z.ZodType<
  OutputConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputConfluentCloudType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() => OutputConfluentCloudTLSSettingsClientSide$inboundSchema)
    .optional(),
  topic: z.string(),
  ack: OutputConfluentCloudAcknowledgments$inboundSchema.default(1),
  format: OutputConfluentCloudRecordDataFormat$inboundSchema.default("json"),
  compression: OutputConfluentCloudCompression$inboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    OutputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => OutputConfluentCloudAuthentication$inboundSchema)
    .optional(),
  onBackpressure: OutputConfluentCloudBackpressureBehavior$inboundSchema
    .default("block"),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputConfluentCloudPqCompressCompression$inboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputConfluentCloudQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputConfluentCloudMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputConfluentCloudPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputConfluentCloud$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  tls?: OutputConfluentCloudTLSSettingsClientSide$Outbound | undefined;
  topic: string;
  ack: number;
  format: string;
  compression: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  kafkaSchemaRegistry?:
    | OutputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: OutputConfluentCloudAuthentication$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  protobufLibraryId?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputConfluentCloudPqControls$Outbound | undefined;
};

/** @internal */
export const OutputConfluentCloud$outboundSchema: z.ZodType<
  OutputConfluentCloud$Outbound,
  z.ZodTypeDef,
  OutputConfluentCloud
> = z.object({
  id: z.string(),
  type: OutputConfluentCloudType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() => OutputConfluentCloudTLSSettingsClientSide$outboundSchema)
    .optional(),
  topic: z.string(),
  ack: OutputConfluentCloudAcknowledgments$outboundSchema.default(1),
  format: OutputConfluentCloudRecordDataFormat$outboundSchema.default("json"),
  compression: OutputConfluentCloudCompression$outboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    OutputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => OutputConfluentCloudAuthentication$outboundSchema)
    .optional(),
  onBackpressure: OutputConfluentCloudBackpressureBehavior$outboundSchema
    .default("block"),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputConfluentCloudPqCompressCompression$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputConfluentCloudQueueFullBehavior$outboundSchema
    .default("block"),
  pqMode: OutputConfluentCloudMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputConfluentCloudPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloud$ {
  /** @deprecated use `OutputConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloud$inboundSchema;
  /** @deprecated use `OutputConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = OutputConfluentCloud$outboundSchema;
  /** @deprecated use `OutputConfluentCloud$Outbound` instead. */
  export type Outbound = OutputConfluentCloud$Outbound;
}

export function outputConfluentCloudToJSON(
  outputConfluentCloud: OutputConfluentCloud,
): string {
  return JSON.stringify(
    OutputConfluentCloud$outboundSchema.parse(outputConfluentCloud),
  );
}

export function outputConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<OutputConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputConfluentCloud' from JSON`,
  );
}

/** @internal */
export const OutputKafkaType$inboundSchema: z.ZodType<
  OutputKafkaType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaType$outboundSchema: z.ZodType<
  OutputKafkaType,
  z.ZodTypeDef,
  OutputKafkaType
> = z.union([
  z.nativeEnum(OutputKafkaType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaType$ {
  /** @deprecated use `OutputKafkaType$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaType$inboundSchema;
  /** @deprecated use `OutputKafkaType$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaType$outboundSchema;
}

/** @internal */
export const OutputKafkaAcknowledgments$inboundSchema: z.ZodType<
  OutputKafkaAcknowledgments,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaAcknowledgments),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaAcknowledgments$outboundSchema: z.ZodType<
  OutputKafkaAcknowledgments,
  z.ZodTypeDef,
  OutputKafkaAcknowledgments
> = z.union([
  z.nativeEnum(OutputKafkaAcknowledgments),
  z.number().and(z.custom<Unrecognized<number>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaAcknowledgments$ {
  /** @deprecated use `OutputKafkaAcknowledgments$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaAcknowledgments$inboundSchema;
  /** @deprecated use `OutputKafkaAcknowledgments$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaAcknowledgments$outboundSchema;
}

/** @internal */
export const OutputKafkaRecordDataFormat$inboundSchema: z.ZodType<
  OutputKafkaRecordDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaRecordDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaRecordDataFormat$outboundSchema: z.ZodType<
  OutputKafkaRecordDataFormat,
  z.ZodTypeDef,
  OutputKafkaRecordDataFormat
> = z.union([
  z.nativeEnum(OutputKafkaRecordDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaRecordDataFormat$ {
  /** @deprecated use `OutputKafkaRecordDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaRecordDataFormat$inboundSchema;
  /** @deprecated use `OutputKafkaRecordDataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaRecordDataFormat$outboundSchema;
}

/** @internal */
export const OutputKafkaCompression$inboundSchema: z.ZodType<
  OutputKafkaCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaCompression$outboundSchema: z.ZodType<
  OutputKafkaCompression,
  z.ZodTypeDef,
  OutputKafkaCompression
> = z.union([
  z.nativeEnum(OutputKafkaCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaCompression$ {
  /** @deprecated use `OutputKafkaCompression$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaCompression$inboundSchema;
  /** @deprecated use `OutputKafkaCompression$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaCompression$outboundSchema;
}

/** @internal */
export const OutputKafkaAuth$inboundSchema: z.ZodType<
  OutputKafkaAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type OutputKafkaAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const OutputKafkaAuth$outboundSchema: z.ZodType<
  OutputKafkaAuth$Outbound,
  z.ZodTypeDef,
  OutputKafkaAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaAuth$ {
  /** @deprecated use `OutputKafkaAuth$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaAuth$inboundSchema;
  /** @deprecated use `OutputKafkaAuth$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaAuth$outboundSchema;
  /** @deprecated use `OutputKafkaAuth$Outbound` instead. */
  export type Outbound = OutputKafkaAuth$Outbound;
}

export function outputKafkaAuthToJSON(
  outputKafkaAuth: OutputKafkaAuth,
): string {
  return JSON.stringify(OutputKafkaAuth$outboundSchema.parse(outputKafkaAuth));
}

export function outputKafkaAuthFromJSON(
  jsonString: string,
): SafeParseResult<OutputKafkaAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKafkaAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKafkaAuth' from JSON`,
  );
}

/** @internal */
export const OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputKafkaKafkaSchemaRegistryMinimumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    OutputKafkaKafkaSchemaRegistryMinimumTLSVersion
  > = z.union([
    z.nativeEnum(OutputKafkaKafkaSchemaRegistryMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$ {
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputKafkaKafkaSchemaRegistryMaximumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    OutputKafkaKafkaSchemaRegistryMaximumTLSVersion
  > = z.union([
    z.nativeEnum(OutputKafkaKafkaSchemaRegistryMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$ {
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema
      .optional(),
    maxVersion: OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema
      .optional(),
  });

/** @internal */
export type OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: OutputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema
      .optional(),
    maxVersion: OutputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$ {
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound` instead. */
  export type Outbound =
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound;
}

export function outputKafkaKafkaSchemaRegistryTLSSettingsClientSideToJSON(
  outputKafkaKafkaSchemaRegistryTLSSettingsClientSide:
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema.parse(
      outputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
    ),
  );
}

export function outputKafkaKafkaSchemaRegistryTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputKafkaKafkaSchemaRegistryAuthentication$inboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryAuthentication,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => OutputKafkaAuth$inboundSchema).optional(),
    tls: z.lazy(() =>
      OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/** @internal */
export type OutputKafkaKafkaSchemaRegistryAuthentication$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: OutputKafkaAuth$Outbound | undefined;
  tls?:
    | OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound
    | undefined;
  defaultKeySchemaId?: number | undefined;
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const OutputKafkaKafkaSchemaRegistryAuthentication$outboundSchema:
  z.ZodType<
    OutputKafkaKafkaSchemaRegistryAuthentication$Outbound,
    z.ZodTypeDef,
    OutputKafkaKafkaSchemaRegistryAuthentication
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => OutputKafkaAuth$outboundSchema).optional(),
    tls: z.lazy(() =>
      OutputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaKafkaSchemaRegistryAuthentication$ {
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryAuthentication$inboundSchema` instead. */
  export const inboundSchema =
    OutputKafkaKafkaSchemaRegistryAuthentication$inboundSchema;
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    OutputKafkaKafkaSchemaRegistryAuthentication$outboundSchema;
  /** @deprecated use `OutputKafkaKafkaSchemaRegistryAuthentication$Outbound` instead. */
  export type Outbound = OutputKafkaKafkaSchemaRegistryAuthentication$Outbound;
}

export function outputKafkaKafkaSchemaRegistryAuthenticationToJSON(
  outputKafkaKafkaSchemaRegistryAuthentication:
    OutputKafkaKafkaSchemaRegistryAuthentication,
): string {
  return JSON.stringify(
    OutputKafkaKafkaSchemaRegistryAuthentication$outboundSchema.parse(
      outputKafkaKafkaSchemaRegistryAuthentication,
    ),
  );
}

export function outputKafkaKafkaSchemaRegistryAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputKafkaKafkaSchemaRegistryAuthentication,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputKafkaKafkaSchemaRegistryAuthentication$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputKafkaKafkaSchemaRegistryAuthentication' from JSON`,
  );
}

/** @internal */
export const OutputKafkaSASLMechanism$inboundSchema: z.ZodType<
  OutputKafkaSASLMechanism,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaSASLMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaSASLMechanism$outboundSchema: z.ZodType<
  OutputKafkaSASLMechanism,
  z.ZodTypeDef,
  OutputKafkaSASLMechanism
> = z.union([
  z.nativeEnum(OutputKafkaSASLMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaSASLMechanism$ {
  /** @deprecated use `OutputKafkaSASLMechanism$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaSASLMechanism$inboundSchema;
  /** @deprecated use `OutputKafkaSASLMechanism$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaSASLMechanism$outboundSchema;
}

/** @internal */
export const OutputKafkaAuthentication$inboundSchema: z.ZodType<
  OutputKafkaAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: OutputKafkaSASLMechanism$inboundSchema.default("plain"),
});

/** @internal */
export type OutputKafkaAuthentication$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const OutputKafkaAuthentication$outboundSchema: z.ZodType<
  OutputKafkaAuthentication$Outbound,
  z.ZodTypeDef,
  OutputKafkaAuthentication
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: OutputKafkaSASLMechanism$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaAuthentication$ {
  /** @deprecated use `OutputKafkaAuthentication$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaAuthentication$inboundSchema;
  /** @deprecated use `OutputKafkaAuthentication$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaAuthentication$outboundSchema;
  /** @deprecated use `OutputKafkaAuthentication$Outbound` instead. */
  export type Outbound = OutputKafkaAuthentication$Outbound;
}

export function outputKafkaAuthenticationToJSON(
  outputKafkaAuthentication: OutputKafkaAuthentication,
): string {
  return JSON.stringify(
    OutputKafkaAuthentication$outboundSchema.parse(outputKafkaAuthentication),
  );
}

export function outputKafkaAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<OutputKafkaAuthentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKafkaAuthentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKafkaAuthentication' from JSON`,
  );
}

/** @internal */
export const OutputKafkaMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputKafkaMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputKafkaMinimumTLSVersion,
  z.ZodTypeDef,
  OutputKafkaMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputKafkaMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaMinimumTLSVersion$ {
  /** @deprecated use `OutputKafkaMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputKafkaMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputKafkaMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputKafkaMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputKafkaMaximumTLSVersion,
  z.ZodTypeDef,
  OutputKafkaMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputKafkaMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaMaximumTLSVersion$ {
  /** @deprecated use `OutputKafkaMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputKafkaMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputKafkaTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputKafkaTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputKafkaMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputKafkaMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputKafkaTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputKafkaTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputKafkaTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputKafkaTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputKafkaMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: OutputKafkaMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaTLSSettingsClientSide$ {
  /** @deprecated use `OutputKafkaTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputKafkaTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputKafkaTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputKafkaTLSSettingsClientSide$Outbound;
}

export function outputKafkaTLSSettingsClientSideToJSON(
  outputKafkaTLSSettingsClientSide: OutputKafkaTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputKafkaTLSSettingsClientSide$outboundSchema.parse(
      outputKafkaTLSSettingsClientSide,
    ),
  );
}

export function outputKafkaTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<OutputKafkaTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKafkaTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKafkaTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputKafkaBackpressureBehavior$inboundSchema: z.ZodType<
  OutputKafkaBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaBackpressureBehavior$outboundSchema: z.ZodType<
  OutputKafkaBackpressureBehavior,
  z.ZodTypeDef,
  OutputKafkaBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputKafkaBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaBackpressureBehavior$ {
  /** @deprecated use `OutputKafkaBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputKafkaBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputKafkaPqCompressCompression$inboundSchema: z.ZodType<
  OutputKafkaPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaPqCompressCompression$outboundSchema: z.ZodType<
  OutputKafkaPqCompressCompression,
  z.ZodTypeDef,
  OutputKafkaPqCompressCompression
> = z.union([
  z.nativeEnum(OutputKafkaPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaPqCompressCompression$ {
  /** @deprecated use `OutputKafkaPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputKafkaPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputKafkaQueueFullBehavior$inboundSchema: z.ZodType<
  OutputKafkaQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaQueueFullBehavior$outboundSchema: z.ZodType<
  OutputKafkaQueueFullBehavior,
  z.ZodTypeDef,
  OutputKafkaQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputKafkaQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaQueueFullBehavior$ {
  /** @deprecated use `OutputKafkaQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputKafkaQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputKafkaMode$inboundSchema: z.ZodType<
  OutputKafkaMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKafkaMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKafkaMode$outboundSchema: z.ZodType<
  OutputKafkaMode,
  z.ZodTypeDef,
  OutputKafkaMode
> = z.union([
  z.nativeEnum(OutputKafkaMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaMode$ {
  /** @deprecated use `OutputKafkaMode$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaMode$inboundSchema;
  /** @deprecated use `OutputKafkaMode$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaMode$outboundSchema;
}

/** @internal */
export const OutputKafkaPqControls$inboundSchema: z.ZodType<
  OutputKafkaPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputKafkaPqControls$Outbound = {};

/** @internal */
export const OutputKafkaPqControls$outboundSchema: z.ZodType<
  OutputKafkaPqControls$Outbound,
  z.ZodTypeDef,
  OutputKafkaPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafkaPqControls$ {
  /** @deprecated use `OutputKafkaPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputKafkaPqControls$inboundSchema;
  /** @deprecated use `OutputKafkaPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputKafkaPqControls$outboundSchema;
  /** @deprecated use `OutputKafkaPqControls$Outbound` instead. */
  export type Outbound = OutputKafkaPqControls$Outbound;
}

export function outputKafkaPqControlsToJSON(
  outputKafkaPqControls: OutputKafkaPqControls,
): string {
  return JSON.stringify(
    OutputKafkaPqControls$outboundSchema.parse(outputKafkaPqControls),
  );
}

export function outputKafkaPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputKafkaPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKafkaPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKafkaPqControls' from JSON`,
  );
}

/** @internal */
export const OutputKafka$inboundSchema: z.ZodType<
  OutputKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputKafkaType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: OutputKafkaAcknowledgments$inboundSchema.default(1),
  format: OutputKafkaRecordDataFormat$inboundSchema.default("json"),
  compression: OutputKafkaCompression$inboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    OutputKafkaKafkaSchemaRegistryAuthentication$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => OutputKafkaAuthentication$inboundSchema).optional(),
  tls: z.lazy(() => OutputKafkaTLSSettingsClientSide$inboundSchema).optional(),
  onBackpressure: OutputKafkaBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputKafkaPqCompressCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputKafkaQueueFullBehavior$inboundSchema.default("block"),
  pqMode: OutputKafkaMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputKafkaPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputKafka$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  topic: string;
  ack: number;
  format: string;
  compression: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  kafkaSchemaRegistry?:
    | OutputKafkaKafkaSchemaRegistryAuthentication$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: OutputKafkaAuthentication$Outbound | undefined;
  tls?: OutputKafkaTLSSettingsClientSide$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  protobufLibraryId?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputKafkaPqControls$Outbound | undefined;
};

/** @internal */
export const OutputKafka$outboundSchema: z.ZodType<
  OutputKafka$Outbound,
  z.ZodTypeDef,
  OutputKafka
> = z.object({
  id: z.string(),
  type: OutputKafkaType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: OutputKafkaAcknowledgments$outboundSchema.default(1),
  format: OutputKafkaRecordDataFormat$outboundSchema.default("json"),
  compression: OutputKafkaCompression$outboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    OutputKafkaKafkaSchemaRegistryAuthentication$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => OutputKafkaAuthentication$outboundSchema).optional(),
  tls: z.lazy(() => OutputKafkaTLSSettingsClientSide$outboundSchema).optional(),
  onBackpressure: OutputKafkaBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputKafkaPqCompressCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputKafkaQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputKafkaMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputKafkaPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafka$ {
  /** @deprecated use `OutputKafka$inboundSchema` instead. */
  export const inboundSchema = OutputKafka$inboundSchema;
  /** @deprecated use `OutputKafka$outboundSchema` instead. */
  export const outboundSchema = OutputKafka$outboundSchema;
  /** @deprecated use `OutputKafka$Outbound` instead. */
  export type Outbound = OutputKafka$Outbound;
}

export function outputKafkaToJSON(outputKafka: OutputKafka): string {
  return JSON.stringify(OutputKafka$outboundSchema.parse(outputKafka));
}

export function outputKafkaFromJSON(
  jsonString: string,
): SafeParseResult<OutputKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKafka' from JSON`,
  );
}

/** @internal */
export const OutputExabeamType$inboundSchema: z.ZodType<
  OutputExabeamType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputExabeamType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputExabeamType$outboundSchema: z.ZodType<
  OutputExabeamType,
  z.ZodTypeDef,
  OutputExabeamType
> = z.union([
  z.nativeEnum(OutputExabeamType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeamType$ {
  /** @deprecated use `OutputExabeamType$inboundSchema` instead. */
  export const inboundSchema = OutputExabeamType$inboundSchema;
  /** @deprecated use `OutputExabeamType$outboundSchema` instead. */
  export const outboundSchema = OutputExabeamType$outboundSchema;
}

/** @internal */
export const OutputExabeamSignatureVersion$inboundSchema: z.ZodType<
  OutputExabeamSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputExabeamSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputExabeamSignatureVersion$outboundSchema: z.ZodType<
  OutputExabeamSignatureVersion,
  z.ZodTypeDef,
  OutputExabeamSignatureVersion
> = z.union([
  z.nativeEnum(OutputExabeamSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeamSignatureVersion$ {
  /** @deprecated use `OutputExabeamSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputExabeamSignatureVersion$inboundSchema;
  /** @deprecated use `OutputExabeamSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputExabeamSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputExabeamObjectACL$inboundSchema: z.ZodType<
  OutputExabeamObjectACL,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputExabeamObjectACL),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputExabeamObjectACL$outboundSchema: z.ZodType<
  OutputExabeamObjectACL,
  z.ZodTypeDef,
  OutputExabeamObjectACL
> = z.union([
  z.nativeEnum(OutputExabeamObjectACL),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeamObjectACL$ {
  /** @deprecated use `OutputExabeamObjectACL$inboundSchema` instead. */
  export const inboundSchema = OutputExabeamObjectACL$inboundSchema;
  /** @deprecated use `OutputExabeamObjectACL$outboundSchema` instead. */
  export const outboundSchema = OutputExabeamObjectACL$outboundSchema;
}

/** @internal */
export const OutputExabeamStorageClass$inboundSchema: z.ZodType<
  OutputExabeamStorageClass,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputExabeamStorageClass),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputExabeamStorageClass$outboundSchema: z.ZodType<
  OutputExabeamStorageClass,
  z.ZodTypeDef,
  OutputExabeamStorageClass
> = z.union([
  z.nativeEnum(OutputExabeamStorageClass),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeamStorageClass$ {
  /** @deprecated use `OutputExabeamStorageClass$inboundSchema` instead. */
  export const inboundSchema = OutputExabeamStorageClass$inboundSchema;
  /** @deprecated use `OutputExabeamStorageClass$outboundSchema` instead. */
  export const outboundSchema = OutputExabeamStorageClass$outboundSchema;
}

/** @internal */
export const OutputExabeamBackpressureBehavior$inboundSchema: z.ZodType<
  OutputExabeamBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputExabeamBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputExabeamBackpressureBehavior$outboundSchema: z.ZodType<
  OutputExabeamBackpressureBehavior,
  z.ZodTypeDef,
  OutputExabeamBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputExabeamBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeamBackpressureBehavior$ {
  /** @deprecated use `OutputExabeamBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputExabeamBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputExabeamBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputExabeamBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputExabeamDiskSpaceProtection$inboundSchema: z.ZodType<
  OutputExabeamDiskSpaceProtection,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputExabeamDiskSpaceProtection),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputExabeamDiskSpaceProtection$outboundSchema: z.ZodType<
  OutputExabeamDiskSpaceProtection,
  z.ZodTypeDef,
  OutputExabeamDiskSpaceProtection
> = z.union([
  z.nativeEnum(OutputExabeamDiskSpaceProtection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeamDiskSpaceProtection$ {
  /** @deprecated use `OutputExabeamDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema = OutputExabeamDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputExabeamDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema = OutputExabeamDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputExabeam$inboundSchema: z.ZodType<
  OutputExabeam,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputExabeamType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: OutputExabeamSignatureVersion$inboundSchema.default("v4"),
  objectACL: OutputExabeamObjectACL$inboundSchema.default("private"),
  storageClass: OutputExabeamStorageClass$inboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  onBackpressure: OutputExabeamBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputExabeamDiskSpaceProtection$inboundSchema
    .default("block"),
  maxFileSizeMB: z.number().default(10),
  encodedConfiguration: z.string().optional(),
  collectorInstanceId: z.string(),
  siteName: z.string().optional(),
  siteId: z.string().optional(),
  timezoneOffset: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  description: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputExabeam$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region: string;
  stagePath: string;
  endpoint: string;
  signatureVersion: string;
  objectACL: string;
  storageClass?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileSizeMB: number;
  encodedConfiguration?: string | undefined;
  collectorInstanceId: string;
  siteName?: string | undefined;
  siteId?: string | undefined;
  timezoneOffset?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecretKey?: string | undefined;
  description?: string | undefined;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputExabeam$outboundSchema: z.ZodType<
  OutputExabeam$Outbound,
  z.ZodTypeDef,
  OutputExabeam
> = z.object({
  id: z.string(),
  type: OutputExabeamType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: OutputExabeamSignatureVersion$outboundSchema.default("v4"),
  objectACL: OutputExabeamObjectACL$outboundSchema.default("private"),
  storageClass: OutputExabeamStorageClass$outboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  onBackpressure: OutputExabeamBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputExabeamDiskSpaceProtection$outboundSchema
    .default("block"),
  maxFileSizeMB: z.number().default(10),
  encodedConfiguration: z.string().optional(),
  collectorInstanceId: z.string(),
  siteName: z.string().optional(),
  siteId: z.string().optional(),
  timezoneOffset: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  description: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeam$ {
  /** @deprecated use `OutputExabeam$inboundSchema` instead. */
  export const inboundSchema = OutputExabeam$inboundSchema;
  /** @deprecated use `OutputExabeam$outboundSchema` instead. */
  export const outboundSchema = OutputExabeam$outboundSchema;
  /** @deprecated use `OutputExabeam$Outbound` instead. */
  export type Outbound = OutputExabeam$Outbound;
}

export function outputExabeamToJSON(outputExabeam: OutputExabeam): string {
  return JSON.stringify(OutputExabeam$outboundSchema.parse(outputExabeam));
}

export function outputExabeamFromJSON(
  jsonString: string,
): SafeParseResult<OutputExabeam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputExabeam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputExabeam' from JSON`,
  );
}

/** @internal */
export const OutputGooglePubsubType$inboundSchema: z.ZodType<
  OutputGooglePubsubType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGooglePubsubType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGooglePubsubType$outboundSchema: z.ZodType<
  OutputGooglePubsubType,
  z.ZodTypeDef,
  OutputGooglePubsubType
> = z.union([
  z.nativeEnum(OutputGooglePubsubType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsubType$ {
  /** @deprecated use `OutputGooglePubsubType$inboundSchema` instead. */
  export const inboundSchema = OutputGooglePubsubType$inboundSchema;
  /** @deprecated use `OutputGooglePubsubType$outboundSchema` instead. */
  export const outboundSchema = OutputGooglePubsubType$outboundSchema;
}

/** @internal */
export const OutputGooglePubsubGoogleAuthenticationMethod$inboundSchema:
  z.ZodType<
    OutputGooglePubsubGoogleAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputGooglePubsubGoogleAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputGooglePubsubGoogleAuthenticationMethod$outboundSchema:
  z.ZodType<
    OutputGooglePubsubGoogleAuthenticationMethod,
    z.ZodTypeDef,
    OutputGooglePubsubGoogleAuthenticationMethod
  > = z.union([
    z.nativeEnum(OutputGooglePubsubGoogleAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsubGoogleAuthenticationMethod$ {
  /** @deprecated use `OutputGooglePubsubGoogleAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputGooglePubsubGoogleAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputGooglePubsubGoogleAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputGooglePubsubGoogleAuthenticationMethod$outboundSchema;
}

/** @internal */
export const FlushPeriodSecType$inboundSchema: z.ZodType<
  FlushPeriodSecType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(FlushPeriodSecType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const FlushPeriodSecType$outboundSchema: z.ZodType<
  FlushPeriodSecType,
  z.ZodTypeDef,
  FlushPeriodSecType
> = z.union([
  z.nativeEnum(FlushPeriodSecType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FlushPeriodSecType$ {
  /** @deprecated use `FlushPeriodSecType$inboundSchema` instead. */
  export const inboundSchema = FlushPeriodSecType$inboundSchema;
  /** @deprecated use `FlushPeriodSecType$outboundSchema` instead. */
  export const outboundSchema = FlushPeriodSecType$outboundSchema;
}

/** @internal */
export const FlushPeriodSec$inboundSchema: z.ZodType<
  FlushPeriodSec,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: FlushPeriodSecType$inboundSchema.optional(),
  default: z.number().optional(),
});

/** @internal */
export type FlushPeriodSec$Outbound = {
  type?: string | undefined;
  default?: number | undefined;
};

/** @internal */
export const FlushPeriodSec$outboundSchema: z.ZodType<
  FlushPeriodSec$Outbound,
  z.ZodTypeDef,
  FlushPeriodSec
> = z.object({
  type: FlushPeriodSecType$outboundSchema.optional(),
  default: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FlushPeriodSec$ {
  /** @deprecated use `FlushPeriodSec$inboundSchema` instead. */
  export const inboundSchema = FlushPeriodSec$inboundSchema;
  /** @deprecated use `FlushPeriodSec$outboundSchema` instead. */
  export const outboundSchema = FlushPeriodSec$outboundSchema;
  /** @deprecated use `FlushPeriodSec$Outbound` instead. */
  export type Outbound = FlushPeriodSec$Outbound;
}

export function flushPeriodSecToJSON(flushPeriodSec: FlushPeriodSec): string {
  return JSON.stringify(FlushPeriodSec$outboundSchema.parse(flushPeriodSec));
}

export function flushPeriodSecFromJSON(
  jsonString: string,
): SafeParseResult<FlushPeriodSec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FlushPeriodSec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FlushPeriodSec' from JSON`,
  );
}

/** @internal */
export const OutputGooglePubsubBackpressureBehavior$inboundSchema: z.ZodType<
  OutputGooglePubsubBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGooglePubsubBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGooglePubsubBackpressureBehavior$outboundSchema: z.ZodType<
  OutputGooglePubsubBackpressureBehavior,
  z.ZodTypeDef,
  OutputGooglePubsubBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputGooglePubsubBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsubBackpressureBehavior$ {
  /** @deprecated use `OutputGooglePubsubBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputGooglePubsubBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputGooglePubsubBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGooglePubsubBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputGooglePubsubCompression$inboundSchema: z.ZodType<
  OutputGooglePubsubCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGooglePubsubCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGooglePubsubCompression$outboundSchema: z.ZodType<
  OutputGooglePubsubCompression,
  z.ZodTypeDef,
  OutputGooglePubsubCompression
> = z.union([
  z.nativeEnum(OutputGooglePubsubCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsubCompression$ {
  /** @deprecated use `OutputGooglePubsubCompression$inboundSchema` instead. */
  export const inboundSchema = OutputGooglePubsubCompression$inboundSchema;
  /** @deprecated use `OutputGooglePubsubCompression$outboundSchema` instead. */
  export const outboundSchema = OutputGooglePubsubCompression$outboundSchema;
}

/** @internal */
export const OutputGooglePubsubQueueFullBehavior$inboundSchema: z.ZodType<
  OutputGooglePubsubQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGooglePubsubQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGooglePubsubQueueFullBehavior$outboundSchema: z.ZodType<
  OutputGooglePubsubQueueFullBehavior,
  z.ZodTypeDef,
  OutputGooglePubsubQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputGooglePubsubQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsubQueueFullBehavior$ {
  /** @deprecated use `OutputGooglePubsubQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputGooglePubsubQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputGooglePubsubQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGooglePubsubQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputGooglePubsubMode$inboundSchema: z.ZodType<
  OutputGooglePubsubMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGooglePubsubMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGooglePubsubMode$outboundSchema: z.ZodType<
  OutputGooglePubsubMode,
  z.ZodTypeDef,
  OutputGooglePubsubMode
> = z.union([
  z.nativeEnum(OutputGooglePubsubMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsubMode$ {
  /** @deprecated use `OutputGooglePubsubMode$inboundSchema` instead. */
  export const inboundSchema = OutputGooglePubsubMode$inboundSchema;
  /** @deprecated use `OutputGooglePubsubMode$outboundSchema` instead. */
  export const outboundSchema = OutputGooglePubsubMode$outboundSchema;
}

/** @internal */
export const OutputGooglePubsubPqControls$inboundSchema: z.ZodType<
  OutputGooglePubsubPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputGooglePubsubPqControls$Outbound = {};

/** @internal */
export const OutputGooglePubsubPqControls$outboundSchema: z.ZodType<
  OutputGooglePubsubPqControls$Outbound,
  z.ZodTypeDef,
  OutputGooglePubsubPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsubPqControls$ {
  /** @deprecated use `OutputGooglePubsubPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputGooglePubsubPqControls$inboundSchema;
  /** @deprecated use `OutputGooglePubsubPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputGooglePubsubPqControls$outboundSchema;
  /** @deprecated use `OutputGooglePubsubPqControls$Outbound` instead. */
  export type Outbound = OutputGooglePubsubPqControls$Outbound;
}

export function outputGooglePubsubPqControlsToJSON(
  outputGooglePubsubPqControls: OutputGooglePubsubPqControls,
): string {
  return JSON.stringify(
    OutputGooglePubsubPqControls$outboundSchema.parse(
      outputGooglePubsubPqControls,
    ),
  );
}

export function outputGooglePubsubPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputGooglePubsubPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGooglePubsubPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGooglePubsubPqControls' from JSON`,
  );
}

/** @internal */
export const OutputGooglePubsub$inboundSchema: z.ZodType<
  OutputGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputGooglePubsubType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicName: z.string(),
  createTopic: z.boolean().default(false),
  orderedDelivery: z.boolean().default(false),
  region: z.string().optional(),
  googleAuthMethod: OutputGooglePubsubGoogleAuthenticationMethod$inboundSchema
    .default("manual"),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  batchSize: z.number().default(1000),
  batchTimeout: z.number().default(100),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.lazy(() => FlushPeriodSec$inboundSchema).optional(),
  maxInProgress: z.number().default(10),
  onBackpressure: OutputGooglePubsubBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGooglePubsubCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputGooglePubsubQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputGooglePubsubMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGooglePubsubPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputGooglePubsub$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  topicName: string;
  createTopic: boolean;
  orderedDelivery: boolean;
  region?: string | undefined;
  googleAuthMethod: string;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  batchSize: number;
  batchTimeout: number;
  maxQueueSize: number;
  maxRecordSizeKB: number;
  flushPeriodSec?: FlushPeriodSec$Outbound | undefined;
  maxInProgress: number;
  onBackpressure: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputGooglePubsubPqControls$Outbound | undefined;
};

/** @internal */
export const OutputGooglePubsub$outboundSchema: z.ZodType<
  OutputGooglePubsub$Outbound,
  z.ZodTypeDef,
  OutputGooglePubsub
> = z.object({
  id: z.string(),
  type: OutputGooglePubsubType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicName: z.string(),
  createTopic: z.boolean().default(false),
  orderedDelivery: z.boolean().default(false),
  region: z.string().optional(),
  googleAuthMethod: OutputGooglePubsubGoogleAuthenticationMethod$outboundSchema
    .default("manual"),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  batchSize: z.number().default(1000),
  batchTimeout: z.number().default(100),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.lazy(() => FlushPeriodSec$outboundSchema).optional(),
  maxInProgress: z.number().default(10),
  onBackpressure: OutputGooglePubsubBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGooglePubsubCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputGooglePubsubQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputGooglePubsubMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGooglePubsubPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsub$ {
  /** @deprecated use `OutputGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = OutputGooglePubsub$inboundSchema;
  /** @deprecated use `OutputGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = OutputGooglePubsub$outboundSchema;
  /** @deprecated use `OutputGooglePubsub$Outbound` instead. */
  export type Outbound = OutputGooglePubsub$Outbound;
}

export function outputGooglePubsubToJSON(
  outputGooglePubsub: OutputGooglePubsub,
): string {
  return JSON.stringify(
    OutputGooglePubsub$outboundSchema.parse(outputGooglePubsub),
  );
}

export function outputGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<OutputGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGooglePubsub' from JSON`,
  );
}

/** @internal */
export const OutputGoogleCloudLoggingType$inboundSchema: z.ZodType<
  OutputGoogleCloudLoggingType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudLoggingType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudLoggingType$outboundSchema: z.ZodType<
  OutputGoogleCloudLoggingType,
  z.ZodTypeDef,
  OutputGoogleCloudLoggingType
> = z.union([
  z.nativeEnum(OutputGoogleCloudLoggingType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLoggingType$ {
  /** @deprecated use `OutputGoogleCloudLoggingType$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudLoggingType$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingType$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleCloudLoggingType$outboundSchema;
}

/** @internal */
export const LogLocationType$inboundSchema: z.ZodType<
  LogLocationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(LogLocationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const LogLocationType$outboundSchema: z.ZodType<
  LogLocationType,
  z.ZodTypeDef,
  LogLocationType
> = z.union([
  z.nativeEnum(LogLocationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLocationType$ {
  /** @deprecated use `LogLocationType$inboundSchema` instead. */
  export const inboundSchema = LogLocationType$inboundSchema;
  /** @deprecated use `LogLocationType$outboundSchema` instead. */
  export const outboundSchema = LogLocationType$outboundSchema;
}

/** @internal */
export const PayloadFormat$inboundSchema: z.ZodType<
  PayloadFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PayloadFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PayloadFormat$outboundSchema: z.ZodType<
  PayloadFormat,
  z.ZodTypeDef,
  PayloadFormat
> = z.union([
  z.nativeEnum(PayloadFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadFormat$ {
  /** @deprecated use `PayloadFormat$inboundSchema` instead. */
  export const inboundSchema = PayloadFormat$inboundSchema;
  /** @deprecated use `PayloadFormat$outboundSchema` instead. */
  export const outboundSchema = PayloadFormat$outboundSchema;
}

/** @internal */
export const LogLabel$inboundSchema: z.ZodType<
  LogLabel,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/** @internal */
export type LogLabel$Outbound = {
  label: string;
  valueExpression: string;
};

/** @internal */
export const LogLabel$outboundSchema: z.ZodType<
  LogLabel$Outbound,
  z.ZodTypeDef,
  LogLabel
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLabel$ {
  /** @deprecated use `LogLabel$inboundSchema` instead. */
  export const inboundSchema = LogLabel$inboundSchema;
  /** @deprecated use `LogLabel$outboundSchema` instead. */
  export const outboundSchema = LogLabel$outboundSchema;
  /** @deprecated use `LogLabel$Outbound` instead. */
  export type Outbound = LogLabel$Outbound;
}

export function logLabelToJSON(logLabel: LogLabel): string {
  return JSON.stringify(LogLabel$outboundSchema.parse(logLabel));
}

export function logLabelFromJSON(
  jsonString: string,
): SafeParseResult<LogLabel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LogLabel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LogLabel' from JSON`,
  );
}

/** @internal */
export const ResourceTypeLabel$inboundSchema: z.ZodType<
  ResourceTypeLabel,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/** @internal */
export type ResourceTypeLabel$Outbound = {
  label: string;
  valueExpression: string;
};

/** @internal */
export const ResourceTypeLabel$outboundSchema: z.ZodType<
  ResourceTypeLabel$Outbound,
  z.ZodTypeDef,
  ResourceTypeLabel
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceTypeLabel$ {
  /** @deprecated use `ResourceTypeLabel$inboundSchema` instead. */
  export const inboundSchema = ResourceTypeLabel$inboundSchema;
  /** @deprecated use `ResourceTypeLabel$outboundSchema` instead. */
  export const outboundSchema = ResourceTypeLabel$outboundSchema;
  /** @deprecated use `ResourceTypeLabel$Outbound` instead. */
  export type Outbound = ResourceTypeLabel$Outbound;
}

export function resourceTypeLabelToJSON(
  resourceTypeLabel: ResourceTypeLabel,
): string {
  return JSON.stringify(
    ResourceTypeLabel$outboundSchema.parse(resourceTypeLabel),
  );
}

export function resourceTypeLabelFromJSON(
  jsonString: string,
): SafeParseResult<ResourceTypeLabel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResourceTypeLabel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResourceTypeLabel' from JSON`,
  );
}

/** @internal */
export const OutputGoogleCloudLoggingGoogleAuthenticationMethod$inboundSchema:
  z.ZodType<
    OutputGoogleCloudLoggingGoogleAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputGoogleCloudLoggingGoogleAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputGoogleCloudLoggingGoogleAuthenticationMethod$outboundSchema:
  z.ZodType<
    OutputGoogleCloudLoggingGoogleAuthenticationMethod,
    z.ZodTypeDef,
    OutputGoogleCloudLoggingGoogleAuthenticationMethod
  > = z.union([
    z.nativeEnum(OutputGoogleCloudLoggingGoogleAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLoggingGoogleAuthenticationMethod$ {
  /** @deprecated use `OutputGoogleCloudLoggingGoogleAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudLoggingGoogleAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingGoogleAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudLoggingGoogleAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudLoggingBackpressureBehavior$inboundSchema:
  z.ZodType<
    OutputGoogleCloudLoggingBackpressureBehavior,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputGoogleCloudLoggingBackpressureBehavior),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputGoogleCloudLoggingBackpressureBehavior$outboundSchema:
  z.ZodType<
    OutputGoogleCloudLoggingBackpressureBehavior,
    z.ZodTypeDef,
    OutputGoogleCloudLoggingBackpressureBehavior
  > = z.union([
    z.nativeEnum(OutputGoogleCloudLoggingBackpressureBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLoggingBackpressureBehavior$ {
  /** @deprecated use `OutputGoogleCloudLoggingBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudLoggingBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudLoggingBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudLoggingCompression$inboundSchema: z.ZodType<
  OutputGoogleCloudLoggingCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudLoggingCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudLoggingCompression$outboundSchema: z.ZodType<
  OutputGoogleCloudLoggingCompression,
  z.ZodTypeDef,
  OutputGoogleCloudLoggingCompression
> = z.union([
  z.nativeEnum(OutputGoogleCloudLoggingCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLoggingCompression$ {
  /** @deprecated use `OutputGoogleCloudLoggingCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudLoggingCompression$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudLoggingCompression$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudLoggingQueueFullBehavior$inboundSchema: z.ZodType<
  OutputGoogleCloudLoggingQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudLoggingQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudLoggingQueueFullBehavior$outboundSchema:
  z.ZodType<
    OutputGoogleCloudLoggingQueueFullBehavior,
    z.ZodTypeDef,
    OutputGoogleCloudLoggingQueueFullBehavior
  > = z.union([
    z.nativeEnum(OutputGoogleCloudLoggingQueueFullBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLoggingQueueFullBehavior$ {
  /** @deprecated use `OutputGoogleCloudLoggingQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudLoggingQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudLoggingQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudLoggingMode$inboundSchema: z.ZodType<
  OutputGoogleCloudLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudLoggingMode$outboundSchema: z.ZodType<
  OutputGoogleCloudLoggingMode,
  z.ZodTypeDef,
  OutputGoogleCloudLoggingMode
> = z.union([
  z.nativeEnum(OutputGoogleCloudLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLoggingMode$ {
  /** @deprecated use `OutputGoogleCloudLoggingMode$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudLoggingMode$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingMode$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleCloudLoggingMode$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudLoggingPqControls$inboundSchema: z.ZodType<
  OutputGoogleCloudLoggingPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputGoogleCloudLoggingPqControls$Outbound = {};

/** @internal */
export const OutputGoogleCloudLoggingPqControls$outboundSchema: z.ZodType<
  OutputGoogleCloudLoggingPqControls$Outbound,
  z.ZodTypeDef,
  OutputGoogleCloudLoggingPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLoggingPqControls$ {
  /** @deprecated use `OutputGoogleCloudLoggingPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudLoggingPqControls$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingPqControls$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudLoggingPqControls$outboundSchema;
  /** @deprecated use `OutputGoogleCloudLoggingPqControls$Outbound` instead. */
  export type Outbound = OutputGoogleCloudLoggingPqControls$Outbound;
}

export function outputGoogleCloudLoggingPqControlsToJSON(
  outputGoogleCloudLoggingPqControls: OutputGoogleCloudLoggingPqControls,
): string {
  return JSON.stringify(
    OutputGoogleCloudLoggingPqControls$outboundSchema.parse(
      outputGoogleCloudLoggingPqControls,
    ),
  );
}

export function outputGoogleCloudLoggingPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleCloudLoggingPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputGoogleCloudLoggingPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleCloudLoggingPqControls' from JSON`,
  );
}

/** @internal */
export const OutputGoogleCloudLogging$inboundSchema: z.ZodType<
  OutputGoogleCloudLogging,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputGoogleCloudLoggingType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logLocationType: LogLocationType$inboundSchema,
  logNameExpression: z.string(),
  payloadFormat: PayloadFormat$inboundSchema.default("text"),
  logLabels: z.array(z.lazy(() => LogLabel$inboundSchema)).optional(),
  resourceTypeExpression: z.string().optional(),
  resourceTypeLabels: z.array(z.lazy(() => ResourceTypeLabel$inboundSchema))
    .optional(),
  severityExpression: z.string().optional(),
  insertIdExpression: z.string().optional(),
  googleAuthMethod:
    OutputGoogleCloudLoggingGoogleAuthenticationMethod$inboundSchema.default(
      "manual",
    ),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  concurrency: z.number().default(5),
  connectionTimeout: z.number().default(10000),
  timeoutSec: z.number().default(30),
  throttleRateReqPerSec: z.number().int().optional(),
  requestMethodExpression: z.string().optional(),
  requestUrlExpression: z.string().optional(),
  requestSizeExpression: z.string().optional(),
  statusExpression: z.string().optional(),
  responseSizeExpression: z.string().optional(),
  userAgentExpression: z.string().optional(),
  remoteIpExpression: z.string().optional(),
  serverIpExpression: z.string().optional(),
  refererExpression: z.string().optional(),
  latencyExpression: z.string().optional(),
  cacheLookupExpression: z.string().optional(),
  cacheHitExpression: z.string().optional(),
  cacheValidatedExpression: z.string().optional(),
  cacheFillBytesExpression: z.string().optional(),
  protocolExpression: z.string().optional(),
  idExpression: z.string().optional(),
  producerExpression: z.string().optional(),
  firstExpression: z.string().optional(),
  lastExpression: z.string().optional(),
  fileExpression: z.string().optional(),
  lineExpression: z.string().optional(),
  functionExpression: z.string().optional(),
  uidExpression: z.string().optional(),
  indexExpression: z.string().optional(),
  totalSplitsExpression: z.string().optional(),
  traceExpression: z.string().optional(),
  spanIdExpression: z.string().optional(),
  traceSampledExpression: z.string().optional(),
  onBackpressure: OutputGoogleCloudLoggingBackpressureBehavior$inboundSchema
    .default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  logLocationExpression: z.string(),
  payloadExpression: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGoogleCloudLoggingCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputGoogleCloudLoggingQueueFullBehavior$inboundSchema
    .default("block"),
  pqMode: OutputGoogleCloudLoggingMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGoogleCloudLoggingPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputGoogleCloudLogging$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  logLocationType: string;
  logNameExpression: string;
  payloadFormat: string;
  logLabels?: Array<LogLabel$Outbound> | undefined;
  resourceTypeExpression?: string | undefined;
  resourceTypeLabels?: Array<ResourceTypeLabel$Outbound> | undefined;
  severityExpression?: string | undefined;
  insertIdExpression?: string | undefined;
  googleAuthMethod: string;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  flushPeriodSec: number;
  concurrency: number;
  connectionTimeout: number;
  timeoutSec: number;
  throttleRateReqPerSec?: number | undefined;
  requestMethodExpression?: string | undefined;
  requestUrlExpression?: string | undefined;
  requestSizeExpression?: string | undefined;
  statusExpression?: string | undefined;
  responseSizeExpression?: string | undefined;
  userAgentExpression?: string | undefined;
  remoteIpExpression?: string | undefined;
  serverIpExpression?: string | undefined;
  refererExpression?: string | undefined;
  latencyExpression?: string | undefined;
  cacheLookupExpression?: string | undefined;
  cacheHitExpression?: string | undefined;
  cacheValidatedExpression?: string | undefined;
  cacheFillBytesExpression?: string | undefined;
  protocolExpression?: string | undefined;
  idExpression?: string | undefined;
  producerExpression?: string | undefined;
  firstExpression?: string | undefined;
  lastExpression?: string | undefined;
  fileExpression?: string | undefined;
  lineExpression?: string | undefined;
  functionExpression?: string | undefined;
  uidExpression?: string | undefined;
  indexExpression?: string | undefined;
  totalSplitsExpression?: string | undefined;
  traceExpression?: string | undefined;
  spanIdExpression?: string | undefined;
  traceSampledExpression?: string | undefined;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  logLocationExpression: string;
  payloadExpression?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputGoogleCloudLoggingPqControls$Outbound | undefined;
};

/** @internal */
export const OutputGoogleCloudLogging$outboundSchema: z.ZodType<
  OutputGoogleCloudLogging$Outbound,
  z.ZodTypeDef,
  OutputGoogleCloudLogging
> = z.object({
  id: z.string(),
  type: OutputGoogleCloudLoggingType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logLocationType: LogLocationType$outboundSchema,
  logNameExpression: z.string(),
  payloadFormat: PayloadFormat$outboundSchema.default("text"),
  logLabels: z.array(z.lazy(() => LogLabel$outboundSchema)).optional(),
  resourceTypeExpression: z.string().optional(),
  resourceTypeLabels: z.array(z.lazy(() => ResourceTypeLabel$outboundSchema))
    .optional(),
  severityExpression: z.string().optional(),
  insertIdExpression: z.string().optional(),
  googleAuthMethod:
    OutputGoogleCloudLoggingGoogleAuthenticationMethod$outboundSchema.default(
      "manual",
    ),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  concurrency: z.number().default(5),
  connectionTimeout: z.number().default(10000),
  timeoutSec: z.number().default(30),
  throttleRateReqPerSec: z.number().int().optional(),
  requestMethodExpression: z.string().optional(),
  requestUrlExpression: z.string().optional(),
  requestSizeExpression: z.string().optional(),
  statusExpression: z.string().optional(),
  responseSizeExpression: z.string().optional(),
  userAgentExpression: z.string().optional(),
  remoteIpExpression: z.string().optional(),
  serverIpExpression: z.string().optional(),
  refererExpression: z.string().optional(),
  latencyExpression: z.string().optional(),
  cacheLookupExpression: z.string().optional(),
  cacheHitExpression: z.string().optional(),
  cacheValidatedExpression: z.string().optional(),
  cacheFillBytesExpression: z.string().optional(),
  protocolExpression: z.string().optional(),
  idExpression: z.string().optional(),
  producerExpression: z.string().optional(),
  firstExpression: z.string().optional(),
  lastExpression: z.string().optional(),
  fileExpression: z.string().optional(),
  lineExpression: z.string().optional(),
  functionExpression: z.string().optional(),
  uidExpression: z.string().optional(),
  indexExpression: z.string().optional(),
  totalSplitsExpression: z.string().optional(),
  traceExpression: z.string().optional(),
  spanIdExpression: z.string().optional(),
  traceSampledExpression: z.string().optional(),
  onBackpressure: OutputGoogleCloudLoggingBackpressureBehavior$outboundSchema
    .default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  logLocationExpression: z.string(),
  payloadExpression: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGoogleCloudLoggingCompression$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputGoogleCloudLoggingQueueFullBehavior$outboundSchema
    .default("block"),
  pqMode: OutputGoogleCloudLoggingMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGoogleCloudLoggingPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLogging$ {
  /** @deprecated use `OutputGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudLogging$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleCloudLogging$outboundSchema;
  /** @deprecated use `OutputGoogleCloudLogging$Outbound` instead. */
  export type Outbound = OutputGoogleCloudLogging$Outbound;
}

export function outputGoogleCloudLoggingToJSON(
  outputGoogleCloudLogging: OutputGoogleCloudLogging,
): string {
  return JSON.stringify(
    OutputGoogleCloudLogging$outboundSchema.parse(outputGoogleCloudLogging),
  );
}

export function outputGoogleCloudLoggingFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleCloudLogging, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGoogleCloudLogging$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleCloudLogging' from JSON`,
  );
}

/** @internal */
export const OutputGoogleCloudStorageType$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageType$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageType,
  z.ZodTypeDef,
  OutputGoogleCloudStorageType
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageType$ {
  /** @deprecated use `OutputGoogleCloudStorageType$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudStorageType$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageType$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleCloudStorageType$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageSignatureVersion$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageSignatureVersion$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageSignatureVersion,
  z.ZodTypeDef,
  OutputGoogleCloudStorageSignatureVersion
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageSignatureVersion$ {
  /** @deprecated use `OutputGoogleCloudStorageSignatureVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageSignatureVersion$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageSignatureVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageAuthenticationMethod$inboundSchema:
  z.ZodType<
    OutputGoogleCloudStorageAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputGoogleCloudStorageAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputGoogleCloudStorageAuthenticationMethod$outboundSchema:
  z.ZodType<
    OutputGoogleCloudStorageAuthenticationMethod,
    z.ZodTypeDef,
    OutputGoogleCloudStorageAuthenticationMethod
  > = z.union([
    z.nativeEnum(OutputGoogleCloudStorageAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageAuthenticationMethod$ {
  /** @deprecated use `OutputGoogleCloudStorageAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageObjectACL$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageObjectACL,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageObjectACL),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageObjectACL$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageObjectACL,
  z.ZodTypeDef,
  OutputGoogleCloudStorageObjectACL
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageObjectACL),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageObjectACL$ {
  /** @deprecated use `OutputGoogleCloudStorageObjectACL$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudStorageObjectACL$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageObjectACL$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageObjectACL$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageStorageClass$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageStorageClass,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageStorageClass),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageStorageClass$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageStorageClass,
  z.ZodTypeDef,
  OutputGoogleCloudStorageStorageClass
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageStorageClass),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageStorageClass$ {
  /** @deprecated use `OutputGoogleCloudStorageStorageClass$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageStorageClass$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageStorageClass$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageStorageClass$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageDataFormat$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageDataFormat$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageDataFormat,
  z.ZodTypeDef,
  OutputGoogleCloudStorageDataFormat
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageDataFormat$ {
  /** @deprecated use `OutputGoogleCloudStorageDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudStorageDataFormat$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageDataFormat$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageDataFormat$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageBackpressureBehavior$inboundSchema:
  z.ZodType<
    OutputGoogleCloudStorageBackpressureBehavior,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputGoogleCloudStorageBackpressureBehavior),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputGoogleCloudStorageBackpressureBehavior$outboundSchema:
  z.ZodType<
    OutputGoogleCloudStorageBackpressureBehavior,
    z.ZodTypeDef,
    OutputGoogleCloudStorageBackpressureBehavior
  > = z.union([
    z.nativeEnum(OutputGoogleCloudStorageBackpressureBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageBackpressureBehavior$ {
  /** @deprecated use `OutputGoogleCloudStorageBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageDiskSpaceProtection$inboundSchema:
  z.ZodType<
    OutputGoogleCloudStorageDiskSpaceProtection,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputGoogleCloudStorageDiskSpaceProtection),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputGoogleCloudStorageDiskSpaceProtection$outboundSchema:
  z.ZodType<
    OutputGoogleCloudStorageDiskSpaceProtection,
    z.ZodTypeDef,
    OutputGoogleCloudStorageDiskSpaceProtection
  > = z.union([
    z.nativeEnum(OutputGoogleCloudStorageDiskSpaceProtection),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageDiskSpaceProtection$ {
  /** @deprecated use `OutputGoogleCloudStorageDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageCompression$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageCompression$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageCompression,
  z.ZodTypeDef,
  OutputGoogleCloudStorageCompression
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageCompression$ {
  /** @deprecated use `OutputGoogleCloudStorageCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageCompression$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageCompression$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageCompressionLevel$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageCompressionLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageCompressionLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageCompressionLevel$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageCompressionLevel,
  z.ZodTypeDef,
  OutputGoogleCloudStorageCompressionLevel
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageCompressionLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageCompressionLevel$ {
  /** @deprecated use `OutputGoogleCloudStorageCompressionLevel$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageCompressionLevel$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageCompressionLevel$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageCompressionLevel$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageParquetVersion$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageParquetVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageParquetVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageParquetVersion$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageParquetVersion,
  z.ZodTypeDef,
  OutputGoogleCloudStorageParquetVersion
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageParquetVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageParquetVersion$ {
  /** @deprecated use `OutputGoogleCloudStorageParquetVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageParquetVersion$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageParquetVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageParquetVersion$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageDataPageVersion$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageDataPageVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleCloudStorageDataPageVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleCloudStorageDataPageVersion$outboundSchema: z.ZodType<
  OutputGoogleCloudStorageDataPageVersion,
  z.ZodTypeDef,
  OutputGoogleCloudStorageDataPageVersion
> = z.union([
  z.nativeEnum(OutputGoogleCloudStorageDataPageVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageDataPageVersion$ {
  /** @deprecated use `OutputGoogleCloudStorageDataPageVersion$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageDataPageVersion$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageDataPageVersion$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageDataPageVersion$outboundSchema;
}

/** @internal */
export const OutputGoogleCloudStorageKeyValueMetadatum$inboundSchema: z.ZodType<
  OutputGoogleCloudStorageKeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputGoogleCloudStorageKeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputGoogleCloudStorageKeyValueMetadatum$outboundSchema:
  z.ZodType<
    OutputGoogleCloudStorageKeyValueMetadatum$Outbound,
    z.ZodTypeDef,
    OutputGoogleCloudStorageKeyValueMetadatum
  > = z.object({
    key: z.string().default(""),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorageKeyValueMetadatum$ {
  /** @deprecated use `OutputGoogleCloudStorageKeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleCloudStorageKeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageKeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleCloudStorageKeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputGoogleCloudStorageKeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputGoogleCloudStorageKeyValueMetadatum$Outbound;
}

export function outputGoogleCloudStorageKeyValueMetadatumToJSON(
  outputGoogleCloudStorageKeyValueMetadatum:
    OutputGoogleCloudStorageKeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputGoogleCloudStorageKeyValueMetadatum$outboundSchema.parse(
      outputGoogleCloudStorageKeyValueMetadatum,
    ),
  );
}

export function outputGoogleCloudStorageKeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputGoogleCloudStorageKeyValueMetadatum,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputGoogleCloudStorageKeyValueMetadatum$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputGoogleCloudStorageKeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputGoogleCloudStorage$inboundSchema: z.ZodType<
  OutputGoogleCloudStorage,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputGoogleCloudStorageType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: OutputGoogleCloudStorageSignatureVersion$inboundSchema
    .default("v4"),
  awsAuthenticationMethod:
    OutputGoogleCloudStorageAuthenticationMethod$inboundSchema.default(
      "manual",
    ),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  destPath: z.string().default(""),
  verifyPermissions: z.boolean().default(true),
  objectACL: OutputGoogleCloudStorageObjectACL$inboundSchema.default("private"),
  storageClass: OutputGoogleCloudStorageStorageClass$inboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputGoogleCloudStorageDataFormat$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputGoogleCloudStorageBackpressureBehavior$inboundSchema
    .default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure:
    OutputGoogleCloudStorageDiskSpaceProtection$inboundSchema.default("block"),
  description: z.string().optional(),
  compress: OutputGoogleCloudStorageCompression$inboundSchema.default("gzip"),
  compressionLevel: OutputGoogleCloudStorageCompressionLevel$inboundSchema
    .default("best_speed"),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputGoogleCloudStorageParquetVersion$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputGoogleCloudStorageDataPageVersion$inboundSchema
    .default("DATA_PAGE_V2"),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputGoogleCloudStorageKeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/** @internal */
export type OutputGoogleCloudStorage$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region: string;
  endpoint: string;
  signatureVersion: string;
  awsAuthenticationMethod: string;
  stagePath: string;
  destPath: string;
  verifyPermissions: boolean;
  objectACL: string;
  storageClass?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  description?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<OutputGoogleCloudStorageKeyValueMetadatum$Outbound>
    | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
  awsApiKey?: string | undefined;
  awsSecretKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const OutputGoogleCloudStorage$outboundSchema: z.ZodType<
  OutputGoogleCloudStorage$Outbound,
  z.ZodTypeDef,
  OutputGoogleCloudStorage
> = z.object({
  id: z.string(),
  type: OutputGoogleCloudStorageType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: OutputGoogleCloudStorageSignatureVersion$outboundSchema
    .default("v4"),
  awsAuthenticationMethod:
    OutputGoogleCloudStorageAuthenticationMethod$outboundSchema.default(
      "manual",
    ),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  destPath: z.string().default(""),
  verifyPermissions: z.boolean().default(true),
  objectACL: OutputGoogleCloudStorageObjectACL$outboundSchema.default(
    "private",
  ),
  storageClass: OutputGoogleCloudStorageStorageClass$outboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputGoogleCloudStorageDataFormat$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputGoogleCloudStorageBackpressureBehavior$outboundSchema
    .default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure:
    OutputGoogleCloudStorageDiskSpaceProtection$outboundSchema.default("block"),
  description: z.string().optional(),
  compress: OutputGoogleCloudStorageCompression$outboundSchema.default("gzip"),
  compressionLevel: OutputGoogleCloudStorageCompressionLevel$outboundSchema
    .default("best_speed"),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputGoogleCloudStorageParquetVersion$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputGoogleCloudStorageDataPageVersion$outboundSchema
    .default("DATA_PAGE_V2"),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputGoogleCloudStorageKeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorage$ {
  /** @deprecated use `OutputGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudStorage$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleCloudStorage$outboundSchema;
  /** @deprecated use `OutputGoogleCloudStorage$Outbound` instead. */
  export type Outbound = OutputGoogleCloudStorage$Outbound;
}

export function outputGoogleCloudStorageToJSON(
  outputGoogleCloudStorage: OutputGoogleCloudStorage,
): string {
  return JSON.stringify(
    OutputGoogleCloudStorage$outboundSchema.parse(outputGoogleCloudStorage),
  );
}

export function outputGoogleCloudStorageFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleCloudStorage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGoogleCloudStorage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleCloudStorage' from JSON`,
  );
}

/** @internal */
export const OutputGoogleChronicleType$inboundSchema: z.ZodType<
  OutputGoogleChronicleType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleChronicleType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleChronicleType$outboundSchema: z.ZodType<
  OutputGoogleChronicleType,
  z.ZodTypeDef,
  OutputGoogleChronicleType
> = z.union([
  z.nativeEnum(OutputGoogleChronicleType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleType$ {
  /** @deprecated use `OutputGoogleChronicleType$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleChronicleType$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleType$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleChronicleType$outboundSchema;
}

/** @internal */
export const CreateOutputAPIVersion$inboundSchema: z.ZodType<
  CreateOutputAPIVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateOutputAPIVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateOutputAPIVersion$outboundSchema: z.ZodType<
  CreateOutputAPIVersion,
  z.ZodTypeDef,
  CreateOutputAPIVersion
> = z.union([
  z.nativeEnum(CreateOutputAPIVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAPIVersion$ {
  /** @deprecated use `CreateOutputAPIVersion$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAPIVersion$inboundSchema;
  /** @deprecated use `CreateOutputAPIVersion$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAPIVersion$outboundSchema;
}

/** @internal */
export const OutputGoogleChronicleAuthenticationMethod$inboundSchema: z.ZodType<
  OutputGoogleChronicleAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleChronicleAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleChronicleAuthenticationMethod$outboundSchema:
  z.ZodType<
    OutputGoogleChronicleAuthenticationMethod,
    z.ZodTypeDef,
    OutputGoogleChronicleAuthenticationMethod
  > = z.union([
    z.nativeEnum(OutputGoogleChronicleAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleAuthenticationMethod$ {
  /** @deprecated use `OutputGoogleChronicleAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleChronicleAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleChronicleAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputGoogleChronicleResponseRetrySetting$inboundSchema: z.ZodType<
  OutputGoogleChronicleResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputGoogleChronicleResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputGoogleChronicleResponseRetrySetting$outboundSchema:
  z.ZodType<
    OutputGoogleChronicleResponseRetrySetting$Outbound,
    z.ZodTypeDef,
    OutputGoogleChronicleResponseRetrySetting
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleResponseRetrySetting$ {
  /** @deprecated use `OutputGoogleChronicleResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleChronicleResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleChronicleResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputGoogleChronicleResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputGoogleChronicleResponseRetrySetting$Outbound;
}

export function outputGoogleChronicleResponseRetrySettingToJSON(
  outputGoogleChronicleResponseRetrySetting:
    OutputGoogleChronicleResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputGoogleChronicleResponseRetrySetting$outboundSchema.parse(
      outputGoogleChronicleResponseRetrySetting,
    ),
  );
}

export function outputGoogleChronicleResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputGoogleChronicleResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputGoogleChronicleResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputGoogleChronicleResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputGoogleChronicleTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputGoogleChronicleTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputGoogleChronicleTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputGoogleChronicleTimeoutRetrySettings$outboundSchema:
  z.ZodType<
    OutputGoogleChronicleTimeoutRetrySettings$Outbound,
    z.ZodTypeDef,
    OutputGoogleChronicleTimeoutRetrySettings
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleTimeoutRetrySettings$ {
  /** @deprecated use `OutputGoogleChronicleTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleChronicleTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleChronicleTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputGoogleChronicleTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputGoogleChronicleTimeoutRetrySettings$Outbound;
}

export function outputGoogleChronicleTimeoutRetrySettingsToJSON(
  outputGoogleChronicleTimeoutRetrySettings:
    OutputGoogleChronicleTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputGoogleChronicleTimeoutRetrySettings$outboundSchema.parse(
      outputGoogleChronicleTimeoutRetrySettings,
    ),
  );
}

export function outputGoogleChronicleTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputGoogleChronicleTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputGoogleChronicleTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputGoogleChronicleTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const SendEventsAs$inboundSchema: z.ZodType<
  SendEventsAs,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SendEventsAs),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SendEventsAs$outboundSchema: z.ZodType<
  SendEventsAs,
  z.ZodTypeDef,
  SendEventsAs
> = z.union([
  z.nativeEnum(SendEventsAs),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendEventsAs$ {
  /** @deprecated use `SendEventsAs$inboundSchema` instead. */
  export const inboundSchema = SendEventsAs$inboundSchema;
  /** @deprecated use `SendEventsAs$outboundSchema` instead. */
  export const outboundSchema = SendEventsAs$outboundSchema;
}

/** @internal */
export const OutputGoogleChronicleExtraHttpHeader$inboundSchema: z.ZodType<
  OutputGoogleChronicleExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputGoogleChronicleExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputGoogleChronicleExtraHttpHeader$outboundSchema: z.ZodType<
  OutputGoogleChronicleExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputGoogleChronicleExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleExtraHttpHeader$ {
  /** @deprecated use `OutputGoogleChronicleExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleChronicleExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleChronicleExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputGoogleChronicleExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputGoogleChronicleExtraHttpHeader$Outbound;
}

export function outputGoogleChronicleExtraHttpHeaderToJSON(
  outputGoogleChronicleExtraHttpHeader: OutputGoogleChronicleExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputGoogleChronicleExtraHttpHeader$outboundSchema.parse(
      outputGoogleChronicleExtraHttpHeader,
    ),
  );
}

export function outputGoogleChronicleExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleChronicleExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputGoogleChronicleExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleChronicleExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputGoogleChronicleFailedRequestLoggingMode$inboundSchema:
  z.ZodType<
    OutputGoogleChronicleFailedRequestLoggingMode,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputGoogleChronicleFailedRequestLoggingMode),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputGoogleChronicleFailedRequestLoggingMode$outboundSchema:
  z.ZodType<
    OutputGoogleChronicleFailedRequestLoggingMode,
    z.ZodTypeDef,
    OutputGoogleChronicleFailedRequestLoggingMode
  > = z.union([
    z.nativeEnum(OutputGoogleChronicleFailedRequestLoggingMode),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleFailedRequestLoggingMode$ {
  /** @deprecated use `OutputGoogleChronicleFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleChronicleFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleChronicleFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputGoogleChronicleBackpressureBehavior$inboundSchema: z.ZodType<
  OutputGoogleChronicleBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleChronicleBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleChronicleBackpressureBehavior$outboundSchema:
  z.ZodType<
    OutputGoogleChronicleBackpressureBehavior,
    z.ZodTypeDef,
    OutputGoogleChronicleBackpressureBehavior
  > = z.union([
    z.nativeEnum(OutputGoogleChronicleBackpressureBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleBackpressureBehavior$ {
  /** @deprecated use `OutputGoogleChronicleBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleChronicleBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleChronicleBackpressureBehavior$outboundSchema;
}

/** @internal */
export const ExtraLogType$inboundSchema: z.ZodType<
  ExtraLogType,
  z.ZodTypeDef,
  unknown
> = z.object({
  logType: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type ExtraLogType$Outbound = {
  logType: string;
  description?: string | undefined;
};

/** @internal */
export const ExtraLogType$outboundSchema: z.ZodType<
  ExtraLogType$Outbound,
  z.ZodTypeDef,
  ExtraLogType
> = z.object({
  logType: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraLogType$ {
  /** @deprecated use `ExtraLogType$inboundSchema` instead. */
  export const inboundSchema = ExtraLogType$inboundSchema;
  /** @deprecated use `ExtraLogType$outboundSchema` instead. */
  export const outboundSchema = ExtraLogType$outboundSchema;
  /** @deprecated use `ExtraLogType$Outbound` instead. */
  export type Outbound = ExtraLogType$Outbound;
}

export function extraLogTypeToJSON(extraLogType: ExtraLogType): string {
  return JSON.stringify(ExtraLogType$outboundSchema.parse(extraLogType));
}

export function extraLogTypeFromJSON(
  jsonString: string,
): SafeParseResult<ExtraLogType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraLogType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraLogType' from JSON`,
  );
}

/** @internal */
export const CustomLabel$inboundSchema: z.ZodType<
  CustomLabel,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  value: z.string(),
});

/** @internal */
export type CustomLabel$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const CustomLabel$outboundSchema: z.ZodType<
  CustomLabel$Outbound,
  z.ZodTypeDef,
  CustomLabel
> = z.object({
  key: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomLabel$ {
  /** @deprecated use `CustomLabel$inboundSchema` instead. */
  export const inboundSchema = CustomLabel$inboundSchema;
  /** @deprecated use `CustomLabel$outboundSchema` instead. */
  export const outboundSchema = CustomLabel$outboundSchema;
  /** @deprecated use `CustomLabel$Outbound` instead. */
  export type Outbound = CustomLabel$Outbound;
}

export function customLabelToJSON(customLabel: CustomLabel): string {
  return JSON.stringify(CustomLabel$outboundSchema.parse(customLabel));
}

export function customLabelFromJSON(
  jsonString: string,
): SafeParseResult<CustomLabel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomLabel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomLabel' from JSON`,
  );
}

/** @internal */
export const OutputGoogleChronicleCompression$inboundSchema: z.ZodType<
  OutputGoogleChronicleCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleChronicleCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleChronicleCompression$outboundSchema: z.ZodType<
  OutputGoogleChronicleCompression,
  z.ZodTypeDef,
  OutputGoogleChronicleCompression
> = z.union([
  z.nativeEnum(OutputGoogleChronicleCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleCompression$ {
  /** @deprecated use `OutputGoogleChronicleCompression$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleChronicleCompression$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleCompression$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleChronicleCompression$outboundSchema;
}

/** @internal */
export const OutputGoogleChronicleQueueFullBehavior$inboundSchema: z.ZodType<
  OutputGoogleChronicleQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleChronicleQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleChronicleQueueFullBehavior$outboundSchema: z.ZodType<
  OutputGoogleChronicleQueueFullBehavior,
  z.ZodTypeDef,
  OutputGoogleChronicleQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputGoogleChronicleQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleQueueFullBehavior$ {
  /** @deprecated use `OutputGoogleChronicleQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputGoogleChronicleQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputGoogleChronicleQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputGoogleChronicleMode$inboundSchema: z.ZodType<
  OutputGoogleChronicleMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputGoogleChronicleMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputGoogleChronicleMode$outboundSchema: z.ZodType<
  OutputGoogleChronicleMode,
  z.ZodTypeDef,
  OutputGoogleChronicleMode
> = z.union([
  z.nativeEnum(OutputGoogleChronicleMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicleMode$ {
  /** @deprecated use `OutputGoogleChronicleMode$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleChronicleMode$inboundSchema;
  /** @deprecated use `OutputGoogleChronicleMode$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleChronicleMode$outboundSchema;
}

/** @internal */
export const OutputGoogleChroniclePqControls$inboundSchema: z.ZodType<
  OutputGoogleChroniclePqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputGoogleChroniclePqControls$Outbound = {};

/** @internal */
export const OutputGoogleChroniclePqControls$outboundSchema: z.ZodType<
  OutputGoogleChroniclePqControls$Outbound,
  z.ZodTypeDef,
  OutputGoogleChroniclePqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChroniclePqControls$ {
  /** @deprecated use `OutputGoogleChroniclePqControls$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleChroniclePqControls$inboundSchema;
  /** @deprecated use `OutputGoogleChroniclePqControls$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleChroniclePqControls$outboundSchema;
  /** @deprecated use `OutputGoogleChroniclePqControls$Outbound` instead. */
  export type Outbound = OutputGoogleChroniclePqControls$Outbound;
}

export function outputGoogleChroniclePqControlsToJSON(
  outputGoogleChroniclePqControls: OutputGoogleChroniclePqControls,
): string {
  return JSON.stringify(
    OutputGoogleChroniclePqControls$outboundSchema.parse(
      outputGoogleChroniclePqControls,
    ),
  );
}

export function outputGoogleChroniclePqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleChroniclePqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGoogleChroniclePqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleChroniclePqControls' from JSON`,
  );
}

/** @internal */
export const OutputGoogleChronicle$inboundSchema: z.ZodType<
  OutputGoogleChronicle,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputGoogleChronicleType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  apiVersion: CreateOutputAPIVersion$inboundSchema.default("v1"),
  authenticationMethod: OutputGoogleChronicleAuthenticationMethod$inboundSchema
    .default("serviceAccount"),
  responseRetrySettings: z.array(
    z.lazy(() => OutputGoogleChronicleResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputGoogleChronicleTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  logFormatType: SendEventsAs$inboundSchema.default("unstructured"),
  region: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(90),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputGoogleChronicleExtraHttpHeader$inboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    OutputGoogleChronicleFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  useRoundRobinDns: z.boolean().default(false),
  onBackpressure: OutputGoogleChronicleBackpressureBehavior$inboundSchema
    .default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  extraLogTypes: z.array(z.lazy(() => ExtraLogType$inboundSchema)).optional(),
  logType: z.string().optional(),
  logTextField: z.string().optional(),
  customerId: z.string().optional(),
  namespace: z.string().optional(),
  customLabels: z.array(z.lazy(() => CustomLabel$inboundSchema)).optional(),
  apiKey: z.string().optional(),
  apiKeySecret: z.string().optional(),
  serviceAccountCredentials: z.string().optional(),
  serviceAccountCredentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGoogleChronicleCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputGoogleChronicleQueueFullBehavior$inboundSchema
    .default("block"),
  pqMode: OutputGoogleChronicleMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGoogleChroniclePqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputGoogleChronicle$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  apiVersion: string;
  authenticationMethod: string;
  responseRetrySettings?:
    | Array<OutputGoogleChronicleResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputGoogleChronicleTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  logFormatType: string;
  region?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<OutputGoogleChronicleExtraHttpHeader$Outbound>
    | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  useRoundRobinDns: boolean;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  extraLogTypes?: Array<ExtraLogType$Outbound> | undefined;
  logType?: string | undefined;
  logTextField?: string | undefined;
  customerId?: string | undefined;
  namespace?: string | undefined;
  customLabels?: Array<CustomLabel$Outbound> | undefined;
  apiKey?: string | undefined;
  apiKeySecret?: string | undefined;
  serviceAccountCredentials?: string | undefined;
  serviceAccountCredentialsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputGoogleChroniclePqControls$Outbound | undefined;
};

/** @internal */
export const OutputGoogleChronicle$outboundSchema: z.ZodType<
  OutputGoogleChronicle$Outbound,
  z.ZodTypeDef,
  OutputGoogleChronicle
> = z.object({
  id: z.string(),
  type: OutputGoogleChronicleType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  apiVersion: CreateOutputAPIVersion$outboundSchema.default("v1"),
  authenticationMethod: OutputGoogleChronicleAuthenticationMethod$outboundSchema
    .default("serviceAccount"),
  responseRetrySettings: z.array(
    z.lazy(() => OutputGoogleChronicleResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputGoogleChronicleTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  logFormatType: SendEventsAs$outboundSchema.default("unstructured"),
  region: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(90),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputGoogleChronicleExtraHttpHeader$outboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    OutputGoogleChronicleFailedRequestLoggingMode$outboundSchema.default(
      "none",
    ),
  safeHeaders: z.array(z.string()).optional(),
  useRoundRobinDns: z.boolean().default(false),
  onBackpressure: OutputGoogleChronicleBackpressureBehavior$outboundSchema
    .default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  extraLogTypes: z.array(z.lazy(() => ExtraLogType$outboundSchema)).optional(),
  logType: z.string().optional(),
  logTextField: z.string().optional(),
  customerId: z.string().optional(),
  namespace: z.string().optional(),
  customLabels: z.array(z.lazy(() => CustomLabel$outboundSchema)).optional(),
  apiKey: z.string().optional(),
  apiKeySecret: z.string().optional(),
  serviceAccountCredentials: z.string().optional(),
  serviceAccountCredentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputGoogleChronicleCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputGoogleChronicleQueueFullBehavior$outboundSchema
    .default("block"),
  pqMode: OutputGoogleChronicleMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputGoogleChroniclePqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicle$ {
  /** @deprecated use `OutputGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleChronicle$inboundSchema;
  /** @deprecated use `OutputGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleChronicle$outboundSchema;
  /** @deprecated use `OutputGoogleChronicle$Outbound` instead. */
  export type Outbound = OutputGoogleChronicle$Outbound;
}

export function outputGoogleChronicleToJSON(
  outputGoogleChronicle: OutputGoogleChronicle,
): string {
  return JSON.stringify(
    OutputGoogleChronicle$outboundSchema.parse(outputGoogleChronicle),
  );
}

export function outputGoogleChronicleFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleChronicle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGoogleChronicle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleChronicle' from JSON`,
  );
}

/** @internal */
export const OutputAzureEventhubType$inboundSchema: z.ZodType<
  OutputAzureEventhubType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubType$outboundSchema: z.ZodType<
  OutputAzureEventhubType,
  z.ZodTypeDef,
  OutputAzureEventhubType
> = z.union([
  z.nativeEnum(OutputAzureEventhubType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubType$ {
  /** @deprecated use `OutputAzureEventhubType$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhubType$inboundSchema;
  /** @deprecated use `OutputAzureEventhubType$outboundSchema` instead. */
  export const outboundSchema = OutputAzureEventhubType$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubAcknowledgments$inboundSchema: z.ZodType<
  OutputAzureEventhubAcknowledgments,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubAcknowledgments),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubAcknowledgments$outboundSchema: z.ZodType<
  OutputAzureEventhubAcknowledgments,
  z.ZodTypeDef,
  OutputAzureEventhubAcknowledgments
> = z.union([
  z.nativeEnum(OutputAzureEventhubAcknowledgments),
  z.number().and(z.custom<Unrecognized<number>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubAcknowledgments$ {
  /** @deprecated use `OutputAzureEventhubAcknowledgments$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhubAcknowledgments$inboundSchema;
  /** @deprecated use `OutputAzureEventhubAcknowledgments$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureEventhubAcknowledgments$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubRecordDataFormat$inboundSchema: z.ZodType<
  OutputAzureEventhubRecordDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubRecordDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubRecordDataFormat$outboundSchema: z.ZodType<
  OutputAzureEventhubRecordDataFormat,
  z.ZodTypeDef,
  OutputAzureEventhubRecordDataFormat
> = z.union([
  z.nativeEnum(OutputAzureEventhubRecordDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubRecordDataFormat$ {
  /** @deprecated use `OutputAzureEventhubRecordDataFormat$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureEventhubRecordDataFormat$inboundSchema;
  /** @deprecated use `OutputAzureEventhubRecordDataFormat$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureEventhubRecordDataFormat$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubSASLMechanism$inboundSchema: z.ZodType<
  OutputAzureEventhubSASLMechanism,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubSASLMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubSASLMechanism$outboundSchema: z.ZodType<
  OutputAzureEventhubSASLMechanism,
  z.ZodTypeDef,
  OutputAzureEventhubSASLMechanism
> = z.union([
  z.nativeEnum(OutputAzureEventhubSASLMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubSASLMechanism$ {
  /** @deprecated use `OutputAzureEventhubSASLMechanism$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhubSASLMechanism$inboundSchema;
  /** @deprecated use `OutputAzureEventhubSASLMechanism$outboundSchema` instead. */
  export const outboundSchema = OutputAzureEventhubSASLMechanism$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubAuthentication$inboundSchema: z.ZodType<
  OutputAzureEventhubAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: OutputAzureEventhubSASLMechanism$inboundSchema.default("plain"),
});

/** @internal */
export type OutputAzureEventhubAuthentication$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const OutputAzureEventhubAuthentication$outboundSchema: z.ZodType<
  OutputAzureEventhubAuthentication$Outbound,
  z.ZodTypeDef,
  OutputAzureEventhubAuthentication
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: OutputAzureEventhubSASLMechanism$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubAuthentication$ {
  /** @deprecated use `OutputAzureEventhubAuthentication$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhubAuthentication$inboundSchema;
  /** @deprecated use `OutputAzureEventhubAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureEventhubAuthentication$outboundSchema;
  /** @deprecated use `OutputAzureEventhubAuthentication$Outbound` instead. */
  export type Outbound = OutputAzureEventhubAuthentication$Outbound;
}

export function outputAzureEventhubAuthenticationToJSON(
  outputAzureEventhubAuthentication: OutputAzureEventhubAuthentication,
): string {
  return JSON.stringify(
    OutputAzureEventhubAuthentication$outboundSchema.parse(
      outputAzureEventhubAuthentication,
    ),
  );
}

export function outputAzureEventhubAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureEventhubAuthentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureEventhubAuthentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureEventhubAuthentication' from JSON`,
  );
}

/** @internal */
export const OutputAzureEventhubTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputAzureEventhubTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/** @internal */
export type OutputAzureEventhubTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
};

/** @internal */
export const OutputAzureEventhubTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputAzureEventhubTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputAzureEventhubTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubTLSSettingsClientSide$ {
  /** @deprecated use `OutputAzureEventhubTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureEventhubTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputAzureEventhubTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureEventhubTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputAzureEventhubTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputAzureEventhubTLSSettingsClientSide$Outbound;
}

export function outputAzureEventhubTLSSettingsClientSideToJSON(
  outputAzureEventhubTLSSettingsClientSide:
    OutputAzureEventhubTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputAzureEventhubTLSSettingsClientSide$outboundSchema.parse(
      outputAzureEventhubTLSSettingsClientSide,
    ),
  );
}

export function outputAzureEventhubTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputAzureEventhubTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputAzureEventhubTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputAzureEventhubTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputAzureEventhubBackpressureBehavior$inboundSchema: z.ZodType<
  OutputAzureEventhubBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubBackpressureBehavior$outboundSchema: z.ZodType<
  OutputAzureEventhubBackpressureBehavior,
  z.ZodTypeDef,
  OutputAzureEventhubBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputAzureEventhubBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubBackpressureBehavior$ {
  /** @deprecated use `OutputAzureEventhubBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureEventhubBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputAzureEventhubBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureEventhubBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubCompression$inboundSchema: z.ZodType<
  OutputAzureEventhubCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubCompression$outboundSchema: z.ZodType<
  OutputAzureEventhubCompression,
  z.ZodTypeDef,
  OutputAzureEventhubCompression
> = z.union([
  z.nativeEnum(OutputAzureEventhubCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubCompression$ {
  /** @deprecated use `OutputAzureEventhubCompression$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhubCompression$inboundSchema;
  /** @deprecated use `OutputAzureEventhubCompression$outboundSchema` instead. */
  export const outboundSchema = OutputAzureEventhubCompression$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubQueueFullBehavior$inboundSchema: z.ZodType<
  OutputAzureEventhubQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubQueueFullBehavior$outboundSchema: z.ZodType<
  OutputAzureEventhubQueueFullBehavior,
  z.ZodTypeDef,
  OutputAzureEventhubQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputAzureEventhubQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubQueueFullBehavior$ {
  /** @deprecated use `OutputAzureEventhubQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureEventhubQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputAzureEventhubQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureEventhubQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubMode$inboundSchema: z.ZodType<
  OutputAzureEventhubMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureEventhubMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureEventhubMode$outboundSchema: z.ZodType<
  OutputAzureEventhubMode,
  z.ZodTypeDef,
  OutputAzureEventhubMode
> = z.union([
  z.nativeEnum(OutputAzureEventhubMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubMode$ {
  /** @deprecated use `OutputAzureEventhubMode$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhubMode$inboundSchema;
  /** @deprecated use `OutputAzureEventhubMode$outboundSchema` instead. */
  export const outboundSchema = OutputAzureEventhubMode$outboundSchema;
}

/** @internal */
export const OutputAzureEventhubPqControls$inboundSchema: z.ZodType<
  OutputAzureEventhubPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputAzureEventhubPqControls$Outbound = {};

/** @internal */
export const OutputAzureEventhubPqControls$outboundSchema: z.ZodType<
  OutputAzureEventhubPqControls$Outbound,
  z.ZodTypeDef,
  OutputAzureEventhubPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhubPqControls$ {
  /** @deprecated use `OutputAzureEventhubPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhubPqControls$inboundSchema;
  /** @deprecated use `OutputAzureEventhubPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputAzureEventhubPqControls$outboundSchema;
  /** @deprecated use `OutputAzureEventhubPqControls$Outbound` instead. */
  export type Outbound = OutputAzureEventhubPqControls$Outbound;
}

export function outputAzureEventhubPqControlsToJSON(
  outputAzureEventhubPqControls: OutputAzureEventhubPqControls,
): string {
  return JSON.stringify(
    OutputAzureEventhubPqControls$outboundSchema.parse(
      outputAzureEventhubPqControls,
    ),
  );
}

export function outputAzureEventhubPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureEventhubPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureEventhubPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureEventhubPqControls' from JSON`,
  );
}

/** @internal */
export const OutputAzureEventhub$inboundSchema: z.ZodType<
  OutputAzureEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputAzureEventhubType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: OutputAzureEventhubAcknowledgments$inboundSchema.default(1),
  format: OutputAzureEventhubRecordDataFormat$inboundSchema.default("json"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => OutputAzureEventhubAuthentication$inboundSchema)
    .optional(),
  tls: z.lazy(() => OutputAzureEventhubTLSSettingsClientSide$inboundSchema)
    .optional(),
  onBackpressure: OutputAzureEventhubBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputAzureEventhubCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputAzureEventhubQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputAzureEventhubMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputAzureEventhubPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputAzureEventhub$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  topic: string;
  ack: number;
  format: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: OutputAzureEventhubAuthentication$Outbound | undefined;
  tls?: OutputAzureEventhubTLSSettingsClientSide$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputAzureEventhubPqControls$Outbound | undefined;
};

/** @internal */
export const OutputAzureEventhub$outboundSchema: z.ZodType<
  OutputAzureEventhub$Outbound,
  z.ZodTypeDef,
  OutputAzureEventhub
> = z.object({
  id: z.string(),
  type: OutputAzureEventhubType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: OutputAzureEventhubAcknowledgments$outboundSchema.default(1),
  format: OutputAzureEventhubRecordDataFormat$outboundSchema.default("json"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => OutputAzureEventhubAuthentication$outboundSchema)
    .optional(),
  tls: z.lazy(() => OutputAzureEventhubTLSSettingsClientSide$outboundSchema)
    .optional(),
  onBackpressure: OutputAzureEventhubBackpressureBehavior$outboundSchema
    .default("block"),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputAzureEventhubCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputAzureEventhubQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputAzureEventhubMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputAzureEventhubPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhub$ {
  /** @deprecated use `OutputAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhub$inboundSchema;
  /** @deprecated use `OutputAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = OutputAzureEventhub$outboundSchema;
  /** @deprecated use `OutputAzureEventhub$Outbound` instead. */
  export type Outbound = OutputAzureEventhub$Outbound;
}

export function outputAzureEventhubToJSON(
  outputAzureEventhub: OutputAzureEventhub,
): string {
  return JSON.stringify(
    OutputAzureEventhub$outboundSchema.parse(outputAzureEventhub),
  );
}

export function outputAzureEventhubFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureEventhub' from JSON`,
  );
}

/** @internal */
export const OutputHoneycombType$inboundSchema: z.ZodType<
  OutputHoneycombType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHoneycombType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHoneycombType$outboundSchema: z.ZodType<
  OutputHoneycombType,
  z.ZodTypeDef,
  OutputHoneycombType
> = z.union([
  z.nativeEnum(OutputHoneycombType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombType$ {
  /** @deprecated use `OutputHoneycombType$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycombType$inboundSchema;
  /** @deprecated use `OutputHoneycombType$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycombType$outboundSchema;
}

/** @internal */
export const OutputHoneycombExtraHttpHeader$inboundSchema: z.ZodType<
  OutputHoneycombExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputHoneycombExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputHoneycombExtraHttpHeader$outboundSchema: z.ZodType<
  OutputHoneycombExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputHoneycombExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombExtraHttpHeader$ {
  /** @deprecated use `OutputHoneycombExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycombExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputHoneycombExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycombExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputHoneycombExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputHoneycombExtraHttpHeader$Outbound;
}

export function outputHoneycombExtraHttpHeaderToJSON(
  outputHoneycombExtraHttpHeader: OutputHoneycombExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputHoneycombExtraHttpHeader$outboundSchema.parse(
      outputHoneycombExtraHttpHeader,
    ),
  );
}

export function outputHoneycombExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputHoneycombExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHoneycombExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHoneycombExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputHoneycombFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputHoneycombFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHoneycombFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHoneycombFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputHoneycombFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputHoneycombFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputHoneycombFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombFailedRequestLoggingMode$ {
  /** @deprecated use `OutputHoneycombFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputHoneycombFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputHoneycombFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputHoneycombFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputHoneycombResponseRetrySetting$inboundSchema: z.ZodType<
  OutputHoneycombResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputHoneycombResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputHoneycombResponseRetrySetting$outboundSchema: z.ZodType<
  OutputHoneycombResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputHoneycombResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombResponseRetrySetting$ {
  /** @deprecated use `OutputHoneycombResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputHoneycombResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputHoneycombResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputHoneycombResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputHoneycombResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputHoneycombResponseRetrySetting$Outbound;
}

export function outputHoneycombResponseRetrySettingToJSON(
  outputHoneycombResponseRetrySetting: OutputHoneycombResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputHoneycombResponseRetrySetting$outboundSchema.parse(
      outputHoneycombResponseRetrySetting,
    ),
  );
}

export function outputHoneycombResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputHoneycombResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputHoneycombResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHoneycombResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputHoneycombTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputHoneycombTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputHoneycombTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputHoneycombTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputHoneycombTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputHoneycombTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombTimeoutRetrySettings$ {
  /** @deprecated use `OutputHoneycombTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputHoneycombTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputHoneycombTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputHoneycombTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputHoneycombTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputHoneycombTimeoutRetrySettings$Outbound;
}

export function outputHoneycombTimeoutRetrySettingsToJSON(
  outputHoneycombTimeoutRetrySettings: OutputHoneycombTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputHoneycombTimeoutRetrySettings$outboundSchema.parse(
      outputHoneycombTimeoutRetrySettings,
    ),
  );
}

export function outputHoneycombTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputHoneycombTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputHoneycombTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHoneycombTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputHoneycombBackpressureBehavior$inboundSchema: z.ZodType<
  OutputHoneycombBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHoneycombBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHoneycombBackpressureBehavior$outboundSchema: z.ZodType<
  OutputHoneycombBackpressureBehavior,
  z.ZodTypeDef,
  OutputHoneycombBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputHoneycombBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombBackpressureBehavior$ {
  /** @deprecated use `OutputHoneycombBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputHoneycombBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputHoneycombBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputHoneycombBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputHoneycombAuthenticationMethod$inboundSchema: z.ZodType<
  OutputHoneycombAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHoneycombAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHoneycombAuthenticationMethod$outboundSchema: z.ZodType<
  OutputHoneycombAuthenticationMethod,
  z.ZodTypeDef,
  OutputHoneycombAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputHoneycombAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombAuthenticationMethod$ {
  /** @deprecated use `OutputHoneycombAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputHoneycombAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputHoneycombAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputHoneycombAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputHoneycombCompression$inboundSchema: z.ZodType<
  OutputHoneycombCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHoneycombCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHoneycombCompression$outboundSchema: z.ZodType<
  OutputHoneycombCompression,
  z.ZodTypeDef,
  OutputHoneycombCompression
> = z.union([
  z.nativeEnum(OutputHoneycombCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombCompression$ {
  /** @deprecated use `OutputHoneycombCompression$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycombCompression$inboundSchema;
  /** @deprecated use `OutputHoneycombCompression$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycombCompression$outboundSchema;
}

/** @internal */
export const OutputHoneycombQueueFullBehavior$inboundSchema: z.ZodType<
  OutputHoneycombQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHoneycombQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHoneycombQueueFullBehavior$outboundSchema: z.ZodType<
  OutputHoneycombQueueFullBehavior,
  z.ZodTypeDef,
  OutputHoneycombQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputHoneycombQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombQueueFullBehavior$ {
  /** @deprecated use `OutputHoneycombQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycombQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputHoneycombQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycombQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputHoneycombMode$inboundSchema: z.ZodType<
  OutputHoneycombMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputHoneycombMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputHoneycombMode$outboundSchema: z.ZodType<
  OutputHoneycombMode,
  z.ZodTypeDef,
  OutputHoneycombMode
> = z.union([
  z.nativeEnum(OutputHoneycombMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombMode$ {
  /** @deprecated use `OutputHoneycombMode$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycombMode$inboundSchema;
  /** @deprecated use `OutputHoneycombMode$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycombMode$outboundSchema;
}

/** @internal */
export const OutputHoneycombPqControls$inboundSchema: z.ZodType<
  OutputHoneycombPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputHoneycombPqControls$Outbound = {};

/** @internal */
export const OutputHoneycombPqControls$outboundSchema: z.ZodType<
  OutputHoneycombPqControls$Outbound,
  z.ZodTypeDef,
  OutputHoneycombPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycombPqControls$ {
  /** @deprecated use `OutputHoneycombPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycombPqControls$inboundSchema;
  /** @deprecated use `OutputHoneycombPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycombPqControls$outboundSchema;
  /** @deprecated use `OutputHoneycombPqControls$Outbound` instead. */
  export type Outbound = OutputHoneycombPqControls$Outbound;
}

export function outputHoneycombPqControlsToJSON(
  outputHoneycombPqControls: OutputHoneycombPqControls,
): string {
  return JSON.stringify(
    OutputHoneycombPqControls$outboundSchema.parse(outputHoneycombPqControls),
  );
}

export function outputHoneycombPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputHoneycombPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHoneycombPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHoneycombPqControls' from JSON`,
  );
}

/** @internal */
export const OutputHoneycomb$inboundSchema: z.ZodType<
  OutputHoneycomb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputHoneycombType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dataset: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputHoneycombExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputHoneycombFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputHoneycombResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputHoneycombTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputHoneycombBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  authType: OutputHoneycombAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputHoneycombCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputHoneycombQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputHoneycombMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputHoneycombPqControls$inboundSchema).optional(),
  team: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputHoneycomb$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  dataset: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputHoneycombExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputHoneycombResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputHoneycombTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputHoneycombPqControls$Outbound | undefined;
  team?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputHoneycomb$outboundSchema: z.ZodType<
  OutputHoneycomb$Outbound,
  z.ZodTypeDef,
  OutputHoneycomb
> = z.object({
  id: z.string(),
  type: OutputHoneycombType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dataset: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputHoneycombExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputHoneycombFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputHoneycombResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputHoneycombTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputHoneycombBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  authType: OutputHoneycombAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputHoneycombCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputHoneycombQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputHoneycombMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputHoneycombPqControls$outboundSchema).optional(),
  team: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycomb$ {
  /** @deprecated use `OutputHoneycomb$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycomb$inboundSchema;
  /** @deprecated use `OutputHoneycomb$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycomb$outboundSchema;
  /** @deprecated use `OutputHoneycomb$Outbound` instead. */
  export type Outbound = OutputHoneycomb$Outbound;
}

export function outputHoneycombToJSON(
  outputHoneycomb: OutputHoneycomb,
): string {
  return JSON.stringify(OutputHoneycomb$outboundSchema.parse(outputHoneycomb));
}

export function outputHoneycombFromJSON(
  jsonString: string,
): SafeParseResult<OutputHoneycomb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHoneycomb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHoneycomb' from JSON`,
  );
}

/** @internal */
export const OutputKinesisType$inboundSchema: z.ZodType<
  OutputKinesisType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisType$outboundSchema: z.ZodType<
  OutputKinesisType,
  z.ZodTypeDef,
  OutputKinesisType
> = z.union([
  z.nativeEnum(OutputKinesisType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisType$ {
  /** @deprecated use `OutputKinesisType$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisType$inboundSchema;
  /** @deprecated use `OutputKinesisType$outboundSchema` instead. */
  export const outboundSchema = OutputKinesisType$outboundSchema;
}

/** @internal */
export const OutputKinesisAuthenticationMethod$inboundSchema: z.ZodType<
  OutputKinesisAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisAuthenticationMethod$outboundSchema: z.ZodType<
  OutputKinesisAuthenticationMethod,
  z.ZodTypeDef,
  OutputKinesisAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputKinesisAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisAuthenticationMethod$ {
  /** @deprecated use `OutputKinesisAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputKinesisAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputKinesisAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputKinesisSignatureVersion$inboundSchema: z.ZodType<
  OutputKinesisSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisSignatureVersion$outboundSchema: z.ZodType<
  OutputKinesisSignatureVersion,
  z.ZodTypeDef,
  OutputKinesisSignatureVersion
> = z.union([
  z.nativeEnum(OutputKinesisSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisSignatureVersion$ {
  /** @deprecated use `OutputKinesisSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisSignatureVersion$inboundSchema;
  /** @deprecated use `OutputKinesisSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputKinesisSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputKinesisCompression$inboundSchema: z.ZodType<
  OutputKinesisCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisCompression$outboundSchema: z.ZodType<
  OutputKinesisCompression,
  z.ZodTypeDef,
  OutputKinesisCompression
> = z.union([
  z.nativeEnum(OutputKinesisCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisCompression$ {
  /** @deprecated use `OutputKinesisCompression$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisCompression$inboundSchema;
  /** @deprecated use `OutputKinesisCompression$outboundSchema` instead. */
  export const outboundSchema = OutputKinesisCompression$outboundSchema;
}

/** @internal */
export const OutputKinesisBackpressureBehavior$inboundSchema: z.ZodType<
  OutputKinesisBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisBackpressureBehavior$outboundSchema: z.ZodType<
  OutputKinesisBackpressureBehavior,
  z.ZodTypeDef,
  OutputKinesisBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputKinesisBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisBackpressureBehavior$ {
  /** @deprecated use `OutputKinesisBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputKinesisBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputKinesisBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputKinesisPqCompressCompression$inboundSchema: z.ZodType<
  OutputKinesisPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisPqCompressCompression$outboundSchema: z.ZodType<
  OutputKinesisPqCompressCompression,
  z.ZodTypeDef,
  OutputKinesisPqCompressCompression
> = z.union([
  z.nativeEnum(OutputKinesisPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisPqCompressCompression$ {
  /** @deprecated use `OutputKinesisPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputKinesisPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputKinesisPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputKinesisQueueFullBehavior$inboundSchema: z.ZodType<
  OutputKinesisQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisQueueFullBehavior$outboundSchema: z.ZodType<
  OutputKinesisQueueFullBehavior,
  z.ZodTypeDef,
  OutputKinesisQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputKinesisQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisQueueFullBehavior$ {
  /** @deprecated use `OutputKinesisQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputKinesisQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputKinesisQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputKinesisMode$inboundSchema: z.ZodType<
  OutputKinesisMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputKinesisMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputKinesisMode$outboundSchema: z.ZodType<
  OutputKinesisMode,
  z.ZodTypeDef,
  OutputKinesisMode
> = z.union([
  z.nativeEnum(OutputKinesisMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisMode$ {
  /** @deprecated use `OutputKinesisMode$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisMode$inboundSchema;
  /** @deprecated use `OutputKinesisMode$outboundSchema` instead. */
  export const outboundSchema = OutputKinesisMode$outboundSchema;
}

/** @internal */
export const OutputKinesisPqControls$inboundSchema: z.ZodType<
  OutputKinesisPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputKinesisPqControls$Outbound = {};

/** @internal */
export const OutputKinesisPqControls$outboundSchema: z.ZodType<
  OutputKinesisPqControls$Outbound,
  z.ZodTypeDef,
  OutputKinesisPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesisPqControls$ {
  /** @deprecated use `OutputKinesisPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputKinesisPqControls$inboundSchema;
  /** @deprecated use `OutputKinesisPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputKinesisPqControls$outboundSchema;
  /** @deprecated use `OutputKinesisPqControls$Outbound` instead. */
  export type Outbound = OutputKinesisPqControls$Outbound;
}

export function outputKinesisPqControlsToJSON(
  outputKinesisPqControls: OutputKinesisPqControls,
): string {
  return JSON.stringify(
    OutputKinesisPqControls$outboundSchema.parse(outputKinesisPqControls),
  );
}

export function outputKinesisPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputKinesisPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKinesisPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKinesisPqControls' from JSON`,
  );
}

/** @internal */
export const OutputKinesis$inboundSchema: z.ZodType<
  OutputKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputKinesisType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  streamName: z.string(),
  awsAuthenticationMethod: OutputKinesisAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: OutputKinesisSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  concurrency: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  compression: OutputKinesisCompression$inboundSchema.default("gzip"),
  useListShards: z.boolean().default(false),
  asNdjson: z.boolean().default(true),
  onBackpressure: OutputKinesisBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputKinesisPqCompressCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputKinesisQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputKinesisMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputKinesisPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputKinesis$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  streamName: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  concurrency: number;
  maxRecordSizeKB: number;
  flushPeriodSec: number;
  compression: string;
  useListShards: boolean;
  asNdjson: boolean;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputKinesisPqControls$Outbound | undefined;
};

/** @internal */
export const OutputKinesis$outboundSchema: z.ZodType<
  OutputKinesis$Outbound,
  z.ZodTypeDef,
  OutputKinesis
> = z.object({
  id: z.string(),
  type: OutputKinesisType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  streamName: z.string(),
  awsAuthenticationMethod: OutputKinesisAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: OutputKinesisSignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  concurrency: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  compression: OutputKinesisCompression$outboundSchema.default("gzip"),
  useListShards: z.boolean().default(false),
  asNdjson: z.boolean().default(true),
  onBackpressure: OutputKinesisBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputKinesisPqCompressCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputKinesisQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputKinesisMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputKinesisPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesis$ {
  /** @deprecated use `OutputKinesis$inboundSchema` instead. */
  export const inboundSchema = OutputKinesis$inboundSchema;
  /** @deprecated use `OutputKinesis$outboundSchema` instead. */
  export const outboundSchema = OutputKinesis$outboundSchema;
  /** @deprecated use `OutputKinesis$Outbound` instead. */
  export type Outbound = OutputKinesis$Outbound;
}

export function outputKinesisToJSON(outputKinesis: OutputKinesis): string {
  return JSON.stringify(OutputKinesis$outboundSchema.parse(outputKinesis));
}

export function outputKinesisFromJSON(
  jsonString: string,
): SafeParseResult<OutputKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKinesis' from JSON`,
  );
}

/** @internal */
export const OutputAzureLogsType$inboundSchema: z.ZodType<
  OutputAzureLogsType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureLogsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureLogsType$outboundSchema: z.ZodType<
  OutputAzureLogsType,
  z.ZodTypeDef,
  OutputAzureLogsType
> = z.union([
  z.nativeEnum(OutputAzureLogsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsType$ {
  /** @deprecated use `OutputAzureLogsType$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogsType$inboundSchema;
  /** @deprecated use `OutputAzureLogsType$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogsType$outboundSchema;
}

/** @internal */
export const OutputAzureLogsExtraHttpHeader$inboundSchema: z.ZodType<
  OutputAzureLogsExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputAzureLogsExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputAzureLogsExtraHttpHeader$outboundSchema: z.ZodType<
  OutputAzureLogsExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputAzureLogsExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsExtraHttpHeader$ {
  /** @deprecated use `OutputAzureLogsExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogsExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputAzureLogsExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogsExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputAzureLogsExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputAzureLogsExtraHttpHeader$Outbound;
}

export function outputAzureLogsExtraHttpHeaderToJSON(
  outputAzureLogsExtraHttpHeader: OutputAzureLogsExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputAzureLogsExtraHttpHeader$outboundSchema.parse(
      outputAzureLogsExtraHttpHeader,
    ),
  );
}

export function outputAzureLogsExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureLogsExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureLogsExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureLogsExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputAzureLogsFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputAzureLogsFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureLogsFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureLogsFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputAzureLogsFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputAzureLogsFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputAzureLogsFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsFailedRequestLoggingMode$ {
  /** @deprecated use `OutputAzureLogsFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureLogsFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputAzureLogsFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureLogsFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputAzureLogsResponseRetrySetting$inboundSchema: z.ZodType<
  OutputAzureLogsResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputAzureLogsResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputAzureLogsResponseRetrySetting$outboundSchema: z.ZodType<
  OutputAzureLogsResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputAzureLogsResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsResponseRetrySetting$ {
  /** @deprecated use `OutputAzureLogsResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureLogsResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputAzureLogsResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureLogsResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputAzureLogsResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputAzureLogsResponseRetrySetting$Outbound;
}

export function outputAzureLogsResponseRetrySettingToJSON(
  outputAzureLogsResponseRetrySetting: OutputAzureLogsResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputAzureLogsResponseRetrySetting$outboundSchema.parse(
      outputAzureLogsResponseRetrySetting,
    ),
  );
}

export function outputAzureLogsResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureLogsResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputAzureLogsResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureLogsResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputAzureLogsTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputAzureLogsTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputAzureLogsTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputAzureLogsTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputAzureLogsTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputAzureLogsTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsTimeoutRetrySettings$ {
  /** @deprecated use `OutputAzureLogsTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureLogsTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputAzureLogsTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureLogsTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputAzureLogsTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputAzureLogsTimeoutRetrySettings$Outbound;
}

export function outputAzureLogsTimeoutRetrySettingsToJSON(
  outputAzureLogsTimeoutRetrySettings: OutputAzureLogsTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputAzureLogsTimeoutRetrySettings$outboundSchema.parse(
      outputAzureLogsTimeoutRetrySettings,
    ),
  );
}

export function outputAzureLogsTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureLogsTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputAzureLogsTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureLogsTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputAzureLogsBackpressureBehavior$inboundSchema: z.ZodType<
  OutputAzureLogsBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureLogsBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureLogsBackpressureBehavior$outboundSchema: z.ZodType<
  OutputAzureLogsBackpressureBehavior,
  z.ZodTypeDef,
  OutputAzureLogsBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputAzureLogsBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsBackpressureBehavior$ {
  /** @deprecated use `OutputAzureLogsBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureLogsBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputAzureLogsBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureLogsBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputAzureLogsAuthenticationMethod$inboundSchema: z.ZodType<
  OutputAzureLogsAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureLogsAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureLogsAuthenticationMethod$outboundSchema: z.ZodType<
  OutputAzureLogsAuthenticationMethod,
  z.ZodTypeDef,
  OutputAzureLogsAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputAzureLogsAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsAuthenticationMethod$ {
  /** @deprecated use `OutputAzureLogsAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureLogsAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputAzureLogsAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureLogsAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputAzureLogsCompression$inboundSchema: z.ZodType<
  OutputAzureLogsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureLogsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureLogsCompression$outboundSchema: z.ZodType<
  OutputAzureLogsCompression,
  z.ZodTypeDef,
  OutputAzureLogsCompression
> = z.union([
  z.nativeEnum(OutputAzureLogsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsCompression$ {
  /** @deprecated use `OutputAzureLogsCompression$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogsCompression$inboundSchema;
  /** @deprecated use `OutputAzureLogsCompression$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogsCompression$outboundSchema;
}

/** @internal */
export const OutputAzureLogsQueueFullBehavior$inboundSchema: z.ZodType<
  OutputAzureLogsQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureLogsQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureLogsQueueFullBehavior$outboundSchema: z.ZodType<
  OutputAzureLogsQueueFullBehavior,
  z.ZodTypeDef,
  OutputAzureLogsQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputAzureLogsQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsQueueFullBehavior$ {
  /** @deprecated use `OutputAzureLogsQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogsQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputAzureLogsQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogsQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputAzureLogsMode$inboundSchema: z.ZodType<
  OutputAzureLogsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureLogsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureLogsMode$outboundSchema: z.ZodType<
  OutputAzureLogsMode,
  z.ZodTypeDef,
  OutputAzureLogsMode
> = z.union([
  z.nativeEnum(OutputAzureLogsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsMode$ {
  /** @deprecated use `OutputAzureLogsMode$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogsMode$inboundSchema;
  /** @deprecated use `OutputAzureLogsMode$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogsMode$outboundSchema;
}

/** @internal */
export const OutputAzureLogsPqControls$inboundSchema: z.ZodType<
  OutputAzureLogsPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputAzureLogsPqControls$Outbound = {};

/** @internal */
export const OutputAzureLogsPqControls$outboundSchema: z.ZodType<
  OutputAzureLogsPqControls$Outbound,
  z.ZodTypeDef,
  OutputAzureLogsPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogsPqControls$ {
  /** @deprecated use `OutputAzureLogsPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogsPqControls$inboundSchema;
  /** @deprecated use `OutputAzureLogsPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogsPqControls$outboundSchema;
  /** @deprecated use `OutputAzureLogsPqControls$Outbound` instead. */
  export type Outbound = OutputAzureLogsPqControls$Outbound;
}

export function outputAzureLogsPqControlsToJSON(
  outputAzureLogsPqControls: OutputAzureLogsPqControls,
): string {
  return JSON.stringify(
    OutputAzureLogsPqControls$outboundSchema.parse(outputAzureLogsPqControls),
  );
}

export function outputAzureLogsPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureLogsPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureLogsPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureLogsPqControls' from JSON`,
  );
}

/** @internal */
export const OutputAzureLogs$inboundSchema: z.ZodType<
  OutputAzureLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputAzureLogsType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logType: z.string().default("Cribl"),
  resourceId: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputAzureLogsExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputAzureLogsFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  apiUrl: z.string().default(".ods.opinsights.azure.com"),
  responseRetrySettings: z.array(
    z.lazy(() => OutputAzureLogsResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputAzureLogsTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputAzureLogsBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  authType: OutputAzureLogsAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputAzureLogsCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputAzureLogsQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputAzureLogsMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputAzureLogsPqControls$inboundSchema).optional(),
  workspaceId: z.string().optional(),
  workspaceKey: z.string().optional(),
  keypairSecret: z.string().optional(),
});

/** @internal */
export type OutputAzureLogs$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  logType: string;
  resourceId?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress?: boolean | undefined;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputAzureLogsExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  apiUrl: string;
  responseRetrySettings?:
    | Array<OutputAzureLogsResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputAzureLogsTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputAzureLogsPqControls$Outbound | undefined;
  workspaceId?: string | undefined;
  workspaceKey?: string | undefined;
  keypairSecret?: string | undefined;
};

/** @internal */
export const OutputAzureLogs$outboundSchema: z.ZodType<
  OutputAzureLogs$Outbound,
  z.ZodTypeDef,
  OutputAzureLogs
> = z.object({
  id: z.string(),
  type: OutputAzureLogsType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logType: z.string().default("Cribl"),
  resourceId: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputAzureLogsExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputAzureLogsFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  apiUrl: z.string().default(".ods.opinsights.azure.com"),
  responseRetrySettings: z.array(
    z.lazy(() => OutputAzureLogsResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputAzureLogsTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputAzureLogsBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  authType: OutputAzureLogsAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputAzureLogsCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputAzureLogsQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputAzureLogsMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputAzureLogsPqControls$outboundSchema).optional(),
  workspaceId: z.string().optional(),
  workspaceKey: z.string().optional(),
  keypairSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogs$ {
  /** @deprecated use `OutputAzureLogs$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogs$inboundSchema;
  /** @deprecated use `OutputAzureLogs$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogs$outboundSchema;
  /** @deprecated use `OutputAzureLogs$Outbound` instead. */
  export type Outbound = OutputAzureLogs$Outbound;
}

export function outputAzureLogsToJSON(
  outputAzureLogs: OutputAzureLogs,
): string {
  return JSON.stringify(OutputAzureLogs$outboundSchema.parse(outputAzureLogs));
}

export function outputAzureLogsFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureLogs' from JSON`,
  );
}

/** @internal */
export const OutputAzureDataExplorerType$inboundSchema: z.ZodType<
  OutputAzureDataExplorerType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureDataExplorerType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureDataExplorerType$outboundSchema: z.ZodType<
  OutputAzureDataExplorerType,
  z.ZodTypeDef,
  OutputAzureDataExplorerType
> = z.union([
  z.nativeEnum(OutputAzureDataExplorerType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerType$ {
  /** @deprecated use `OutputAzureDataExplorerType$inboundSchema` instead. */
  export const inboundSchema = OutputAzureDataExplorerType$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerType$outboundSchema` instead. */
  export const outboundSchema = OutputAzureDataExplorerType$outboundSchema;
}

/** @internal */
export const IngestionMode$inboundSchema: z.ZodType<
  IngestionMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(IngestionMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const IngestionMode$outboundSchema: z.ZodType<
  IngestionMode,
  z.ZodTypeDef,
  IngestionMode
> = z.union([
  z.nativeEnum(IngestionMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngestionMode$ {
  /** @deprecated use `IngestionMode$inboundSchema` instead. */
  export const inboundSchema = IngestionMode$inboundSchema;
  /** @deprecated use `IngestionMode$outboundSchema` instead. */
  export const outboundSchema = IngestionMode$outboundSchema;
}

/** @internal */
export const MicrosoftEntraIDAuthenticationEndpoint$inboundSchema: z.ZodType<
  MicrosoftEntraIDAuthenticationEndpoint,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(MicrosoftEntraIDAuthenticationEndpoint),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const MicrosoftEntraIDAuthenticationEndpoint$outboundSchema: z.ZodType<
  MicrosoftEntraIDAuthenticationEndpoint,
  z.ZodTypeDef,
  MicrosoftEntraIDAuthenticationEndpoint
> = z.union([
  z.nativeEnum(MicrosoftEntraIDAuthenticationEndpoint),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MicrosoftEntraIDAuthenticationEndpoint$ {
  /** @deprecated use `MicrosoftEntraIDAuthenticationEndpoint$inboundSchema` instead. */
  export const inboundSchema =
    MicrosoftEntraIDAuthenticationEndpoint$inboundSchema;
  /** @deprecated use `MicrosoftEntraIDAuthenticationEndpoint$outboundSchema` instead. */
  export const outboundSchema =
    MicrosoftEntraIDAuthenticationEndpoint$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerAuthenticationMethod$inboundSchema:
  z.ZodType<
    OutputAzureDataExplorerAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputAzureDataExplorerAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputAzureDataExplorerAuthenticationMethod$outboundSchema:
  z.ZodType<
    OutputAzureDataExplorerAuthenticationMethod,
    z.ZodTypeDef,
    OutputAzureDataExplorerAuthenticationMethod
  > = z.union([
    z.nativeEnum(OutputAzureDataExplorerAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerAuthenticationMethod$ {
  /** @deprecated use `OutputAzureDataExplorerAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerCertificate$inboundSchema: z.ZodType<
  OutputAzureDataExplorerCertificate,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string().optional(),
});

/** @internal */
export type OutputAzureDataExplorerCertificate$Outbound = {
  certificateName?: string | undefined;
};

/** @internal */
export const OutputAzureDataExplorerCertificate$outboundSchema: z.ZodType<
  OutputAzureDataExplorerCertificate$Outbound,
  z.ZodTypeDef,
  OutputAzureDataExplorerCertificate
> = z.object({
  certificateName: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerCertificate$ {
  /** @deprecated use `OutputAzureDataExplorerCertificate$inboundSchema` instead. */
  export const inboundSchema = OutputAzureDataExplorerCertificate$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerCertificate$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerCertificate$outboundSchema;
  /** @deprecated use `OutputAzureDataExplorerCertificate$Outbound` instead. */
  export type Outbound = OutputAzureDataExplorerCertificate$Outbound;
}

export function outputAzureDataExplorerCertificateToJSON(
  outputAzureDataExplorerCertificate: OutputAzureDataExplorerCertificate,
): string {
  return JSON.stringify(
    OutputAzureDataExplorerCertificate$outboundSchema.parse(
      outputAzureDataExplorerCertificate,
    ),
  );
}

export function outputAzureDataExplorerCertificateFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureDataExplorerCertificate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputAzureDataExplorerCertificate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureDataExplorerCertificate' from JSON`,
  );
}

/** @internal */
export const OutputAzureDataExplorerBackpressureBehavior$inboundSchema:
  z.ZodType<
    OutputAzureDataExplorerBackpressureBehavior,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputAzureDataExplorerBackpressureBehavior),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputAzureDataExplorerBackpressureBehavior$outboundSchema:
  z.ZodType<
    OutputAzureDataExplorerBackpressureBehavior,
    z.ZodTypeDef,
    OutputAzureDataExplorerBackpressureBehavior
  > = z.union([
    z.nativeEnum(OutputAzureDataExplorerBackpressureBehavior),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerBackpressureBehavior$ {
  /** @deprecated use `OutputAzureDataExplorerBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerDataFormat$inboundSchema: z.ZodType<
  OutputAzureDataExplorerDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureDataExplorerDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureDataExplorerDataFormat$outboundSchema: z.ZodType<
  OutputAzureDataExplorerDataFormat,
  z.ZodTypeDef,
  OutputAzureDataExplorerDataFormat
> = z.union([
  z.nativeEnum(OutputAzureDataExplorerDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerDataFormat$ {
  /** @deprecated use `OutputAzureDataExplorerDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputAzureDataExplorerDataFormat$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerDataFormat$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerDataFormat$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerDiskSpaceProtection$inboundSchema:
  z.ZodType<OutputAzureDataExplorerDiskSpaceProtection, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(OutputAzureDataExplorerDiskSpaceProtection),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const OutputAzureDataExplorerDiskSpaceProtection$outboundSchema:
  z.ZodType<
    OutputAzureDataExplorerDiskSpaceProtection,
    z.ZodTypeDef,
    OutputAzureDataExplorerDiskSpaceProtection
  > = z.union([
    z.nativeEnum(OutputAzureDataExplorerDiskSpaceProtection),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerDiskSpaceProtection$ {
  /** @deprecated use `OutputAzureDataExplorerDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const PrefixOptional$inboundSchema: z.ZodType<
  PrefixOptional,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PrefixOptional),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PrefixOptional$outboundSchema: z.ZodType<
  PrefixOptional,
  z.ZodTypeDef,
  PrefixOptional
> = z.union([
  z.nativeEnum(PrefixOptional),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrefixOptional$ {
  /** @deprecated use `PrefixOptional$inboundSchema` instead. */
  export const inboundSchema = PrefixOptional$inboundSchema;
  /** @deprecated use `PrefixOptional$outboundSchema` instead. */
  export const outboundSchema = PrefixOptional$outboundSchema;
}

/** @internal */
export const ExtentTag$inboundSchema: z.ZodType<
  ExtentTag,
  z.ZodTypeDef,
  unknown
> = z.object({
  prefix: PrefixOptional$inboundSchema.optional(),
  value: z.string(),
});

/** @internal */
export type ExtentTag$Outbound = {
  prefix?: string | undefined;
  value: string;
};

/** @internal */
export const ExtentTag$outboundSchema: z.ZodType<
  ExtentTag$Outbound,
  z.ZodTypeDef,
  ExtentTag
> = z.object({
  prefix: PrefixOptional$outboundSchema.optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtentTag$ {
  /** @deprecated use `ExtentTag$inboundSchema` instead. */
  export const inboundSchema = ExtentTag$inboundSchema;
  /** @deprecated use `ExtentTag$outboundSchema` instead. */
  export const outboundSchema = ExtentTag$outboundSchema;
  /** @deprecated use `ExtentTag$Outbound` instead. */
  export type Outbound = ExtentTag$Outbound;
}

export function extentTagToJSON(extentTag: ExtentTag): string {
  return JSON.stringify(ExtentTag$outboundSchema.parse(extentTag));
}

export function extentTagFromJSON(
  jsonString: string,
): SafeParseResult<ExtentTag, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtentTag$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtentTag' from JSON`,
  );
}

/** @internal */
export const IngestIfNotExist$inboundSchema: z.ZodType<
  IngestIfNotExist,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
});

/** @internal */
export type IngestIfNotExist$Outbound = {
  value: string;
};

/** @internal */
export const IngestIfNotExist$outboundSchema: z.ZodType<
  IngestIfNotExist$Outbound,
  z.ZodTypeDef,
  IngestIfNotExist
> = z.object({
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngestIfNotExist$ {
  /** @deprecated use `IngestIfNotExist$inboundSchema` instead. */
  export const inboundSchema = IngestIfNotExist$inboundSchema;
  /** @deprecated use `IngestIfNotExist$outboundSchema` instead. */
  export const outboundSchema = IngestIfNotExist$outboundSchema;
  /** @deprecated use `IngestIfNotExist$Outbound` instead. */
  export type Outbound = IngestIfNotExist$Outbound;
}

export function ingestIfNotExistToJSON(
  ingestIfNotExist: IngestIfNotExist,
): string {
  return JSON.stringify(
    IngestIfNotExist$outboundSchema.parse(ingestIfNotExist),
  );
}

export function ingestIfNotExistFromJSON(
  jsonString: string,
): SafeParseResult<IngestIfNotExist, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IngestIfNotExist$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IngestIfNotExist' from JSON`,
  );
}

/** @internal */
export const ReportLevel$inboundSchema: z.ZodType<
  ReportLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReportLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ReportLevel$outboundSchema: z.ZodType<
  ReportLevel,
  z.ZodTypeDef,
  ReportLevel
> = z.union([
  z.nativeEnum(ReportLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReportLevel$ {
  /** @deprecated use `ReportLevel$inboundSchema` instead. */
  export const inboundSchema = ReportLevel$inboundSchema;
  /** @deprecated use `ReportLevel$outboundSchema` instead. */
  export const outboundSchema = ReportLevel$outboundSchema;
}

/** @internal */
export const ReportMethod$inboundSchema: z.ZodType<
  ReportMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReportMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ReportMethod$outboundSchema: z.ZodType<
  ReportMethod,
  z.ZodTypeDef,
  ReportMethod
> = z.union([
  z.nativeEnum(ReportMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReportMethod$ {
  /** @deprecated use `ReportMethod$inboundSchema` instead. */
  export const inboundSchema = ReportMethod$inboundSchema;
  /** @deprecated use `ReportMethod$outboundSchema` instead. */
  export const outboundSchema = ReportMethod$outboundSchema;
}

/** @internal */
export const AdditionalProperty$inboundSchema: z.ZodType<
  AdditionalProperty,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  value: z.string(),
});

/** @internal */
export type AdditionalProperty$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const AdditionalProperty$outboundSchema: z.ZodType<
  AdditionalProperty$Outbound,
  z.ZodTypeDef,
  AdditionalProperty
> = z.object({
  key: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdditionalProperty$ {
  /** @deprecated use `AdditionalProperty$inboundSchema` instead. */
  export const inboundSchema = AdditionalProperty$inboundSchema;
  /** @deprecated use `AdditionalProperty$outboundSchema` instead. */
  export const outboundSchema = AdditionalProperty$outboundSchema;
  /** @deprecated use `AdditionalProperty$Outbound` instead. */
  export type Outbound = AdditionalProperty$Outbound;
}

export function additionalPropertyToJSON(
  additionalProperty: AdditionalProperty,
): string {
  return JSON.stringify(
    AdditionalProperty$outboundSchema.parse(additionalProperty),
  );
}

export function additionalPropertyFromJSON(
  jsonString: string,
): SafeParseResult<AdditionalProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdditionalProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdditionalProperty' from JSON`,
  );
}

/** @internal */
export const OutputAzureDataExplorerResponseRetrySetting$inboundSchema:
  z.ZodType<
    OutputAzureDataExplorerResponseRetrySetting,
    z.ZodTypeDef,
    unknown
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/** @internal */
export type OutputAzureDataExplorerResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputAzureDataExplorerResponseRetrySetting$outboundSchema:
  z.ZodType<
    OutputAzureDataExplorerResponseRetrySetting$Outbound,
    z.ZodTypeDef,
    OutputAzureDataExplorerResponseRetrySetting
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerResponseRetrySetting$ {
  /** @deprecated use `OutputAzureDataExplorerResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputAzureDataExplorerResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputAzureDataExplorerResponseRetrySetting$Outbound;
}

export function outputAzureDataExplorerResponseRetrySettingToJSON(
  outputAzureDataExplorerResponseRetrySetting:
    OutputAzureDataExplorerResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputAzureDataExplorerResponseRetrySetting$outboundSchema.parse(
      outputAzureDataExplorerResponseRetrySetting,
    ),
  );
}

export function outputAzureDataExplorerResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputAzureDataExplorerResponseRetrySetting,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputAzureDataExplorerResponseRetrySetting$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputAzureDataExplorerResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputAzureDataExplorerTimeoutRetrySettings$inboundSchema:
  z.ZodType<
    OutputAzureDataExplorerTimeoutRetrySettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/** @internal */
export type OutputAzureDataExplorerTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputAzureDataExplorerTimeoutRetrySettings$outboundSchema:
  z.ZodType<
    OutputAzureDataExplorerTimeoutRetrySettings$Outbound,
    z.ZodTypeDef,
    OutputAzureDataExplorerTimeoutRetrySettings
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerTimeoutRetrySettings$ {
  /** @deprecated use `OutputAzureDataExplorerTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputAzureDataExplorerTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputAzureDataExplorerTimeoutRetrySettings$Outbound;
}

export function outputAzureDataExplorerTimeoutRetrySettingsToJSON(
  outputAzureDataExplorerTimeoutRetrySettings:
    OutputAzureDataExplorerTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputAzureDataExplorerTimeoutRetrySettings$outboundSchema.parse(
      outputAzureDataExplorerTimeoutRetrySettings,
    ),
  );
}

export function outputAzureDataExplorerTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  OutputAzureDataExplorerTimeoutRetrySettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OutputAzureDataExplorerTimeoutRetrySettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OutputAzureDataExplorerTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputAzureDataExplorerCompressCompression$inboundSchema:
  z.ZodType<OutputAzureDataExplorerCompressCompression, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(OutputAzureDataExplorerCompressCompression),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const OutputAzureDataExplorerCompressCompression$outboundSchema:
  z.ZodType<
    OutputAzureDataExplorerCompressCompression,
    z.ZodTypeDef,
    OutputAzureDataExplorerCompressCompression
  > = z.union([
    z.nativeEnum(OutputAzureDataExplorerCompressCompression),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerCompressCompression$ {
  /** @deprecated use `OutputAzureDataExplorerCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerCompressCompression$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerCompressCompression$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerPqCompressCompression$inboundSchema:
  z.ZodType<
    OutputAzureDataExplorerPqCompressCompression,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputAzureDataExplorerPqCompressCompression),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputAzureDataExplorerPqCompressCompression$outboundSchema:
  z.ZodType<
    OutputAzureDataExplorerPqCompressCompression,
    z.ZodTypeDef,
    OutputAzureDataExplorerPqCompressCompression
  > = z.union([
    z.nativeEnum(OutputAzureDataExplorerPqCompressCompression),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerPqCompressCompression$ {
  /** @deprecated use `OutputAzureDataExplorerPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerQueueFullBehavior$inboundSchema: z.ZodType<
  OutputAzureDataExplorerQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureDataExplorerQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureDataExplorerQueueFullBehavior$outboundSchema: z.ZodType<
  OutputAzureDataExplorerQueueFullBehavior,
  z.ZodTypeDef,
  OutputAzureDataExplorerQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputAzureDataExplorerQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerQueueFullBehavior$ {
  /** @deprecated use `OutputAzureDataExplorerQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureDataExplorerQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerMode$inboundSchema: z.ZodType<
  OutputAzureDataExplorerMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureDataExplorerMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureDataExplorerMode$outboundSchema: z.ZodType<
  OutputAzureDataExplorerMode,
  z.ZodTypeDef,
  OutputAzureDataExplorerMode
> = z.union([
  z.nativeEnum(OutputAzureDataExplorerMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerMode$ {
  /** @deprecated use `OutputAzureDataExplorerMode$inboundSchema` instead. */
  export const inboundSchema = OutputAzureDataExplorerMode$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerMode$outboundSchema` instead. */
  export const outboundSchema = OutputAzureDataExplorerMode$outboundSchema;
}

/** @internal */
export const OutputAzureDataExplorerPqControls$inboundSchema: z.ZodType<
  OutputAzureDataExplorerPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputAzureDataExplorerPqControls$Outbound = {};

/** @internal */
export const OutputAzureDataExplorerPqControls$outboundSchema: z.ZodType<
  OutputAzureDataExplorerPqControls$Outbound,
  z.ZodTypeDef,
  OutputAzureDataExplorerPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorerPqControls$ {
  /** @deprecated use `OutputAzureDataExplorerPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputAzureDataExplorerPqControls$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorerPqControls$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureDataExplorerPqControls$outboundSchema;
  /** @deprecated use `OutputAzureDataExplorerPqControls$Outbound` instead. */
  export type Outbound = OutputAzureDataExplorerPqControls$Outbound;
}

export function outputAzureDataExplorerPqControlsToJSON(
  outputAzureDataExplorerPqControls: OutputAzureDataExplorerPqControls,
): string {
  return JSON.stringify(
    OutputAzureDataExplorerPqControls$outboundSchema.parse(
      outputAzureDataExplorerPqControls,
    ),
  );
}

export function outputAzureDataExplorerPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureDataExplorerPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureDataExplorerPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureDataExplorerPqControls' from JSON`,
  );
}

/** @internal */
export const OutputAzureDataExplorer$inboundSchema: z.ZodType<
  OutputAzureDataExplorer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputAzureDataExplorerType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  clusterUrl: z.string(),
  database: z.string(),
  table: z.string(),
  validateDatabaseSettings: z.boolean().default(true),
  ingestMode: IngestionMode$inboundSchema.default("batching"),
  oauthEndpoint: MicrosoftEntraIDAuthenticationEndpoint$inboundSchema.default(
    "https://login.microsoftonline.com",
  ),
  tenantId: z.string(),
  clientId: z.string(),
  scope: z.string(),
  oauthType: OutputAzureDataExplorerAuthenticationMethod$inboundSchema.default(
    "clientSecret",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
  certificate: z.lazy(() => OutputAzureDataExplorerCertificate$inboundSchema)
    .optional(),
  ingestUrl: z.string().optional(),
  onBackpressure: OutputAzureDataExplorerBackpressureBehavior$inboundSchema
    .default("block"),
  isMappingObj: z.boolean().default(false),
  format: OutputAzureDataExplorerDataFormat$inboundSchema.default("json"),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  maxConcurrentFileParts: z.number().default(1),
  onDiskFullBackpressure:
    OutputAzureDataExplorerDiskSpaceProtection$inboundSchema.default("block"),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  deadletterEnabled: z.boolean().default(false),
  timeoutSec: z.number().default(30),
  flushImmediately: z.boolean().default(false),
  retainBlobOnSuccess: z.boolean().default(false),
  extentTags: z.array(z.lazy(() => ExtentTag$inboundSchema)).optional(),
  ingestIfNotExists: z.array(z.lazy(() => IngestIfNotExist$inboundSchema))
    .optional(),
  reportLevel: ReportLevel$inboundSchema.default("failuresOnly"),
  reportMethod: ReportMethod$inboundSchema.default("queue"),
  additionalProperties: z.array(z.lazy(() => AdditionalProperty$inboundSchema))
    .optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputAzureDataExplorerResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputAzureDataExplorerTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  compress: OutputAzureDataExplorerCompressCompression$inboundSchema.default(
    "gzip",
  ),
  mappingRef: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  keepAlive: z.boolean().default(true),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputAzureDataExplorerPqCompressCompression$inboundSchema
    .default("none"),
  pqOnBackpressure: OutputAzureDataExplorerQueueFullBehavior$inboundSchema
    .default("block"),
  pqMode: OutputAzureDataExplorerMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputAzureDataExplorerPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputAzureDataExplorer$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  clusterUrl: string;
  database: string;
  table: string;
  validateDatabaseSettings: boolean;
  ingestMode: string;
  oauthEndpoint: string;
  tenantId: string;
  clientId: string;
  scope: string;
  oauthType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
  certificate?: OutputAzureDataExplorerCertificate$Outbound | undefined;
  ingestUrl?: string | undefined;
  onBackpressure: string;
  isMappingObj: boolean;
  format: string;
  stagePath: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  maxConcurrentFileParts: number;
  onDiskFullBackpressure: string;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  deadletterEnabled: boolean;
  timeoutSec: number;
  flushImmediately: boolean;
  retainBlobOnSuccess: boolean;
  extentTags?: Array<ExtentTag$Outbound> | undefined;
  ingestIfNotExists?: Array<IngestIfNotExist$Outbound> | undefined;
  reportLevel: string;
  reportMethod: string;
  additionalProperties?: Array<AdditionalProperty$Outbound> | undefined;
  responseRetrySettings?:
    | Array<OutputAzureDataExplorerResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputAzureDataExplorerTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  compress: string;
  mappingRef?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  flushPeriodSec: number;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  keepAlive: boolean;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputAzureDataExplorerPqControls$Outbound | undefined;
};

/** @internal */
export const OutputAzureDataExplorer$outboundSchema: z.ZodType<
  OutputAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  OutputAzureDataExplorer
> = z.object({
  id: z.string(),
  type: OutputAzureDataExplorerType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  clusterUrl: z.string(),
  database: z.string(),
  table: z.string(),
  validateDatabaseSettings: z.boolean().default(true),
  ingestMode: IngestionMode$outboundSchema.default("batching"),
  oauthEndpoint: MicrosoftEntraIDAuthenticationEndpoint$outboundSchema.default(
    "https://login.microsoftonline.com",
  ),
  tenantId: z.string(),
  clientId: z.string(),
  scope: z.string(),
  oauthType: OutputAzureDataExplorerAuthenticationMethod$outboundSchema.default(
    "clientSecret",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
  certificate: z.lazy(() => OutputAzureDataExplorerCertificate$outboundSchema)
    .optional(),
  ingestUrl: z.string().optional(),
  onBackpressure: OutputAzureDataExplorerBackpressureBehavior$outboundSchema
    .default("block"),
  isMappingObj: z.boolean().default(false),
  format: OutputAzureDataExplorerDataFormat$outboundSchema.default("json"),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  maxConcurrentFileParts: z.number().default(1),
  onDiskFullBackpressure:
    OutputAzureDataExplorerDiskSpaceProtection$outboundSchema.default("block"),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  deadletterEnabled: z.boolean().default(false),
  timeoutSec: z.number().default(30),
  flushImmediately: z.boolean().default(false),
  retainBlobOnSuccess: z.boolean().default(false),
  extentTags: z.array(z.lazy(() => ExtentTag$outboundSchema)).optional(),
  ingestIfNotExists: z.array(z.lazy(() => IngestIfNotExist$outboundSchema))
    .optional(),
  reportLevel: ReportLevel$outboundSchema.default("failuresOnly"),
  reportMethod: ReportMethod$outboundSchema.default("queue"),
  additionalProperties: z.array(z.lazy(() => AdditionalProperty$outboundSchema))
    .optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputAzureDataExplorerResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputAzureDataExplorerTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  compress: OutputAzureDataExplorerCompressCompression$outboundSchema.default(
    "gzip",
  ),
  mappingRef: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  keepAlive: z.boolean().default(true),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputAzureDataExplorerPqCompressCompression$outboundSchema
    .default("none"),
  pqOnBackpressure: OutputAzureDataExplorerQueueFullBehavior$outboundSchema
    .default("block"),
  pqMode: OutputAzureDataExplorerMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputAzureDataExplorerPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorer$ {
  /** @deprecated use `OutputAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = OutputAzureDataExplorer$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema = OutputAzureDataExplorer$outboundSchema;
  /** @deprecated use `OutputAzureDataExplorer$Outbound` instead. */
  export type Outbound = OutputAzureDataExplorer$Outbound;
}

export function outputAzureDataExplorerToJSON(
  outputAzureDataExplorer: OutputAzureDataExplorer,
): string {
  return JSON.stringify(
    OutputAzureDataExplorer$outboundSchema.parse(outputAzureDataExplorer),
  );
}

export function outputAzureDataExplorerFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureDataExplorer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureDataExplorer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureDataExplorer' from JSON`,
  );
}

/** @internal */
export const OutputAzureBlobType$inboundSchema: z.ZodType<
  OutputAzureBlobType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobType$outboundSchema: z.ZodType<
  OutputAzureBlobType,
  z.ZodTypeDef,
  OutputAzureBlobType
> = z.union([
  z.nativeEnum(OutputAzureBlobType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobType$ {
  /** @deprecated use `OutputAzureBlobType$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobType$inboundSchema;
  /** @deprecated use `OutputAzureBlobType$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobType$outboundSchema;
}

/** @internal */
export const OutputAzureBlobDataFormat$inboundSchema: z.ZodType<
  OutputAzureBlobDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobDataFormat$outboundSchema: z.ZodType<
  OutputAzureBlobDataFormat,
  z.ZodTypeDef,
  OutputAzureBlobDataFormat
> = z.union([
  z.nativeEnum(OutputAzureBlobDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobDataFormat$ {
  /** @deprecated use `OutputAzureBlobDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobDataFormat$inboundSchema;
  /** @deprecated use `OutputAzureBlobDataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobDataFormat$outboundSchema;
}

/** @internal */
export const OutputAzureBlobBackpressureBehavior$inboundSchema: z.ZodType<
  OutputAzureBlobBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobBackpressureBehavior$outboundSchema: z.ZodType<
  OutputAzureBlobBackpressureBehavior,
  z.ZodTypeDef,
  OutputAzureBlobBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputAzureBlobBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobBackpressureBehavior$ {
  /** @deprecated use `OutputAzureBlobBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureBlobBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputAzureBlobBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureBlobBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputAzureBlobDiskSpaceProtection$inboundSchema: z.ZodType<
  OutputAzureBlobDiskSpaceProtection,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobDiskSpaceProtection),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobDiskSpaceProtection$outboundSchema: z.ZodType<
  OutputAzureBlobDiskSpaceProtection,
  z.ZodTypeDef,
  OutputAzureBlobDiskSpaceProtection
> = z.union([
  z.nativeEnum(OutputAzureBlobDiskSpaceProtection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobDiskSpaceProtection$ {
  /** @deprecated use `OutputAzureBlobDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputAzureBlobDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureBlobDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputAzureBlobAuthenticationMethod$inboundSchema: z.ZodType<
  OutputAzureBlobAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobAuthenticationMethod$outboundSchema: z.ZodType<
  OutputAzureBlobAuthenticationMethod,
  z.ZodTypeDef,
  OutputAzureBlobAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputAzureBlobAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobAuthenticationMethod$ {
  /** @deprecated use `OutputAzureBlobAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputAzureBlobAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputAzureBlobAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputAzureBlobAuthenticationMethod$outboundSchema;
}

/** @internal */
export const BlobAccessTier$inboundSchema: z.ZodType<
  BlobAccessTier,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(BlobAccessTier),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const BlobAccessTier$outboundSchema: z.ZodType<
  BlobAccessTier,
  z.ZodTypeDef,
  BlobAccessTier
> = z.union([
  z.nativeEnum(BlobAccessTier),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BlobAccessTier$ {
  /** @deprecated use `BlobAccessTier$inboundSchema` instead. */
  export const inboundSchema = BlobAccessTier$inboundSchema;
  /** @deprecated use `BlobAccessTier$outboundSchema` instead. */
  export const outboundSchema = BlobAccessTier$outboundSchema;
}

/** @internal */
export const OutputAzureBlobCompression$inboundSchema: z.ZodType<
  OutputAzureBlobCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobCompression$outboundSchema: z.ZodType<
  OutputAzureBlobCompression,
  z.ZodTypeDef,
  OutputAzureBlobCompression
> = z.union([
  z.nativeEnum(OutputAzureBlobCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobCompression$ {
  /** @deprecated use `OutputAzureBlobCompression$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobCompression$inboundSchema;
  /** @deprecated use `OutputAzureBlobCompression$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobCompression$outboundSchema;
}

/** @internal */
export const OutputAzureBlobCompressionLevel$inboundSchema: z.ZodType<
  OutputAzureBlobCompressionLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobCompressionLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobCompressionLevel$outboundSchema: z.ZodType<
  OutputAzureBlobCompressionLevel,
  z.ZodTypeDef,
  OutputAzureBlobCompressionLevel
> = z.union([
  z.nativeEnum(OutputAzureBlobCompressionLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobCompressionLevel$ {
  /** @deprecated use `OutputAzureBlobCompressionLevel$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobCompressionLevel$inboundSchema;
  /** @deprecated use `OutputAzureBlobCompressionLevel$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobCompressionLevel$outboundSchema;
}

/** @internal */
export const OutputAzureBlobParquetVersion$inboundSchema: z.ZodType<
  OutputAzureBlobParquetVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobParquetVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobParquetVersion$outboundSchema: z.ZodType<
  OutputAzureBlobParquetVersion,
  z.ZodTypeDef,
  OutputAzureBlobParquetVersion
> = z.union([
  z.nativeEnum(OutputAzureBlobParquetVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobParquetVersion$ {
  /** @deprecated use `OutputAzureBlobParquetVersion$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobParquetVersion$inboundSchema;
  /** @deprecated use `OutputAzureBlobParquetVersion$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobParquetVersion$outboundSchema;
}

/** @internal */
export const OutputAzureBlobDataPageVersion$inboundSchema: z.ZodType<
  OutputAzureBlobDataPageVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputAzureBlobDataPageVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputAzureBlobDataPageVersion$outboundSchema: z.ZodType<
  OutputAzureBlobDataPageVersion,
  z.ZodTypeDef,
  OutputAzureBlobDataPageVersion
> = z.union([
  z.nativeEnum(OutputAzureBlobDataPageVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobDataPageVersion$ {
  /** @deprecated use `OutputAzureBlobDataPageVersion$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobDataPageVersion$inboundSchema;
  /** @deprecated use `OutputAzureBlobDataPageVersion$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobDataPageVersion$outboundSchema;
}

/** @internal */
export const OutputAzureBlobKeyValueMetadatum$inboundSchema: z.ZodType<
  OutputAzureBlobKeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputAzureBlobKeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputAzureBlobKeyValueMetadatum$outboundSchema: z.ZodType<
  OutputAzureBlobKeyValueMetadatum$Outbound,
  z.ZodTypeDef,
  OutputAzureBlobKeyValueMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobKeyValueMetadatum$ {
  /** @deprecated use `OutputAzureBlobKeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobKeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputAzureBlobKeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobKeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputAzureBlobKeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputAzureBlobKeyValueMetadatum$Outbound;
}

export function outputAzureBlobKeyValueMetadatumToJSON(
  outputAzureBlobKeyValueMetadatum: OutputAzureBlobKeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputAzureBlobKeyValueMetadatum$outboundSchema.parse(
      outputAzureBlobKeyValueMetadatum,
    ),
  );
}

export function outputAzureBlobKeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureBlobKeyValueMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureBlobKeyValueMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureBlobKeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputAzureBlobCertificate$inboundSchema: z.ZodType<
  OutputAzureBlobCertificate,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string(),
});

/** @internal */
export type OutputAzureBlobCertificate$Outbound = {
  certificateName: string;
};

/** @internal */
export const OutputAzureBlobCertificate$outboundSchema: z.ZodType<
  OutputAzureBlobCertificate$Outbound,
  z.ZodTypeDef,
  OutputAzureBlobCertificate
> = z.object({
  certificateName: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlobCertificate$ {
  /** @deprecated use `OutputAzureBlobCertificate$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlobCertificate$inboundSchema;
  /** @deprecated use `OutputAzureBlobCertificate$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlobCertificate$outboundSchema;
  /** @deprecated use `OutputAzureBlobCertificate$Outbound` instead. */
  export type Outbound = OutputAzureBlobCertificate$Outbound;
}

export function outputAzureBlobCertificateToJSON(
  outputAzureBlobCertificate: OutputAzureBlobCertificate,
): string {
  return JSON.stringify(
    OutputAzureBlobCertificate$outboundSchema.parse(outputAzureBlobCertificate),
  );
}

export function outputAzureBlobCertificateFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureBlobCertificate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureBlobCertificate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureBlobCertificate' from JSON`,
  );
}

/** @internal */
export const OutputAzureBlob$inboundSchema: z.ZodType<
  OutputAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputAzureBlobType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  containerName: z.string(),
  createContainer: z.boolean().default(false),
  destPath: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  maxConcurrentFileParts: z.number().default(1),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputAzureBlobDataFormat$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputAzureBlobBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputAzureBlobDiskSpaceProtection$inboundSchema
    .default("block"),
  authType: OutputAzureBlobAuthenticationMethod$inboundSchema.default("manual"),
  storageClass: BlobAccessTier$inboundSchema.default("Inferred"),
  description: z.string().optional(),
  compress: OutputAzureBlobCompression$inboundSchema.default("gzip"),
  compressionLevel: OutputAzureBlobCompressionLevel$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputAzureBlobParquetVersion$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputAzureBlobDataPageVersion$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputAzureBlobKeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => OutputAzureBlobCertificate$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputAzureBlob$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  containerName: string;
  createContainer: boolean;
  destPath?: string | undefined;
  stagePath: string;
  addIdToStagePath: boolean;
  maxConcurrentFileParts: number;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  authType: string;
  storageClass: string;
  description?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<OutputAzureBlobKeyValueMetadatum$Outbound>
    | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?: OutputAzureBlobCertificate$Outbound | undefined;
};

/** @internal */
export const OutputAzureBlob$outboundSchema: z.ZodType<
  OutputAzureBlob$Outbound,
  z.ZodTypeDef,
  OutputAzureBlob
> = z.object({
  id: z.string(),
  type: OutputAzureBlobType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  containerName: z.string(),
  createContainer: z.boolean().default(false),
  destPath: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  maxConcurrentFileParts: z.number().default(1),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputAzureBlobDataFormat$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputAzureBlobBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputAzureBlobDiskSpaceProtection$outboundSchema
    .default("block"),
  authType: OutputAzureBlobAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  storageClass: BlobAccessTier$outboundSchema.default("Inferred"),
  description: z.string().optional(),
  compress: OutputAzureBlobCompression$outboundSchema.default("gzip"),
  compressionLevel: OutputAzureBlobCompressionLevel$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputAzureBlobParquetVersion$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputAzureBlobDataPageVersion$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputAzureBlobKeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => OutputAzureBlobCertificate$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlob$ {
  /** @deprecated use `OutputAzureBlob$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlob$inboundSchema;
  /** @deprecated use `OutputAzureBlob$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlob$outboundSchema;
  /** @deprecated use `OutputAzureBlob$Outbound` instead. */
  export type Outbound = OutputAzureBlob$Outbound;
}

export function outputAzureBlobToJSON(
  outputAzureBlob: OutputAzureBlob,
): string {
  return JSON.stringify(OutputAzureBlob$outboundSchema.parse(outputAzureBlob));
}

export function outputAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureBlob' from JSON`,
  );
}

/** @internal */
export const OutputS3Type$inboundSchema: z.ZodType<
  OutputS3Type,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3Type),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3Type$outboundSchema: z.ZodType<
  OutputS3Type,
  z.ZodTypeDef,
  OutputS3Type
> = z.union([
  z.nativeEnum(OutputS3Type),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3Type$ {
  /** @deprecated use `OutputS3Type$inboundSchema` instead. */
  export const inboundSchema = OutputS3Type$inboundSchema;
  /** @deprecated use `OutputS3Type$outboundSchema` instead. */
  export const outboundSchema = OutputS3Type$outboundSchema;
}

/** @internal */
export const OutputS3AuthenticationMethod$inboundSchema: z.ZodType<
  OutputS3AuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3AuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3AuthenticationMethod$outboundSchema: z.ZodType<
  OutputS3AuthenticationMethod,
  z.ZodTypeDef,
  OutputS3AuthenticationMethod
> = z.union([
  z.nativeEnum(OutputS3AuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3AuthenticationMethod$ {
  /** @deprecated use `OutputS3AuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputS3AuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputS3AuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputS3AuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputS3SignatureVersion$inboundSchema: z.ZodType<
  OutputS3SignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3SignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3SignatureVersion$outboundSchema: z.ZodType<
  OutputS3SignatureVersion,
  z.ZodTypeDef,
  OutputS3SignatureVersion
> = z.union([
  z.nativeEnum(OutputS3SignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3SignatureVersion$ {
  /** @deprecated use `OutputS3SignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputS3SignatureVersion$inboundSchema;
  /** @deprecated use `OutputS3SignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputS3SignatureVersion$outboundSchema;
}

/** @internal */
export const OutputS3ObjectACL$inboundSchema: z.ZodType<
  OutputS3ObjectACL,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3ObjectACL),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3ObjectACL$outboundSchema: z.ZodType<
  OutputS3ObjectACL,
  z.ZodTypeDef,
  OutputS3ObjectACL
> = z.union([
  z.nativeEnum(OutputS3ObjectACL),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3ObjectACL$ {
  /** @deprecated use `OutputS3ObjectACL$inboundSchema` instead. */
  export const inboundSchema = OutputS3ObjectACL$inboundSchema;
  /** @deprecated use `OutputS3ObjectACL$outboundSchema` instead. */
  export const outboundSchema = OutputS3ObjectACL$outboundSchema;
}

/** @internal */
export const OutputS3StorageClass$inboundSchema: z.ZodType<
  OutputS3StorageClass,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3StorageClass),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3StorageClass$outboundSchema: z.ZodType<
  OutputS3StorageClass,
  z.ZodTypeDef,
  OutputS3StorageClass
> = z.union([
  z.nativeEnum(OutputS3StorageClass),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3StorageClass$ {
  /** @deprecated use `OutputS3StorageClass$inboundSchema` instead. */
  export const inboundSchema = OutputS3StorageClass$inboundSchema;
  /** @deprecated use `OutputS3StorageClass$outboundSchema` instead. */
  export const outboundSchema = OutputS3StorageClass$outboundSchema;
}

/** @internal */
export const OutputS3ServerSideEncryptionForUploadedObjects$inboundSchema:
  z.ZodType<
    OutputS3ServerSideEncryptionForUploadedObjects,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(OutputS3ServerSideEncryptionForUploadedObjects),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const OutputS3ServerSideEncryptionForUploadedObjects$outboundSchema:
  z.ZodType<
    OutputS3ServerSideEncryptionForUploadedObjects,
    z.ZodTypeDef,
    OutputS3ServerSideEncryptionForUploadedObjects
  > = z.union([
    z.nativeEnum(OutputS3ServerSideEncryptionForUploadedObjects),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3ServerSideEncryptionForUploadedObjects$ {
  /** @deprecated use `OutputS3ServerSideEncryptionForUploadedObjects$inboundSchema` instead. */
  export const inboundSchema =
    OutputS3ServerSideEncryptionForUploadedObjects$inboundSchema;
  /** @deprecated use `OutputS3ServerSideEncryptionForUploadedObjects$outboundSchema` instead. */
  export const outboundSchema =
    OutputS3ServerSideEncryptionForUploadedObjects$outboundSchema;
}

/** @internal */
export const OutputS3DataFormat$inboundSchema: z.ZodType<
  OutputS3DataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3DataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3DataFormat$outboundSchema: z.ZodType<
  OutputS3DataFormat,
  z.ZodTypeDef,
  OutputS3DataFormat
> = z.union([
  z.nativeEnum(OutputS3DataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3DataFormat$ {
  /** @deprecated use `OutputS3DataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputS3DataFormat$inboundSchema;
  /** @deprecated use `OutputS3DataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputS3DataFormat$outboundSchema;
}

/** @internal */
export const OutputS3BackpressureBehavior$inboundSchema: z.ZodType<
  OutputS3BackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3BackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3BackpressureBehavior$outboundSchema: z.ZodType<
  OutputS3BackpressureBehavior,
  z.ZodTypeDef,
  OutputS3BackpressureBehavior
> = z.union([
  z.nativeEnum(OutputS3BackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3BackpressureBehavior$ {
  /** @deprecated use `OutputS3BackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputS3BackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputS3BackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputS3BackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputS3DiskSpaceProtection$inboundSchema: z.ZodType<
  OutputS3DiskSpaceProtection,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3DiskSpaceProtection),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3DiskSpaceProtection$outboundSchema: z.ZodType<
  OutputS3DiskSpaceProtection,
  z.ZodTypeDef,
  OutputS3DiskSpaceProtection
> = z.union([
  z.nativeEnum(OutputS3DiskSpaceProtection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3DiskSpaceProtection$ {
  /** @deprecated use `OutputS3DiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema = OutputS3DiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputS3DiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema = OutputS3DiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputS3Compression$inboundSchema: z.ZodType<
  OutputS3Compression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3Compression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3Compression$outboundSchema: z.ZodType<
  OutputS3Compression,
  z.ZodTypeDef,
  OutputS3Compression
> = z.union([
  z.nativeEnum(OutputS3Compression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3Compression$ {
  /** @deprecated use `OutputS3Compression$inboundSchema` instead. */
  export const inboundSchema = OutputS3Compression$inboundSchema;
  /** @deprecated use `OutputS3Compression$outboundSchema` instead. */
  export const outboundSchema = OutputS3Compression$outboundSchema;
}

/** @internal */
export const OutputS3CompressionLevel$inboundSchema: z.ZodType<
  OutputS3CompressionLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3CompressionLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3CompressionLevel$outboundSchema: z.ZodType<
  OutputS3CompressionLevel,
  z.ZodTypeDef,
  OutputS3CompressionLevel
> = z.union([
  z.nativeEnum(OutputS3CompressionLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3CompressionLevel$ {
  /** @deprecated use `OutputS3CompressionLevel$inboundSchema` instead. */
  export const inboundSchema = OutputS3CompressionLevel$inboundSchema;
  /** @deprecated use `OutputS3CompressionLevel$outboundSchema` instead. */
  export const outboundSchema = OutputS3CompressionLevel$outboundSchema;
}

/** @internal */
export const OutputS3ParquetVersion$inboundSchema: z.ZodType<
  OutputS3ParquetVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3ParquetVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3ParquetVersion$outboundSchema: z.ZodType<
  OutputS3ParquetVersion,
  z.ZodTypeDef,
  OutputS3ParquetVersion
> = z.union([
  z.nativeEnum(OutputS3ParquetVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3ParquetVersion$ {
  /** @deprecated use `OutputS3ParquetVersion$inboundSchema` instead. */
  export const inboundSchema = OutputS3ParquetVersion$inboundSchema;
  /** @deprecated use `OutputS3ParquetVersion$outboundSchema` instead. */
  export const outboundSchema = OutputS3ParquetVersion$outboundSchema;
}

/** @internal */
export const OutputS3DataPageVersion$inboundSchema: z.ZodType<
  OutputS3DataPageVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputS3DataPageVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputS3DataPageVersion$outboundSchema: z.ZodType<
  OutputS3DataPageVersion,
  z.ZodTypeDef,
  OutputS3DataPageVersion
> = z.union([
  z.nativeEnum(OutputS3DataPageVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3DataPageVersion$ {
  /** @deprecated use `OutputS3DataPageVersion$inboundSchema` instead. */
  export const inboundSchema = OutputS3DataPageVersion$inboundSchema;
  /** @deprecated use `OutputS3DataPageVersion$outboundSchema` instead. */
  export const outboundSchema = OutputS3DataPageVersion$outboundSchema;
}

/** @internal */
export const OutputS3KeyValueMetadatum$inboundSchema: z.ZodType<
  OutputS3KeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputS3KeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputS3KeyValueMetadatum$outboundSchema: z.ZodType<
  OutputS3KeyValueMetadatum$Outbound,
  z.ZodTypeDef,
  OutputS3KeyValueMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3KeyValueMetadatum$ {
  /** @deprecated use `OutputS3KeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputS3KeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputS3KeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputS3KeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputS3KeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputS3KeyValueMetadatum$Outbound;
}

export function outputS3KeyValueMetadatumToJSON(
  outputS3KeyValueMetadatum: OutputS3KeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputS3KeyValueMetadatum$outboundSchema.parse(outputS3KeyValueMetadatum),
  );
}

export function outputS3KeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputS3KeyValueMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputS3KeyValueMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputS3KeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputS3$inboundSchema: z.ZodType<
  OutputS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputS3Type$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: OutputS3AuthenticationMethod$inboundSchema.default(
    "auto",
  ),
  endpoint: z.string().optional(),
  signatureVersion: OutputS3SignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: OutputS3ObjectACL$inboundSchema.default("private"),
  storageClass: OutputS3StorageClass$inboundSchema.optional(),
  serverSideEncryption:
    OutputS3ServerSideEncryptionForUploadedObjects$inboundSchema.optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputS3DataFormat$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputS3BackpressureBehavior$inboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputS3DiskSpaceProtection$inboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputS3Compression$inboundSchema.default("gzip"),
  compressionLevel: OutputS3CompressionLevel$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputS3ParquetVersion$inboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: OutputS3DataPageVersion$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputS3KeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputS3$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region?: string | undefined;
  awsSecretKey?: string | undefined;
  awsAuthenticationMethod: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  stagePath: string;
  addIdToStagePath: boolean;
  destPath: string;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  kmsKeyId?: string | undefined;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  verifyPermissions: boolean;
  maxClosingFilesToBackpressure: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<OutputS3KeyValueMetadatum$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputS3$outboundSchema: z.ZodType<
  OutputS3$Outbound,
  z.ZodTypeDef,
  OutputS3
> = z.object({
  id: z.string(),
  type: OutputS3Type$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: OutputS3AuthenticationMethod$outboundSchema.default(
    "auto",
  ),
  endpoint: z.string().optional(),
  signatureVersion: OutputS3SignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: OutputS3ObjectACL$outboundSchema.default("private"),
  storageClass: OutputS3StorageClass$outboundSchema.optional(),
  serverSideEncryption:
    OutputS3ServerSideEncryptionForUploadedObjects$outboundSchema.optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputS3DataFormat$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputS3BackpressureBehavior$outboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputS3DiskSpaceProtection$outboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputS3Compression$outboundSchema.default("gzip"),
  compressionLevel: OutputS3CompressionLevel$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputS3ParquetVersion$outboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: OutputS3DataPageVersion$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputS3KeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3$ {
  /** @deprecated use `OutputS3$inboundSchema` instead. */
  export const inboundSchema = OutputS3$inboundSchema;
  /** @deprecated use `OutputS3$outboundSchema` instead. */
  export const outboundSchema = OutputS3$outboundSchema;
  /** @deprecated use `OutputS3$Outbound` instead. */
  export type Outbound = OutputS3$Outbound;
}

export function outputS3ToJSON(outputS3: OutputS3): string {
  return JSON.stringify(OutputS3$outboundSchema.parse(outputS3));
}

export function outputS3FromJSON(
  jsonString: string,
): SafeParseResult<OutputS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputS3' from JSON`,
  );
}

/** @internal */
export const OutputFilesystemType$inboundSchema: z.ZodType<
  OutputFilesystemType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemType$outboundSchema: z.ZodType<
  OutputFilesystemType,
  z.ZodTypeDef,
  OutputFilesystemType
> = z.union([
  z.nativeEnum(OutputFilesystemType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemType$ {
  /** @deprecated use `OutputFilesystemType$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystemType$inboundSchema;
  /** @deprecated use `OutputFilesystemType$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystemType$outboundSchema;
}

/** @internal */
export const OutputFilesystemDataFormat$inboundSchema: z.ZodType<
  OutputFilesystemDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemDataFormat$outboundSchema: z.ZodType<
  OutputFilesystemDataFormat,
  z.ZodTypeDef,
  OutputFilesystemDataFormat
> = z.union([
  z.nativeEnum(OutputFilesystemDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemDataFormat$ {
  /** @deprecated use `OutputFilesystemDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystemDataFormat$inboundSchema;
  /** @deprecated use `OutputFilesystemDataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystemDataFormat$outboundSchema;
}

/** @internal */
export const OutputFilesystemBackpressureBehavior$inboundSchema: z.ZodType<
  OutputFilesystemBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemBackpressureBehavior$outboundSchema: z.ZodType<
  OutputFilesystemBackpressureBehavior,
  z.ZodTypeDef,
  OutputFilesystemBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputFilesystemBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemBackpressureBehavior$ {
  /** @deprecated use `OutputFilesystemBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputFilesystemBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputFilesystemBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputFilesystemBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputFilesystemDiskSpaceProtection$inboundSchema: z.ZodType<
  OutputFilesystemDiskSpaceProtection,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemDiskSpaceProtection),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemDiskSpaceProtection$outboundSchema: z.ZodType<
  OutputFilesystemDiskSpaceProtection,
  z.ZodTypeDef,
  OutputFilesystemDiskSpaceProtection
> = z.union([
  z.nativeEnum(OutputFilesystemDiskSpaceProtection),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemDiskSpaceProtection$ {
  /** @deprecated use `OutputFilesystemDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema =
    OutputFilesystemDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputFilesystemDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema =
    OutputFilesystemDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputFilesystemCompression$inboundSchema: z.ZodType<
  OutputFilesystemCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemCompression$outboundSchema: z.ZodType<
  OutputFilesystemCompression,
  z.ZodTypeDef,
  OutputFilesystemCompression
> = z.union([
  z.nativeEnum(OutputFilesystemCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemCompression$ {
  /** @deprecated use `OutputFilesystemCompression$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystemCompression$inboundSchema;
  /** @deprecated use `OutputFilesystemCompression$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystemCompression$outboundSchema;
}

/** @internal */
export const OutputFilesystemCompressionLevel$inboundSchema: z.ZodType<
  OutputFilesystemCompressionLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemCompressionLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemCompressionLevel$outboundSchema: z.ZodType<
  OutputFilesystemCompressionLevel,
  z.ZodTypeDef,
  OutputFilesystemCompressionLevel
> = z.union([
  z.nativeEnum(OutputFilesystemCompressionLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemCompressionLevel$ {
  /** @deprecated use `OutputFilesystemCompressionLevel$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystemCompressionLevel$inboundSchema;
  /** @deprecated use `OutputFilesystemCompressionLevel$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystemCompressionLevel$outboundSchema;
}

/** @internal */
export const OutputFilesystemParquetVersion$inboundSchema: z.ZodType<
  OutputFilesystemParquetVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemParquetVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemParquetVersion$outboundSchema: z.ZodType<
  OutputFilesystemParquetVersion,
  z.ZodTypeDef,
  OutputFilesystemParquetVersion
> = z.union([
  z.nativeEnum(OutputFilesystemParquetVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemParquetVersion$ {
  /** @deprecated use `OutputFilesystemParquetVersion$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystemParquetVersion$inboundSchema;
  /** @deprecated use `OutputFilesystemParquetVersion$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystemParquetVersion$outboundSchema;
}

/** @internal */
export const OutputFilesystemDataPageVersion$inboundSchema: z.ZodType<
  OutputFilesystemDataPageVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputFilesystemDataPageVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputFilesystemDataPageVersion$outboundSchema: z.ZodType<
  OutputFilesystemDataPageVersion,
  z.ZodTypeDef,
  OutputFilesystemDataPageVersion
> = z.union([
  z.nativeEnum(OutputFilesystemDataPageVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemDataPageVersion$ {
  /** @deprecated use `OutputFilesystemDataPageVersion$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystemDataPageVersion$inboundSchema;
  /** @deprecated use `OutputFilesystemDataPageVersion$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystemDataPageVersion$outboundSchema;
}

/** @internal */
export const OutputFilesystemKeyValueMetadatum$inboundSchema: z.ZodType<
  OutputFilesystemKeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputFilesystemKeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputFilesystemKeyValueMetadatum$outboundSchema: z.ZodType<
  OutputFilesystemKeyValueMetadatum$Outbound,
  z.ZodTypeDef,
  OutputFilesystemKeyValueMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystemKeyValueMetadatum$ {
  /** @deprecated use `OutputFilesystemKeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystemKeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputFilesystemKeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema =
    OutputFilesystemKeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputFilesystemKeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputFilesystemKeyValueMetadatum$Outbound;
}

export function outputFilesystemKeyValueMetadatumToJSON(
  outputFilesystemKeyValueMetadatum: OutputFilesystemKeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputFilesystemKeyValueMetadatum$outboundSchema.parse(
      outputFilesystemKeyValueMetadatum,
    ),
  );
}

export function outputFilesystemKeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputFilesystemKeyValueMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputFilesystemKeyValueMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputFilesystemKeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputFilesystem$inboundSchema: z.ZodType<
  OutputFilesystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputFilesystemType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  destPath: z.string(),
  stagePath: z.string().optional(),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputFilesystemDataFormat$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputFilesystemBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputFilesystemDiskSpaceProtection$inboundSchema
    .default("block"),
  description: z.string().optional(),
  compress: OutputFilesystemCompression$inboundSchema.default("gzip"),
  compressionLevel: OutputFilesystemCompressionLevel$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputFilesystemParquetVersion$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputFilesystemDataPageVersion$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputFilesystemKeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputFilesystem$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  destPath: string;
  stagePath?: string | undefined;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  description?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<OutputFilesystemKeyValueMetadatum$Outbound>
    | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputFilesystem$outboundSchema: z.ZodType<
  OutputFilesystem$Outbound,
  z.ZodTypeDef,
  OutputFilesystem
> = z.object({
  id: z.string(),
  type: OutputFilesystemType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  destPath: z.string(),
  stagePath: z.string().optional(),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputFilesystemDataFormat$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputFilesystemBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputFilesystemDiskSpaceProtection$outboundSchema
    .default("block"),
  description: z.string().optional(),
  compress: OutputFilesystemCompression$outboundSchema.default("gzip"),
  compressionLevel: OutputFilesystemCompressionLevel$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputFilesystemParquetVersion$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputFilesystemDataPageVersion$outboundSchema
    .default("DATA_PAGE_V2"),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputFilesystemKeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystem$ {
  /** @deprecated use `OutputFilesystem$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystem$inboundSchema;
  /** @deprecated use `OutputFilesystem$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystem$outboundSchema;
  /** @deprecated use `OutputFilesystem$Outbound` instead. */
  export type Outbound = OutputFilesystem$Outbound;
}

export function outputFilesystemToJSON(
  outputFilesystem: OutputFilesystem,
): string {
  return JSON.stringify(
    OutputFilesystem$outboundSchema.parse(outputFilesystem),
  );
}

export function outputFilesystemFromJSON(
  jsonString: string,
): SafeParseResult<OutputFilesystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputFilesystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputFilesystem' from JSON`,
  );
}

/** @internal */
export const OutputSignalfxType$inboundSchema: z.ZodType<
  OutputSignalfxType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSignalfxType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSignalfxType$outboundSchema: z.ZodType<
  OutputSignalfxType,
  z.ZodTypeDef,
  OutputSignalfxType
> = z.union([
  z.nativeEnum(OutputSignalfxType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxType$ {
  /** @deprecated use `OutputSignalfxType$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxType$inboundSchema;
  /** @deprecated use `OutputSignalfxType$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfxType$outboundSchema;
}

/** @internal */
export const OutputSignalfxAuthenticationMethod$inboundSchema: z.ZodType<
  OutputSignalfxAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSignalfxAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSignalfxAuthenticationMethod$outboundSchema: z.ZodType<
  OutputSignalfxAuthenticationMethod,
  z.ZodTypeDef,
  OutputSignalfxAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputSignalfxAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxAuthenticationMethod$ {
  /** @deprecated use `OutputSignalfxAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputSignalfxAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputSignalfxAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputSignalfxExtraHttpHeader$inboundSchema: z.ZodType<
  OutputSignalfxExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputSignalfxExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputSignalfxExtraHttpHeader$outboundSchema: z.ZodType<
  OutputSignalfxExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputSignalfxExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxExtraHttpHeader$ {
  /** @deprecated use `OutputSignalfxExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputSignalfxExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfxExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputSignalfxExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputSignalfxExtraHttpHeader$Outbound;
}

export function outputSignalfxExtraHttpHeaderToJSON(
  outputSignalfxExtraHttpHeader: OutputSignalfxExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputSignalfxExtraHttpHeader$outboundSchema.parse(
      outputSignalfxExtraHttpHeader,
    ),
  );
}

export function outputSignalfxExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputSignalfxExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSignalfxExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSignalfxExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputSignalfxFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputSignalfxFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSignalfxFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSignalfxFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputSignalfxFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputSignalfxFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputSignalfxFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxFailedRequestLoggingMode$ {
  /** @deprecated use `OutputSignalfxFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputSignalfxFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputSignalfxFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputSignalfxFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputSignalfxResponseRetrySetting$inboundSchema: z.ZodType<
  OutputSignalfxResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputSignalfxResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSignalfxResponseRetrySetting$outboundSchema: z.ZodType<
  OutputSignalfxResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputSignalfxResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxResponseRetrySetting$ {
  /** @deprecated use `OutputSignalfxResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputSignalfxResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputSignalfxResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputSignalfxResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputSignalfxResponseRetrySetting$Outbound;
}

export function outputSignalfxResponseRetrySettingToJSON(
  outputSignalfxResponseRetrySetting: OutputSignalfxResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputSignalfxResponseRetrySetting$outboundSchema.parse(
      outputSignalfxResponseRetrySetting,
    ),
  );
}

export function outputSignalfxResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputSignalfxResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSignalfxResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSignalfxResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputSignalfxTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputSignalfxTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputSignalfxTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSignalfxTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputSignalfxTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputSignalfxTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxTimeoutRetrySettings$ {
  /** @deprecated use `OutputSignalfxTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputSignalfxTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputSignalfxTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputSignalfxTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputSignalfxTimeoutRetrySettings$Outbound;
}

export function outputSignalfxTimeoutRetrySettingsToJSON(
  outputSignalfxTimeoutRetrySettings: OutputSignalfxTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputSignalfxTimeoutRetrySettings$outboundSchema.parse(
      outputSignalfxTimeoutRetrySettings,
    ),
  );
}

export function outputSignalfxTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSignalfxTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSignalfxTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSignalfxTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputSignalfxBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSignalfxBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSignalfxBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSignalfxBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSignalfxBackpressureBehavior,
  z.ZodTypeDef,
  OutputSignalfxBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSignalfxBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxBackpressureBehavior$ {
  /** @deprecated use `OutputSignalfxBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSignalfxBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputSignalfxBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSignalfxCompression$inboundSchema: z.ZodType<
  OutputSignalfxCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSignalfxCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSignalfxCompression$outboundSchema: z.ZodType<
  OutputSignalfxCompression,
  z.ZodTypeDef,
  OutputSignalfxCompression
> = z.union([
  z.nativeEnum(OutputSignalfxCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxCompression$ {
  /** @deprecated use `OutputSignalfxCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxCompression$inboundSchema;
  /** @deprecated use `OutputSignalfxCompression$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfxCompression$outboundSchema;
}

/** @internal */
export const OutputSignalfxQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSignalfxQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSignalfxQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSignalfxQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSignalfxQueueFullBehavior,
  z.ZodTypeDef,
  OutputSignalfxQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSignalfxQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxQueueFullBehavior$ {
  /** @deprecated use `OutputSignalfxQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSignalfxQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfxQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSignalfxMode$inboundSchema: z.ZodType<
  OutputSignalfxMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSignalfxMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSignalfxMode$outboundSchema: z.ZodType<
  OutputSignalfxMode,
  z.ZodTypeDef,
  OutputSignalfxMode
> = z.union([
  z.nativeEnum(OutputSignalfxMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxMode$ {
  /** @deprecated use `OutputSignalfxMode$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxMode$inboundSchema;
  /** @deprecated use `OutputSignalfxMode$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfxMode$outboundSchema;
}

/** @internal */
export const OutputSignalfxPqControls$inboundSchema: z.ZodType<
  OutputSignalfxPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSignalfxPqControls$Outbound = {};

/** @internal */
export const OutputSignalfxPqControls$outboundSchema: z.ZodType<
  OutputSignalfxPqControls$Outbound,
  z.ZodTypeDef,
  OutputSignalfxPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfxPqControls$ {
  /** @deprecated use `OutputSignalfxPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfxPqControls$inboundSchema;
  /** @deprecated use `OutputSignalfxPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfxPqControls$outboundSchema;
  /** @deprecated use `OutputSignalfxPqControls$Outbound` instead. */
  export type Outbound = OutputSignalfxPqControls$Outbound;
}

export function outputSignalfxPqControlsToJSON(
  outputSignalfxPqControls: OutputSignalfxPqControls,
): string {
  return JSON.stringify(
    OutputSignalfxPqControls$outboundSchema.parse(outputSignalfxPqControls),
  );
}

export function outputSignalfxPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSignalfxPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSignalfxPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSignalfxPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSignalfx$inboundSchema: z.ZodType<
  OutputSignalfx,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSignalfxType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: OutputSignalfxAuthenticationMethod$inboundSchema.default("manual"),
  realm: z.string().default("us0"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSignalfxExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: OutputSignalfxFailedRequestLoggingMode$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSignalfxResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSignalfxTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSignalfxBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSignalfxCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSignalfxQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputSignalfxMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSignalfxPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputSignalfx$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  authType: string;
  realm: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputSignalfxExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputSignalfxResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputSignalfxTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSignalfxPqControls$Outbound | undefined;
};

/** @internal */
export const OutputSignalfx$outboundSchema: z.ZodType<
  OutputSignalfx$Outbound,
  z.ZodTypeDef,
  OutputSignalfx
> = z.object({
  id: z.string(),
  type: OutputSignalfxType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: OutputSignalfxAuthenticationMethod$outboundSchema.default("manual"),
  realm: z.string().default("us0"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSignalfxExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputSignalfxFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSignalfxResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSignalfxTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSignalfxBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSignalfxCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputSignalfxQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputSignalfxMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSignalfxPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfx$ {
  /** @deprecated use `OutputSignalfx$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfx$inboundSchema;
  /** @deprecated use `OutputSignalfx$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfx$outboundSchema;
  /** @deprecated use `OutputSignalfx$Outbound` instead. */
  export type Outbound = OutputSignalfx$Outbound;
}

export function outputSignalfxToJSON(outputSignalfx: OutputSignalfx): string {
  return JSON.stringify(OutputSignalfx$outboundSchema.parse(outputSignalfx));
}

export function outputSignalfxFromJSON(
  jsonString: string,
): SafeParseResult<OutputSignalfx, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSignalfx$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSignalfx' from JSON`,
  );
}

/** @internal */
export const OutputWavefrontType$inboundSchema: z.ZodType<
  OutputWavefrontType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWavefrontType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputWavefrontType$outboundSchema: z.ZodType<
  OutputWavefrontType,
  z.ZodTypeDef,
  OutputWavefrontType
> = z.union([
  z.nativeEnum(OutputWavefrontType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontType$ {
  /** @deprecated use `OutputWavefrontType$inboundSchema` instead. */
  export const inboundSchema = OutputWavefrontType$inboundSchema;
  /** @deprecated use `OutputWavefrontType$outboundSchema` instead. */
  export const outboundSchema = OutputWavefrontType$outboundSchema;
}

/** @internal */
export const OutputWavefrontAuthenticationMethod$inboundSchema: z.ZodType<
  OutputWavefrontAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWavefrontAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputWavefrontAuthenticationMethod$outboundSchema: z.ZodType<
  OutputWavefrontAuthenticationMethod,
  z.ZodTypeDef,
  OutputWavefrontAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputWavefrontAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontAuthenticationMethod$ {
  /** @deprecated use `OutputWavefrontAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    OutputWavefrontAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputWavefrontAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputWavefrontAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputWavefrontExtraHttpHeader$inboundSchema: z.ZodType<
  OutputWavefrontExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputWavefrontExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputWavefrontExtraHttpHeader$outboundSchema: z.ZodType<
  OutputWavefrontExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputWavefrontExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontExtraHttpHeader$ {
  /** @deprecated use `OutputWavefrontExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputWavefrontExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputWavefrontExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputWavefrontExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputWavefrontExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputWavefrontExtraHttpHeader$Outbound;
}

export function outputWavefrontExtraHttpHeaderToJSON(
  outputWavefrontExtraHttpHeader: OutputWavefrontExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputWavefrontExtraHttpHeader$outboundSchema.parse(
      outputWavefrontExtraHttpHeader,
    ),
  );
}

export function outputWavefrontExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputWavefrontExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWavefrontExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWavefrontExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputWavefrontFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputWavefrontFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWavefrontFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputWavefrontFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputWavefrontFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputWavefrontFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputWavefrontFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontFailedRequestLoggingMode$ {
  /** @deprecated use `OutputWavefrontFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputWavefrontFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputWavefrontFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputWavefrontFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputWavefrontResponseRetrySetting$inboundSchema: z.ZodType<
  OutputWavefrontResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputWavefrontResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputWavefrontResponseRetrySetting$outboundSchema: z.ZodType<
  OutputWavefrontResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputWavefrontResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontResponseRetrySetting$ {
  /** @deprecated use `OutputWavefrontResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema =
    OutputWavefrontResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputWavefrontResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputWavefrontResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputWavefrontResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputWavefrontResponseRetrySetting$Outbound;
}

export function outputWavefrontResponseRetrySettingToJSON(
  outputWavefrontResponseRetrySetting: OutputWavefrontResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputWavefrontResponseRetrySetting$outboundSchema.parse(
      outputWavefrontResponseRetrySetting,
    ),
  );
}

export function outputWavefrontResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputWavefrontResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputWavefrontResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWavefrontResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputWavefrontTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputWavefrontTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputWavefrontTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputWavefrontTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputWavefrontTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputWavefrontTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontTimeoutRetrySettings$ {
  /** @deprecated use `OutputWavefrontTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema =
    OutputWavefrontTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputWavefrontTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputWavefrontTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputWavefrontTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputWavefrontTimeoutRetrySettings$Outbound;
}

export function outputWavefrontTimeoutRetrySettingsToJSON(
  outputWavefrontTimeoutRetrySettings: OutputWavefrontTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputWavefrontTimeoutRetrySettings$outboundSchema.parse(
      outputWavefrontTimeoutRetrySettings,
    ),
  );
}

export function outputWavefrontTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputWavefrontTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputWavefrontTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWavefrontTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputWavefrontBackpressureBehavior$inboundSchema: z.ZodType<
  OutputWavefrontBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWavefrontBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputWavefrontBackpressureBehavior$outboundSchema: z.ZodType<
  OutputWavefrontBackpressureBehavior,
  z.ZodTypeDef,
  OutputWavefrontBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputWavefrontBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontBackpressureBehavior$ {
  /** @deprecated use `OutputWavefrontBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema =
    OutputWavefrontBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputWavefrontBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputWavefrontBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputWavefrontCompression$inboundSchema: z.ZodType<
  OutputWavefrontCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWavefrontCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputWavefrontCompression$outboundSchema: z.ZodType<
  OutputWavefrontCompression,
  z.ZodTypeDef,
  OutputWavefrontCompression
> = z.union([
  z.nativeEnum(OutputWavefrontCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontCompression$ {
  /** @deprecated use `OutputWavefrontCompression$inboundSchema` instead. */
  export const inboundSchema = OutputWavefrontCompression$inboundSchema;
  /** @deprecated use `OutputWavefrontCompression$outboundSchema` instead. */
  export const outboundSchema = OutputWavefrontCompression$outboundSchema;
}

/** @internal */
export const OutputWavefrontQueueFullBehavior$inboundSchema: z.ZodType<
  OutputWavefrontQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWavefrontQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputWavefrontQueueFullBehavior$outboundSchema: z.ZodType<
  OutputWavefrontQueueFullBehavior,
  z.ZodTypeDef,
  OutputWavefrontQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputWavefrontQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontQueueFullBehavior$ {
  /** @deprecated use `OutputWavefrontQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputWavefrontQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputWavefrontQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputWavefrontQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputWavefrontMode$inboundSchema: z.ZodType<
  OutputWavefrontMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWavefrontMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputWavefrontMode$outboundSchema: z.ZodType<
  OutputWavefrontMode,
  z.ZodTypeDef,
  OutputWavefrontMode
> = z.union([
  z.nativeEnum(OutputWavefrontMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontMode$ {
  /** @deprecated use `OutputWavefrontMode$inboundSchema` instead. */
  export const inboundSchema = OutputWavefrontMode$inboundSchema;
  /** @deprecated use `OutputWavefrontMode$outboundSchema` instead. */
  export const outboundSchema = OutputWavefrontMode$outboundSchema;
}

/** @internal */
export const OutputWavefrontPqControls$inboundSchema: z.ZodType<
  OutputWavefrontPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputWavefrontPqControls$Outbound = {};

/** @internal */
export const OutputWavefrontPqControls$outboundSchema: z.ZodType<
  OutputWavefrontPqControls$Outbound,
  z.ZodTypeDef,
  OutputWavefrontPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefrontPqControls$ {
  /** @deprecated use `OutputWavefrontPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputWavefrontPqControls$inboundSchema;
  /** @deprecated use `OutputWavefrontPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputWavefrontPqControls$outboundSchema;
  /** @deprecated use `OutputWavefrontPqControls$Outbound` instead. */
  export type Outbound = OutputWavefrontPqControls$Outbound;
}

export function outputWavefrontPqControlsToJSON(
  outputWavefrontPqControls: OutputWavefrontPqControls,
): string {
  return JSON.stringify(
    OutputWavefrontPqControls$outboundSchema.parse(outputWavefrontPqControls),
  );
}

export function outputWavefrontPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputWavefrontPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWavefrontPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWavefrontPqControls' from JSON`,
  );
}

/** @internal */
export const OutputWavefront$inboundSchema: z.ZodType<
  OutputWavefront,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputWavefrontType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: OutputWavefrontAuthenticationMethod$inboundSchema.default("manual"),
  domain: z.string().default("longboard"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputWavefrontExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputWavefrontFailedRequestLoggingMode$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputWavefrontResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputWavefrontTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputWavefrontBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputWavefrontCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputWavefrontQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputWavefrontMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputWavefrontPqControls$inboundSchema).optional(),
});

/** @internal */
export type OutputWavefront$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  authType: string;
  domain: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputWavefrontExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputWavefrontResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputWavefrontTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputWavefrontPqControls$Outbound | undefined;
};

/** @internal */
export const OutputWavefront$outboundSchema: z.ZodType<
  OutputWavefront$Outbound,
  z.ZodTypeDef,
  OutputWavefront
> = z.object({
  id: z.string(),
  type: OutputWavefrontType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: OutputWavefrontAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  domain: z.string().default("longboard"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputWavefrontExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputWavefrontFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputWavefrontResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputWavefrontTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputWavefrontBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputWavefrontCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputWavefrontQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputWavefrontMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputWavefrontPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefront$ {
  /** @deprecated use `OutputWavefront$inboundSchema` instead. */
  export const inboundSchema = OutputWavefront$inboundSchema;
  /** @deprecated use `OutputWavefront$outboundSchema` instead. */
  export const outboundSchema = OutputWavefront$outboundSchema;
  /** @deprecated use `OutputWavefront$Outbound` instead. */
  export type Outbound = OutputWavefront$Outbound;
}

export function outputWavefrontToJSON(
  outputWavefront: OutputWavefront,
): string {
  return JSON.stringify(OutputWavefront$outboundSchema.parse(outputWavefront));
}

export function outputWavefrontFromJSON(
  jsonString: string,
): SafeParseResult<OutputWavefront, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWavefront$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWavefront' from JSON`,
  );
}

/** @internal */
export const OutputSplunkLbType$inboundSchema: z.ZodType<
  OutputSplunkLbType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbType$outboundSchema: z.ZodType<
  OutputSplunkLbType,
  z.ZodTypeDef,
  OutputSplunkLbType
> = z.union([
  z.nativeEnum(OutputSplunkLbType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbType$ {
  /** @deprecated use `OutputSplunkLbType$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbType$inboundSchema;
  /** @deprecated use `OutputSplunkLbType$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbType$outboundSchema;
}

/** @internal */
export const OutputSplunkLbNestedFieldSerialization$inboundSchema: z.ZodType<
  OutputSplunkLbNestedFieldSerialization,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbNestedFieldSerialization),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbNestedFieldSerialization$outboundSchema: z.ZodType<
  OutputSplunkLbNestedFieldSerialization,
  z.ZodTypeDef,
  OutputSplunkLbNestedFieldSerialization
> = z.union([
  z.nativeEnum(OutputSplunkLbNestedFieldSerialization),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbNestedFieldSerialization$ {
  /** @deprecated use `OutputSplunkLbNestedFieldSerialization$inboundSchema` instead. */
  export const inboundSchema =
    OutputSplunkLbNestedFieldSerialization$inboundSchema;
  /** @deprecated use `OutputSplunkLbNestedFieldSerialization$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkLbNestedFieldSerialization$outboundSchema;
}

/** @internal */
export const OutputSplunkLbMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputSplunkLbMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputSplunkLbMinimumTLSVersion,
  z.ZodTypeDef,
  OutputSplunkLbMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputSplunkLbMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbMinimumTLSVersion$ {
  /** @deprecated use `OutputSplunkLbMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputSplunkLbMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputSplunkLbMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputSplunkLbMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputSplunkLbMaximumTLSVersion,
  z.ZodTypeDef,
  OutputSplunkLbMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputSplunkLbMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbMaximumTLSVersion$ {
  /** @deprecated use `OutputSplunkLbMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputSplunkLbMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputSplunkLbTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputSplunkLbTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputSplunkLbMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputSplunkLbMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputSplunkLbTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputSplunkLbTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputSplunkLbTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputSplunkLbTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputSplunkLbMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: OutputSplunkLbMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbTLSSettingsClientSide$ {
  /** @deprecated use `OutputSplunkLbTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    OutputSplunkLbTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputSplunkLbTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkLbTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputSplunkLbTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputSplunkLbTLSSettingsClientSide$Outbound;
}

export function outputSplunkLbTLSSettingsClientSideToJSON(
  outputSplunkLbTLSSettingsClientSide: OutputSplunkLbTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputSplunkLbTLSSettingsClientSide$outboundSchema.parse(
      outputSplunkLbTLSSettingsClientSide,
    ),
  );
}

export function outputSplunkLbTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunkLbTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSplunkLbTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunkLbTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputSplunkLbMaxS2SVersion$inboundSchema: z.ZodType<
  OutputSplunkLbMaxS2SVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbMaxS2SVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbMaxS2SVersion$outboundSchema: z.ZodType<
  OutputSplunkLbMaxS2SVersion,
  z.ZodTypeDef,
  OutputSplunkLbMaxS2SVersion
> = z.union([
  z.nativeEnum(OutputSplunkLbMaxS2SVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbMaxS2SVersion$ {
  /** @deprecated use `OutputSplunkLbMaxS2SVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbMaxS2SVersion$inboundSchema;
  /** @deprecated use `OutputSplunkLbMaxS2SVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbMaxS2SVersion$outboundSchema;
}

/** @internal */
export const OutputSplunkLbBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSplunkLbBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSplunkLbBackpressureBehavior,
  z.ZodTypeDef,
  OutputSplunkLbBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSplunkLbBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbBackpressureBehavior$ {
  /** @deprecated use `OutputSplunkLbBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSplunkLbBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkLbBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSplunkLbAuthenticationMethod$inboundSchema: z.ZodType<
  OutputSplunkLbAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbAuthenticationMethod$outboundSchema: z.ZodType<
  OutputSplunkLbAuthenticationMethod,
  z.ZodTypeDef,
  OutputSplunkLbAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputSplunkLbAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbAuthenticationMethod$ {
  /** @deprecated use `OutputSplunkLbAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputSplunkLbAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkLbAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputSplunkLbCompressCompression$inboundSchema: z.ZodType<
  OutputSplunkLbCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbCompressCompression$outboundSchema: z.ZodType<
  OutputSplunkLbCompressCompression,
  z.ZodTypeDef,
  OutputSplunkLbCompressCompression
> = z.union([
  z.nativeEnum(OutputSplunkLbCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbCompressCompression$ {
  /** @deprecated use `OutputSplunkLbCompressCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbCompressCompression$inboundSchema;
  /** @deprecated use `OutputSplunkLbCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkLbCompressCompression$outboundSchema;
}

/** @internal */
export const IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema:
  z.ZodType<
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(IndexerDiscoveryConfigsAuthTokenAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema:
  z.ZodType<
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod,
    z.ZodTypeDef,
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod
  > = z.union([
    z.nativeEnum(IndexerDiscoveryConfigsAuthTokenAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$ {
  /** @deprecated use `IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema;
}

/** @internal */
export const CreateOutputAuthToken$inboundSchema: z.ZodType<
  CreateOutputAuthToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema
    .default("manual"),
});

/** @internal */
export type CreateOutputAuthToken$Outbound = {
  authType: string;
};

/** @internal */
export const CreateOutputAuthToken$outboundSchema: z.ZodType<
  CreateOutputAuthToken$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthToken
> = z.object({
  authType: IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema
    .default("manual"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthToken$ {
  /** @deprecated use `CreateOutputAuthToken$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthToken$inboundSchema;
  /** @deprecated use `CreateOutputAuthToken$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAuthToken$outboundSchema;
  /** @deprecated use `CreateOutputAuthToken$Outbound` instead. */
  export type Outbound = CreateOutputAuthToken$Outbound;
}

export function createOutputAuthTokenToJSON(
  createOutputAuthToken: CreateOutputAuthToken,
): string {
  return JSON.stringify(
    CreateOutputAuthToken$outboundSchema.parse(createOutputAuthToken),
  );
}

export function createOutputAuthTokenFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputAuthToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputAuthToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputAuthToken' from JSON`,
  );
}

/** @internal */
export const IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema:
  z.ZodType<
    IndexerDiscoveryConfigsAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(IndexerDiscoveryConfigsAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema:
  z.ZodType<
    IndexerDiscoveryConfigsAuthenticationMethod,
    z.ZodTypeDef,
    IndexerDiscoveryConfigsAuthenticationMethod
  > = z.union([
    z.nativeEnum(IndexerDiscoveryConfigsAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IndexerDiscoveryConfigsAuthenticationMethod$ {
  /** @deprecated use `IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema;
}

/** @internal */
export const IndexerDiscoveryConfigs$inboundSchema: z.ZodType<
  IndexerDiscoveryConfigs,
  z.ZodTypeDef,
  unknown
> = z.object({
  site: z.string().default("default"),
  masterUri: z.string(),
  refreshIntervalSec: z.number().default(300),
  rejectUnauthorized: z.boolean().default(false),
  authTokens: z.array(z.lazy(() => CreateOutputAuthToken$inboundSchema))
    .optional(),
  authType: IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type IndexerDiscoveryConfigs$Outbound = {
  site: string;
  masterUri: string;
  refreshIntervalSec: number;
  rejectUnauthorized: boolean;
  authTokens?: Array<CreateOutputAuthToken$Outbound> | undefined;
  authType: string;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const IndexerDiscoveryConfigs$outboundSchema: z.ZodType<
  IndexerDiscoveryConfigs$Outbound,
  z.ZodTypeDef,
  IndexerDiscoveryConfigs
> = z.object({
  site: z.string().default("default"),
  masterUri: z.string(),
  refreshIntervalSec: z.number().default(300),
  rejectUnauthorized: z.boolean().default(false),
  authTokens: z.array(z.lazy(() => CreateOutputAuthToken$outboundSchema))
    .optional(),
  authType: IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IndexerDiscoveryConfigs$ {
  /** @deprecated use `IndexerDiscoveryConfigs$inboundSchema` instead. */
  export const inboundSchema = IndexerDiscoveryConfigs$inboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigs$outboundSchema` instead. */
  export const outboundSchema = IndexerDiscoveryConfigs$outboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigs$Outbound` instead. */
  export type Outbound = IndexerDiscoveryConfigs$Outbound;
}

export function indexerDiscoveryConfigsToJSON(
  indexerDiscoveryConfigs: IndexerDiscoveryConfigs,
): string {
  return JSON.stringify(
    IndexerDiscoveryConfigs$outboundSchema.parse(indexerDiscoveryConfigs),
  );
}

export function indexerDiscoveryConfigsFromJSON(
  jsonString: string,
): SafeParseResult<IndexerDiscoveryConfigs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IndexerDiscoveryConfigs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IndexerDiscoveryConfigs' from JSON`,
  );
}

/** @internal */
export const Tls$inboundSchema: z.ZodType<Tls, z.ZodTypeDef, unknown> = z
  .union([
    z.nativeEnum(Tls),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Tls$outboundSchema: z.ZodType<Tls, z.ZodTypeDef, Tls> = z.union([
  z.nativeEnum(Tls),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tls$ {
  /** @deprecated use `Tls$inboundSchema` instead. */
  export const inboundSchema = Tls$inboundSchema;
  /** @deprecated use `Tls$outboundSchema` instead. */
  export const outboundSchema = Tls$outboundSchema;
}

/** @internal */
export const OutputSplunkLbHost$inboundSchema: z.ZodType<
  OutputSplunkLbHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  port: z.number().default(9997),
  tls: Tls$inboundSchema.default("inherit"),
  servername: z.string().optional(),
  weight: z.number().default(1),
});

/** @internal */
export type OutputSplunkLbHost$Outbound = {
  host: string;
  port: number;
  tls: string;
  servername?: string | undefined;
  weight: number;
};

/** @internal */
export const OutputSplunkLbHost$outboundSchema: z.ZodType<
  OutputSplunkLbHost$Outbound,
  z.ZodTypeDef,
  OutputSplunkLbHost
> = z.object({
  host: z.string(),
  port: z.number().default(9997),
  tls: Tls$outboundSchema.default("inherit"),
  servername: z.string().optional(),
  weight: z.number().default(1),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbHost$ {
  /** @deprecated use `OutputSplunkLbHost$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbHost$inboundSchema;
  /** @deprecated use `OutputSplunkLbHost$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbHost$outboundSchema;
  /** @deprecated use `OutputSplunkLbHost$Outbound` instead. */
  export type Outbound = OutputSplunkLbHost$Outbound;
}

export function outputSplunkLbHostToJSON(
  outputSplunkLbHost: OutputSplunkLbHost,
): string {
  return JSON.stringify(
    OutputSplunkLbHost$outboundSchema.parse(outputSplunkLbHost),
  );
}

export function outputSplunkLbHostFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunkLbHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunkLbHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunkLbHost' from JSON`,
  );
}

/** @internal */
export const OutputSplunkLbPqCompressCompression$inboundSchema: z.ZodType<
  OutputSplunkLbPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbPqCompressCompression$outboundSchema: z.ZodType<
  OutputSplunkLbPqCompressCompression,
  z.ZodTypeDef,
  OutputSplunkLbPqCompressCompression
> = z.union([
  z.nativeEnum(OutputSplunkLbPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbPqCompressCompression$ {
  /** @deprecated use `OutputSplunkLbPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema =
    OutputSplunkLbPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputSplunkLbPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkLbPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputSplunkLbQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSplunkLbQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSplunkLbQueueFullBehavior,
  z.ZodTypeDef,
  OutputSplunkLbQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSplunkLbQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbQueueFullBehavior$ {
  /** @deprecated use `OutputSplunkLbQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSplunkLbQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSplunkLbMode$inboundSchema: z.ZodType<
  OutputSplunkLbMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkLbMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkLbMode$outboundSchema: z.ZodType<
  OutputSplunkLbMode,
  z.ZodTypeDef,
  OutputSplunkLbMode
> = z.union([
  z.nativeEnum(OutputSplunkLbMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbMode$ {
  /** @deprecated use `OutputSplunkLbMode$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbMode$inboundSchema;
  /** @deprecated use `OutputSplunkLbMode$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbMode$outboundSchema;
}

/** @internal */
export const OutputSplunkLbPqControls$inboundSchema: z.ZodType<
  OutputSplunkLbPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSplunkLbPqControls$Outbound = {};

/** @internal */
export const OutputSplunkLbPqControls$outboundSchema: z.ZodType<
  OutputSplunkLbPqControls$Outbound,
  z.ZodTypeDef,
  OutputSplunkLbPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLbPqControls$ {
  /** @deprecated use `OutputSplunkLbPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLbPqControls$inboundSchema;
  /** @deprecated use `OutputSplunkLbPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLbPqControls$outboundSchema;
  /** @deprecated use `OutputSplunkLbPqControls$Outbound` instead. */
  export type Outbound = OutputSplunkLbPqControls$Outbound;
}

export function outputSplunkLbPqControlsToJSON(
  outputSplunkLbPqControls: OutputSplunkLbPqControls,
): string {
  return JSON.stringify(
    OutputSplunkLbPqControls$outboundSchema.parse(outputSplunkLbPqControls),
  );
}

export function outputSplunkLbPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunkLbPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunkLbPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunkLbPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSplunkLb$inboundSchema: z.ZodType<
  OutputSplunkLb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSplunkLbType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  maxConcurrentSenders: z.number().default(0),
  nestedFields: OutputSplunkLbNestedFieldSerialization$inboundSchema.default(
    "none",
  ),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => OutputSplunkLbTLSSettingsClientSide$inboundSchema)
    .optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: OutputSplunkLbMaxS2SVersion$inboundSchema.default("v3"),
  onBackpressure: OutputSplunkLbBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  indexerDiscovery: z.boolean().default(false),
  senderUnhealthyTimeAllowance: z.number().default(100),
  authType: OutputSplunkLbAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: OutputSplunkLbCompressCompression$inboundSchema.default("disabled"),
  indexerDiscoveryConfigs: z.lazy(() => IndexerDiscoveryConfigs$inboundSchema)
    .optional(),
  excludeSelf: z.boolean().default(false),
  hosts: z.array(z.lazy(() => OutputSplunkLbHost$inboundSchema)),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSplunkLbPqCompressCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSplunkLbQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputSplunkLbMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSplunkLbPqControls$inboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputSplunkLb$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
  maxConcurrentSenders: number;
  nestedFields: string;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  tls?: OutputSplunkLbTLSSettingsClientSide$Outbound | undefined;
  enableMultiMetrics: boolean;
  enableACK: boolean;
  logFailedRequests: boolean;
  maxS2Sversion: string;
  onBackpressure: string;
  indexerDiscovery: boolean;
  senderUnhealthyTimeAllowance: number;
  authType: string;
  description?: string | undefined;
  maxFailedHealthChecks: number;
  compress: string;
  indexerDiscoveryConfigs?: IndexerDiscoveryConfigs$Outbound | undefined;
  excludeSelf: boolean;
  hosts: Array<OutputSplunkLbHost$Outbound>;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSplunkLbPqControls$Outbound | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputSplunkLb$outboundSchema: z.ZodType<
  OutputSplunkLb$Outbound,
  z.ZodTypeDef,
  OutputSplunkLb
> = z.object({
  id: z.string(),
  type: OutputSplunkLbType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  maxConcurrentSenders: z.number().default(0),
  nestedFields: OutputSplunkLbNestedFieldSerialization$outboundSchema.default(
    "none",
  ),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => OutputSplunkLbTLSSettingsClientSide$outboundSchema)
    .optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: OutputSplunkLbMaxS2SVersion$outboundSchema.default("v3"),
  onBackpressure: OutputSplunkLbBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  indexerDiscovery: z.boolean().default(false),
  senderUnhealthyTimeAllowance: z.number().default(100),
  authType: OutputSplunkLbAuthenticationMethod$outboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: OutputSplunkLbCompressCompression$outboundSchema.default(
    "disabled",
  ),
  indexerDiscoveryConfigs: z.lazy(() => IndexerDiscoveryConfigs$outboundSchema)
    .optional(),
  excludeSelf: z.boolean().default(false),
  hosts: z.array(z.lazy(() => OutputSplunkLbHost$outboundSchema)),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSplunkLbPqCompressCompression$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: OutputSplunkLbQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputSplunkLbMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSplunkLbPqControls$outboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLb$ {
  /** @deprecated use `OutputSplunkLb$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLb$inboundSchema;
  /** @deprecated use `OutputSplunkLb$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLb$outboundSchema;
  /** @deprecated use `OutputSplunkLb$Outbound` instead. */
  export type Outbound = OutputSplunkLb$Outbound;
}

export function outputSplunkLbToJSON(outputSplunkLb: OutputSplunkLb): string {
  return JSON.stringify(OutputSplunkLb$outboundSchema.parse(outputSplunkLb));
}

export function outputSplunkLbFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunkLb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunkLb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunkLb' from JSON`,
  );
}

/** @internal */
export const OutputSplunkType$inboundSchema: z.ZodType<
  OutputSplunkType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkType$outboundSchema: z.ZodType<
  OutputSplunkType,
  z.ZodTypeDef,
  OutputSplunkType
> = z.union([
  z.nativeEnum(OutputSplunkType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkType$ {
  /** @deprecated use `OutputSplunkType$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkType$inboundSchema;
  /** @deprecated use `OutputSplunkType$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkType$outboundSchema;
}

/** @internal */
export const OutputSplunkNestedFieldSerialization$inboundSchema: z.ZodType<
  OutputSplunkNestedFieldSerialization,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkNestedFieldSerialization),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkNestedFieldSerialization$outboundSchema: z.ZodType<
  OutputSplunkNestedFieldSerialization,
  z.ZodTypeDef,
  OutputSplunkNestedFieldSerialization
> = z.union([
  z.nativeEnum(OutputSplunkNestedFieldSerialization),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkNestedFieldSerialization$ {
  /** @deprecated use `OutputSplunkNestedFieldSerialization$inboundSchema` instead. */
  export const inboundSchema =
    OutputSplunkNestedFieldSerialization$inboundSchema;
  /** @deprecated use `OutputSplunkNestedFieldSerialization$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkNestedFieldSerialization$outboundSchema;
}

/** @internal */
export const OutputSplunkMinimumTLSVersion$inboundSchema: z.ZodType<
  OutputSplunkMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkMinimumTLSVersion$outboundSchema: z.ZodType<
  OutputSplunkMinimumTLSVersion,
  z.ZodTypeDef,
  OutputSplunkMinimumTLSVersion
> = z.union([
  z.nativeEnum(OutputSplunkMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkMinimumTLSVersion$ {
  /** @deprecated use `OutputSplunkMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkMinimumTLSVersion$inboundSchema;
  /** @deprecated use `OutputSplunkMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputSplunkMaximumTLSVersion$inboundSchema: z.ZodType<
  OutputSplunkMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkMaximumTLSVersion$outboundSchema: z.ZodType<
  OutputSplunkMaximumTLSVersion,
  z.ZodTypeDef,
  OutputSplunkMaximumTLSVersion
> = z.union([
  z.nativeEnum(OutputSplunkMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkMaximumTLSVersion$ {
  /** @deprecated use `OutputSplunkMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkMaximumTLSVersion$inboundSchema;
  /** @deprecated use `OutputSplunkMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const OutputSplunkTLSSettingsClientSide$inboundSchema: z.ZodType<
  OutputSplunkTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputSplunkMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: OutputSplunkMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type OutputSplunkTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const OutputSplunkTLSSettingsClientSide$outboundSchema: z.ZodType<
  OutputSplunkTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  OutputSplunkTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: OutputSplunkMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: OutputSplunkMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkTLSSettingsClientSide$ {
  /** @deprecated use `OutputSplunkTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `OutputSplunkTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `OutputSplunkTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = OutputSplunkTLSSettingsClientSide$Outbound;
}

export function outputSplunkTLSSettingsClientSideToJSON(
  outputSplunkTLSSettingsClientSide: OutputSplunkTLSSettingsClientSide,
): string {
  return JSON.stringify(
    OutputSplunkTLSSettingsClientSide$outboundSchema.parse(
      outputSplunkTLSSettingsClientSide,
    ),
  );
}

export function outputSplunkTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunkTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunkTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunkTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const OutputSplunkMaxS2SVersion$inboundSchema: z.ZodType<
  OutputSplunkMaxS2SVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkMaxS2SVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkMaxS2SVersion$outboundSchema: z.ZodType<
  OutputSplunkMaxS2SVersion,
  z.ZodTypeDef,
  OutputSplunkMaxS2SVersion
> = z.union([
  z.nativeEnum(OutputSplunkMaxS2SVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkMaxS2SVersion$ {
  /** @deprecated use `OutputSplunkMaxS2SVersion$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkMaxS2SVersion$inboundSchema;
  /** @deprecated use `OutputSplunkMaxS2SVersion$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkMaxS2SVersion$outboundSchema;
}

/** @internal */
export const OutputSplunkBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSplunkBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSplunkBackpressureBehavior,
  z.ZodTypeDef,
  OutputSplunkBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSplunkBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkBackpressureBehavior$ {
  /** @deprecated use `OutputSplunkBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSplunkBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputSplunkAuthenticationMethod$inboundSchema: z.ZodType<
  OutputSplunkAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkAuthenticationMethod$outboundSchema: z.ZodType<
  OutputSplunkAuthenticationMethod,
  z.ZodTypeDef,
  OutputSplunkAuthenticationMethod
> = z.union([
  z.nativeEnum(OutputSplunkAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkAuthenticationMethod$ {
  /** @deprecated use `OutputSplunkAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputSplunkAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputSplunkCompressCompression$inboundSchema: z.ZodType<
  OutputSplunkCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkCompressCompression$outboundSchema: z.ZodType<
  OutputSplunkCompressCompression,
  z.ZodTypeDef,
  OutputSplunkCompressCompression
> = z.union([
  z.nativeEnum(OutputSplunkCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkCompressCompression$ {
  /** @deprecated use `OutputSplunkCompressCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkCompressCompression$inboundSchema;
  /** @deprecated use `OutputSplunkCompressCompression$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkCompressCompression$outboundSchema;
}

/** @internal */
export const OutputSplunkPqCompressCompression$inboundSchema: z.ZodType<
  OutputSplunkPqCompressCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkPqCompressCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkPqCompressCompression$outboundSchema: z.ZodType<
  OutputSplunkPqCompressCompression,
  z.ZodTypeDef,
  OutputSplunkPqCompressCompression
> = z.union([
  z.nativeEnum(OutputSplunkPqCompressCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkPqCompressCompression$ {
  /** @deprecated use `OutputSplunkPqCompressCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkPqCompressCompression$inboundSchema;
  /** @deprecated use `OutputSplunkPqCompressCompression$outboundSchema` instead. */
  export const outboundSchema =
    OutputSplunkPqCompressCompression$outboundSchema;
}

/** @internal */
export const OutputSplunkQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSplunkQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSplunkQueueFullBehavior,
  z.ZodTypeDef,
  OutputSplunkQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSplunkQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkQueueFullBehavior$ {
  /** @deprecated use `OutputSplunkQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSplunkQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSplunkMode$inboundSchema: z.ZodType<
  OutputSplunkMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSplunkMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSplunkMode$outboundSchema: z.ZodType<
  OutputSplunkMode,
  z.ZodTypeDef,
  OutputSplunkMode
> = z.union([
  z.nativeEnum(OutputSplunkMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkMode$ {
  /** @deprecated use `OutputSplunkMode$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkMode$inboundSchema;
  /** @deprecated use `OutputSplunkMode$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkMode$outboundSchema;
}

/** @internal */
export const OutputSplunkPqControls$inboundSchema: z.ZodType<
  OutputSplunkPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSplunkPqControls$Outbound = {};

/** @internal */
export const OutputSplunkPqControls$outboundSchema: z.ZodType<
  OutputSplunkPqControls$Outbound,
  z.ZodTypeDef,
  OutputSplunkPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkPqControls$ {
  /** @deprecated use `OutputSplunkPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkPqControls$inboundSchema;
  /** @deprecated use `OutputSplunkPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkPqControls$outboundSchema;
  /** @deprecated use `OutputSplunkPqControls$Outbound` instead. */
  export type Outbound = OutputSplunkPqControls$Outbound;
}

export function outputSplunkPqControlsToJSON(
  outputSplunkPqControls: OutputSplunkPqControls,
): string {
  return JSON.stringify(
    OutputSplunkPqControls$outboundSchema.parse(outputSplunkPqControls),
  );
}

export function outputSplunkPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunkPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunkPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunkPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSplunk$inboundSchema: z.ZodType<
  OutputSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSplunkType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  host: z.string(),
  port: z.number().default(9997),
  nestedFields: OutputSplunkNestedFieldSerialization$inboundSchema.default(
    "none",
  ),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => OutputSplunkTLSSettingsClientSide$inboundSchema).optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: OutputSplunkMaxS2SVersion$inboundSchema.default("v3"),
  onBackpressure: OutputSplunkBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  authType: OutputSplunkAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: OutputSplunkCompressCompression$inboundSchema.default("disabled"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSplunkPqCompressCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSplunkQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputSplunkMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSplunkPqControls$inboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputSplunk$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  host: string;
  port: number;
  nestedFields: string;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  tls?: OutputSplunkTLSSettingsClientSide$Outbound | undefined;
  enableMultiMetrics: boolean;
  enableACK: boolean;
  logFailedRequests: boolean;
  maxS2Sversion: string;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  maxFailedHealthChecks: number;
  compress: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSplunkPqControls$Outbound | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputSplunk$outboundSchema: z.ZodType<
  OutputSplunk$Outbound,
  z.ZodTypeDef,
  OutputSplunk
> = z.object({
  id: z.string(),
  type: OutputSplunkType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  host: z.string(),
  port: z.number().default(9997),
  nestedFields: OutputSplunkNestedFieldSerialization$outboundSchema.default(
    "none",
  ),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => OutputSplunkTLSSettingsClientSide$outboundSchema)
    .optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: OutputSplunkMaxS2SVersion$outboundSchema.default("v3"),
  onBackpressure: OutputSplunkBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  authType: OutputSplunkAuthenticationMethod$outboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: OutputSplunkCompressCompression$outboundSchema.default("disabled"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSplunkPqCompressCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputSplunkQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputSplunkMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSplunkPqControls$outboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunk$ {
  /** @deprecated use `OutputSplunk$inboundSchema` instead. */
  export const inboundSchema = OutputSplunk$inboundSchema;
  /** @deprecated use `OutputSplunk$outboundSchema` instead. */
  export const outboundSchema = OutputSplunk$outboundSchema;
  /** @deprecated use `OutputSplunk$Outbound` instead. */
  export type Outbound = OutputSplunk$Outbound;
}

export function outputSplunkToJSON(outputSplunk: OutputSplunk): string {
  return JSON.stringify(OutputSplunk$outboundSchema.parse(outputSplunk));
}

export function outputSplunkFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunk' from JSON`,
  );
}

/** @internal */
export const OutputSentinelType$inboundSchema: z.ZodType<
  OutputSentinelType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelType$outboundSchema: z.ZodType<
  OutputSentinelType,
  z.ZodTypeDef,
  OutputSentinelType
> = z.union([
  z.nativeEnum(OutputSentinelType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelType$ {
  /** @deprecated use `OutputSentinelType$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelType$inboundSchema;
  /** @deprecated use `OutputSentinelType$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelType$outboundSchema;
}

/** @internal */
export const OutputSentinelExtraHttpHeader$inboundSchema: z.ZodType<
  OutputSentinelExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type OutputSentinelExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const OutputSentinelExtraHttpHeader$outboundSchema: z.ZodType<
  OutputSentinelExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  OutputSentinelExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelExtraHttpHeader$ {
  /** @deprecated use `OutputSentinelExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelExtraHttpHeader$inboundSchema;
  /** @deprecated use `OutputSentinelExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelExtraHttpHeader$outboundSchema;
  /** @deprecated use `OutputSentinelExtraHttpHeader$Outbound` instead. */
  export type Outbound = OutputSentinelExtraHttpHeader$Outbound;
}

export function outputSentinelExtraHttpHeaderToJSON(
  outputSentinelExtraHttpHeader: OutputSentinelExtraHttpHeader,
): string {
  return JSON.stringify(
    OutputSentinelExtraHttpHeader$outboundSchema.parse(
      outputSentinelExtraHttpHeader,
    ),
  );
}

export function outputSentinelExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSentinelExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const OutputSentinelFailedRequestLoggingMode$inboundSchema: z.ZodType<
  OutputSentinelFailedRequestLoggingMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelFailedRequestLoggingMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelFailedRequestLoggingMode$outboundSchema: z.ZodType<
  OutputSentinelFailedRequestLoggingMode,
  z.ZodTypeDef,
  OutputSentinelFailedRequestLoggingMode
> = z.union([
  z.nativeEnum(OutputSentinelFailedRequestLoggingMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelFailedRequestLoggingMode$ {
  /** @deprecated use `OutputSentinelFailedRequestLoggingMode$inboundSchema` instead. */
  export const inboundSchema =
    OutputSentinelFailedRequestLoggingMode$inboundSchema;
  /** @deprecated use `OutputSentinelFailedRequestLoggingMode$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelFailedRequestLoggingMode$outboundSchema;
}

/** @internal */
export const OutputSentinelResponseRetrySetting$inboundSchema: z.ZodType<
  OutputSentinelResponseRetrySetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputSentinelResponseRetrySetting$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSentinelResponseRetrySetting$outboundSchema: z.ZodType<
  OutputSentinelResponseRetrySetting$Outbound,
  z.ZodTypeDef,
  OutputSentinelResponseRetrySetting
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelResponseRetrySetting$ {
  /** @deprecated use `OutputSentinelResponseRetrySetting$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelResponseRetrySetting$inboundSchema;
  /** @deprecated use `OutputSentinelResponseRetrySetting$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelResponseRetrySetting$outboundSchema;
  /** @deprecated use `OutputSentinelResponseRetrySetting$Outbound` instead. */
  export type Outbound = OutputSentinelResponseRetrySetting$Outbound;
}

export function outputSentinelResponseRetrySettingToJSON(
  outputSentinelResponseRetrySetting: OutputSentinelResponseRetrySetting,
): string {
  return JSON.stringify(
    OutputSentinelResponseRetrySetting$outboundSchema.parse(
      outputSentinelResponseRetrySetting,
    ),
  );
}

export function outputSentinelResponseRetrySettingFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelResponseRetrySetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSentinelResponseRetrySetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelResponseRetrySetting' from JSON`,
  );
}

/** @internal */
export const OutputSentinelTimeoutRetrySettings$inboundSchema: z.ZodType<
  OutputSentinelTimeoutRetrySettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type OutputSentinelTimeoutRetrySettings$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const OutputSentinelTimeoutRetrySettings$outboundSchema: z.ZodType<
  OutputSentinelTimeoutRetrySettings$Outbound,
  z.ZodTypeDef,
  OutputSentinelTimeoutRetrySettings
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelTimeoutRetrySettings$ {
  /** @deprecated use `OutputSentinelTimeoutRetrySettings$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelTimeoutRetrySettings$inboundSchema;
  /** @deprecated use `OutputSentinelTimeoutRetrySettings$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelTimeoutRetrySettings$outboundSchema;
  /** @deprecated use `OutputSentinelTimeoutRetrySettings$Outbound` instead. */
  export type Outbound = OutputSentinelTimeoutRetrySettings$Outbound;
}

export function outputSentinelTimeoutRetrySettingsToJSON(
  outputSentinelTimeoutRetrySettings: OutputSentinelTimeoutRetrySettings,
): string {
  return JSON.stringify(
    OutputSentinelTimeoutRetrySettings$outboundSchema.parse(
      outputSentinelTimeoutRetrySettings,
    ),
  );
}

export function outputSentinelTimeoutRetrySettingsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelTimeoutRetrySettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OutputSentinelTimeoutRetrySettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelTimeoutRetrySettings' from JSON`,
  );
}

/** @internal */
export const OutputSentinelBackpressureBehavior$inboundSchema: z.ZodType<
  OutputSentinelBackpressureBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelBackpressureBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelBackpressureBehavior$outboundSchema: z.ZodType<
  OutputSentinelBackpressureBehavior,
  z.ZodTypeDef,
  OutputSentinelBackpressureBehavior
> = z.union([
  z.nativeEnum(OutputSentinelBackpressureBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelBackpressureBehavior$ {
  /** @deprecated use `OutputSentinelBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputSentinelBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema =
    OutputSentinelBackpressureBehavior$outboundSchema;
}

/** @internal */
export const AuthType$inboundSchema: z.ZodType<
  AuthType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AuthType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AuthType$outboundSchema: z.ZodType<
  AuthType,
  z.ZodTypeDef,
  AuthType
> = z.union([
  z.nativeEnum(AuthType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthType$ {
  /** @deprecated use `AuthType$inboundSchema` instead. */
  export const inboundSchema = AuthType$inboundSchema;
  /** @deprecated use `AuthType$outboundSchema` instead. */
  export const outboundSchema = AuthType$outboundSchema;
}

/** @internal */
export const EndpointConfiguration$inboundSchema: z.ZodType<
  EndpointConfiguration,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EndpointConfiguration),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EndpointConfiguration$outboundSchema: z.ZodType<
  EndpointConfiguration,
  z.ZodTypeDef,
  EndpointConfiguration
> = z.union([
  z.nativeEnum(EndpointConfiguration),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointConfiguration$ {
  /** @deprecated use `EndpointConfiguration$inboundSchema` instead. */
  export const inboundSchema = EndpointConfiguration$inboundSchema;
  /** @deprecated use `EndpointConfiguration$outboundSchema` instead. */
  export const outboundSchema = EndpointConfiguration$outboundSchema;
}

/** @internal */
export const OutputSentinelFormat$inboundSchema: z.ZodType<
  OutputSentinelFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelFormat$outboundSchema: z.ZodType<
  OutputSentinelFormat,
  z.ZodTypeDef,
  OutputSentinelFormat
> = z.union([
  z.nativeEnum(OutputSentinelFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelFormat$ {
  /** @deprecated use `OutputSentinelFormat$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelFormat$inboundSchema;
  /** @deprecated use `OutputSentinelFormat$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelFormat$outboundSchema;
}

/** @internal */
export const OutputSentinelCompression$inboundSchema: z.ZodType<
  OutputSentinelCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelCompression$outboundSchema: z.ZodType<
  OutputSentinelCompression,
  z.ZodTypeDef,
  OutputSentinelCompression
> = z.union([
  z.nativeEnum(OutputSentinelCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelCompression$ {
  /** @deprecated use `OutputSentinelCompression$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelCompression$inboundSchema;
  /** @deprecated use `OutputSentinelCompression$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelCompression$outboundSchema;
}

/** @internal */
export const OutputSentinelQueueFullBehavior$inboundSchema: z.ZodType<
  OutputSentinelQueueFullBehavior,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelQueueFullBehavior),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelQueueFullBehavior$outboundSchema: z.ZodType<
  OutputSentinelQueueFullBehavior,
  z.ZodTypeDef,
  OutputSentinelQueueFullBehavior
> = z.union([
  z.nativeEnum(OutputSentinelQueueFullBehavior),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelQueueFullBehavior$ {
  /** @deprecated use `OutputSentinelQueueFullBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelQueueFullBehavior$inboundSchema;
  /** @deprecated use `OutputSentinelQueueFullBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelQueueFullBehavior$outboundSchema;
}

/** @internal */
export const OutputSentinelMode$inboundSchema: z.ZodType<
  OutputSentinelMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputSentinelMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputSentinelMode$outboundSchema: z.ZodType<
  OutputSentinelMode,
  z.ZodTypeDef,
  OutputSentinelMode
> = z.union([
  z.nativeEnum(OutputSentinelMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelMode$ {
  /** @deprecated use `OutputSentinelMode$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelMode$inboundSchema;
  /** @deprecated use `OutputSentinelMode$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelMode$outboundSchema;
}

/** @internal */
export const OutputSentinelPqControls$inboundSchema: z.ZodType<
  OutputSentinelPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type OutputSentinelPqControls$Outbound = {};

/** @internal */
export const OutputSentinelPqControls$outboundSchema: z.ZodType<
  OutputSentinelPqControls$Outbound,
  z.ZodTypeDef,
  OutputSentinelPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelPqControls$ {
  /** @deprecated use `OutputSentinelPqControls$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelPqControls$inboundSchema;
  /** @deprecated use `OutputSentinelPqControls$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelPqControls$outboundSchema;
  /** @deprecated use `OutputSentinelPqControls$Outbound` instead. */
  export type Outbound = OutputSentinelPqControls$Outbound;
}

export function outputSentinelPqControlsToJSON(
  outputSentinelPqControls: OutputSentinelPqControls,
): string {
  return JSON.stringify(
    OutputSentinelPqControls$outboundSchema.parse(outputSentinelPqControls),
  );
}

export function outputSentinelPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSentinelPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelPqControls' from JSON`,
  );
}

/** @internal */
export const OutputSentinel$inboundSchema: z.ZodType<
  OutputSentinel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputSentinelType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1000),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSentinelExtraHttpHeader$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: OutputSentinelFailedRequestLoggingMode$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSentinelResponseRetrySetting$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSentinelTimeoutRetrySettings$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSentinelBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  authType: AuthType$inboundSchema.optional(),
  loginUrl: z.string(),
  secret: z.string(),
  client_id: z.string(),
  scope: z.string().default("https://monitor.azure.com/.default"),
  endpointURLConfiguration: EndpointConfiguration$inboundSchema.default("url"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  format: OutputSentinelFormat$inboundSchema.optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSentinelCompression$inboundSchema.default("none"),
  pqOnBackpressure: OutputSentinelQueueFullBehavior$inboundSchema.default(
    "block",
  ),
  pqMode: OutputSentinelMode$inboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSentinelPqControls$inboundSchema).optional(),
  url: z.string().optional(),
  dcrID: z.string().optional(),
  dceEndpoint: z.string().optional(),
  streamName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "client_id": "clientId",
  });
});

/** @internal */
export type OutputSentinel$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<OutputSentinelExtraHttpHeader$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<OutputSentinelResponseRetrySetting$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | OutputSentinelTimeoutRetrySettings$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType?: string | undefined;
  loginUrl: string;
  secret: string;
  client_id: string;
  scope: string;
  endpointURLConfiguration: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  format?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: OutputSentinelPqControls$Outbound | undefined;
  url?: string | undefined;
  dcrID?: string | undefined;
  dceEndpoint?: string | undefined;
  streamName?: string | undefined;
};

/** @internal */
export const OutputSentinel$outboundSchema: z.ZodType<
  OutputSentinel$Outbound,
  z.ZodTypeDef,
  OutputSentinel
> = z.object({
  id: z.string(),
  type: OutputSentinelType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1000),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => OutputSentinelExtraHttpHeader$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    OutputSentinelFailedRequestLoggingMode$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => OutputSentinelResponseRetrySetting$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    OutputSentinelTimeoutRetrySettings$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OutputSentinelBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  authType: AuthType$outboundSchema.optional(),
  loginUrl: z.string(),
  secret: z.string(),
  clientId: z.string(),
  scope: z.string().default("https://monitor.azure.com/.default"),
  endpointURLConfiguration: EndpointConfiguration$outboundSchema.default("url"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  format: OutputSentinelFormat$outboundSchema.optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: OutputSentinelCompression$outboundSchema.default("none"),
  pqOnBackpressure: OutputSentinelQueueFullBehavior$outboundSchema.default(
    "block",
  ),
  pqMode: OutputSentinelMode$outboundSchema.default("error"),
  pqControls: z.lazy(() => OutputSentinelPqControls$outboundSchema).optional(),
  url: z.string().optional(),
  dcrID: z.string().optional(),
  dceEndpoint: z.string().optional(),
  streamName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    clientId: "client_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinel$ {
  /** @deprecated use `OutputSentinel$inboundSchema` instead. */
  export const inboundSchema = OutputSentinel$inboundSchema;
  /** @deprecated use `OutputSentinel$outboundSchema` instead. */
  export const outboundSchema = OutputSentinel$outboundSchema;
  /** @deprecated use `OutputSentinel$Outbound` instead. */
  export type Outbound = OutputSentinel$Outbound;
}

export function outputSentinelToJSON(outputSentinel: OutputSentinel): string {
  return JSON.stringify(OutputSentinel$outboundSchema.parse(outputSentinel));
}

export function outputSentinelFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSentinel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinel' from JSON`,
  );
}

/** @internal */
export const OutputDefaultType$inboundSchema: z.ZodType<
  OutputDefaultType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputDefaultType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputDefaultType$outboundSchema: z.ZodType<
  OutputDefaultType,
  z.ZodTypeDef,
  OutputDefaultType
> = z.union([
  z.nativeEnum(OutputDefaultType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDefaultType$ {
  /** @deprecated use `OutputDefaultType$inboundSchema` instead. */
  export const inboundSchema = OutputDefaultType$inboundSchema;
  /** @deprecated use `OutputDefaultType$outboundSchema` instead. */
  export const outboundSchema = OutputDefaultType$outboundSchema;
}

/** @internal */
export const OutputDefault$inboundSchema: z.ZodType<
  OutputDefault,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputDefaultType$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  defaultId: z.string(),
});

/** @internal */
export type OutputDefault$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  defaultId: string;
};

/** @internal */
export const OutputDefault$outboundSchema: z.ZodType<
  OutputDefault$Outbound,
  z.ZodTypeDef,
  OutputDefault
> = z.object({
  id: z.string(),
  type: OutputDefaultType$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  defaultId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDefault$ {
  /** @deprecated use `OutputDefault$inboundSchema` instead. */
  export const inboundSchema = OutputDefault$inboundSchema;
  /** @deprecated use `OutputDefault$outboundSchema` instead. */
  export const outboundSchema = OutputDefault$outboundSchema;
  /** @deprecated use `OutputDefault$Outbound` instead. */
  export type Outbound = OutputDefault$Outbound;
}

export function outputDefaultToJSON(outputDefault: OutputDefault): string {
  return JSON.stringify(OutputDefault$outboundSchema.parse(outputDefault));
}

export function outputDefaultFromJSON(
  jsonString: string,
): SafeParseResult<OutputDefault, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDefault$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDefault' from JSON`,
  );
}

/** @internal */
export const CreateOutputRequest$inboundSchema: z.ZodType<
  CreateOutputRequest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OutputAzureDataExplorer$inboundSchema),
  z.lazy(() => OutputSecurityLake$inboundSchema),
  z.lazy(() => OutputSentinel$inboundSchema),
  z.lazy(() => OutputGoogleCloudLogging$inboundSchema),
  z.lazy(() => OutputExabeam$inboundSchema),
  z.lazy(() => OutputMsk$inboundSchema),
  z.lazy(() => OutputCloudwatch$inboundSchema),
  z.lazy(() => OutputClickHouse$inboundSchema),
  z.lazy(() => OutputDefault$inboundSchema),
  z.lazy(() => OutputSplunkLb$inboundSchema),
  z.lazy(() => OutputFilesystem$inboundSchema),
  z.lazy(() => OutputKinesis$inboundSchema),
  z.lazy(() => OutputHoneycomb$inboundSchema),
  z.lazy(() => OutputAzureEventhub$inboundSchema),
  z.lazy(() => OutputGoogleCloudStorage$inboundSchema),
  z.lazy(() => OutputGooglePubsub$inboundSchema),
  z.lazy(() => OutputKafka$inboundSchema),
  z.lazy(() => OutputConfluentCloud$inboundSchema),
  z.lazy(() => OutputElastic$inboundSchema),
  z.lazy(() => OutputElasticCloud$inboundSchema),
  z.lazy(() => OutputNewrelicEvents$inboundSchema),
  z.lazy(() => OutputInfluxdb$inboundSchema),
  z.lazy(() => OutputMinio$inboundSchema),
  z.lazy(() => OutputRouter$inboundSchema),
  z.lazy(() => OutputSns$inboundSchema),
  z.lazy(() => OutputSnmp$inboundSchema),
  z.lazy(() => OutputSumoLogic$inboundSchema),
  z.lazy(() => OutputLoki$inboundSchema),
  z.lazy(() => OutputPrometheus$inboundSchema),
  z.lazy(() => OutputOpenTelemetry$inboundSchema),
  z.lazy(() => OutputNetflow$inboundSchema),
  models.OutputWebhook$inboundSchema,
  models.OutputDevnull$inboundSchema,
  models.OutputSyslog$inboundSchema,
  z.lazy(() => OutputSplunk$inboundSchema),
  models.OutputSplunkHec$inboundSchema,
  models.OutputTcpjson$inboundSchema,
  z.lazy(() => OutputWavefront$inboundSchema),
  z.lazy(() => OutputSignalfx$inboundSchema),
  z.lazy(() => OutputS3$inboundSchema),
  z.lazy(() => OutputAzureBlob$inboundSchema),
  z.lazy(() => OutputAzureLogs$inboundSchema),
  z.lazy(() => OutputGoogleChronicle$inboundSchema),
  models.OutputNewrelic$inboundSchema,
  z.lazy(() => OutputStatsd$inboundSchema),
  z.lazy(() => OutputStatsdExt$inboundSchema),
  z.lazy(() => OutputGraphite$inboundSchema),
  z.lazy(() => OutputSqs$inboundSchema),
  models.OutputDatadog$inboundSchema,
  models.OutputRing$inboundSchema,
  z.lazy(() => OutputServiceNow$inboundSchema),
  models.OutputDataset$inboundSchema,
  models.OutputCriblTcp$inboundSchema,
  models.OutputCriblHttp$inboundSchema,
  z.lazy(() => OutputCrowdstrikeNextGenSiem$inboundSchema),
  z.lazy(() => OutputDlS3$inboundSchema),
  models.OutputCriblLake$inboundSchema,
  models.OutputDiskSpool$inboundSchema,
  models.OutputXsiam$inboundSchema,
  z.lazy(() => OutputDynatraceOtlp$inboundSchema),
  z.lazy(() => OutputHumioHec$inboundSchema),
  z.lazy(() => OutputDynatraceHttp$inboundSchema),
  z.lazy(() => OutputSentinelOneAiSiem$inboundSchema),
  models.OutputGrafanaCloudUnion$inboundSchema,
]);

/** @internal */
export type CreateOutputRequest$Outbound =
  | OutputAzureDataExplorer$Outbound
  | OutputSecurityLake$Outbound
  | OutputSentinel$Outbound
  | OutputGoogleCloudLogging$Outbound
  | OutputExabeam$Outbound
  | OutputMsk$Outbound
  | OutputCloudwatch$Outbound
  | OutputClickHouse$Outbound
  | OutputDefault$Outbound
  | OutputSplunkLb$Outbound
  | OutputFilesystem$Outbound
  | OutputKinesis$Outbound
  | OutputHoneycomb$Outbound
  | OutputAzureEventhub$Outbound
  | OutputGoogleCloudStorage$Outbound
  | OutputGooglePubsub$Outbound
  | OutputKafka$Outbound
  | OutputConfluentCloud$Outbound
  | OutputElastic$Outbound
  | OutputElasticCloud$Outbound
  | OutputNewrelicEvents$Outbound
  | OutputInfluxdb$Outbound
  | OutputMinio$Outbound
  | OutputRouter$Outbound
  | OutputSns$Outbound
  | OutputSnmp$Outbound
  | OutputSumoLogic$Outbound
  | OutputLoki$Outbound
  | OutputPrometheus$Outbound
  | OutputOpenTelemetry$Outbound
  | OutputNetflow$Outbound
  | models.OutputWebhook$Outbound
  | models.OutputDevnull$Outbound
  | models.OutputSyslog$Outbound
  | OutputSplunk$Outbound
  | models.OutputSplunkHec$Outbound
  | models.OutputTcpjson$Outbound
  | OutputWavefront$Outbound
  | OutputSignalfx$Outbound
  | OutputS3$Outbound
  | OutputAzureBlob$Outbound
  | OutputAzureLogs$Outbound
  | OutputGoogleChronicle$Outbound
  | models.OutputNewrelic$Outbound
  | OutputStatsd$Outbound
  | OutputStatsdExt$Outbound
  | OutputGraphite$Outbound
  | OutputSqs$Outbound
  | models.OutputDatadog$Outbound
  | models.OutputRing$Outbound
  | OutputServiceNow$Outbound
  | models.OutputDataset$Outbound
  | models.OutputCriblTcp$Outbound
  | models.OutputCriblHttp$Outbound
  | OutputCrowdstrikeNextGenSiem$Outbound
  | OutputDlS3$Outbound
  | models.OutputCriblLake$Outbound
  | models.OutputDiskSpool$Outbound
  | models.OutputXsiam$Outbound
  | OutputDynatraceOtlp$Outbound
  | OutputHumioHec$Outbound
  | OutputDynatraceHttp$Outbound
  | OutputSentinelOneAiSiem$Outbound
  | models.OutputGrafanaCloudUnion$Outbound;

/** @internal */
export const CreateOutputRequest$outboundSchema: z.ZodType<
  CreateOutputRequest$Outbound,
  z.ZodTypeDef,
  CreateOutputRequest
> = z.union([
  z.lazy(() => OutputAzureDataExplorer$outboundSchema),
  z.lazy(() => OutputSecurityLake$outboundSchema),
  z.lazy(() => OutputSentinel$outboundSchema),
  z.lazy(() => OutputGoogleCloudLogging$outboundSchema),
  z.lazy(() => OutputExabeam$outboundSchema),
  z.lazy(() => OutputMsk$outboundSchema),
  z.lazy(() => OutputCloudwatch$outboundSchema),
  z.lazy(() => OutputClickHouse$outboundSchema),
  z.lazy(() => OutputDefault$outboundSchema),
  z.lazy(() => OutputSplunkLb$outboundSchema),
  z.lazy(() => OutputFilesystem$outboundSchema),
  z.lazy(() => OutputKinesis$outboundSchema),
  z.lazy(() => OutputHoneycomb$outboundSchema),
  z.lazy(() => OutputAzureEventhub$outboundSchema),
  z.lazy(() => OutputGoogleCloudStorage$outboundSchema),
  z.lazy(() => OutputGooglePubsub$outboundSchema),
  z.lazy(() => OutputKafka$outboundSchema),
  z.lazy(() => OutputConfluentCloud$outboundSchema),
  z.lazy(() => OutputElastic$outboundSchema),
  z.lazy(() => OutputElasticCloud$outboundSchema),
  z.lazy(() => OutputNewrelicEvents$outboundSchema),
  z.lazy(() => OutputInfluxdb$outboundSchema),
  z.lazy(() => OutputMinio$outboundSchema),
  z.lazy(() => OutputRouter$outboundSchema),
  z.lazy(() => OutputSns$outboundSchema),
  z.lazy(() => OutputSnmp$outboundSchema),
  z.lazy(() => OutputSumoLogic$outboundSchema),
  z.lazy(() => OutputLoki$outboundSchema),
  z.lazy(() => OutputPrometheus$outboundSchema),
  z.lazy(() => OutputOpenTelemetry$outboundSchema),
  z.lazy(() => OutputNetflow$outboundSchema),
  models.OutputWebhook$outboundSchema,
  models.OutputDevnull$outboundSchema,
  models.OutputSyslog$outboundSchema,
  z.lazy(() => OutputSplunk$outboundSchema),
  models.OutputSplunkHec$outboundSchema,
  models.OutputTcpjson$outboundSchema,
  z.lazy(() => OutputWavefront$outboundSchema),
  z.lazy(() => OutputSignalfx$outboundSchema),
  z.lazy(() => OutputS3$outboundSchema),
  z.lazy(() => OutputAzureBlob$outboundSchema),
  z.lazy(() => OutputAzureLogs$outboundSchema),
  z.lazy(() => OutputGoogleChronicle$outboundSchema),
  models.OutputNewrelic$outboundSchema,
  z.lazy(() => OutputStatsd$outboundSchema),
  z.lazy(() => OutputStatsdExt$outboundSchema),
  z.lazy(() => OutputGraphite$outboundSchema),
  z.lazy(() => OutputSqs$outboundSchema),
  models.OutputDatadog$outboundSchema,
  models.OutputRing$outboundSchema,
  z.lazy(() => OutputServiceNow$outboundSchema),
  models.OutputDataset$outboundSchema,
  models.OutputCriblTcp$outboundSchema,
  models.OutputCriblHttp$outboundSchema,
  z.lazy(() => OutputCrowdstrikeNextGenSiem$outboundSchema),
  z.lazy(() => OutputDlS3$outboundSchema),
  models.OutputCriblLake$outboundSchema,
  models.OutputDiskSpool$outboundSchema,
  models.OutputXsiam$outboundSchema,
  z.lazy(() => OutputDynatraceOtlp$outboundSchema),
  z.lazy(() => OutputHumioHec$outboundSchema),
  z.lazy(() => OutputDynatraceHttp$outboundSchema),
  z.lazy(() => OutputSentinelOneAiSiem$outboundSchema),
  models.OutputGrafanaCloudUnion$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputRequest$ {
  /** @deprecated use `CreateOutputRequest$inboundSchema` instead. */
  export const inboundSchema = CreateOutputRequest$inboundSchema;
  /** @deprecated use `CreateOutputRequest$outboundSchema` instead. */
  export const outboundSchema = CreateOutputRequest$outboundSchema;
  /** @deprecated use `CreateOutputRequest$Outbound` instead. */
  export type Outbound = CreateOutputRequest$Outbound;
}

export function createOutputRequestToJSON(
  createOutputRequest: CreateOutputRequest,
): string {
  return JSON.stringify(
    CreateOutputRequest$outboundSchema.parse(createOutputRequest),
  );
}

export function createOutputRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputRequest' from JSON`,
  );
}

/** @internal */
export const CreateOutputResponse$inboundSchema: z.ZodType<
  CreateOutputResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Output$inboundSchema).optional(),
});

/** @internal */
export type CreateOutputResponse$Outbound = {
  count?: number | undefined;
  items?: Array<models.Output$Outbound> | undefined;
};

/** @internal */
export const CreateOutputResponse$outboundSchema: z.ZodType<
  CreateOutputResponse$Outbound,
  z.ZodTypeDef,
  CreateOutputResponse
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Output$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputResponse$ {
  /** @deprecated use `CreateOutputResponse$inboundSchema` instead. */
  export const inboundSchema = CreateOutputResponse$inboundSchema;
  /** @deprecated use `CreateOutputResponse$outboundSchema` instead. */
  export const outboundSchema = CreateOutputResponse$outboundSchema;
  /** @deprecated use `CreateOutputResponse$Outbound` instead. */
  export type Outbound = CreateOutputResponse$Outbound;
}

export function createOutputResponseToJSON(
  createOutputResponse: CreateOutputResponse,
): string {
  return JSON.stringify(
    CreateOutputResponse$outboundSchema.parse(createOutputResponse),
  );
}

export function createOutputResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputResponse' from JSON`,
  );
}
