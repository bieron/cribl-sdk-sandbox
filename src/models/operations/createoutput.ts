/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const TypeSentinelOneAiSiem = {
  SentinelOneAiSiem: "sentinel_one_ai_siem",
} as const;
export type TypeSentinelOneAiSiem = ClosedEnum<typeof TypeSentinelOneAiSiem>;

/**
 * The SentinelOne region to send events to. In most cases you can find the region by either looking at your SentinelOne URL or knowing what geographic region your SentinelOne instance is contained in.
 */
export const RegionSentinelOneAiSiem = {
  Us: "US",
  Ca: "CA",
  Emea: "EMEA",
  Ap: "AP",
  Aps: "APS",
  Au: "AU",
  Custom: "Custom",
} as const;
/**
 * The SentinelOne region to send events to. In most cases you can find the region by either looking at your SentinelOne URL or knowing what geographic region your SentinelOne instance is contained in.
 */
export type RegionSentinelOneAiSiem = ClosedEnum<
  typeof RegionSentinelOneAiSiem
>;

/**
 * Regional endpoint used to send events to, such as /services/collector/event or /services/collector/raw
 */
export const AISIEMEndpointPath = {
  RootServicesCollectorEvent: "/services/collector/event",
  RootServicesCollectorRaw: "/services/collector/raw",
} as const;
/**
 * Regional endpoint used to send events to, such as /services/collector/event or /services/collector/raw
 */
export type AISIEMEndpointPath = ClosedEnum<typeof AISIEMEndpointPath>;

export type ExtraHttpHeaderSentinelOneAiSiem = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeSentinelOneAiSiem = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeSentinelOneAiSiem = ClosedEnum<
  typeof FailedRequestLoggingModeSentinelOneAiSiem
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodSentinelOneAiSiem = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodSentinelOneAiSiem = ClosedEnum<
  typeof AuthenticationMethodSentinelOneAiSiem
>;

export type ResponseRetrySettingSentinelOneAiSiem = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsSentinelOneAiSiem = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSentinelOneAiSiem = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSentinelOneAiSiem = ClosedEnum<
  typeof BackpressureBehaviorSentinelOneAiSiem
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSentinelOneAiSiem = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSentinelOneAiSiem = ClosedEnum<
  typeof CompressionSentinelOneAiSiem
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSentinelOneAiSiem = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSentinelOneAiSiem = ClosedEnum<
  typeof QueueFullBehaviorSentinelOneAiSiem
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeSentinelOneAiSiem = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeSentinelOneAiSiem = ClosedEnum<typeof ModeSentinelOneAiSiem>;

export type PqControlsSentinelOneAiSiem = {};

export type OutputSentinelOneAiSiem = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeSentinelOneAiSiem | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The SentinelOne region to send events to. In most cases you can find the region by either looking at your SentinelOne URL or knowing what geographic region your SentinelOne instance is contained in.
   */
  region?: RegionSentinelOneAiSiem | undefined;
  /**
   * Regional endpoint used to send events to, such as /services/collector/event or /services/collector/raw
   */
  endpoint?: AISIEMEndpointPath | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderSentinelOneAiSiem> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | FailedRequestLoggingModeSentinelOneAiSiem
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodSentinelOneAiSiem | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<ResponseRetrySettingSentinelOneAiSiem>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsSentinelOneAiSiem | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSentinelOneAiSiem | undefined;
  description?: string | undefined;
  /**
   * In the SentinelOne Console select Policy & Settings then select the Singularity AI SIEM section, API Keys will be at the bottom. Under Log Access Keys select a Write token and copy it here
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Base URL of the endpoint used to send events to, such as https://<Your-S1-Tenant>.sentinelone.net. Must begin with http:// or https://, can include a port number, and no trailing slashes. Matches pattern: ^https?://[a-zA-Z0-9.-]+(:[0-9]+)?$.
   */
  baseUrl?: string | undefined;
  /**
   * Define serverHost for events using a JavaScript expression. You must enclose text constants in quotes (such as, 'myServer').
   */
  hostExpression?: string | undefined;
  /**
   * Define logFile for events using a JavaScript expression. You must enclose text constants in quotes (such as, 'myLogFile.txt').
   */
  sourceExpression?: string | undefined;
  /**
   * Define the parser for events using a JavaScript expression. This value helps parse data into AI SIEM. You must enclose text constants in quotes (such as, 'dottedJson'). For custom parsers, substitute 'dottedJson' with your parser's name.
   */
  sourceTypeExpression?: string | undefined;
  /**
   * Define the dataSource.category for events using a JavaScript expression. This value helps categorize data and helps enable extra features in SentinelOne AI SIEM. You must enclose text constants in quotes. The default value is 'security'.
   */
  dataSourceCategoryExpression?: string | undefined;
  /**
   * Define the dataSource.name for events using a JavaScript expression. This value should reflect the type of data being inserted into AI SIEM. You must enclose text constants in quotes (such as, 'networkActivity' or 'authLogs').
   */
  dataSourceNameExpression?: string | undefined;
  /**
   * Define the dataSource.vendor for events using a JavaScript expression. This value should reflect the vendor of the data being inserted into AI SIEM. You must enclose text constants in quotes (such as, 'Cisco' or 'Microsoft').
   */
  dataSourceVendorExpression?: string | undefined;
  /**
   * Optionally, define the event.type for events using a JavaScript expression. This value acts as a label, grouping events into meaningful categories. You must enclose text constants in quotes (such as, 'Process Creation' or 'Network Connection').
   */
  eventTypeExpression?: string | undefined;
  /**
   * Define the serverHost for events using a JavaScript expression. This value will be passed to AI SIEM. You must enclose text constants in quotes (such as, 'myServerName').
   */
  host?: string | undefined;
  /**
   * Specify the logFile value to pass as a parameter to SentinelOne AI SIEM. Don't quote this value. The default is cribl.
   */
  source?: string | undefined;
  /**
   * Specify the sourcetype parameter for SentinelOne AI SIEM, which determines the parser. Don't quote this value. For custom parsers, substitute hecRawParser with your parser's name. The default is hecRawParser.
   */
  sourceType?: string | undefined;
  /**
   * Specify the dataSource.category value to pass as a parameter to SentinelOne AI SIEM. This value helps categorize data and enables additional features. Don't quote this value. The default is security.
   */
  dataSourceCategory?: string | undefined;
  /**
   * Specify the dataSource.name value to pass as a parameter to AI SIEM. This value should reflect the type of data being inserted. Don't quote this value. The default is cribl.
   */
  dataSourceName?: string | undefined;
  /**
   * Specify the dataSource.vendorvalue to pass as a parameter to AI SIEM. This value should reflect the vendor of the data being inserted. Don't quote this value. The default is cribl.
   */
  dataSourceVendor?: string | undefined;
  /**
   * Specify the event.type value to pass as an optional parameter to AI SIEM. This value acts as a label, grouping events into meaningful categories like Process Creation, File Modification, or Network Connection. Don't quote this value. By default, this field is empty.
   */
  eventType?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionSentinelOneAiSiem | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSentinelOneAiSiem | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeSentinelOneAiSiem | undefined;
  pqControls?: PqControlsSentinelOneAiSiem | undefined;
};

export const TypeDynatraceOtlp = {
  DynatraceOtlp: "dynatrace_otlp",
} as const;
export type TypeDynatraceOtlp = ClosedEnum<typeof TypeDynatraceOtlp>;

/**
 * Select a transport option for Dynatrace
 */
export const ProtocolHTTP = {
  Http: "http",
} as const;
/**
 * Select a transport option for Dynatrace
 */
export type ProtocolHTTP = ClosedEnum<typeof ProtocolHTTP>;

/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export const OTLPVersionHTTP = {
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export type OTLPVersionHTTP = ClosedEnum<typeof OTLPVersionHTTP>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const CreateOutputCompressCompressionHTTP = {
  None: "none",
  Deflate: "deflate",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type CreateOutputCompressCompressionHTTP = ClosedEnum<
  typeof CreateOutputCompressCompressionHTTP
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const HTTPCompressCompressionHTTP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type HTTPCompressCompressionHTTP = ClosedEnum<
  typeof HTTPCompressCompressionHTTP
>;

export type CreateOutputMetadatumHTTP = {
  key?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeHTTP = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeHTTP = ClosedEnum<
  typeof FailedRequestLoggingModeHTTP
>;

/**
 * Select the type of Dynatrace endpoint configured
 */
export const EndpointType = {
  Saas: "saas",
  Ag: "ag",
} as const;
/**
 * Select the type of Dynatrace endpoint configured
 */
export type EndpointType = ClosedEnum<typeof EndpointType>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorHTTP = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorHTTP = ClosedEnum<
  typeof BackpressureBehaviorHTTP
>;

export type ExtraHTTPHeaderHTTP = {
  name?: string | undefined;
  value: string;
};

export type ResponseRetrySettingHTTP = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsHTTP = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionHTTP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionHTTP = ClosedEnum<
  typeof PqCompressCompressionHTTP
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorHTTP = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorHTTP = ClosedEnum<typeof QueueFullBehaviorHTTP>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeHTTP = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeHTTP = ClosedEnum<typeof CreateOutputModeHTTP>;

export type PqControlsHTTP = {};

export type OutputDynatraceOtlp = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeDynatraceOtlp | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select a transport option for Dynatrace
   */
  protocol?: ProtocolHTTP | undefined;
  /**
   * The endpoint where Dynatrace events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets)
   */
  endpoint?: string | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when structuring data to send
   */
  otlpVersion?: OTLPVersionHTTP | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  compress?: CreateOutputCompressCompressionHTTP | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  httpCompress?: HTTPCompressCompressionHTTP | undefined;
  /**
   * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpTracesEndpointOverride?: string | undefined;
  /**
   * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpMetricsEndpointOverride?: string | undefined;
  /**
   * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpLogsEndpointOverride?: string | undefined;
  /**
   * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
   */
  metadata?: Array<CreateOutputMetadatumHTTP> | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size (in KB) of the request body. The maximum payload size is 4 MB. If this limit is exceeded, the entire OTLP message is dropped
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeHTTP | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * How often the sender should ping the peer to keep the connection open
   */
  keepAliveTime?: number | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Select the type of Dynatrace endpoint configured
   */
  endpointType?: EndpointType | undefined;
  /**
   * Select or create a stored text secret
   */
  tokenSecret: string;
  authTokenName?: string | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorHTTP | undefined;
  description?: string | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHTTPHeaderHTTP> | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingHTTP> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsHTTP | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionHTTP | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorHTTP | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeHTTP | undefined;
  pqControls?: PqControlsHTTP | undefined;
};

export const TypeDynatraceHTTP = {
  DynatraceHttp: "dynatrace_http",
} as const;
export type TypeDynatraceHTTP = ClosedEnum<typeof TypeDynatraceHTTP>;

/**
 * The method to use when sending events
 */
export const Method = {
  Post: "POST",
  Put: "PUT",
  Patch: "PATCH",
} as const;
/**
 * The method to use when sending events
 */
export type Method = ClosedEnum<typeof Method>;

export type ExtraHTTPHeaderDynatraceHTTP = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeDynatraceHTTP = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeDynatraceHTTP = ClosedEnum<
  typeof FailedRequestLoggingModeDynatraceHTTP
>;

export type ResponseRetrySettingDynatraceHTTP = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsDynatraceHTTP = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorDynatraceHTTP = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorDynatraceHTTP = ClosedEnum<
  typeof BackpressureBehaviorDynatraceHTTP
>;

export const AuthenticationTypeDynatraceHTTP = {
  Token: "token",
  TextSecret: "textSecret",
} as const;
export type AuthenticationTypeDynatraceHTTP = ClosedEnum<
  typeof AuthenticationTypeDynatraceHTTP
>;

/**
 * How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
 */
export const FormatDynatraceHTTP = {
  JsonArray: "json_array",
  Plaintext: "plaintext",
} as const;
/**
 * How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
 */
export type FormatDynatraceHTTP = ClosedEnum<typeof FormatDynatraceHTTP>;

export const Endpoint = {
  Cloud: "cloud",
  ActiveGate: "activeGate",
  Manual: "manual",
} as const;
export type Endpoint = ClosedEnum<typeof Endpoint>;

export const TelemetryType = {
  Logs: "logs",
  Metrics: "metrics",
} as const;
export type TelemetryType = ClosedEnum<typeof TelemetryType>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionDynatraceHTTP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionDynatraceHTTP = ClosedEnum<
  typeof CompressionDynatraceHTTP
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorDynatraceHTTP = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorDynatraceHTTP = ClosedEnum<
  typeof QueueFullBehaviorDynatraceHTTP
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeDynatraceHTTP = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeDynatraceHTTP = ClosedEnum<typeof ModeDynatraceHTTP>;

export type PqControlsDynatraceHTTP = {};

export type OutputDynatraceHttp = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeDynatraceHTTP | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHTTPHeaderDynatraceHTTP> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeDynatraceHTTP | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingDynatraceHTTP> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsDynatraceHTTP | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorDynatraceHTTP | undefined;
  authType?: AuthenticationTypeDynatraceHTTP | undefined;
  /**
   * How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
   */
  format?: FormatDynatraceHTTP | undefined;
  endpoint?: Endpoint | undefined;
  telemetryType?: TelemetryType | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionDynatraceHTTP | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorDynatraceHTTP | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeDynatraceHTTP | undefined;
  pqControls?: PqControlsDynatraceHTTP | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * ID of the environment to send to
   */
  environmentId?: string | undefined;
  /**
   * ActiveGate domain with Log analytics collector module enabled. For example https://{activeGate-domain}:9999/e/{environment-id}/api/v2/logs/ingest.
   */
  activeGateDomain?: string | undefined;
  /**
   * URL to send events to. Can be overwritten by an event's __url field.
   */
  url?: string | undefined;
};

export const CreateOutputTypeNetflow = {
  Netflow: "netflow",
} as const;
export type CreateOutputTypeNetflow = ClosedEnum<
  typeof CreateOutputTypeNetflow
>;

export type HostNetflow = {
  /**
   * Destination host
   */
  host: string;
  /**
   * Destination port, default is 2055
   */
  port?: number | undefined;
};

export type OutputNetflow = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: CreateOutputTypeNetflow;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * One or more NetFlow destinations to forward events to
   */
  hosts: Array<HostNetflow>;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
};

export const TypeClickHouse = {
  ClickHouse: "click_house",
} as const;
export type TypeClickHouse = ClosedEnum<typeof TypeClickHouse>;

export const AuthenticationTypeClickHouse = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  SslUserCertificate: "sslUserCertificate",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
export type AuthenticationTypeClickHouse = ClosedEnum<
  typeof AuthenticationTypeClickHouse
>;

/**
 * Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
 */
export const FormatClickHouse = {
  JsonCompactEachRowWithNames: "json-compact-each-row-with-names",
  JsonEachRow: "json-each-row",
} as const;
/**
 * Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
 */
export type FormatClickHouse = ClosedEnum<typeof FormatClickHouse>;

/**
 * How event fields are mapped to ClickHouse columns.
 */
export const MappingType = {
  Automatic: "automatic",
  Custom: "custom",
} as const;
/**
 * How event fields are mapped to ClickHouse columns.
 */
export type MappingType = ClosedEnum<typeof MappingType>;

export const MinimumTLSVersionClickHouse = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionClickHouse = ClosedEnum<
  typeof MinimumTLSVersionClickHouse
>;

export const MaximumTLSVersionClickHouse = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionClickHouse = ClosedEnum<
  typeof MaximumTLSVersionClickHouse
>;

export type TLSSettingsClientSideClickHouse = {
  disabled?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: MinimumTLSVersionClickHouse | undefined;
  maxVersion?: MaximumTLSVersionClickHouse | undefined;
};

export type ExtraHttpHeaderClickHouse = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeClickHouse = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeClickHouse = ClosedEnum<
  typeof FailedRequestLoggingModeClickHouse
>;

export type ResponseRetrySettingClickHouse = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsClickHouse = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorClickHouse = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorClickHouse = ClosedEnum<
  typeof BackpressureBehaviorClickHouse
>;

export type OauthParamClickHouse = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OauthHeaderClickHouse = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type ColumnMapping = {
  /**
   * Name of the column in ClickHouse that will store field value
   */
  columnName: string;
  /**
   * Type of the column in the ClickHouse database
   */
  columnType?: string | undefined;
  /**
   * JavaScript expression to compute value to be inserted into ClickHouse table
   */
  columnValueExpression: string;
};

/**
 * Codec to use to compress the persisted data
 */
export const CompressionClickHouse = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionClickHouse = ClosedEnum<typeof CompressionClickHouse>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorClickHouse = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorClickHouse = ClosedEnum<
  typeof QueueFullBehaviorClickHouse
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeClickHouse = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeClickHouse = ClosedEnum<typeof ModeClickHouse>;

export type PqControlsClickHouse = {};

export type OutputClickHouse = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeClickHouse | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of the ClickHouse instance. Example: http://localhost:8123/
   */
  url: string;
  authType?: AuthenticationTypeClickHouse | undefined;
  database: string;
  /**
   * Name of the ClickHouse table where data will be inserted. Name can contain letters (A-Z, a-z), numbers (0-9), and the character "_", and must start with either a letter or the character "_".
   */
  tableName: string;
  /**
   * Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
   */
  format?: FormatClickHouse | undefined;
  /**
   * How event fields are mapped to ClickHouse columns.
   */
  mappingType?: MappingType | undefined;
  /**
   * Collect data into batches for later processing. Disable to write to a ClickHouse table immediately.
   */
  asyncInserts?: boolean | undefined;
  tls?: TLSSettingsClientSideClickHouse | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderClickHouse> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeClickHouse | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingClickHouse> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsClickHouse | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Log the most recent event that fails to match the table schema
   */
  dumpFormatErrorsToDisk?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorClickHouse | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OauthParamClickHouse> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OauthHeaderClickHouse> | undefined;
  /**
   * Username for certificate authentication
   */
  sqlUsername?: string | undefined;
  /**
   * Cribl will wait for confirmation that data has been fully inserted into the ClickHouse database before proceeding. Disabling this option can increase throughput, but Cribl won’t be able to verify data has been completely inserted.
   */
  waitForAsyncInserts?: boolean | undefined;
  /**
   * Fields to exclude from sending to ClickHouse
   */
  excludeMappingFields?: Array<string> | undefined;
  /**
   * Retrieves the table schema from ClickHouse and populates the Column Mapping table
   */
  describeTable?: string | undefined;
  columnMappings?: Array<ColumnMapping> | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionClickHouse | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorClickHouse | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeClickHouse | undefined;
  pqControls?: PqControlsClickHouse | undefined;
};

export const CreateOutputTypeSecurityLake = {
  SecurityLake: "security_lake",
} as const;
export type CreateOutputTypeSecurityLake = ClosedEnum<
  typeof CreateOutputTypeSecurityLake
>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateOutputAuthenticationMethodSecurityLake = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateOutputAuthenticationMethodSecurityLake = ClosedEnum<
  typeof CreateOutputAuthenticationMethodSecurityLake
>;

/**
 * Signature version to use for signing Amazon Security Lake requests
 */
export const CreateOutputSignatureVersionSecurityLake = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Amazon Security Lake requests
 */
export type CreateOutputSignatureVersionSecurityLake = ClosedEnum<
  typeof CreateOutputSignatureVersionSecurityLake
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const ObjectACLSecurityLake = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type ObjectACLSecurityLake = ClosedEnum<typeof ObjectACLSecurityLake>;

/**
 * Storage class to select for uploaded objects
 */
export const StorageClassSecurityLake = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
  StandardIa: "STANDARD_IA",
  OnezoneIa: "ONEZONE_IA",
  IntelligentTiering: "INTELLIGENT_TIERING",
  Glacier: "GLACIER",
  GlacierIr: "GLACIER_IR",
  DeepArchive: "DEEP_ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type StorageClassSecurityLake = ClosedEnum<
  typeof StorageClassSecurityLake
>;

export const ServerSideEncryptionForUploadedObjectsSecurityLake = {
  Aes256: "AES256",
  AwsKms: "aws:kms",
} as const;
export type ServerSideEncryptionForUploadedObjectsSecurityLake = ClosedEnum<
  typeof ServerSideEncryptionForUploadedObjectsSecurityLake
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSecurityLake = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSecurityLake = ClosedEnum<
  typeof BackpressureBehaviorSecurityLake
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionSecurityLake = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionSecurityLake = ClosedEnum<
  typeof DiskSpaceProtectionSecurityLake
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const ParquetVersionSecurityLake = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type ParquetVersionSecurityLake = ClosedEnum<
  typeof ParquetVersionSecurityLake
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const DataPageVersionSecurityLake = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type DataPageVersionSecurityLake = ClosedEnum<
  typeof DataPageVersionSecurityLake
>;

export type KeyValueMetadatumSecurityLake = {
  key?: string | undefined;
  value: string;
};

export type OutputSecurityLake = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeSecurityLake | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * Region where the Amazon Security Lake is located.
   */
  region: string;
  awsSecretKey?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?:
    | CreateOutputAuthenticationMethodSecurityLake
    | undefined;
  /**
   * Amazon Security Lake service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Amazon Security Lake-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Amazon Security Lake requests
   */
  signatureVersion?: CreateOutputSignatureVersionSecurityLake | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn: string;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: ObjectACLSecurityLake | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: StorageClassSecurityLake | undefined;
  serverSideEncryption?:
    | ServerSideEncryptionForUploadedObjectsSecurityLake
    | undefined;
  /**
   * ID or ARN of the KMS customer-managed key to use for encryption
   */
  kmsKeyId?: string | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSecurityLake | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionSecurityLake | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Maximum number of files that can be waiting for upload before backpressure is applied
   */
  maxClosingFilesToBackpressure?: number | undefined;
  /**
   * ID of the AWS account whose data the Destination will write to Security Lake. This should have been configured when creating the Amazon Security Lake custom source.
   */
  accountId: string;
  /**
   * Name of the custom source configured in Amazon Security Lake
   */
  customSource: string;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: ParquetVersionSecurityLake | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: DataPageVersionSecurityLake | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<KeyValueMetadatumSecurityLake> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
   */
  parquetSchema?: string | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const TypeDlS3 = {
  DlS3: "dl_s3",
} as const;
export type TypeDlS3 = ClosedEnum<typeof TypeDlS3>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const AuthenticationMethodDlS3 = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type AuthenticationMethodDlS3 = ClosedEnum<
  typeof AuthenticationMethodDlS3
>;

/**
 * Signature version to use for signing S3 requests
 */
export const SignatureVersionDlS3 = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type SignatureVersionDlS3 = ClosedEnum<typeof SignatureVersionDlS3>;

/**
 * Object ACL to assign to uploaded objects
 */
export const ObjectACLDlS3 = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type ObjectACLDlS3 = ClosedEnum<typeof ObjectACLDlS3>;

/**
 * Storage class to select for uploaded objects
 */
export const StorageClassDlS3 = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
  StandardIa: "STANDARD_IA",
  OnezoneIa: "ONEZONE_IA",
  IntelligentTiering: "INTELLIGENT_TIERING",
  Glacier: "GLACIER",
  GlacierIr: "GLACIER_IR",
  DeepArchive: "DEEP_ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type StorageClassDlS3 = ClosedEnum<typeof StorageClassDlS3>;

export const ServerSideEncryptionForUploadedObjectsDlS3 = {
  Aes256: "AES256",
  AwsKms: "aws:kms",
} as const;
export type ServerSideEncryptionForUploadedObjectsDlS3 = ClosedEnum<
  typeof ServerSideEncryptionForUploadedObjectsDlS3
>;

/**
 * Format of the output data
 */
export const DataFormatDlS3 = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type DataFormatDlS3 = ClosedEnum<typeof DataFormatDlS3>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorDlS3 = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorDlS3 = ClosedEnum<
  typeof BackpressureBehaviorDlS3
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionDlS3 = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionDlS3 = ClosedEnum<
  typeof DiskSpaceProtectionDlS3
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const CompressionDlS3 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type CompressionDlS3 = ClosedEnum<typeof CompressionDlS3>;

/**
 * Compression level to apply before moving files to final destination
 */
export const CompressionLevelDlS3 = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type CompressionLevelDlS3 = ClosedEnum<typeof CompressionLevelDlS3>;

/**
 * Determines which data types are supported and how they are represented
 */
export const ParquetVersionDlS3 = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type ParquetVersionDlS3 = ClosedEnum<typeof ParquetVersionDlS3>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const DataPageVersionDlS3 = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type DataPageVersionDlS3 = ClosedEnum<typeof DataPageVersionDlS3>;

export type KeyValueMetadatumDlS3 = {
  key?: string | undefined;
  value: string;
};

export type OutputDlS3 = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeDlS3 | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * Region where the S3 bucket is located
   */
  region?: string | undefined;
  /**
   * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
   */
  awsSecretKey?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AuthenticationMethodDlS3 | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: SignatureVersionDlS3 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`
   */
  destPath?: string | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: ObjectACLDlS3 | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: StorageClassDlS3 | undefined;
  serverSideEncryption?: ServerSideEncryptionForUploadedObjectsDlS3 | undefined;
  /**
   * ID or ARN of the KMS customer-managed key to use for encryption
   */
  kmsKeyId?: string | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * Format of the output data
   */
  format?: DataFormatDlS3 | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorDlS3 | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionDlS3 | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Maximum number of files that can be waiting for upload before backpressure is applied
   */
  maxClosingFilesToBackpressure?: number | undefined;
  /**
   * List of fields to partition the path by, in addition to time, which is included automatically. The effective partition will be YYYY/MM/DD/HH/<list/of/fields>.
   */
  partitioningFields?: Array<string> | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: CompressionDlS3 | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: CompressionLevelDlS3 | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: ParquetVersionDlS3 | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: DataPageVersionDlS3 | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<KeyValueMetadatumDlS3> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const TypeCrowdstrikeNextGenSiem = {
  CrowdstrikeNextGenSiem: "crowdstrike_next_gen_siem",
} as const;
export type TypeCrowdstrikeNextGenSiem = ClosedEnum<
  typeof TypeCrowdstrikeNextGenSiem
>;

export type ExtraHttpHeaderCrowdstrikeNextGenSiem = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeCrowdstrikeNextGenSiem = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeCrowdstrikeNextGenSiem = ClosedEnum<
  typeof FailedRequestLoggingModeCrowdstrikeNextGenSiem
>;

/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export const RequestFormatCrowdstrikeNextGenSiem = {
  Json: "JSON",
  Raw: "raw",
} as const;
/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export type RequestFormatCrowdstrikeNextGenSiem = ClosedEnum<
  typeof RequestFormatCrowdstrikeNextGenSiem
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodCrowdstrikeNextGenSiem = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodCrowdstrikeNextGenSiem = ClosedEnum<
  typeof AuthenticationMethodCrowdstrikeNextGenSiem
>;

export type ResponseRetrySettingCrowdstrikeNextGenSiem = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsCrowdstrikeNextGenSiem = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorCrowdstrikeNextGenSiem = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorCrowdstrikeNextGenSiem = ClosedEnum<
  typeof BackpressureBehaviorCrowdstrikeNextGenSiem
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionCrowdstrikeNextGenSiem = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionCrowdstrikeNextGenSiem = ClosedEnum<
  typeof CompressionCrowdstrikeNextGenSiem
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorCrowdstrikeNextGenSiem = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorCrowdstrikeNextGenSiem = ClosedEnum<
  typeof QueueFullBehaviorCrowdstrikeNextGenSiem
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeCrowdstrikeNextGenSiem = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeCrowdstrikeNextGenSiem = ClosedEnum<
  typeof ModeCrowdstrikeNextGenSiem
>;

export type PqControlsCrowdstrikeNextGenSiem = {};

export type OutputCrowdstrikeNextGenSiem = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeCrowdstrikeNextGenSiem | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL provided from a CrowdStrike data connector.
   *
   * @remarks
   * Example: https://ingest.<region>.crowdstrike.com/api/ingest/hec/<connection-id>/v1/services/collector
   */
  url: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderCrowdstrikeNextGenSiem> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | FailedRequestLoggingModeCrowdstrikeNextGenSiem
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
   */
  format?: RequestFormatCrowdstrikeNextGenSiem | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodCrowdstrikeNextGenSiem | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<ResponseRetrySettingCrowdstrikeNextGenSiem>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsCrowdstrikeNextGenSiem | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorCrowdstrikeNextGenSiem | undefined;
  description?: string | undefined;
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionCrowdstrikeNextGenSiem | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorCrowdstrikeNextGenSiem | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeCrowdstrikeNextGenSiem | undefined;
  pqControls?: PqControlsCrowdstrikeNextGenSiem | undefined;
};

export const TypeHumioHec = {
  HumioHec: "humio_hec",
} as const;
export type TypeHumioHec = ClosedEnum<typeof TypeHumioHec>;

export type ExtraHttpHeaderHumioHec = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeHumioHec = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeHumioHec = ClosedEnum<
  typeof FailedRequestLoggingModeHumioHec
>;

/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export const RequestFormatHumioHec = {
  Json: "JSON",
  Raw: "raw",
} as const;
/**
 * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
 */
export type RequestFormatHumioHec = ClosedEnum<typeof RequestFormatHumioHec>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodHumioHec = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodHumioHec = ClosedEnum<
  typeof AuthenticationMethodHumioHec
>;

export type ResponseRetrySettingHumioHec = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsHumioHec = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorHumioHec = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorHumioHec = ClosedEnum<
  typeof BackpressureBehaviorHumioHec
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionHumioHec = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionHumioHec = ClosedEnum<typeof CompressionHumioHec>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorHumioHec = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorHumioHec = ClosedEnum<
  typeof QueueFullBehaviorHumioHec
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeHumioHec = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeHumioHec = ClosedEnum<typeof ModeHumioHec>;

export type PqControlsHumioHec = {};

export type OutputHumioHec = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeHumioHec | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL to a CrowdStrike Falcon LogScale endpoint to send events to. Examples: https://cloud.us.humio.com/api/v1/ingest/hec for JSON and https://cloud.us.humio.com/api/v1/ingest/hec/raw for raw
   */
  url?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderHumioHec> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeHumioHec | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
   */
  format?: RequestFormatHumioHec | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodHumioHec | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingHumioHec> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsHumioHec | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorHumioHec | undefined;
  description?: string | undefined;
  /**
   * CrowdStrike Falcon LogScale authentication token
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionHumioHec | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorHumioHec | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeHumioHec | undefined;
  pqControls?: PqControlsHumioHec | undefined;
};

export const TypeServiceNow = {
  ServiceNow: "service_now",
} as const;
export type TypeServiceNow = ClosedEnum<typeof TypeServiceNow>;

/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export const OTLPVersion131 = {
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export type OTLPVersion131 = ClosedEnum<typeof OTLPVersion131>;

/**
 * Select a transport option for OpenTelemetry
 */
export const Protocol131 = {
  Grpc: "grpc",
  Http: "http",
} as const;
/**
 * Select a transport option for OpenTelemetry
 */
export type Protocol131 = ClosedEnum<typeof Protocol131>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const CompressCompression131 = {
  None: "none",
  Deflate: "deflate",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type CompressCompression131 = ClosedEnum<typeof CompressCompression131>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const HttpCompressCompression131 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type HttpCompressCompression131 = ClosedEnum<
  typeof HttpCompressCompression131
>;

export type Metadatum131 = {
  key?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingMode131 = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingMode131 = ClosedEnum<
  typeof FailedRequestLoggingMode131
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehavior131 = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehavior131 = ClosedEnum<
  typeof BackpressureBehavior131
>;

export type ExtraHttpHeader131 = {
  name?: string | undefined;
  value: string;
};

export type ResponseRetrySetting131 = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettings131 = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export const MinimumTLSVersion131 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersion131 = ClosedEnum<typeof MinimumTLSVersion131>;

export const MaximumTLSVersion131 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersion131 = ClosedEnum<typeof MaximumTLSVersion131>;

export type TLSSettingsClientSide131 = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: MinimumTLSVersion131 | undefined;
  maxVersion?: MaximumTLSVersion131 | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompression131 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompression131 = ClosedEnum<
  typeof PqCompressCompression131
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehavior131 = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehavior131 = ClosedEnum<typeof QueueFullBehavior131>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const Mode131 = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type Mode131 = ClosedEnum<typeof Mode131>;

export type PqControls131 = {};

export type OutputServiceNow = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeServiceNow | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The endpoint where ServiceNow events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets)
   */
  endpoint?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  tokenSecret: string;
  authTokenName?: string | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when structuring data to send
   */
  otlpVersion?: OTLPVersion131 | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Select a transport option for OpenTelemetry
   */
  protocol?: Protocol131 | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  compress?: CompressCompression131 | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  httpCompress?: HttpCompressCompression131 | undefined;
  /**
   * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpTracesEndpointOverride?: string | undefined;
  /**
   * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpMetricsEndpointOverride?: string | undefined;
  /**
   * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpLogsEndpointOverride?: string | undefined;
  /**
   * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
   */
  metadata?: Array<Metadatum131> | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingMode131 | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * How often the sender should ping the peer to keep the connection open
   */
  keepAliveTime?: number | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehavior131 | undefined;
  description?: string | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeader131> | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySetting131> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettings131 | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  tls?: TLSSettingsClientSide131 | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompression131 | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehavior131 | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: Mode131 | undefined;
  pqControls?: PqControls131 | undefined;
};

export const CreateOutputTypeOpenTelemetry = {
  OpenTelemetry: "open_telemetry",
} as const;
export type CreateOutputTypeOpenTelemetry = ClosedEnum<
  typeof CreateOutputTypeOpenTelemetry
>;

/**
 * Select a transport option for OpenTelemetry
 */
export const CreateOutputProtocolOpenTelemetry = {
  Grpc: "grpc",
  Http: "http",
} as const;
/**
 * Select a transport option for OpenTelemetry
 */
export type CreateOutputProtocolOpenTelemetry = ClosedEnum<
  typeof CreateOutputProtocolOpenTelemetry
>;

/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export const CreateOutputOTLPVersionOpenTelemetry = {
  ZeroDot10Dot0: "0.10.0",
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when structuring data to send
 */
export type CreateOutputOTLPVersionOpenTelemetry = ClosedEnum<
  typeof CreateOutputOTLPVersionOpenTelemetry
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const CreateOutputCompressCompressionOpenTelemetry = {
  None: "none",
  Deflate: "deflate",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type CreateOutputCompressCompressionOpenTelemetry = ClosedEnum<
  typeof CreateOutputCompressCompressionOpenTelemetry
>;

/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export const HttpCompressCompressionOpenTelemetry = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Type of compression to apply to messages sent to the OpenTelemetry endpoint
 */
export type HttpCompressCompressionOpenTelemetry = ClosedEnum<
  typeof HttpCompressCompressionOpenTelemetry
>;

/**
 * OpenTelemetry authentication type
 */
export const CreateOutputAuthenticationTypeOpenTelemetry = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * OpenTelemetry authentication type
 */
export type CreateOutputAuthenticationTypeOpenTelemetry = ClosedEnum<
  typeof CreateOutputAuthenticationTypeOpenTelemetry
>;

export type CreateOutputMetadatumOpenTelemetry = {
  key?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeOpenTelemetry = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeOpenTelemetry = ClosedEnum<
  typeof FailedRequestLoggingModeOpenTelemetry
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorOpenTelemetry = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorOpenTelemetry = ClosedEnum<
  typeof BackpressureBehaviorOpenTelemetry
>;

export type CreateOutputOauthParamOpenTelemetry = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type CreateOutputOauthHeaderOpenTelemetry = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type ExtraHttpHeaderOpenTelemetry = {
  name?: string | undefined;
  value: string;
};

export type ResponseRetrySettingOpenTelemetry = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsOpenTelemetry = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export const CreateOutputMinimumTLSVersionOpenTelemetry = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMinimumTLSVersionOpenTelemetry = ClosedEnum<
  typeof CreateOutputMinimumTLSVersionOpenTelemetry
>;

export const CreateOutputMaximumTLSVersionOpenTelemetry = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMaximumTLSVersionOpenTelemetry = ClosedEnum<
  typeof CreateOutputMaximumTLSVersionOpenTelemetry
>;

export type TLSSettingsClientSideOpenTelemetry = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateOutputMinimumTLSVersionOpenTelemetry | undefined;
  maxVersion?: CreateOutputMaximumTLSVersionOpenTelemetry | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionOpenTelemetry = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionOpenTelemetry = ClosedEnum<
  typeof PqCompressCompressionOpenTelemetry
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorOpenTelemetry = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorOpenTelemetry = ClosedEnum<
  typeof QueueFullBehaviorOpenTelemetry
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeOpenTelemetry = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeOpenTelemetry = ClosedEnum<
  typeof CreateOutputModeOpenTelemetry
>;

export type PqControlsOpenTelemetry = {};

export type OutputOpenTelemetry = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: CreateOutputTypeOpenTelemetry;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select a transport option for OpenTelemetry
   */
  protocol?: CreateOutputProtocolOpenTelemetry | undefined;
  /**
   * The endpoint where OTel events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Unspecified ports will default to 4317, unless the endpoint is an HTTPS-based URL or TLS is enabled, in which case 443 will be used.
   */
  endpoint: string;
  /**
   * The version of OTLP Protobuf definitions to use when structuring data to send
   */
  otlpVersion?: CreateOutputOTLPVersionOpenTelemetry | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  compress?: CreateOutputCompressCompressionOpenTelemetry | undefined;
  /**
   * Type of compression to apply to messages sent to the OpenTelemetry endpoint
   */
  httpCompress?: HttpCompressCompressionOpenTelemetry | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: CreateOutputAuthenticationTypeOpenTelemetry | undefined;
  /**
   * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpTracesEndpointOverride?: string | undefined;
  /**
   * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpMetricsEndpointOverride?: string | undefined;
  /**
   * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
   */
  httpLogsEndpointOverride?: string | undefined;
  /**
   * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
   */
  metadata?: Array<CreateOutputMetadatumOpenTelemetry> | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOpenTelemetry | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * How often the sender should ping the peer to keep the connection open
   */
  keepAliveTime?: number | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorOpenTelemetry | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<CreateOutputOauthParamOpenTelemetry> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<CreateOutputOauthHeaderOpenTelemetry> | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderOpenTelemetry> | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingOpenTelemetry> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsOpenTelemetry | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  tls?: TLSSettingsClientSideOpenTelemetry | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionOpenTelemetry | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorOpenTelemetry | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeOpenTelemetry | undefined;
  pqControls?: PqControlsOpenTelemetry | undefined;
};

export const CreateOutputTypePrometheus = {
  Prometheus: "prometheus",
} as const;
export type CreateOutputTypePrometheus = ClosedEnum<
  typeof CreateOutputTypePrometheus
>;

export type ExtraHttpHeaderPrometheus = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModePrometheus = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModePrometheus = ClosedEnum<
  typeof FailedRequestLoggingModePrometheus
>;

export type ResponseRetrySettingPrometheus = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsPrometheus = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorPrometheus = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorPrometheus = ClosedEnum<
  typeof BackpressureBehaviorPrometheus
>;

/**
 * Remote Write authentication type
 */
export const AuthenticationTypePrometheus = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type AuthenticationTypePrometheus = ClosedEnum<
  typeof AuthenticationTypePrometheus
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionPrometheus = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionPrometheus = ClosedEnum<
  typeof PqCompressCompressionPrometheus
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorPrometheus = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorPrometheus = ClosedEnum<
  typeof QueueFullBehaviorPrometheus
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModePrometheus = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModePrometheus = ClosedEnum<
  typeof CreateOutputModePrometheus
>;

export type PqControlsPrometheus = {};

export type OauthParamPrometheus = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OauthHeaderPrometheus = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type OutputPrometheus = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: CreateOutputTypePrometheus;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions to generated metrics.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The endpoint to send metrics to
   */
  url: string;
  /**
   * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>.
   */
  metricRenameExpr?: string | undefined;
  /**
   * Generate and send metadata (`type` and `metricFamilyName`) requests
   */
  sendMetadata?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderPrometheus> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModePrometheus | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingPrometheus> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsPrometheus | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorPrometheus | undefined;
  /**
   * Remote Write authentication type
   */
  authType?: AuthenticationTypePrometheus | undefined;
  description?: string | undefined;
  /**
   * How frequently metrics metadata is sent out. Value cannot be smaller than the base Flush period set above.
   */
  metricsFlushPeriodSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionPrometheus | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorPrometheus | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModePrometheus | undefined;
  pqControls?: PqControlsPrometheus | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OauthParamPrometheus> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OauthHeaderPrometheus> | undefined;
};

export const CreateOutputTypeLoki = {
  Loki: "loki",
} as const;
export type CreateOutputTypeLoki = ClosedEnum<typeof CreateOutputTypeLoki>;

/**
 * Format to use when sending logs to Loki (Protobuf or JSON)
 */
export const MessageFormat = {
  Protobuf: "protobuf",
  Json: "json",
} as const;
/**
 * Format to use when sending logs to Loki (Protobuf or JSON)
 */
export type MessageFormat = ClosedEnum<typeof MessageFormat>;

export type Label = {
  name?: string | undefined;
  value: string;
};

export const CreateOutputAuthenticationTypeLoki = {
  None: "none",
  Token: "token",
  TextSecret: "textSecret",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
} as const;
export type CreateOutputAuthenticationTypeLoki = ClosedEnum<
  typeof CreateOutputAuthenticationTypeLoki
>;

export type ExtraHttpHeaderLoki = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeLoki = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeLoki = ClosedEnum<
  typeof FailedRequestLoggingModeLoki
>;

export type ResponseRetrySettingLoki = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsLoki = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorLoki = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorLoki = ClosedEnum<
  typeof BackpressureBehaviorLoki
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionLoki = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionLoki = ClosedEnum<
  typeof PqCompressCompressionLoki
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorLoki = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorLoki = ClosedEnum<typeof QueueFullBehaviorLoki>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeLoki = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeLoki = ClosedEnum<typeof CreateOutputModeLoki>;

export type PqControlsLoki = {};

export type OutputLoki = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: CreateOutputTypeLoki;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as labels to generated logs.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The endpoint to send logs to
   */
  url: string;
  /**
   * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
   */
  message?: string | undefined;
  /**
   * Format to use when sending logs to Loki (Protobuf or JSON)
   */
  messageFormat?: MessageFormat | undefined;
  /**
   * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field. Example: '__labels: {host: "cribl.io", level: "error"}'
   */
  labels?: Array<Label> | undefined;
  authType?: CreateOutputAuthenticationTypeLoki | undefined;
  /**
   * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki to complain about entries being delivered out of order.
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderLoki> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeLoki | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingLoki> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsLoki | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorLoki | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Username for authentication
   */
  username?: string | undefined;
  /**
   * Password (API key in Grafana Cloud domain) for authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionLoki | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorLoki | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeLoki | undefined;
  pqControls?: PqControlsLoki | undefined;
};

export const TypeSumoLogic = {
  SumoLogic: "sumo_logic",
} as const;
export type TypeSumoLogic = ClosedEnum<typeof TypeSumoLogic>;

/**
 * Preserve the raw event format instead of JSONifying it
 */
export const DataFormatSumoLogic = {
  Json: "json",
  Raw: "raw",
} as const;
/**
 * Preserve the raw event format instead of JSONifying it
 */
export type DataFormatSumoLogic = ClosedEnum<typeof DataFormatSumoLogic>;

export type ExtraHttpHeaderSumoLogic = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeSumoLogic = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeSumoLogic = ClosedEnum<
  typeof FailedRequestLoggingModeSumoLogic
>;

export type ResponseRetrySettingSumoLogic = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsSumoLogic = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSumoLogic = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSumoLogic = ClosedEnum<
  typeof BackpressureBehaviorSumoLogic
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSumoLogic = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSumoLogic = ClosedEnum<typeof CompressionSumoLogic>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSumoLogic = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSumoLogic = ClosedEnum<
  typeof QueueFullBehaviorSumoLogic
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeSumoLogic = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeSumoLogic = ClosedEnum<typeof ModeSumoLogic>;

export type PqControlsSumoLogic = {};

export type OutputSumoLogic = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeSumoLogic;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Sumo Logic HTTP collector URL to which events should be sent
   */
  url: string;
  /**
   * Override the source name configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceName field.
   */
  customSource?: string | undefined;
  /**
   * Override the source category configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceCategory field.
   */
  customCategory?: string | undefined;
  /**
   * Preserve the raw event format instead of JSONifying it
   */
  format?: DataFormatSumoLogic | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderSumoLogic> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeSumoLogic | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingSumoLogic> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsSumoLogic | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSumoLogic | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionSumoLogic | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSumoLogic | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeSumoLogic | undefined;
  pqControls?: PqControlsSumoLogic | undefined;
};

export const CreateOutputTypeSnmp = {
  Snmp: "snmp",
} as const;
export type CreateOutputTypeSnmp = ClosedEnum<typeof CreateOutputTypeSnmp>;

export type HostSnmp = {
  /**
   * Destination host
   */
  host: string;
  /**
   * Destination port, default is 162
   */
  port?: number | undefined;
};

export type OutputSnmp = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: CreateOutputTypeSnmp;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * One or more SNMP destinations to forward traps to
   */
  hosts: Array<HostSnmp>;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every trap sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
};

export const CreateOutputTypeSqs = {
  Sqs: "sqs",
} as const;
export type CreateOutputTypeSqs = ClosedEnum<typeof CreateOutputTypeSqs>;

/**
 * The queue type used (or created). Defaults to Standard.
 */
export const CreateOutputQueueType = {
  Standard: "standard",
  Fifo: "fifo",
} as const;
/**
 * The queue type used (or created). Defaults to Standard.
 */
export type CreateOutputQueueType = ClosedEnum<typeof CreateOutputQueueType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateOutputAuthenticationMethodSqs = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateOutputAuthenticationMethodSqs = ClosedEnum<
  typeof CreateOutputAuthenticationMethodSqs
>;

/**
 * Signature version to use for signing SQS requests
 */
export const CreateOutputSignatureVersionSqs = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing SQS requests
 */
export type CreateOutputSignatureVersionSqs = ClosedEnum<
  typeof CreateOutputSignatureVersionSqs
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSqs = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSqs = ClosedEnum<
  typeof BackpressureBehaviorSqs
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionSqs = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionSqs = ClosedEnum<
  typeof PqCompressCompressionSqs
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSqs = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSqs = ClosedEnum<typeof QueueFullBehaviorSqs>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeSqs = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeSqs = ClosedEnum<typeof CreateOutputModeSqs>;

export type PqControlsSqs = {};

export type OutputSqs = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeSqs | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created). Defaults to Standard.
   */
  queueType?: CreateOutputQueueType | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value.
   */
  messageGroupId?: string | undefined;
  /**
   * Create queue if it does not exist.
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateOutputAuthenticationMethodSqs | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: CreateOutputSignatureVersionSqs | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Maximum number of queued batches before blocking.
   */
  maxQueueSize?: number | undefined;
  /**
   * Maximum size (KB) of batches to send. Per the SQS spec, the max allowed value is 256 KB.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * The maximum number of in-progress API requests before backpressure is applied.
   */
  maxInProgress?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSqs | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionSqs | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSqs | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeSqs | undefined;
  pqControls?: PqControlsSqs | undefined;
};

export const TypeSns = {
  Sns: "sns",
} as const;
export type TypeSns = ClosedEnum<typeof TypeSns>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const AuthenticationMethodSns = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type AuthenticationMethodSns = ClosedEnum<
  typeof AuthenticationMethodSns
>;

/**
 * Signature version to use for signing SNS requests
 */
export const SignatureVersionSns = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing SNS requests
 */
export type SignatureVersionSns = ClosedEnum<typeof SignatureVersionSns>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSns = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSns = ClosedEnum<
  typeof BackpressureBehaviorSns
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSns = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSns = ClosedEnum<typeof CompressionSns>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSns = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSns = ClosedEnum<typeof QueueFullBehaviorSns>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeSns = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeSns = ClosedEnum<typeof ModeSns>;

export type PqControlsSns = {};

export type OutputSns = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeSns | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The ARN of the SNS topic to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`
   */
  topicArn: string;
  /**
   * Messages in the same group are processed in a FIFO manner. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  messageGroupId: string;
  /**
   * Maximum number of retries before the output returns an error. Note that not all errors are retryable. The retries use an exponential backoff policy.
   */
  maxRetries?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AuthenticationMethodSns | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the SNS is located
   */
  region?: string | undefined;
  /**
   * SNS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SNS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SNS requests
   */
  signatureVersion?: SignatureVersionSns | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SNS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSns | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionSns | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSns | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeSns | undefined;
  pqControls?: PqControlsSns | undefined;
};

export const TypeRouter = {
  Router: "router",
} as const;
export type TypeRouter = ClosedEnum<typeof TypeRouter>;

export type CreateOutputRule = {
  /**
   * JavaScript expression to select events to send to output
   */
  filter: string;
  /**
   * Output to send matching events to
   */
  output: string;
  /**
   * Description of this rule's purpose
   */
  description?: string | undefined;
  /**
   * Flag to control whether to stop the event from being checked against other rules
   */
  final?: boolean | undefined;
};

export type OutputRouter = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeRouter;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Event routing rules
   */
  rules: Array<CreateOutputRule>;
  description?: string | undefined;
};

export const TypeGraphite = {
  Graphite: "graphite",
} as const;
export type TypeGraphite = ClosedEnum<typeof TypeGraphite>;

/**
 * Protocol to use when communicating with the destination.
 */
export const DestinationProtocolGraphite = {
  Udp: "udp",
  Tcp: "tcp",
} as const;
/**
 * Protocol to use when communicating with the destination.
 */
export type DestinationProtocolGraphite = ClosedEnum<
  typeof DestinationProtocolGraphite
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorGraphite = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorGraphite = ClosedEnum<
  typeof BackpressureBehaviorGraphite
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionGraphite = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionGraphite = ClosedEnum<typeof CompressionGraphite>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorGraphite = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorGraphite = ClosedEnum<
  typeof QueueFullBehaviorGraphite
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeGraphite = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeGraphite = ClosedEnum<typeof ModeGraphite>;

export type PqControlsGraphite = {};

export type OutputGraphite = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeGraphite | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Protocol to use when communicating with the destination.
   */
  protocol?: DestinationProtocolGraphite | undefined;
  /**
   * The hostname of the destination.
   */
  host: string;
  /**
   * Destination port.
   */
  port?: number | undefined;
  /**
   * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
   */
  mtu?: number | undefined;
  /**
   * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorGraphite | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionGraphite | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorGraphite | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeGraphite | undefined;
  pqControls?: PqControlsGraphite | undefined;
};

export const TypeStatsdExt = {
  StatsdExt: "statsd_ext",
} as const;
export type TypeStatsdExt = ClosedEnum<typeof TypeStatsdExt>;

/**
 * Protocol to use when communicating with the destination.
 */
export const DestinationProtocolStatsdExt = {
  Udp: "udp",
  Tcp: "tcp",
} as const;
/**
 * Protocol to use when communicating with the destination.
 */
export type DestinationProtocolStatsdExt = ClosedEnum<
  typeof DestinationProtocolStatsdExt
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorStatsdExt = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorStatsdExt = ClosedEnum<
  typeof BackpressureBehaviorStatsdExt
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionStatsdExt = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionStatsdExt = ClosedEnum<typeof CompressionStatsdExt>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorStatsdExt = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorStatsdExt = ClosedEnum<
  typeof QueueFullBehaviorStatsdExt
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeStatsdExt = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeStatsdExt = ClosedEnum<typeof ModeStatsdExt>;

export type PqControlsStatsdExt = {};

export type OutputStatsdExt = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeStatsdExt | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Protocol to use when communicating with the destination.
   */
  protocol?: DestinationProtocolStatsdExt | undefined;
  /**
   * The hostname of the destination.
   */
  host: string;
  /**
   * Destination port.
   */
  port?: number | undefined;
  /**
   * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
   */
  mtu?: number | undefined;
  /**
   * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorStatsdExt | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionStatsdExt | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorStatsdExt | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeStatsdExt | undefined;
  pqControls?: PqControlsStatsdExt | undefined;
};

export const TypeStatsd = {
  Statsd: "statsd",
} as const;
export type TypeStatsd = ClosedEnum<typeof TypeStatsd>;

/**
 * Protocol to use when communicating with the destination.
 */
export const DestinationProtocolStatsd = {
  Udp: "udp",
  Tcp: "tcp",
} as const;
/**
 * Protocol to use when communicating with the destination.
 */
export type DestinationProtocolStatsd = ClosedEnum<
  typeof DestinationProtocolStatsd
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorStatsd = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorStatsd = ClosedEnum<
  typeof BackpressureBehaviorStatsd
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionStatsd = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionStatsd = ClosedEnum<typeof CompressionStatsd>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorStatsd = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorStatsd = ClosedEnum<
  typeof QueueFullBehaviorStatsd
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeStatsd = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeStatsd = ClosedEnum<typeof ModeStatsd>;

export type PqControlsStatsd = {};

export type OutputStatsd = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeStatsd | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Protocol to use when communicating with the destination.
   */
  protocol?: DestinationProtocolStatsd | undefined;
  /**
   * The hostname of the destination.
   */
  host: string;
  /**
   * Destination port.
   */
  port?: number | undefined;
  /**
   * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
   */
  mtu?: number | undefined;
  /**
   * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  description?: string | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorStatsd | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionStatsd | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorStatsd | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeStatsd | undefined;
  pqControls?: PqControlsStatsd | undefined;
};

export const OutputMinioType = {
  Minio: "minio",
} as const;
export type OutputMinioType = ClosedEnum<typeof OutputMinioType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const OutputMinioAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type OutputMinioAuthenticationMethod = ClosedEnum<
  typeof OutputMinioAuthenticationMethod
>;

/**
 * Signature version to use for signing MinIO requests
 */
export const OutputMinioSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing MinIO requests
 */
export type OutputMinioSignatureVersion = ClosedEnum<
  typeof OutputMinioSignatureVersion
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const OutputMinioObjectACL = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type OutputMinioObjectACL = ClosedEnum<typeof OutputMinioObjectACL>;

/**
 * Storage class to select for uploaded objects
 */
export const OutputMinioStorageClass = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type OutputMinioStorageClass = ClosedEnum<
  typeof OutputMinioStorageClass
>;

/**
 * Server-side encryption for uploaded objects
 */
export const ServerSideEncryption = {
  Aes256: "AES256",
} as const;
/**
 * Server-side encryption for uploaded objects
 */
export type ServerSideEncryption = ClosedEnum<typeof ServerSideEncryption>;

/**
 * Format of the output data
 */
export const OutputMinioDataFormat = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type OutputMinioDataFormat = ClosedEnum<typeof OutputMinioDataFormat>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const OutputMinioBackpressureBehavior = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type OutputMinioBackpressureBehavior = ClosedEnum<
  typeof OutputMinioBackpressureBehavior
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const OutputMinioDiskSpaceProtection = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type OutputMinioDiskSpaceProtection = ClosedEnum<
  typeof OutputMinioDiskSpaceProtection
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const OutputMinioCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type OutputMinioCompression = ClosedEnum<typeof OutputMinioCompression>;

/**
 * Compression level to apply before moving files to final destination
 */
export const OutputMinioCompressionLevel = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type OutputMinioCompressionLevel = ClosedEnum<
  typeof OutputMinioCompressionLevel
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const OutputMinioParquetVersion = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type OutputMinioParquetVersion = ClosedEnum<
  typeof OutputMinioParquetVersion
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const OutputMinioDataPageVersion = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type OutputMinioDataPageVersion = ClosedEnum<
  typeof OutputMinioDataPageVersion
>;

export type OutputMinioKeyValueMetadatum = {
  key?: string | undefined;
  value: string;
};

export type OutputMinio = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: OutputMinioType | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * MinIO service url (e.g. http://minioHost:9000)
   */
  endpoint: string;
  /**
   * Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: OutputMinioAuthenticationMethod | undefined;
  /**
   * Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`).
   */
  awsSecretKey?: string | undefined;
  /**
   * Region where the MinIO service/cluster is located
   */
  region?: string | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks.
   */
  destPath?: string | undefined;
  /**
   * Signature version to use for signing MinIO requests
   */
  signatureVersion?: OutputMinioSignatureVersion | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: OutputMinioObjectACL | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: OutputMinioStorageClass | undefined;
  /**
   * Server-side encryption for uploaded objects
   */
  serverSideEncryption?: ServerSideEncryption | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: OutputMinioDataFormat | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OutputMinioBackpressureBehavior | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: OutputMinioDiskSpaceProtection | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: OutputMinioCompression | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: OutputMinioCompressionLevel | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: OutputMinioParquetVersion | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: OutputMinioDataPageVersion | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<OutputMinioKeyValueMetadatum> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const TypeCloudwatch = {
  Cloudwatch: "cloudwatch",
} as const;
export type TypeCloudwatch = ClosedEnum<typeof TypeCloudwatch>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const AuthenticationMethodCloudwatch = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type AuthenticationMethodCloudwatch = ClosedEnum<
  typeof AuthenticationMethodCloudwatch
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorCloudwatch = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorCloudwatch = ClosedEnum<
  typeof BackpressureBehaviorCloudwatch
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionCloudwatch = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionCloudwatch = ClosedEnum<typeof CompressionCloudwatch>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorCloudwatch = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorCloudwatch = ClosedEnum<
  typeof QueueFullBehaviorCloudwatch
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeCloudwatch = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeCloudwatch = ClosedEnum<typeof ModeCloudwatch>;

export type PqControlsCloudwatch = {};

export type OutputCloudwatch = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeCloudwatch | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * CloudWatch log group to associate events with
   */
  logGroupName: string;
  /**
   * Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId
   */
  logStreamName: string;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AuthenticationMethodCloudwatch | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the CloudWatchLogs is located
   */
  region: string;
  /**
   * CloudWatchLogs service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to CloudWatchLogs-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access CloudWatchLogs
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Maximum number of queued batches before blocking
   */
  maxQueueSize?: number | undefined;
  /**
   * Maximum size (KB) of each individual record before compression. For non compressible data 1MB is the max recommended size
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorCloudwatch | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionCloudwatch | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorCloudwatch | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeCloudwatch | undefined;
  pqControls?: PqControlsCloudwatch | undefined;
};

export const TypeInfluxdb = {
  Influxdb: "influxdb",
} as const;
export type TypeInfluxdb = ClosedEnum<typeof TypeInfluxdb>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision = {
  Ns: "ns",
  U: "u",
  Ms: "ms",
  S: "s",
  M: "m",
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision = ClosedEnum<typeof TimestampPrecision>;

export type ExtraHttpHeaderInfluxdb = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeInfluxdb = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeInfluxdb = ClosedEnum<
  typeof FailedRequestLoggingModeInfluxdb
>;

export type ResponseRetrySettingInfluxdb = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsInfluxdb = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorInfluxdb = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorInfluxdb = ClosedEnum<
  typeof BackpressureBehaviorInfluxdb
>;

/**
 * InfluxDB authentication type
 */
export const AuthenticationTypeInfluxdb = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * InfluxDB authentication type
 */
export type AuthenticationTypeInfluxdb = ClosedEnum<
  typeof AuthenticationTypeInfluxdb
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionInfluxdb = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionInfluxdb = ClosedEnum<typeof CompressionInfluxdb>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorInfluxdb = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorInfluxdb = ClosedEnum<
  typeof QueueFullBehaviorInfluxdb
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeInfluxdb = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeInfluxdb = ClosedEnum<typeof ModeInfluxdb>;

export type PqControlsInfluxdb = {};

export type OauthParamInfluxdb = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OauthHeaderInfluxdb = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type OutputInfluxdb = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeInfluxdb;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderInfluxdb> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeInfluxdb | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingInfluxdb> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsInfluxdb | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorInfluxdb | undefined;
  /**
   * InfluxDB authentication type
   */
  authType?: AuthenticationTypeInfluxdb | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionInfluxdb | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorInfluxdb | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeInfluxdb | undefined;
  pqControls?: PqControlsInfluxdb | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OauthParamInfluxdb> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OauthHeaderInfluxdb> | undefined;
};

export const TypeNewrelicEvents = {
  NewrelicEvents: "newrelic_events",
} as const;
export type TypeNewrelicEvents = ClosedEnum<typeof TypeNewrelicEvents>;

/**
 * Which New Relic region endpoint to use.
 */
export const RegionNewrelicEvents = {
  Us: "US",
  Eu: "EU",
  Custom: "Custom",
} as const;
/**
 * Which New Relic region endpoint to use.
 */
export type RegionNewrelicEvents = ClosedEnum<typeof RegionNewrelicEvents>;

export type ExtraHttpHeaderNewrelicEvents = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeNewrelicEvents = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeNewrelicEvents = ClosedEnum<
  typeof FailedRequestLoggingModeNewrelicEvents
>;

export type ResponseRetrySettingNewrelicEvents = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsNewrelicEvents = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorNewrelicEvents = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorNewrelicEvents = ClosedEnum<
  typeof BackpressureBehaviorNewrelicEvents
>;

/**
 * Enter API key directly, or select a stored secret
 */
export const AuthenticationMethodNewrelicEvents = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter API key directly, or select a stored secret
 */
export type AuthenticationMethodNewrelicEvents = ClosedEnum<
  typeof AuthenticationMethodNewrelicEvents
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionNewrelicEvents = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionNewrelicEvents = ClosedEnum<
  typeof CompressionNewrelicEvents
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorNewrelicEvents = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorNewrelicEvents = ClosedEnum<
  typeof QueueFullBehaviorNewrelicEvents
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeNewrelicEvents = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeNewrelicEvents = ClosedEnum<typeof ModeNewrelicEvents>;

export type PqControlsNewrelicEvents = {};

export type OutputNewrelicEvents = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeNewrelicEvents | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Which New Relic region endpoint to use.
   */
  region?: RegionNewrelicEvents | undefined;
  /**
   * New Relic account ID
   */
  accountId: string;
  /**
   * Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words).
   */
  eventType: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderNewrelicEvents> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeNewrelicEvents | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingNewrelicEvents> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsNewrelicEvents | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorNewrelicEvents | undefined;
  /**
   * Enter API key directly, or select a stored secret
   */
  authType?: AuthenticationMethodNewrelicEvents | undefined;
  description?: string | undefined;
  customUrl?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionNewrelicEvents | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorNewrelicEvents | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeNewrelicEvents | undefined;
  pqControls?: PqControlsNewrelicEvents | undefined;
  /**
   * New Relic API key. Can be overridden using __newRelic_apiKey field.
   */
  apiKey?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const TypeElasticCloud = {
  ElasticCloud: "elastic_cloud",
} as const;
export type TypeElasticCloud = ClosedEnum<typeof TypeElasticCloud>;

export type ExtraHttpHeaderElasticCloud = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeElasticCloud = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeElasticCloud = ClosedEnum<
  typeof FailedRequestLoggingModeElasticCloud
>;

export type ExtraParamElasticCloud = {
  name: string;
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const AuthenticationMethodElasticCloud = {
  Manual: "manual",
  Secret: "secret",
  ManualAPIKey: "manualAPIKey",
  TextSecret: "textSecret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type AuthenticationMethodElasticCloud = ClosedEnum<
  typeof AuthenticationMethodElasticCloud
>;

export type AuthElasticCloud = {
  disabled?: boolean | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthenticationMethodElasticCloud | undefined;
};

export type ResponseRetrySettingElasticCloud = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsElasticCloud = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorElasticCloud = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorElasticCloud = ClosedEnum<
  typeof BackpressureBehaviorElasticCloud
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionElasticCloud = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionElasticCloud = ClosedEnum<
  typeof CompressionElasticCloud
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorElasticCloud = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorElasticCloud = ClosedEnum<
  typeof QueueFullBehaviorElasticCloud
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeElasticCloud = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeElasticCloud = ClosedEnum<typeof ModeElasticCloud>;

export type PqControlsElasticCloud = {};

export type OutputElasticCloud = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeElasticCloud | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enter Cloud ID of the Elastic Cloud environment to send events to
   */
  url: string;
  /**
   * Data stream or index to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
   */
  index: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderElasticCloud> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeElasticCloud | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Extra parameters to use in HTTP requests
   */
  extraParams?: Array<ExtraParamElasticCloud> | undefined;
  auth?: AuthElasticCloud | undefined;
  /**
   * Optional Elastic Cloud Destination pipeline
   */
  elasticPipeline?: string | undefined;
  /**
   * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream)
   */
  includeDocId?: boolean | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingElasticCloud> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsElasticCloud | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorElasticCloud | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionElasticCloud | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorElasticCloud | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeElasticCloud | undefined;
  pqControls?: PqControlsElasticCloud | undefined;
};

export const CreateOutputTypeElastic = {
  Elastic: "elastic",
} as const;
export type CreateOutputTypeElastic = ClosedEnum<
  typeof CreateOutputTypeElastic
>;

export type CreateOutputExtraHttpHeaderElastic = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeElastic = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeElastic = ClosedEnum<
  typeof FailedRequestLoggingModeElastic
>;

export type ResponseRetrySettingElastic = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsElastic = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type ExtraParamElastic = {
  name: string;
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const AuthAuthenticationMethodElastic = {
  Manual: "manual",
  Secret: "secret",
  ManualAPIKey: "manualAPIKey",
  TextSecret: "textSecret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type AuthAuthenticationMethodElastic = ClosedEnum<
  typeof AuthAuthenticationMethodElastic
>;

export type AuthElastic = {
  disabled?: boolean | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthAuthenticationMethodElastic | undefined;
};

/**
 * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
 */
export const ElasticVersion = {
  Auto: "auto",
  Six: "6",
  Seven: "7",
} as const;
/**
 * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
 */
export type ElasticVersion = ClosedEnum<typeof ElasticVersion>;

/**
 * Action to use when writing events. Must be set to `Create` when writing to a data stream.
 */
export const WriteAction = {
  Index: "index",
  Create: "create",
} as const;
/**
 * Action to use when writing events. Must be set to `Create` when writing to a data stream.
 */
export type WriteAction = ClosedEnum<typeof WriteAction>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorElastic = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorElastic = ClosedEnum<
  typeof BackpressureBehaviorElastic
>;

export type Url = {
  /**
   * The URL to an Elastic node to send events to. Example: http://elastic:9200/_bulk
   */
  url: string;
  /**
   * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
   */
  weight?: number | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionElastic = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionElastic = ClosedEnum<
  typeof PqCompressCompressionElastic
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorElastic = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorElastic = ClosedEnum<
  typeof QueueFullBehaviorElastic
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeElastic = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeElastic = ClosedEnum<
  typeof CreateOutputModeElastic
>;

export type PqControlsElastic = {};

export type OutputElastic = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: CreateOutputTypeElastic;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  /**
   * Index or data stream to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
   */
  index: string;
  /**
   * Document type to use for events. Can be overwritten by an event's __type field.
   */
  docType?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<CreateOutputExtraHttpHeaderElastic> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeElastic | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingElastic> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsElastic | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  extraParams?: Array<ExtraParamElastic> | undefined;
  auth?: AuthElastic | undefined;
  /**
   * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
   */
  elasticVersion?: ElasticVersion | undefined;
  /**
   * Optional Elasticsearch destination pipeline
   */
  elasticPipeline?: string | undefined;
  /**
   * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream)
   */
  includeDocId?: boolean | undefined;
  /**
   * Action to use when writing events. Must be set to `Create` when writing to a data stream.
   */
  writeAction?: WriteAction | undefined;
  /**
   * Retry failed events when a bulk request to Elastic is successful, but the response body returns an error for one or more events in the batch
   */
  retryPartialErrors?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorElastic | undefined;
  description?: string | undefined;
  /**
   * The Cloud ID or URL to an Elastic cluster to send events to. Example: http://elastic:9200/_bulk
   */
  url?: string | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<Url> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionElastic | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorElastic | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeElastic | undefined;
  pqControls?: PqControlsElastic | undefined;
};

export const CreateOutputTypeMsk = {
  Msk: "msk",
} as const;
export type CreateOutputTypeMsk = ClosedEnum<typeof CreateOutputTypeMsk>;

/**
 * Control the number of required acknowledgments.
 */
export const AcknowledgmentsMsk = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments.
 */
export type AcknowledgmentsMsk = ClosedEnum<typeof AcknowledgmentsMsk>;

/**
 * Format to use to serialize events before writing to Kafka.
 */
export const RecordDataFormatMsk = {
  Json: "json",
  Raw: "raw",
  Protobuf: "protobuf",
} as const;
/**
 * Format to use to serialize events before writing to Kafka.
 */
export type RecordDataFormatMsk = ClosedEnum<typeof RecordDataFormatMsk>;

/**
 * Codec to use to compress the data before sending to Kafka
 */
export const CreateOutputCompressionMsk = {
  None: "none",
  Gzip: "gzip",
  Snappy: "snappy",
  Lz4: "lz4",
} as const;
/**
 * Codec to use to compress the data before sending to Kafka
 */
export type CreateOutputCompressionMsk = ClosedEnum<
  typeof CreateOutputCompressionMsk
>;

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type CreateOutputAuthMsk = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk = ClosedEnum<
  typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk
>;

export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk = ClosedEnum<
  typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk
>;

export type CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk | undefined;
  maxVersion?: CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk | undefined;
};

export type CreateOutputKafkaSchemaRegistryAuthenticationMsk = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: CreateOutputAuthMsk | undefined;
  tls?: CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateOutputAuthenticationMethodMsk = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateOutputAuthenticationMethodMsk = ClosedEnum<
  typeof CreateOutputAuthenticationMethodMsk
>;

/**
 * Signature version to use for signing MSK cluster requests
 */
export const CreateOutputSignatureVersionMsk = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing MSK cluster requests
 */
export type CreateOutputSignatureVersionMsk = ClosedEnum<
  typeof CreateOutputSignatureVersionMsk
>;

export const CreateOutputMinimumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMinimumTLSVersionMsk = ClosedEnum<
  typeof CreateOutputMinimumTLSVersionMsk
>;

export const CreateOutputMaximumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMaximumTLSVersionMsk = ClosedEnum<
  typeof CreateOutputMaximumTLSVersionMsk
>;

export type CreateOutputTLSSettingsClientSideMsk = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateOutputMinimumTLSVersionMsk | undefined;
  maxVersion?: CreateOutputMaximumTLSVersionMsk | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorMsk = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorMsk = ClosedEnum<
  typeof BackpressureBehaviorMsk
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionMsk = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionMsk = ClosedEnum<
  typeof PqCompressCompressionMsk
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorMsk = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorMsk = ClosedEnum<typeof QueueFullBehaviorMsk>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeMsk = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeMsk = ClosedEnum<typeof CreateOutputModeMsk>;

export type PqControlsMsk = {};

export type OutputMsk = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeMsk | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
   */
  brokers: Array<string>;
  /**
   * The topic to publish events to. Can be overridden using the __topicOut field.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments.
   */
  ack?: AcknowledgmentsMsk | undefined;
  /**
   * Format to use to serialize events before writing to Kafka.
   */
  format?: RecordDataFormatMsk | undefined;
  /**
   * Codec to use to compress the data before sending to Kafka
   */
  compression?: CreateOutputCompressionMsk | undefined;
  /**
   * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * The maximum number of events you want the Destination to allow in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
   */
  flushPeriodSec?: number | undefined;
  kafkaSchemaRegistry?:
    | CreateOutputKafkaSchemaRegistryAuthenticationMsk
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateOutputAuthenticationMethodMsk | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: CreateOutputSignatureVersionMsk | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: CreateOutputTLSSettingsClientSideMsk | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorMsk | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Select a set of Protobuf definitions for the events you want to send
   */
  protobufLibraryId?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionMsk | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorMsk | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeMsk | undefined;
  pqControls?: PqControlsMsk | undefined;
};

export const CreateOutputTypeConfluentCloud = {
  ConfluentCloud: "confluent_cloud",
} as const;
export type CreateOutputTypeConfluentCloud = ClosedEnum<
  typeof CreateOutputTypeConfluentCloud
>;

export const CreateOutputMinimumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMinimumTLSVersionConfluentCloud = ClosedEnum<
  typeof CreateOutputMinimumTLSVersionConfluentCloud
>;

export const CreateOutputMaximumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMaximumTLSVersionConfluentCloud = ClosedEnum<
  typeof CreateOutputMaximumTLSVersionConfluentCloud
>;

export type CreateOutputTLSSettingsClientSideConfluentCloud = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateOutputMinimumTLSVersionConfluentCloud | undefined;
  maxVersion?: CreateOutputMaximumTLSVersionConfluentCloud | undefined;
};

/**
 * Control the number of required acknowledgments.
 */
export const AcknowledgmentsConfluentCloud = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments.
 */
export type AcknowledgmentsConfluentCloud = ClosedEnum<
  typeof AcknowledgmentsConfluentCloud
>;

/**
 * Format to use to serialize events before writing to Kafka.
 */
export const RecordDataFormatConfluentCloud = {
  Json: "json",
  Raw: "raw",
  Protobuf: "protobuf",
} as const;
/**
 * Format to use to serialize events before writing to Kafka.
 */
export type RecordDataFormatConfluentCloud = ClosedEnum<
  typeof RecordDataFormatConfluentCloud
>;

/**
 * Codec to use to compress the data before sending to Kafka
 */
export const CreateOutputCompressionConfluentCloud = {
  None: "none",
  Gzip: "gzip",
  Snappy: "snappy",
  Lz4: "lz4",
} as const;
/**
 * Codec to use to compress the data before sending to Kafka
 */
export type CreateOutputCompressionConfluentCloud = ClosedEnum<
  typeof CreateOutputCompressionConfluentCloud
>;

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type CreateOutputAuthConfluentCloud = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud =
  ClosedEnum<
    typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
  >;

export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud =
  ClosedEnum<
    typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
  >;

export type CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud =
  {
    disabled?: boolean | undefined;
    /**
     * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
     *
     * @remarks
     *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
     */
    rejectUnauthorized?: boolean | undefined;
    /**
     * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
     */
    servername?: string | undefined;
    /**
     * The name of the predefined certificate
     */
    certificateName?: string | undefined;
    /**
     * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
     */
    caPath?: string | undefined;
    /**
     * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
     */
    privKeyPath?: string | undefined;
    /**
     * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
     */
    certPath?: string | undefined;
    /**
     * Passphrase to use to decrypt private key
     */
    passphrase?: string | undefined;
    minVersion?:
      | CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
      | undefined;
    maxVersion?:
      | CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
      | undefined;
  };

export type CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: CreateOutputAuthConfluentCloud | undefined;
  tls?:
    | CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud
    | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

export const CreateOutputSASLMechanismConfluentCloud = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type CreateOutputSASLMechanismConfluentCloud = ClosedEnum<
  typeof CreateOutputSASLMechanismConfluentCloud
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type CreateOutputAuthenticationConfluentCloud = {
  disabled?: boolean | undefined;
  mechanism?: CreateOutputSASLMechanismConfluentCloud | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorConfluentCloud = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorConfluentCloud = ClosedEnum<
  typeof BackpressureBehaviorConfluentCloud
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionConfluentCloud = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionConfluentCloud = ClosedEnum<
  typeof PqCompressCompressionConfluentCloud
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorConfluentCloud = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorConfluentCloud = ClosedEnum<
  typeof QueueFullBehaviorConfluentCloud
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeConfluentCloud = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeConfluentCloud = ClosedEnum<
  typeof CreateOutputModeConfluentCloud
>;

export type PqControlsConfluentCloud = {};

export type OutputConfluentCloud = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeConfluentCloud | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092.
   */
  brokers: Array<string>;
  tls?: CreateOutputTLSSettingsClientSideConfluentCloud | undefined;
  /**
   * The topic to publish events to. Can be overridden using the __topicOut field.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments.
   */
  ack?: AcknowledgmentsConfluentCloud | undefined;
  /**
   * Format to use to serialize events before writing to Kafka.
   */
  format?: RecordDataFormatConfluentCloud | undefined;
  /**
   * Codec to use to compress the data before sending to Kafka
   */
  compression?: CreateOutputCompressionConfluentCloud | undefined;
  /**
   * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * The maximum number of events you want the Destination to allow in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
   */
  flushPeriodSec?: number | undefined;
  kafkaSchemaRegistry?:
    | CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: CreateOutputAuthenticationConfluentCloud | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorConfluentCloud | undefined;
  description?: string | undefined;
  /**
   * Select a set of Protobuf definitions for the events you want to send
   */
  protobufLibraryId?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionConfluentCloud | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorConfluentCloud | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeConfluentCloud | undefined;
  pqControls?: PqControlsConfluentCloud | undefined;
};

export const CreateOutputTypeKafka = {
  Kafka: "kafka",
} as const;
export type CreateOutputTypeKafka = ClosedEnum<typeof CreateOutputTypeKafka>;

/**
 * Control the number of required acknowledgments.
 */
export const AcknowledgmentsKafka = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments.
 */
export type AcknowledgmentsKafka = ClosedEnum<typeof AcknowledgmentsKafka>;

/**
 * Format to use to serialize events before writing to Kafka.
 */
export const RecordDataFormatKafka = {
  Json: "json",
  Raw: "raw",
  Protobuf: "protobuf",
} as const;
/**
 * Format to use to serialize events before writing to Kafka.
 */
export type RecordDataFormatKafka = ClosedEnum<typeof RecordDataFormatKafka>;

/**
 * Codec to use to compress the data before sending to Kafka
 */
export const CreateOutputCompressionKafka = {
  None: "none",
  Gzip: "gzip",
  Snappy: "snappy",
  Lz4: "lz4",
} as const;
/**
 * Codec to use to compress the data before sending to Kafka
 */
export type CreateOutputCompressionKafka = ClosedEnum<
  typeof CreateOutputCompressionKafka
>;

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type CreateOutputAuthKafka = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka = ClosedEnum<
  typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka
>;

export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka = ClosedEnum<
  typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka
>;

export type CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?:
    | CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka
    | undefined;
  maxVersion?:
    | CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka
    | undefined;
};

export type CreateOutputKafkaSchemaRegistryAuthenticationKafka = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: CreateOutputAuthKafka | undefined;
  tls?: CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

export const CreateOutputSASLMechanismKafka = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type CreateOutputSASLMechanismKafka = ClosedEnum<
  typeof CreateOutputSASLMechanismKafka
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type CreateOutputAuthenticationKafka = {
  disabled?: boolean | undefined;
  mechanism?: CreateOutputSASLMechanismKafka | undefined;
};

export const CreateOutputMinimumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMinimumTLSVersionKafka = ClosedEnum<
  typeof CreateOutputMinimumTLSVersionKafka
>;

export const CreateOutputMaximumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMaximumTLSVersionKafka = ClosedEnum<
  typeof CreateOutputMaximumTLSVersionKafka
>;

export type CreateOutputTLSSettingsClientSideKafka = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateOutputMinimumTLSVersionKafka | undefined;
  maxVersion?: CreateOutputMaximumTLSVersionKafka | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorKafka = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorKafka = ClosedEnum<
  typeof BackpressureBehaviorKafka
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionKafka = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionKafka = ClosedEnum<
  typeof PqCompressCompressionKafka
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorKafka = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorKafka = ClosedEnum<typeof QueueFullBehaviorKafka>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeKafka = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeKafka = ClosedEnum<typeof CreateOutputModeKafka>;

export type PqControlsKafka = {};

export type OutputKafka = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeKafka | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
   */
  brokers: Array<string>;
  /**
   * The topic to publish events to. Can be overridden using the __topicOut field.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments.
   */
  ack?: AcknowledgmentsKafka | undefined;
  /**
   * Format to use to serialize events before writing to Kafka.
   */
  format?: RecordDataFormatKafka | undefined;
  /**
   * Codec to use to compress the data before sending to Kafka
   */
  compression?: CreateOutputCompressionKafka | undefined;
  /**
   * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * The maximum number of events you want the Destination to allow in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
   */
  flushPeriodSec?: number | undefined;
  kafkaSchemaRegistry?:
    | CreateOutputKafkaSchemaRegistryAuthenticationKafka
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: CreateOutputAuthenticationKafka | undefined;
  tls?: CreateOutputTLSSettingsClientSideKafka | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorKafka | undefined;
  description?: string | undefined;
  /**
   * Select a set of Protobuf definitions for the events you want to send
   */
  protobufLibraryId?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionKafka | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorKafka | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeKafka | undefined;
  pqControls?: PqControlsKafka | undefined;
};

export const TypeExabeam = {
  Exabeam: "exabeam",
} as const;
export type TypeExabeam = ClosedEnum<typeof TypeExabeam>;

/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export const SignatureVersionExabeam = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export type SignatureVersionExabeam = ClosedEnum<
  typeof SignatureVersionExabeam
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const ObjectACLExabeam = {
  Private: "private",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
  ProjectPrivate: "project-private",
  AuthenticatedRead: "authenticated-read",
  PublicRead: "public-read",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type ObjectACLExabeam = ClosedEnum<typeof ObjectACLExabeam>;

/**
 * Storage class to select for uploaded objects
 */
export const StorageClassExabeam = {
  Standard: "STANDARD",
  Nearline: "NEARLINE",
  Coldline: "COLDLINE",
  Archive: "ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type StorageClassExabeam = ClosedEnum<typeof StorageClassExabeam>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorExabeam = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorExabeam = ClosedEnum<
  typeof BackpressureBehaviorExabeam
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionExabeam = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionExabeam = ClosedEnum<
  typeof DiskSpaceProtectionExabeam
>;

export type OutputExabeam = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeExabeam | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination bucket. A constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a JavaScript Global Variable: `myBucket-${C.vars.myVar}`.
   */
  bucket: string;
  /**
   * Region where the bucket is located
   */
  region: string;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Google Cloud Storage service endpoint
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Google Cloud Storage requests
   */
  signatureVersion?: SignatureVersionExabeam | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: ObjectACLExabeam | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: StorageClassExabeam | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorExabeam | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionExabeam | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Enter an encoded string containing Exabeam configurations
   */
  encodedConfiguration?: string | undefined;
  /**
   * ID of the Exabeam Collector where data should be sent. Example: 11112222-3333-4444-5555-666677778888
   *
   * @remarks
   */
  collectorInstanceId: string;
  /**
   * Constant or JavaScript expression to create an Exabeam site name. Values that aren't successfully evaluated will be treated as string constants.
   */
  siteName?: string | undefined;
  /**
   * Exabeam site ID. If left blank, @{product} will use the value of the Exabeam site name.
   */
  siteId?: string | undefined;
  timezoneOffset?: string | undefined;
  /**
   * HMAC access key. Can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
   */
  awsApiKey?: string | undefined;
  /**
   * HMAC secret. Can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
   */
  awsSecretKey?: string | undefined;
  description?: string | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const CreateOutputTypeGooglePubsub = {
  GooglePubsub: "google_pubsub",
} as const;
export type CreateOutputTypeGooglePubsub = ClosedEnum<
  typeof CreateOutputTypeGooglePubsub
>;

/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export const CreateOutputGoogleAuthenticationMethodGooglePubsub = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export type CreateOutputGoogleAuthenticationMethodGooglePubsub = ClosedEnum<
  typeof CreateOutputGoogleAuthenticationMethodGooglePubsub
>;

export const FlushPeriodSecType = {
  Number: "number",
} as const;
export type FlushPeriodSecType = ClosedEnum<typeof FlushPeriodSecType>;

/**
 * Maximum time to wait before sending a batch (when batch size limit is not reached).
 */
export type FlushPeriodSec = {
  type?: FlushPeriodSecType | undefined;
  default?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorGooglePubsub = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorGooglePubsub = ClosedEnum<
  typeof BackpressureBehaviorGooglePubsub
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionGooglePubsub = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionGooglePubsub = ClosedEnum<
  typeof PqCompressCompressionGooglePubsub
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorGooglePubsub = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorGooglePubsub = ClosedEnum<
  typeof QueueFullBehaviorGooglePubsub
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeGooglePubsub = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeGooglePubsub = ClosedEnum<
  typeof CreateOutputModeGooglePubsub
>;

export type PqControlsGooglePubsub = {};

export type OutputGooglePubsub = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: CreateOutputTypeGooglePubsub;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * ID of the topic to send events to.
   */
  topicName: string;
  /**
   * If enabled, create topic if it does not exist.
   */
  createTopic?: boolean | undefined;
  /**
   * If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
  /**
   * Region to publish messages to. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?:
    | CreateOutputGoogleAuthenticationMethodGooglePubsub
    | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * The maximum number of items the Google API should batch before it sends them to the topic.
   */
  batchSize?: number | undefined;
  /**
   * The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached).
   */
  batchTimeout?: number | undefined;
  /**
   * Maximum number of queued batches before blocking.
   */
  maxQueueSize?: number | undefined;
  /**
   * Maximum size (KB) of batches to send.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time to wait before sending a batch (when batch size limit is not reached).
   */
  flushPeriodSec?: FlushPeriodSec | undefined;
  /**
   * The maximum number of in-progress API requests before backpressure is applied.
   */
  maxInProgress?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorGooglePubsub | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionGooglePubsub | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorGooglePubsub | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeGooglePubsub | undefined;
  pqControls?: PqControlsGooglePubsub | undefined;
};

export const TypeGoogleCloudLogging = {
  GoogleCloudLogging: "google_cloud_logging",
} as const;
export type TypeGoogleCloudLogging = ClosedEnum<typeof TypeGoogleCloudLogging>;

export const LogLocationType = {
  Project: "project",
  Organization: "organization",
  BillingAccount: "billingAccount",
  Folder: "folder",
} as const;
export type LogLocationType = ClosedEnum<typeof LogLocationType>;

/**
 * Format to use when sending payload. Defaults to Text.
 */
export const PayloadFormat = {
  Text: "text",
  Json: "json",
} as const;
/**
 * Format to use when sending payload. Defaults to Text.
 */
export type PayloadFormat = ClosedEnum<typeof PayloadFormat>;

export type LogLabel = {
  /**
   * Label name
   */
  label: string;
  /**
   * JavaScript expression to compute the label's value.
   */
  valueExpression: string;
};

export type ResourceTypeLabel = {
  /**
   * Label name
   */
  label: string;
  /**
   * JavaScript expression to compute the label's value.
   */
  valueExpression: string;
};

/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export const GoogleAuthenticationMethodGoogleCloudLogging = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export type GoogleAuthenticationMethodGoogleCloudLogging = ClosedEnum<
  typeof GoogleAuthenticationMethodGoogleCloudLogging
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorGoogleCloudLogging = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorGoogleCloudLogging = ClosedEnum<
  typeof BackpressureBehaviorGoogleCloudLogging
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionGoogleCloudLogging = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionGoogleCloudLogging = ClosedEnum<
  typeof CompressionGoogleCloudLogging
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorGoogleCloudLogging = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorGoogleCloudLogging = ClosedEnum<
  typeof QueueFullBehaviorGoogleCloudLogging
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeGoogleCloudLogging = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeGoogleCloudLogging = ClosedEnum<typeof ModeGoogleCloudLogging>;

export type PqControlsGoogleCloudLogging = {};

export type OutputGoogleCloudLogging = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeGoogleCloudLogging | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  logLocationType: LogLocationType;
  /**
   * JavaScript expression to compute the value of the log name.
   */
  logNameExpression: string;
  /**
   * Format to use when sending payload. Defaults to Text.
   */
  payloadFormat?: PayloadFormat | undefined;
  /**
   * Labels to apply to the log entry
   */
  logLabels?: Array<LogLabel> | undefined;
  /**
   * JavaScript expression to compute the value of the managed resource type field. Must evaluate to one of the valid values [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types). Defaults to "global".
   */
  resourceTypeExpression?: string | undefined;
  /**
   * Labels to apply to the managed resource. These must correspond to the valid labels for the specified resource type (see [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types)). Otherwise, they will be dropped by Google Cloud Logging.
   */
  resourceTypeLabels?: Array<ResourceTypeLabel> | undefined;
  /**
   * JavaScript expression to compute the value of the severity field. Must evaluate to one of the severity values supported by Google Cloud Logging [here](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity) (case insensitive). Defaults to "DEFAULT".
   */
  severityExpression?: string | undefined;
  /**
   * JavaScript expression to compute the value of the insert ID field.
   */
  insertIdExpression?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: GoogleAuthenticationMethodGoogleCloudLogging | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * Maximum size, in KB, of the request body.
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Max number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Maximum number of ongoing requests before blocking.
   */
  concurrency?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it.
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum number of requests to limit to per second.
   */
  throttleRateReqPerSec?: number | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request method as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  requestMethodExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request URL as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  requestUrlExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  requestSizeExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request method as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  statusExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP response size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  responseSizeExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request user agent as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  userAgentExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request remote IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  remoteIpExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request server IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  serverIpExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request referer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  refererExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request latency, formatted as <seconds>.<nanoseconds>s (for example, 1.23s). See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  latencyExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache lookup as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheLookupExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache hit as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheHitExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache validated with origin server as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheValidatedExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request cache fill bytes as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  cacheFillBytesExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the HTTP request protocol as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
   */
  protocolExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation ID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  idExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation producer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  producerExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation first flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  firstExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry operation last flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
   */
  lastExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry source location file as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
   */
  fileExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry source location line as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
   */
  lineExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry source location function as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
   */
  functionExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry log split UID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
   */
  uidExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry log split index as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
   */
  indexExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the log entry log split total splits as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
   */
  totalSplitsExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the REST resource name of the trace being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
   */
  traceExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the ID of the cloud trace span associated with the current operation in which the log is being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
   */
  spanIdExpression?: string | undefined;
  /**
   * A JavaScript expression that evaluates to the the sampling decision of the span associated with the log entry. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
   */
  traceSampledExpression?: string | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorGoogleCloudLogging | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * JavaScript expression to compute the value of the folder ID with which log entries should be associated.
   */
  logLocationExpression: string;
  /**
   * JavaScript expression to compute the value of the payload. Must evaluate to a JavaScript object value. If an invalid value is encountered it will result in the default value instead. Defaults to the entire event.
   */
  payloadExpression?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionGoogleCloudLogging | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorGoogleCloudLogging | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeGoogleCloudLogging | undefined;
  pqControls?: PqControlsGoogleCloudLogging | undefined;
};

export const TypeGoogleCloudStorage = {
  GoogleCloudStorage: "google_cloud_storage",
} as const;
export type TypeGoogleCloudStorage = ClosedEnum<typeof TypeGoogleCloudStorage>;

/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export const SignatureVersionGoogleCloudStorage = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Google Cloud Storage requests
 */
export type SignatureVersionGoogleCloudStorage = ClosedEnum<
  typeof SignatureVersionGoogleCloudStorage
>;

export const AuthenticationMethodGoogleCloudStorage = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
export type AuthenticationMethodGoogleCloudStorage = ClosedEnum<
  typeof AuthenticationMethodGoogleCloudStorage
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const ObjectACLGoogleCloudStorage = {
  Private: "private",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
  ProjectPrivate: "project-private",
  AuthenticatedRead: "authenticated-read",
  PublicRead: "public-read",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type ObjectACLGoogleCloudStorage = ClosedEnum<
  typeof ObjectACLGoogleCloudStorage
>;

/**
 * Storage class to select for uploaded objects
 */
export const StorageClassGoogleCloudStorage = {
  Standard: "STANDARD",
  Nearline: "NEARLINE",
  Coldline: "COLDLINE",
  Archive: "ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type StorageClassGoogleCloudStorage = ClosedEnum<
  typeof StorageClassGoogleCloudStorage
>;

/**
 * Format of the output data
 */
export const DataFormatGoogleCloudStorage = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type DataFormatGoogleCloudStorage = ClosedEnum<
  typeof DataFormatGoogleCloudStorage
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorGoogleCloudStorage = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorGoogleCloudStorage = ClosedEnum<
  typeof BackpressureBehaviorGoogleCloudStorage
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionGoogleCloudStorage = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionGoogleCloudStorage = ClosedEnum<
  typeof DiskSpaceProtectionGoogleCloudStorage
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const CompressionGoogleCloudStorage = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type CompressionGoogleCloudStorage = ClosedEnum<
  typeof CompressionGoogleCloudStorage
>;

/**
 * Compression level to apply before moving files to final destination
 */
export const CompressionLevelGoogleCloudStorage = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type CompressionLevelGoogleCloudStorage = ClosedEnum<
  typeof CompressionLevelGoogleCloudStorage
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const ParquetVersionGoogleCloudStorage = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type ParquetVersionGoogleCloudStorage = ClosedEnum<
  typeof ParquetVersionGoogleCloudStorage
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const DataPageVersionGoogleCloudStorage = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type DataPageVersionGoogleCloudStorage = ClosedEnum<
  typeof DataPageVersionGoogleCloudStorage
>;

export type KeyValueMetadatumGoogleCloudStorage = {
  key?: string | undefined;
  value: string;
};

export type OutputGoogleCloudStorage = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeGoogleCloudStorage | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a Global Variable: `myBucket-${C.vars.myVar}`.
   */
  bucket: string;
  /**
   * Region where the bucket is located
   */
  region: string;
  /**
   * Google Cloud Storage service endpoint
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Google Cloud Storage requests
   */
  signatureVersion?: SignatureVersionGoogleCloudStorage | undefined;
  awsAuthenticationMethod?: AuthenticationMethodGoogleCloudStorage | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`
   */
  destPath?: string | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: ObjectACLGoogleCloudStorage | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: StorageClassGoogleCloudStorage | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: DataFormatGoogleCloudStorage | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorGoogleCloudStorage | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionGoogleCloudStorage | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: CompressionGoogleCloudStorage | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: CompressionLevelGoogleCloudStorage | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: ParquetVersionGoogleCloudStorage | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: DataPageVersionGoogleCloudStorage | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<KeyValueMetadatumGoogleCloudStorage> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
  /**
   * HMAC access key. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
   */
  awsApiKey?: string | undefined;
  /**
   * HMAC secret. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
   */
  awsSecretKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export const TypeGoogleChronicle = {
  GoogleChronicle: "google_chronicle",
} as const;
export type TypeGoogleChronicle = ClosedEnum<typeof TypeGoogleChronicle>;

export const CreateOutputAPIVersion = {
  V1: "v1",
  V2: "v2",
} as const;
export type CreateOutputAPIVersion = ClosedEnum<typeof CreateOutputAPIVersion>;

export const AuthenticationMethodGoogleChronicle = {
  Manual: "manual",
  Secret: "secret",
  ServiceAccount: "serviceAccount",
  ServiceAccountSecret: "serviceAccountSecret",
} as const;
export type AuthenticationMethodGoogleChronicle = ClosedEnum<
  typeof AuthenticationMethodGoogleChronicle
>;

export type ResponseRetrySettingGoogleChronicle = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsGoogleChronicle = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export const SendEventsAs = {
  Unstructured: "unstructured",
  Udm: "udm",
} as const;
export type SendEventsAs = ClosedEnum<typeof SendEventsAs>;

export type ExtraHttpHeaderGoogleChronicle = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeGoogleChronicle = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeGoogleChronicle = ClosedEnum<
  typeof FailedRequestLoggingModeGoogleChronicle
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorGoogleChronicle = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorGoogleChronicle = ClosedEnum<
  typeof BackpressureBehaviorGoogleChronicle
>;

export type ExtraLogType = {
  logType: string;
  description?: string | undefined;
};

export type CustomLabel = {
  key: string;
  value: string;
};

/**
 * Codec to use to compress the persisted data
 */
export const CompressionGoogleChronicle = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionGoogleChronicle = ClosedEnum<
  typeof CompressionGoogleChronicle
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorGoogleChronicle = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorGoogleChronicle = ClosedEnum<
  typeof QueueFullBehaviorGoogleChronicle
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeGoogleChronicle = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeGoogleChronicle = ClosedEnum<typeof ModeGoogleChronicle>;

export type PqControlsGoogleChronicle = {};

export type OutputGoogleChronicle = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeGoogleChronicle;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  apiVersion?: CreateOutputAPIVersion | undefined;
  authenticationMethod?: AuthenticationMethodGoogleChronicle | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<ResponseRetrySettingGoogleChronicle>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsGoogleChronicle | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  logFormatType?: SendEventsAs | undefined;
  /**
   * Regional endpoint to send events to
   */
  region?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderGoogleChronicle> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?:
    | FailedRequestLoggingModeGoogleChronicle
    | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorGoogleChronicle | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * Custom log types. If the value "Custom" is selected in the setting "Default log type" above, the first custom log type in this table will be automatically selected as default log type.
   */
  extraLogTypes?: Array<ExtraLogType> | undefined;
  /**
   * Default log type value to send to SecOps. Can be overwritten by event field __logType.
   */
  logType?: string | undefined;
  /**
   * Name of the event field that contains the log text to send. If not specified, Stream sends a JSON representation of the whole event.
   */
  logTextField?: string | undefined;
  /**
   * Unique identifier (UUID) corresponding to a particular SecOps instance. Provided by your SecOps representative.
   */
  customerId?: string | undefined;
  /**
   * User-configured environment namespace to identify the data domain the logs originated from. Use namespace as a tag to identify the appropriate data domain for indexing and enrichment functionality. Can be overwritten by event field __namespace.
   */
  namespace?: string | undefined;
  /**
   * Custom labels to be added to every batch
   */
  customLabels?: Array<CustomLabel> | undefined;
  /**
   * Organization's API key in Google SecOps
   */
  apiKey?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  apiKeySecret?: string | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  serviceAccountCredentialsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionGoogleChronicle | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorGoogleChronicle | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeGoogleChronicle | undefined;
  pqControls?: PqControlsGoogleChronicle | undefined;
};

export const TypeAzureEventhub = {
  AzureEventhub: "azure_eventhub",
} as const;
export type TypeAzureEventhub = ClosedEnum<typeof TypeAzureEventhub>;

/**
 * Control the number of required acknowledgments
 */
export const AcknowledgmentsAzureEventhub = {
  One: 1,
  Zero: 0,
  Minus1: -1,
} as const;
/**
 * Control the number of required acknowledgments
 */
export type AcknowledgmentsAzureEventhub = ClosedEnum<
  typeof AcknowledgmentsAzureEventhub
>;

/**
 * Format to use to serialize events before writing to the Event Hubs Kafka brokers
 */
export const RecordDataFormatAzureEventhub = {
  Json: "json",
  Raw: "raw",
} as const;
/**
 * Format to use to serialize events before writing to the Event Hubs Kafka brokers
 */
export type RecordDataFormatAzureEventhub = ClosedEnum<
  typeof RecordDataFormatAzureEventhub
>;

export const SASLMechanismAzureEventhub = {
  Plain: "plain",
  Oauthbearer: "oauthbearer",
} as const;
export type SASLMechanismAzureEventhub = ClosedEnum<
  typeof SASLMechanismAzureEventhub
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type AuthenticationAzureEventhub = {
  disabled?: boolean | undefined;
  mechanism?: SASLMechanismAzureEventhub | undefined;
};

export type TLSSettingsClientSideAzureEventhub = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's)
   */
  rejectUnauthorized?: boolean | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorAzureEventhub = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorAzureEventhub = ClosedEnum<
  typeof BackpressureBehaviorAzureEventhub
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionAzureEventhub = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionAzureEventhub = ClosedEnum<
  typeof CompressionAzureEventhub
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorAzureEventhub = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorAzureEventhub = ClosedEnum<
  typeof QueueFullBehaviorAzureEventhub
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeAzureEventhub = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeAzureEventhub = ClosedEnum<typeof ModeAzureEventhub>;

export type PqControlsAzureEventhub = {};

export type OutputAzureEventhub = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeAzureEventhub | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka Topic) to publish events. Can be overwritten using field __topicOut.
   */
  topic: string;
  /**
   * Control the number of required acknowledgments
   */
  ack?: AcknowledgmentsAzureEventhub | undefined;
  /**
   * Format to use to serialize events before writing to the Event Hubs Kafka brokers
   */
  format?: RecordDataFormatAzureEventhub | undefined;
  /**
   * Maximum size of each record batch before compression. Setting should be < message.max.bytes settings in Event Hubs brokers.
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum number of events in a batch before forcing a flush
   */
  flushEventCount?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: AuthenticationAzureEventhub | undefined;
  tls?: TLSSettingsClientSideAzureEventhub | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorAzureEventhub | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionAzureEventhub | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorAzureEventhub | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeAzureEventhub | undefined;
  pqControls?: PqControlsAzureEventhub | undefined;
};

export const TypeHoneycomb = {
  Honeycomb: "honeycomb",
} as const;
export type TypeHoneycomb = ClosedEnum<typeof TypeHoneycomb>;

export type ExtraHttpHeaderHoneycomb = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeHoneycomb = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeHoneycomb = ClosedEnum<
  typeof FailedRequestLoggingModeHoneycomb
>;

export type ResponseRetrySettingHoneycomb = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsHoneycomb = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorHoneycomb = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorHoneycomb = ClosedEnum<
  typeof BackpressureBehaviorHoneycomb
>;

/**
 * Enter API key directly, or select a stored secret
 */
export const AuthenticationMethodHoneycomb = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter API key directly, or select a stored secret
 */
export type AuthenticationMethodHoneycomb = ClosedEnum<
  typeof AuthenticationMethodHoneycomb
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionHoneycomb = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionHoneycomb = ClosedEnum<typeof CompressionHoneycomb>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorHoneycomb = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorHoneycomb = ClosedEnum<
  typeof QueueFullBehaviorHoneycomb
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeHoneycomb = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeHoneycomb = ClosedEnum<typeof ModeHoneycomb>;

export type PqControlsHoneycomb = {};

export type OutputHoneycomb = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeHoneycomb;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the dataset to send events to – e.g., observability
   */
  dataset: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderHoneycomb> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeHoneycomb | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingHoneycomb> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsHoneycomb | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorHoneycomb | undefined;
  /**
   * Enter API key directly, or select a stored secret
   */
  authType?: AuthenticationMethodHoneycomb | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionHoneycomb | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorHoneycomb | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeHoneycomb | undefined;
  pqControls?: PqControlsHoneycomb | undefined;
  /**
   * Team API key where the dataset belongs
   */
  team?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const CreateOutputTypeKinesis = {
  Kinesis: "kinesis",
} as const;
export type CreateOutputTypeKinesis = ClosedEnum<
  typeof CreateOutputTypeKinesis
>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateOutputAuthenticationMethodKinesis = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateOutputAuthenticationMethodKinesis = ClosedEnum<
  typeof CreateOutputAuthenticationMethodKinesis
>;

/**
 * Signature version to use for signing Kinesis stream requests
 */
export const CreateOutputSignatureVersionKinesis = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Kinesis stream requests
 */
export type CreateOutputSignatureVersionKinesis = ClosedEnum<
  typeof CreateOutputSignatureVersionKinesis
>;

/**
 * Compression type to use for records
 */
export const CreateOutputCompressionKinesis = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Compression type to use for records
 */
export type CreateOutputCompressionKinesis = ClosedEnum<
  typeof CreateOutputCompressionKinesis
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorKinesis = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorKinesis = ClosedEnum<
  typeof BackpressureBehaviorKinesis
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionKinesis = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionKinesis = ClosedEnum<
  typeof PqCompressCompressionKinesis
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorKinesis = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorKinesis = ClosedEnum<
  typeof QueueFullBehaviorKinesis
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeKinesis = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeKinesis = ClosedEnum<
  typeof CreateOutputModeKinesis
>;

export type PqControlsKinesis = {};

export type OutputKinesis = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeKinesis | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Kinesis stream name to send events to.
   */
  streamName: string;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateOutputAuthenticationMethodKinesis | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: CreateOutputSignatureVersionKinesis | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Maximum number of ongoing put requests before blocking.
   */
  concurrency?: number | undefined;
  /**
   * Maximum size (KB) of each individual record before compression. For uncompressed or non-compressible data 1MB is the max recommended size
   */
  maxRecordSizeKB?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Compression type to use for records
   */
  compression?: CreateOutputCompressionKinesis | undefined;
  /**
   * Provides higher stream rate limits, improving delivery speed and reliability by minimizing throttling. See the [ListShards API](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_ListShards.html) documentation for details.
   */
  useListShards?: boolean | undefined;
  /**
   * Batch events into a single record as NDJSON
   */
  asNdjson?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorKinesis | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionKinesis | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorKinesis | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeKinesis | undefined;
  pqControls?: PqControlsKinesis | undefined;
};

export const TypeAzureLogs = {
  AzureLogs: "azure_logs",
} as const;
export type TypeAzureLogs = ClosedEnum<typeof TypeAzureLogs>;

export type ExtraHttpHeaderAzureLogs = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeAzureLogs = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeAzureLogs = ClosedEnum<
  typeof FailedRequestLoggingModeAzureLogs
>;

export type ResponseRetrySettingAzureLogs = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsAzureLogs = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorAzureLogs = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorAzureLogs = ClosedEnum<
  typeof BackpressureBehaviorAzureLogs
>;

/**
 * Enter workspace ID and workspace key directly, or select a stored secret
 */
export const AuthenticationMethodAzureLogs = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter workspace ID and workspace key directly, or select a stored secret
 */
export type AuthenticationMethodAzureLogs = ClosedEnum<
  typeof AuthenticationMethodAzureLogs
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionAzureLogs = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionAzureLogs = ClosedEnum<typeof CompressionAzureLogs>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorAzureLogs = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorAzureLogs = ClosedEnum<
  typeof QueueFullBehaviorAzureLogs
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeAzureLogs = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeAzureLogs = ClosedEnum<typeof ModeAzureLogs>;

export type PqControlsAzureLogs = {};

export type OutputAzureLogs = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeAzureLogs;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The Log Type of events sent to this LogAnalytics workspace. Defaults to `Cribl`. Use only letters, numbers, and `_` characters, and can't exceed 100 characters. Can be overwritten by event field __logType.
   */
  logType?: string | undefined;
  /**
   * Optional Resource ID of the Azure resource to associate the data with. Can be overridden by the __resourceId event field. This ID populates the _ResourceId property, allowing the data to be included in resource-centric queries. If the ID is neither specified nor overridden, resource-centric queries will omit the data.
   */
  resourceId?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderAzureLogs> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeAzureLogs | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * The DNS name of the Log API endpoint that sends log data to a Log Analytics workspace in Azure Monitor. Defaults to .ods.opinsights.azure.com. @{product} will add a prefix and suffix to construct a URI in this format: <https://<Workspace_ID><your_DNS_name>/api/logs?api-version=<API version>.
   */
  apiUrl?: string | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingAzureLogs> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsAzureLogs | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorAzureLogs | undefined;
  /**
   * Enter workspace ID and workspace key directly, or select a stored secret
   */
  authType?: AuthenticationMethodAzureLogs | undefined;
  description?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionAzureLogs | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorAzureLogs | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeAzureLogs | undefined;
  pqControls?: PqControlsAzureLogs | undefined;
  /**
   * Azure Log Analytics Workspace ID. See Azure Dashboard Workspace > Advanced settings.
   */
  workspaceId?: string | undefined;
  /**
   * Azure Log Analytics Workspace Primary or Secondary Shared Key. See Azure Dashboard Workspace > Advanced settings.
   */
  workspaceKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  keypairSecret?: string | undefined;
};

export const TypeAzureDataExplorer = {
  AzureDataExplorer: "azure_data_explorer",
} as const;
export type TypeAzureDataExplorer = ClosedEnum<typeof TypeAzureDataExplorer>;

export const IngestionMode = {
  Batching: "batching",
  Streaming: "streaming",
} as const;
export type IngestionMode = ClosedEnum<typeof IngestionMode>;

/**
 * Endpoint used to acquire authentication tokens from Azure
 */
export const MicrosoftEntraIDAuthenticationEndpoint = {
  HttpsLoginMicrosoftonlineCom: "https://login.microsoftonline.com",
  HttpsLoginMicrosoftonlineUs: "https://login.microsoftonline.us",
  HttpsLoginPartnerMicrosoftonlineCn:
    "https://login.partner.microsoftonline.cn",
} as const;
/**
 * Endpoint used to acquire authentication tokens from Azure
 */
export type MicrosoftEntraIDAuthenticationEndpoint = ClosedEnum<
  typeof MicrosoftEntraIDAuthenticationEndpoint
>;

/**
 * The type of OAuth 2.0 client credentials grant flow to use
 */
export const OauthTypeAuthenticationMethod = {
  ClientSecret: "clientSecret",
  ClientTextSecret: "clientTextSecret",
  Certificate: "certificate",
} as const;
/**
 * The type of OAuth 2.0 client credentials grant flow to use
 */
export type OauthTypeAuthenticationMethod = ClosedEnum<
  typeof OauthTypeAuthenticationMethod
>;

export type CertificateAzureDataExplorer = {
  /**
   * The certificate you registered as credentials for your app in the Azure portal
   */
  certificateName?: string | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorAzureDataExplorer = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorAzureDataExplorer = ClosedEnum<
  typeof BackpressureBehaviorAzureDataExplorer
>;

/**
 * Format of the output data
 */
export const DataFormatAzureDataExplorer = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type DataFormatAzureDataExplorer = ClosedEnum<
  typeof DataFormatAzureDataExplorer
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionAzureDataExplorer = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionAzureDataExplorer = ClosedEnum<
  typeof DiskSpaceProtectionAzureDataExplorer
>;

export const PrefixOptional = {
  DropBy: "dropBy",
  IngestBy: "ingestBy",
} as const;
export type PrefixOptional = ClosedEnum<typeof PrefixOptional>;

export type ExtentTag = {
  prefix?: PrefixOptional | undefined;
  value: string;
};

export type IngestIfNotExist = {
  value: string;
};

/**
 * Level of ingestion status reporting. Defaults to FailuresOnly.
 */
export const ReportLevel = {
  FailuresOnly: "failuresOnly",
  DoNotReport: "doNotReport",
  FailuresAndSuccesses: "failuresAndSuccesses",
} as const;
/**
 * Level of ingestion status reporting. Defaults to FailuresOnly.
 */
export type ReportLevel = ClosedEnum<typeof ReportLevel>;

/**
 * Target of the ingestion status reporting. Defaults to Queue.
 */
export const ReportMethod = {
  Queue: "queue",
  Table: "table",
  QueueAndTable: "queueAndTable",
} as const;
/**
 * Target of the ingestion status reporting. Defaults to Queue.
 */
export type ReportMethod = ClosedEnum<typeof ReportMethod>;

export type AdditionalProperty = {
  key: string;
  value: string;
};

export type ResponseRetrySettingAzureDataExplorer = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsAzureDataExplorer = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const CompressCompressionAzureDataExplorer = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type CompressCompressionAzureDataExplorer = ClosedEnum<
  typeof CompressCompressionAzureDataExplorer
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionAzureDataExplorer = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionAzureDataExplorer = ClosedEnum<
  typeof PqCompressCompressionAzureDataExplorer
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorAzureDataExplorer = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorAzureDataExplorer = ClosedEnum<
  typeof QueueFullBehaviorAzureDataExplorer
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeAzureDataExplorer = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeAzureDataExplorer = ClosedEnum<typeof ModeAzureDataExplorer>;

export type PqControlsAzureDataExplorer = {};

export type OutputAzureDataExplorer = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeAzureDataExplorer | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The base URI for your cluster. Typically, `https://<cluster>.<region>.kusto.windows.net`.
   */
  clusterUrl: string;
  /**
   * Name of the database containing the table where data will be ingested
   */
  database: string;
  /**
   * Name of the table to ingest data into
   */
  table: string;
  /**
   * When saving or starting the Destination, validate the database name and credentials; also validate table name, except when creating a new table. Disable if your Azure app does not have both the Database Viewer and the Table Viewer role.
   */
  validateDatabaseSettings?: boolean | undefined;
  ingestMode?: IngestionMode | undefined;
  /**
   * Endpoint used to acquire authentication tokens from Azure
   */
  oauthEndpoint?: MicrosoftEntraIDAuthenticationEndpoint | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory
   */
  tenantId: string;
  /**
   * client_id to pass in the OAuth request parameter
   */
  clientId: string;
  /**
   * Scope to pass in the OAuth request parameter
   */
  scope: string;
  /**
   * The type of OAuth 2.0 client credentials grant flow to use
   */
  oauthType?: OauthTypeAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * The client secret that you generated for your app in the Azure portal
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  certificate?: CertificateAzureDataExplorer | undefined;
  /**
   * The ingestion service URI for your cluster. Typically, `https://ingest-<cluster>.<region>.kusto.windows.net`.
   */
  ingestUrl?: string | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorAzureDataExplorer | undefined;
  /**
   * Send a JSON mapping object instead of specifying an existing named data mapping
   */
  isMappingObj?: boolean | undefined;
  /**
   * Format of the output data
   */
  format?: DataFormatAzureDataExplorer | undefined;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionAzureDataExplorer | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Bypass the data management service's aggregation mechanism
   */
  flushImmediately?: boolean | undefined;
  /**
   * Prevent blob deletion after ingestion is complete
   */
  retainBlobOnSuccess?: boolean | undefined;
  /**
   * Strings or tags associated with the extent (ingested data shard)
   */
  extentTags?: Array<ExtentTag> | undefined;
  /**
   * Prevents duplicate ingestion by verifying whether an extent with the specified ingest-by tag already exists
   */
  ingestIfNotExists?: Array<IngestIfNotExist> | undefined;
  /**
   * Level of ingestion status reporting. Defaults to FailuresOnly.
   */
  reportLevel?: ReportLevel | undefined;
  /**
   * Target of the ingestion status reporting. Defaults to Queue.
   */
  reportMethod?: ReportMethod | undefined;
  /**
   * Optionally, enter additional configuration properties to send to the ingestion service
   */
  additionalProperties?: Array<AdditionalProperty> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<ResponseRetrySettingAzureDataExplorer>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsAzureDataExplorer | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: CompressCompressionAzureDataExplorer | undefined;
  /**
   * Enter the name of a data mapping associated with your target table. Or, if incoming event and target table fields match exactly, you can leave the field empty.
   */
  mappingRef?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionAzureDataExplorer | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorAzureDataExplorer | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeAzureDataExplorer | undefined;
  pqControls?: PqControlsAzureDataExplorer | undefined;
};

export const CreateOutputTypeAzureBlob = {
  AzureBlob: "azure_blob",
} as const;
export type CreateOutputTypeAzureBlob = ClosedEnum<
  typeof CreateOutputTypeAzureBlob
>;

/**
 * Format of the output data
 */
export const DataFormatAzureBlob = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type DataFormatAzureBlob = ClosedEnum<typeof DataFormatAzureBlob>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorAzureBlob = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorAzureBlob = ClosedEnum<
  typeof BackpressureBehaviorAzureBlob
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionAzureBlob = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionAzureBlob = ClosedEnum<
  typeof DiskSpaceProtectionAzureBlob
>;

export const CreateOutputAuthenticationMethodAzureBlob = {
  Manual: "manual",
  Secret: "secret",
  ClientSecret: "clientSecret",
  ClientCert: "clientCert",
} as const;
export type CreateOutputAuthenticationMethodAzureBlob = ClosedEnum<
  typeof CreateOutputAuthenticationMethodAzureBlob
>;

export const BlobAccessTier = {
  Inferred: "Inferred",
  Hot: "Hot",
  Cool: "Cool",
  Cold: "Cold",
  Archive: "Archive",
} as const;
export type BlobAccessTier = ClosedEnum<typeof BlobAccessTier>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const CreateOutputCompressionAzureBlob = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type CreateOutputCompressionAzureBlob = ClosedEnum<
  typeof CreateOutputCompressionAzureBlob
>;

/**
 * Compression level to apply before moving files to final destination
 */
export const CompressionLevelAzureBlob = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type CompressionLevelAzureBlob = ClosedEnum<
  typeof CompressionLevelAzureBlob
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const ParquetVersionAzureBlob = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type ParquetVersionAzureBlob = ClosedEnum<
  typeof ParquetVersionAzureBlob
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const DataPageVersionAzureBlob = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type DataPageVersionAzureBlob = ClosedEnum<
  typeof DataPageVersionAzureBlob
>;

export type KeyValueMetadatumAzureBlob = {
  key?: string | undefined;
  value: string;
};

export type CreateOutputCertificateAzureBlob = {
  /**
   * The certificate you registered as credentials for your app in the Azure portal
   */
  certificateName: string;
};

export type OutputAzureBlob = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeAzureBlob | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env["CRIBL_WORKER_ID"]}`.
   */
  containerName: string;
  /**
   * Create the configured container in Azure Blob Storage if it does not already exist
   */
  createContainer?: boolean | undefined;
  /**
   * Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env["CRIBL_WORKER_ID"]}`.
   */
  destPath?: string | undefined;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Maximum number of parts to upload in parallel per file
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: DataFormatAzureBlob | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorAzureBlob | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionAzureBlob | undefined;
  authType?: CreateOutputAuthenticationMethodAzureBlob | undefined;
  storageClass?: BlobAccessTier | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: CreateOutputCompressionAzureBlob | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: CompressionLevelAzureBlob | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: ParquetVersionAzureBlob | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: DataPageVersionAzureBlob | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<KeyValueMetadatumAzureBlob> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: CreateOutputCertificateAzureBlob | undefined;
};

export const CreateOutputTypeS3 = {
  S3: "s3",
} as const;
export type CreateOutputTypeS3 = ClosedEnum<typeof CreateOutputTypeS3>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateOutputAuthenticationMethodS3 = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateOutputAuthenticationMethodS3 = ClosedEnum<
  typeof CreateOutputAuthenticationMethodS3
>;

/**
 * Signature version to use for signing S3 requests
 */
export const CreateOutputSignatureVersionS3 = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type CreateOutputSignatureVersionS3 = ClosedEnum<
  typeof CreateOutputSignatureVersionS3
>;

/**
 * Object ACL to assign to uploaded objects
 */
export const ObjectAcls3 = {
  Private: "private",
  PublicRead: "public-read",
  PublicReadWrite: "public-read-write",
  AuthenticatedRead: "authenticated-read",
  AwsExecRead: "aws-exec-read",
  BucketOwnerRead: "bucket-owner-read",
  BucketOwnerFullControl: "bucket-owner-full-control",
} as const;
/**
 * Object ACL to assign to uploaded objects
 */
export type ObjectAcls3 = ClosedEnum<typeof ObjectAcls3>;

/**
 * Storage class to select for uploaded objects
 */
export const StorageClassS3 = {
  Standard: "STANDARD",
  ReducedRedundancy: "REDUCED_REDUNDANCY",
  StandardIa: "STANDARD_IA",
  OnezoneIa: "ONEZONE_IA",
  IntelligentTiering: "INTELLIGENT_TIERING",
  Glacier: "GLACIER",
  GlacierIr: "GLACIER_IR",
  DeepArchive: "DEEP_ARCHIVE",
} as const;
/**
 * Storage class to select for uploaded objects
 */
export type StorageClassS3 = ClosedEnum<typeof StorageClassS3>;

export const ServerSideEncryptionForUploadedObjectsS3 = {
  Aes256: "AES256",
  AwsKms: "aws:kms",
} as const;
export type ServerSideEncryptionForUploadedObjectsS3 = ClosedEnum<
  typeof ServerSideEncryptionForUploadedObjectsS3
>;

/**
 * Format of the output data
 */
export const DataFormatS3 = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type DataFormatS3 = ClosedEnum<typeof DataFormatS3>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorS3 = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorS3 = ClosedEnum<typeof BackpressureBehaviorS3>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionS3 = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionS3 = ClosedEnum<typeof DiskSpaceProtectionS3>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const CreateOutputCompressionS3 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type CreateOutputCompressionS3 = ClosedEnum<
  typeof CreateOutputCompressionS3
>;

/**
 * Compression level to apply before moving files to final destination
 */
export const CompressionLevelS3 = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type CompressionLevelS3 = ClosedEnum<typeof CompressionLevelS3>;

/**
 * Determines which data types are supported and how they are represented
 */
export const ParquetVersionS3 = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type ParquetVersionS3 = ClosedEnum<typeof ParquetVersionS3>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const DataPageVersionS3 = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type DataPageVersionS3 = ClosedEnum<typeof DataPageVersionS3>;

export type KeyValueMetadatumS3 = {
  key?: string | undefined;
  value: string;
};

export type OutputS3 = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeS3 | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * Region where the S3 bucket is located
   */
  region?: string | undefined;
  /**
   * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
   */
  awsSecretKey?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateOutputAuthenticationMethodS3 | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: CreateOutputSignatureVersionS3 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`
   */
  destPath?: string | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: ObjectAcls3 | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: StorageClassS3 | undefined;
  serverSideEncryption?: ServerSideEncryptionForUploadedObjectsS3 | undefined;
  /**
   * ID or ARN of the KMS customer-managed key to use for encryption
   */
  kmsKeyId?: string | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: DataFormatS3 | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorS3 | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionS3 | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Maximum number of files that can be waiting for upload before backpressure is applied
   */
  maxClosingFilesToBackpressure?: number | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: CreateOutputCompressionS3 | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: CompressionLevelS3 | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: ParquetVersionS3 | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: DataPageVersionS3 | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<KeyValueMetadatumS3> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const TypeFilesystem = {
  Filesystem: "filesystem",
} as const;
export type TypeFilesystem = ClosedEnum<typeof TypeFilesystem>;

/**
 * Format of the output data
 */
export const DataFormatFilesystem = {
  Json: "json",
  Raw: "raw",
  Parquet: "parquet",
} as const;
/**
 * Format of the output data
 */
export type DataFormatFilesystem = ClosedEnum<typeof DataFormatFilesystem>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorFilesystem = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorFilesystem = ClosedEnum<
  typeof BackpressureBehaviorFilesystem
>;

/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export const DiskSpaceProtectionFilesystem = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when disk space is below the global 'Min free disk space' limit
 */
export type DiskSpaceProtectionFilesystem = ClosedEnum<
  typeof DiskSpaceProtectionFilesystem
>;

/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export const CompressionFilesystem = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format to apply to HTTP content before it is delivered
 */
export type CompressionFilesystem = ClosedEnum<typeof CompressionFilesystem>;

/**
 * Compression level to apply before moving files to final destination
 */
export const CompressionLevelFilesystem = {
  BestSpeed: "best_speed",
  Normal: "normal",
  BestCompression: "best_compression",
} as const;
/**
 * Compression level to apply before moving files to final destination
 */
export type CompressionLevelFilesystem = ClosedEnum<
  typeof CompressionLevelFilesystem
>;

/**
 * Determines which data types are supported and how they are represented
 */
export const ParquetVersionFilesystem = {
  Parquet10: "PARQUET_1_0",
  Parquet24: "PARQUET_2_4",
  Parquet26: "PARQUET_2_6",
} as const;
/**
 * Determines which data types are supported and how they are represented
 */
export type ParquetVersionFilesystem = ClosedEnum<
  typeof ParquetVersionFilesystem
>;

/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export const DataPageVersionFilesystem = {
  DataPageV1: "DATA_PAGE_V1",
  DataPageV2: "DATA_PAGE_V2",
} as const;
/**
 * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
 */
export type DataPageVersionFilesystem = ClosedEnum<
  typeof DataPageVersionFilesystem
>;

export type KeyValueMetadatumFilesystem = {
  key?: string | undefined;
  value: string;
};

export type OutputFilesystem = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeFilesystem;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Final destination for the output files
   */
  destPath: string;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: DataFormatFilesystem | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorFilesystem | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: DiskSpaceProtectionFilesystem | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: CompressionFilesystem | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: CompressionLevelFilesystem | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: ParquetVersionFilesystem | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: DataPageVersionFilesystem | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<KeyValueMetadatumFilesystem> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export const TypeSignalfx = {
  Signalfx: "signalfx",
} as const;
export type TypeSignalfx = ClosedEnum<typeof TypeSignalfx>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodSignalfx = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodSignalfx = ClosedEnum<
  typeof AuthenticationMethodSignalfx
>;

export type ExtraHttpHeaderSignalfx = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeSignalfx = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeSignalfx = ClosedEnum<
  typeof FailedRequestLoggingModeSignalfx
>;

export type ResponseRetrySettingSignalfx = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsSignalfx = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSignalfx = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSignalfx = ClosedEnum<
  typeof BackpressureBehaviorSignalfx
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSignalfx = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSignalfx = ClosedEnum<typeof CompressionSignalfx>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSignalfx = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSignalfx = ClosedEnum<
  typeof QueueFullBehaviorSignalfx
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeSignalfx = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeSignalfx = ClosedEnum<typeof ModeSignalfx>;

export type PqControlsSignalfx = {};

export type OutputSignalfx = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeSignalfx;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodSignalfx | undefined;
  /**
   * SignalFx realm name, e.g. "us0". For a complete list of available SignalFx realm names, please check [here](https://docs.splunk.com/observability/en/get-started/service-description.html#sd-regions).
   */
  realm?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderSignalfx> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeSignalfx | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingSignalfx> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsSignalfx | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSignalfx | undefined;
  description?: string | undefined;
  /**
   * SignalFx API access token (see [here](https://docs.signalfx.com/en/latest/admin-guide/tokens.html#working-with-access-tokens))
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionSignalfx | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSignalfx | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeSignalfx | undefined;
  pqControls?: PqControlsSignalfx | undefined;
};

export const TypeWavefront = {
  Wavefront: "wavefront",
} as const;
export type TypeWavefront = ClosedEnum<typeof TypeWavefront>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodWavefront = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodWavefront = ClosedEnum<
  typeof AuthenticationMethodWavefront
>;

export type ExtraHttpHeaderWavefront = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeWavefront = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeWavefront = ClosedEnum<
  typeof FailedRequestLoggingModeWavefront
>;

export type ResponseRetrySettingWavefront = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsWavefront = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorWavefront = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorWavefront = ClosedEnum<
  typeof BackpressureBehaviorWavefront
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionWavefront = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionWavefront = ClosedEnum<typeof CompressionWavefront>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorWavefront = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorWavefront = ClosedEnum<
  typeof QueueFullBehaviorWavefront
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeWavefront = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeWavefront = ClosedEnum<typeof ModeWavefront>;

export type PqControlsWavefront = {};

export type OutputWavefront = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeWavefront;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodWavefront | undefined;
  /**
   * WaveFront domain name, e.g. "longboard"
   */
  domain?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderWavefront> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeWavefront | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingWavefront> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsWavefront | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorWavefront | undefined;
  description?: string | undefined;
  /**
   * WaveFront API authentication token (see [here](https://docs.wavefront.com/wavefront_api.html#generating-an-api-token))
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionWavefront | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorWavefront | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeWavefront | undefined;
  pqControls?: PqControlsWavefront | undefined;
};

export const TypeSplunkLb = {
  SplunkLb: "splunk_lb",
} as const;
export type TypeSplunkLb = ClosedEnum<typeof TypeSplunkLb>;

/**
 * How to serialize nested fields into index-time fields
 */
export const NestedFieldSerializationSplunkLb = {
  Json: "json",
  None: "none",
} as const;
/**
 * How to serialize nested fields into index-time fields
 */
export type NestedFieldSerializationSplunkLb = ClosedEnum<
  typeof NestedFieldSerializationSplunkLb
>;

export const MinimumTLSVersionSplunkLb = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionSplunkLb = ClosedEnum<
  typeof MinimumTLSVersionSplunkLb
>;

export const MaximumTLSVersionSplunkLb = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionSplunkLb = ClosedEnum<
  typeof MaximumTLSVersionSplunkLb
>;

export type TLSSettingsClientSideSplunkLb = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: MinimumTLSVersionSplunkLb | undefined;
  maxVersion?: MaximumTLSVersionSplunkLb | undefined;
};

/**
 * The highest S2S protocol version to advertise during handshake
 */
export const MaxS2SVersionSplunkLb = {
  V3: "v3",
  V4: "v4",
} as const;
/**
 * The highest S2S protocol version to advertise during handshake
 */
export type MaxS2SVersionSplunkLb = ClosedEnum<typeof MaxS2SVersionSplunkLb>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSplunkLb = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSplunkLb = ClosedEnum<
  typeof BackpressureBehaviorSplunkLb
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodSplunkLb = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodSplunkLb = ClosedEnum<
  typeof AuthenticationMethodSplunkLb
>;

/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export const CompressCompressionSplunkLb = {
  Disabled: "disabled",
  Auto: "auto",
  Always: "always",
} as const;
/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export type CompressCompressionSplunkLb = ClosedEnum<
  typeof CompressCompressionSplunkLb
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const IndexerDiscoveryConfigsAuthTokenAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type IndexerDiscoveryConfigsAuthTokenAuthenticationMethod = ClosedEnum<
  typeof IndexerDiscoveryConfigsAuthTokenAuthenticationMethod
>;

export type CreateOutputAuthToken = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: IndexerDiscoveryConfigsAuthTokenAuthenticationMethod | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const IndexerDiscoveryConfigsAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type IndexerDiscoveryConfigsAuthenticationMethod = ClosedEnum<
  typeof IndexerDiscoveryConfigsAuthenticationMethod
>;

/**
 * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
 */
export type IndexerDiscoveryConfigs = {
  /**
   * Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site.
   */
  site?: string | undefined;
  /**
   * Full URI of Splunk cluster manager (scheme://host:port). Example: https://managerAddress:8089
   */
  masterUri: string;
  /**
   * Time interval, in seconds, between two consecutive indexer list fetches from cluster manager
   */
  refreshIntervalSec?: number | undefined;
  /**
   * During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Tokens required to authenticate to cluster manager for indexer discovery
   */
  authTokens?: Array<CreateOutputAuthToken> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: IndexerDiscoveryConfigsAuthenticationMethod | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/**
 * Whether to inherit TLS configs from group setting or disable TLS
 */
export const Tls = {
  Inherit: "inherit",
  Off: "off",
} as const;
/**
 * Whether to inherit TLS configs from group setting or disable TLS
 */
export type Tls = ClosedEnum<typeof Tls>;

export type HostSplunkLb = {
  /**
   * The hostname of the receiver
   */
  host: string;
  /**
   * The port to connect to on the provided host
   */
  port?: number | undefined;
  /**
   * Whether to inherit TLS configs from group setting or disable TLS
   */
  tls?: Tls | undefined;
  /**
   * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
   */
  servername?: string | undefined;
  /**
   * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
   */
  weight?: number | undefined;
};

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionSplunkLb = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionSplunkLb = ClosedEnum<
  typeof PqCompressCompressionSplunkLb
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSplunkLb = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSplunkLb = ClosedEnum<
  typeof QueueFullBehaviorSplunkLb
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeSplunkLb = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeSplunkLb = ClosedEnum<typeof ModeSplunkLb>;

export type PqControlsSplunkLb = {};

export type OutputSplunkLb = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeSplunkLb;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
   */
  maxConcurrentSenders?: number | undefined;
  /**
   * How to serialize nested fields into index-time fields
   */
  nestedFields?: NestedFieldSerializationSplunkLb | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  tls?: TLSSettingsClientSideSplunkLb | undefined;
  /**
   * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
   */
  enableACK?: boolean | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: MaxS2SVersionSplunkLb | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSplunkLb | undefined;
  /**
   * Automatically discover indexers in indexer clustering environment.
   */
  indexerDiscovery?: boolean | undefined;
  /**
   * How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute.
   */
  senderUnhealthyTimeAllowance?: number | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodSplunkLb | undefined;
  description?: string | undefined;
  /**
   * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
   */
  maxFailedHealthChecks?: number | undefined;
  /**
   * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
   */
  compress?: CompressCompressionSplunkLb | undefined;
  /**
   * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
   */
  indexerDiscoveryConfigs?: IndexerDiscoveryConfigs | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  /**
   * Set of Splunk indexers to load-balance data to.
   */
  hosts: Array<HostSplunkLb>;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionSplunkLb | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSplunkLb | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeSplunkLb | undefined;
  pqControls?: PqControlsSplunkLb | undefined;
  /**
   * Shared secret token to use when establishing a connection to a Splunk indexer.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const CreateOutputTypeSplunk = {
  Splunk: "splunk",
} as const;
export type CreateOutputTypeSplunk = ClosedEnum<typeof CreateOutputTypeSplunk>;

/**
 * How to serialize nested fields into index-time fields
 */
export const NestedFieldSerializationSplunk = {
  Json: "json",
  None: "none",
} as const;
/**
 * How to serialize nested fields into index-time fields
 */
export type NestedFieldSerializationSplunk = ClosedEnum<
  typeof NestedFieldSerializationSplunk
>;

export const CreateOutputMinimumTLSVersionSplunk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMinimumTLSVersionSplunk = ClosedEnum<
  typeof CreateOutputMinimumTLSVersionSplunk
>;

export const CreateOutputMaximumTLSVersionSplunk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateOutputMaximumTLSVersionSplunk = ClosedEnum<
  typeof CreateOutputMaximumTLSVersionSplunk
>;

export type TLSSettingsClientSideSplunk = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateOutputMinimumTLSVersionSplunk | undefined;
  maxVersion?: CreateOutputMaximumTLSVersionSplunk | undefined;
};

/**
 * The highest S2S protocol version to advertise during handshake
 */
export const CreateOutputMaxS2SVersionSplunk = {
  V3: "v3",
  V4: "v4",
} as const;
/**
 * The highest S2S protocol version to advertise during handshake
 */
export type CreateOutputMaxS2SVersionSplunk = ClosedEnum<
  typeof CreateOutputMaxS2SVersionSplunk
>;

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSplunk = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSplunk = ClosedEnum<
  typeof BackpressureBehaviorSplunk
>;

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodSplunk = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodSplunk = ClosedEnum<
  typeof AuthenticationMethodSplunk
>;

/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export const CreateOutputCompressCompressionSplunk = {
  Disabled: "disabled",
  Auto: "auto",
  Always: "always",
} as const;
/**
 * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
 */
export type CreateOutputCompressCompressionSplunk = ClosedEnum<
  typeof CreateOutputCompressCompressionSplunk
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressCompressionSplunk = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressCompressionSplunk = ClosedEnum<
  typeof PqCompressCompressionSplunk
>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSplunk = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSplunk = ClosedEnum<
  typeof QueueFullBehaviorSplunk
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const CreateOutputModeSplunk = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type CreateOutputModeSplunk = ClosedEnum<typeof CreateOutputModeSplunk>;

export type PqControlsSplunk = {};

export type OutputSplunk = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: CreateOutputTypeSplunk | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The hostname of the receiver
   */
  host: string;
  /**
   * The port to connect to on the provided host
   */
  port?: number | undefined;
  /**
   * How to serialize nested fields into index-time fields
   */
  nestedFields?: NestedFieldSerializationSplunk | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  tls?: TLSSettingsClientSideSplunk | undefined;
  /**
   * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
   */
  enableACK?: boolean | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: CreateOutputMaxS2SVersionSplunk | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSplunk | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodSplunk | undefined;
  description?: string | undefined;
  /**
   * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
   */
  maxFailedHealthChecks?: number | undefined;
  /**
   * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
   */
  compress?: CreateOutputCompressCompressionSplunk | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressCompressionSplunk | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSplunk | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: CreateOutputModeSplunk | undefined;
  pqControls?: PqControlsSplunk | undefined;
  /**
   * Shared secret token to use when establishing a connection to a Splunk indexer.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const TypeSentinel = {
  Sentinel: "sentinel",
} as const;
export type TypeSentinel = ClosedEnum<typeof TypeSentinel>;

export type ExtraHttpHeaderSentinel = {
  name?: string | undefined;
  value: string;
};

/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export const FailedRequestLoggingModeSentinel = {
  Payload: "payload",
  PayloadAndHeaders: "payloadAndHeaders",
  None: "none",
} as const;
/**
 * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
 */
export type FailedRequestLoggingModeSentinel = ClosedEnum<
  typeof FailedRequestLoggingModeSentinel
>;

export type ResponseRetrySettingSentinel = {
  /**
   * The HTTP response status code that will trigger retries
   */
  httpStatus: number;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

export type TimeoutRetrySettingsSentinel = {
  timeoutRetry?: boolean | undefined;
  /**
   * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
   */
  backoffRate?: number | undefined;
  /**
   * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackoff?: number | undefined;
};

/**
 * How to handle events when all receivers are exerting backpressure
 */
export const BackpressureBehaviorSentinel = {
  Block: "block",
  Drop: "drop",
  Queue: "queue",
} as const;
/**
 * How to handle events when all receivers are exerting backpressure
 */
export type BackpressureBehaviorSentinel = ClosedEnum<
  typeof BackpressureBehaviorSentinel
>;

export const AuthType = {
  Oauth: "oauth",
} as const;
export type AuthType = ClosedEnum<typeof AuthType>;

/**
 * Enter the data collection endpoint URL or the individual ID
 */
export const EndpointConfiguration = {
  Url: "url",
  Id: "ID",
} as const;
/**
 * Enter the data collection endpoint URL or the individual ID
 */
export type EndpointConfiguration = ClosedEnum<typeof EndpointConfiguration>;

export const FormatSentinel = {
  Ndjson: "ndjson",
  JsonArray: "json_array",
  Custom: "custom",
  Advanced: "advanced",
} as const;
export type FormatSentinel = ClosedEnum<typeof FormatSentinel>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSentinel = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSentinel = ClosedEnum<typeof CompressionSentinel>;

/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export const QueueFullBehaviorSentinel = {
  Block: "block",
  Drop: "drop",
} as const;
/**
 * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
 */
export type QueueFullBehaviorSentinel = ClosedEnum<
  typeof QueueFullBehaviorSentinel
>;

/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export const ModeSentinel = {
  Error: "error",
  Backpressure: "backpressure",
  Always: "always",
} as const;
/**
 * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
 */
export type ModeSentinel = ClosedEnum<typeof ModeSentinel>;

export type PqControlsSentinel = {};

export type OutputSentinel = {
  /**
   * Unique ID for this output
   */
  id: string;
  type?: TypeSentinel | undefined;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size (KB) of the request body (defaults to the API's maximum limit of 1000 KB)
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeaderSentinel> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeSentinel | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingSentinel> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsSentinel | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorSentinel | undefined;
  authType?: AuthType | undefined;
  /**
   * URL for OAuth
   */
  loginUrl: string;
  /**
   * Secret parameter value to pass in request body
   */
  secret: string;
  /**
   * JavaScript expression to compute the Client ID for the Azure application. Can be a constant.
   */
  clientId: string;
  /**
   * Scope to pass in the OAuth request
   */
  scope?: string | undefined;
  /**
   * Enter the data collection endpoint URL or the individual ID
   */
  endpointURLConfiguration?: EndpointConfiguration | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  format?: FormatSentinel | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: CompressionSentinel | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: QueueFullBehaviorSentinel | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: ModeSentinel | undefined;
  pqControls?: PqControlsSentinel | undefined;
  /**
   * URL to send events to. Can be overwritten by an event's __url field.
   */
  url?: string | undefined;
  /**
   * Immutable ID for the Data Collection Rule (DCR)
   */
  dcrID?: string | undefined;
  /**
   * Data collection endpoint (DCE) URL. In the format: `https://<Endpoint-Name>-<Identifier>.<Region>.ingest.monitor.azure.com`
   */
  dceEndpoint?: string | undefined;
  /**
   * The name of the stream (Sentinel table) in which to store the events
   */
  streamName?: string | undefined;
};

export const TypeDefault = {
  Default: "default",
} as const;
export type TypeDefault = ClosedEnum<typeof TypeDefault>;

export type OutputDefault = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: TypeDefault;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.
   */
  defaultId: string;
};

/**
 * New Destination object
 */
export type CreateOutputRequest =
  | OutputAzureDataExplorer
  | OutputSecurityLake
  | OutputSentinel
  | OutputGoogleCloudLogging
  | OutputExabeam
  | OutputMsk
  | OutputCloudwatch
  | OutputClickHouse
  | OutputDefault
  | OutputSplunkLb
  | OutputFilesystem
  | OutputKinesis
  | OutputHoneycomb
  | OutputAzureEventhub
  | OutputGoogleCloudStorage
  | OutputGooglePubsub
  | OutputKafka
  | OutputConfluentCloud
  | OutputElastic
  | OutputElasticCloud
  | OutputNewrelicEvents
  | OutputInfluxdb
  | OutputMinio
  | OutputRouter
  | OutputSns
  | OutputSnmp
  | OutputSumoLogic
  | OutputLoki
  | OutputPrometheus
  | OutputOpenTelemetry
  | OutputNetflow
  | models.OutputWebhook
  | models.OutputDevnull
  | models.OutputSyslog
  | OutputSplunk
  | models.OutputSplunkHec
  | models.OutputTcpjson
  | OutputWavefront
  | OutputSignalfx
  | OutputS3
  | OutputAzureBlob
  | OutputAzureLogs
  | OutputGoogleChronicle
  | models.OutputNewrelic
  | OutputStatsd
  | OutputStatsdExt
  | OutputGraphite
  | OutputSqs
  | models.OutputDatadog
  | models.OutputRing
  | OutputServiceNow
  | models.OutputDataset
  | models.OutputCriblTcp
  | models.OutputCriblHttp
  | OutputCrowdstrikeNextGenSiem
  | OutputDlS3
  | models.OutputCriblLake
  | models.OutputDiskSpool
  | models.OutputXsiam
  | OutputDynatraceOtlp
  | OutputHumioHec
  | OutputDynatraceHttp
  | OutputSentinelOneAiSiem
  | models.OutputGrafanaCloud;

/**
 * a list of Destination objects
 */
export type CreateOutputResponse = {
  /**
   * number of items present in the items array
   */
  count?: number | undefined;
  items?: Array<models.Output> | undefined;
};

/** @internal */
export const TypeSentinelOneAiSiem$inboundSchema: z.ZodNativeEnum<
  typeof TypeSentinelOneAiSiem
> = z.nativeEnum(TypeSentinelOneAiSiem);

/** @internal */
export const TypeSentinelOneAiSiem$outboundSchema: z.ZodNativeEnum<
  typeof TypeSentinelOneAiSiem
> = TypeSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSentinelOneAiSiem$ {
  /** @deprecated use `TypeSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = TypeSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `TypeSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = TypeSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const RegionSentinelOneAiSiem$inboundSchema: z.ZodNativeEnum<
  typeof RegionSentinelOneAiSiem
> = z.nativeEnum(RegionSentinelOneAiSiem);

/** @internal */
export const RegionSentinelOneAiSiem$outboundSchema: z.ZodNativeEnum<
  typeof RegionSentinelOneAiSiem
> = RegionSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RegionSentinelOneAiSiem$ {
  /** @deprecated use `RegionSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = RegionSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `RegionSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = RegionSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const AISIEMEndpointPath$inboundSchema: z.ZodNativeEnum<
  typeof AISIEMEndpointPath
> = z.nativeEnum(AISIEMEndpointPath);

/** @internal */
export const AISIEMEndpointPath$outboundSchema: z.ZodNativeEnum<
  typeof AISIEMEndpointPath
> = AISIEMEndpointPath$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AISIEMEndpointPath$ {
  /** @deprecated use `AISIEMEndpointPath$inboundSchema` instead. */
  export const inboundSchema = AISIEMEndpointPath$inboundSchema;
  /** @deprecated use `AISIEMEndpointPath$outboundSchema` instead. */
  export const outboundSchema = AISIEMEndpointPath$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderSentinelOneAiSiem$inboundSchema: z.ZodType<
  ExtraHttpHeaderSentinelOneAiSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderSentinelOneAiSiem$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderSentinelOneAiSiem$outboundSchema: z.ZodType<
  ExtraHttpHeaderSentinelOneAiSiem$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderSentinelOneAiSiem
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderSentinelOneAiSiem$ {
  /** @deprecated use `ExtraHttpHeaderSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderSentinelOneAiSiem$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderSentinelOneAiSiem$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderSentinelOneAiSiem$Outbound;
}

export function extraHttpHeaderSentinelOneAiSiemToJSON(
  extraHttpHeaderSentinelOneAiSiem: ExtraHttpHeaderSentinelOneAiSiem,
): string {
  return JSON.stringify(
    ExtraHttpHeaderSentinelOneAiSiem$outboundSchema.parse(
      extraHttpHeaderSentinelOneAiSiem,
    ),
  );
}

export function extraHttpHeaderSentinelOneAiSiemFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderSentinelOneAiSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderSentinelOneAiSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderSentinelOneAiSiem' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeSentinelOneAiSiem$inboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeSentinelOneAiSiem> = z
    .nativeEnum(FailedRequestLoggingModeSentinelOneAiSiem);

/** @internal */
export const FailedRequestLoggingModeSentinelOneAiSiem$outboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeSentinelOneAiSiem> =
    FailedRequestLoggingModeSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeSentinelOneAiSiem$ {
  /** @deprecated use `FailedRequestLoggingModeSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema =
    FailedRequestLoggingModeSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const AuthenticationMethodSentinelOneAiSiem$inboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodSentinelOneAiSiem> = z.nativeEnum(
    AuthenticationMethodSentinelOneAiSiem,
  );

/** @internal */
export const AuthenticationMethodSentinelOneAiSiem$outboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodSentinelOneAiSiem> =
    AuthenticationMethodSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodSentinelOneAiSiem$ {
  /** @deprecated use `AuthenticationMethodSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema =
    AuthenticationMethodSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `AuthenticationMethodSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingSentinelOneAiSiem$inboundSchema: z.ZodType<
  ResponseRetrySettingSentinelOneAiSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingSentinelOneAiSiem$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingSentinelOneAiSiem$outboundSchema: z.ZodType<
  ResponseRetrySettingSentinelOneAiSiem$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingSentinelOneAiSiem
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingSentinelOneAiSiem$ {
  /** @deprecated use `ResponseRetrySettingSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema =
    ResponseRetrySettingSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `ResponseRetrySettingSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema =
    ResponseRetrySettingSentinelOneAiSiem$outboundSchema;
  /** @deprecated use `ResponseRetrySettingSentinelOneAiSiem$Outbound` instead. */
  export type Outbound = ResponseRetrySettingSentinelOneAiSiem$Outbound;
}

export function responseRetrySettingSentinelOneAiSiemToJSON(
  responseRetrySettingSentinelOneAiSiem: ResponseRetrySettingSentinelOneAiSiem,
): string {
  return JSON.stringify(
    ResponseRetrySettingSentinelOneAiSiem$outboundSchema.parse(
      responseRetrySettingSentinelOneAiSiem,
    ),
  );
}

export function responseRetrySettingSentinelOneAiSiemFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingSentinelOneAiSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ResponseRetrySettingSentinelOneAiSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingSentinelOneAiSiem' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsSentinelOneAiSiem$inboundSchema: z.ZodType<
  TimeoutRetrySettingsSentinelOneAiSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsSentinelOneAiSiem$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsSentinelOneAiSiem$outboundSchema: z.ZodType<
  TimeoutRetrySettingsSentinelOneAiSiem$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsSentinelOneAiSiem
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsSentinelOneAiSiem$ {
  /** @deprecated use `TimeoutRetrySettingsSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema =
    TimeoutRetrySettingsSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema =
    TimeoutRetrySettingsSentinelOneAiSiem$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSentinelOneAiSiem$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsSentinelOneAiSiem$Outbound;
}

export function timeoutRetrySettingsSentinelOneAiSiemToJSON(
  timeoutRetrySettingsSentinelOneAiSiem: TimeoutRetrySettingsSentinelOneAiSiem,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsSentinelOneAiSiem$outboundSchema.parse(
      timeoutRetrySettingsSentinelOneAiSiem,
    ),
  );
}

export function timeoutRetrySettingsSentinelOneAiSiemFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsSentinelOneAiSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TimeoutRetrySettingsSentinelOneAiSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsSentinelOneAiSiem' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorSentinelOneAiSiem$inboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorSentinelOneAiSiem> = z.nativeEnum(
    BackpressureBehaviorSentinelOneAiSiem,
  );

/** @internal */
export const BackpressureBehaviorSentinelOneAiSiem$outboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorSentinelOneAiSiem> =
    BackpressureBehaviorSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSentinelOneAiSiem$ {
  /** @deprecated use `BackpressureBehaviorSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema =
    BackpressureBehaviorSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const CompressionSentinelOneAiSiem$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSentinelOneAiSiem
> = z.nativeEnum(CompressionSentinelOneAiSiem);

/** @internal */
export const CompressionSentinelOneAiSiem$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSentinelOneAiSiem
> = CompressionSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSentinelOneAiSiem$ {
  /** @deprecated use `CompressionSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = CompressionSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `CompressionSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = CompressionSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSentinelOneAiSiem$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSentinelOneAiSiem
> = z.nativeEnum(QueueFullBehaviorSentinelOneAiSiem);

/** @internal */
export const QueueFullBehaviorSentinelOneAiSiem$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSentinelOneAiSiem
> = QueueFullBehaviorSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSentinelOneAiSiem$ {
  /** @deprecated use `QueueFullBehaviorSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema =
    QueueFullBehaviorSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const ModeSentinelOneAiSiem$inboundSchema: z.ZodNativeEnum<
  typeof ModeSentinelOneAiSiem
> = z.nativeEnum(ModeSentinelOneAiSiem);

/** @internal */
export const ModeSentinelOneAiSiem$outboundSchema: z.ZodNativeEnum<
  typeof ModeSentinelOneAiSiem
> = ModeSentinelOneAiSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSentinelOneAiSiem$ {
  /** @deprecated use `ModeSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = ModeSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `ModeSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = ModeSentinelOneAiSiem$outboundSchema;
}

/** @internal */
export const PqControlsSentinelOneAiSiem$inboundSchema: z.ZodType<
  PqControlsSentinelOneAiSiem,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSentinelOneAiSiem$Outbound = {};

/** @internal */
export const PqControlsSentinelOneAiSiem$outboundSchema: z.ZodType<
  PqControlsSentinelOneAiSiem$Outbound,
  z.ZodTypeDef,
  PqControlsSentinelOneAiSiem
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSentinelOneAiSiem$ {
  /** @deprecated use `PqControlsSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = PqControlsSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `PqControlsSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = PqControlsSentinelOneAiSiem$outboundSchema;
  /** @deprecated use `PqControlsSentinelOneAiSiem$Outbound` instead. */
  export type Outbound = PqControlsSentinelOneAiSiem$Outbound;
}

export function pqControlsSentinelOneAiSiemToJSON(
  pqControlsSentinelOneAiSiem: PqControlsSentinelOneAiSiem,
): string {
  return JSON.stringify(
    PqControlsSentinelOneAiSiem$outboundSchema.parse(
      pqControlsSentinelOneAiSiem,
    ),
  );
}

export function pqControlsSentinelOneAiSiemFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSentinelOneAiSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSentinelOneAiSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSentinelOneAiSiem' from JSON`,
  );
}

/** @internal */
export const OutputSentinelOneAiSiem$inboundSchema: z.ZodType<
  OutputSentinelOneAiSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSentinelOneAiSiem$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: RegionSentinelOneAiSiem$inboundSchema.default("US"),
  endpoint: AISIEMEndpointPath$inboundSchema.default(
    "/services/collector/event",
  ),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(5120),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(5),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderSentinelOneAiSiem$inboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    FailedRequestLoggingModeSentinelOneAiSiem$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  authType: AuthenticationMethodSentinelOneAiSiem$inboundSchema.default(
    "manual",
  ),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSentinelOneAiSiem$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsSentinelOneAiSiem$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSentinelOneAiSiem$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  baseUrl: z.string().default("https://<Your-S1-Tenant>.sentinelone.net"),
  hostExpression: z.string().default("__e.host || C.os.hostname()"),
  sourceExpression: z.string().default(
    "__e.source || (__e.__criblMetrics ? 'metrics' : 'cribl')",
  ),
  sourceTypeExpression: z.string().default("__e.sourcetype || 'dottedJson'"),
  dataSourceCategoryExpression: z.string().default("'security'"),
  dataSourceNameExpression: z.string().default(
    "__e.__dataSourceName || 'cribl'",
  ),
  dataSourceVendorExpression: z.string().default(
    "__e.__dataSourceVendor || 'cribl'",
  ),
  eventTypeExpression: z.string().default(""),
  host: z.string().default("C.os.hostname()"),
  source: z.string().default("cribl"),
  sourceType: z.string().default("hecRawParser"),
  dataSourceCategory: z.string().default("security"),
  dataSourceName: z.string().default("cribl"),
  dataSourceVendor: z.string().default("cribl"),
  eventType: z.string().default(""),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSentinelOneAiSiem$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSentinelOneAiSiem$inboundSchema.default(
    "block",
  ),
  pqMode: ModeSentinelOneAiSiem$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSentinelOneAiSiem$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputSentinelOneAiSiem$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  region: string;
  endpoint: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<ExtraHttpHeaderSentinelOneAiSiem$Outbound>
    | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  authType: string;
  responseRetrySettings?:
    | Array<ResponseRetrySettingSentinelOneAiSiem$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | TimeoutRetrySettingsSentinelOneAiSiem$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  baseUrl: string;
  hostExpression: string;
  sourceExpression: string;
  sourceTypeExpression: string;
  dataSourceCategoryExpression: string;
  dataSourceNameExpression: string;
  dataSourceVendorExpression: string;
  eventTypeExpression: string;
  host: string;
  source: string;
  sourceType: string;
  dataSourceCategory: string;
  dataSourceName: string;
  dataSourceVendor: string;
  eventType: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSentinelOneAiSiem$Outbound | undefined;
};

/** @internal */
export const OutputSentinelOneAiSiem$outboundSchema: z.ZodType<
  OutputSentinelOneAiSiem$Outbound,
  z.ZodTypeDef,
  OutputSentinelOneAiSiem
> = z.object({
  id: z.string(),
  type: TypeSentinelOneAiSiem$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: RegionSentinelOneAiSiem$outboundSchema.default("US"),
  endpoint: AISIEMEndpointPath$outboundSchema.default(
    "/services/collector/event",
  ),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(5120),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(5),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderSentinelOneAiSiem$outboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    FailedRequestLoggingModeSentinelOneAiSiem$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  authType: AuthenticationMethodSentinelOneAiSiem$outboundSchema.default(
    "manual",
  ),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSentinelOneAiSiem$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsSentinelOneAiSiem$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSentinelOneAiSiem$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  baseUrl: z.string().default("https://<Your-S1-Tenant>.sentinelone.net"),
  hostExpression: z.string().default("__e.host || C.os.hostname()"),
  sourceExpression: z.string().default(
    "__e.source || (__e.__criblMetrics ? 'metrics' : 'cribl')",
  ),
  sourceTypeExpression: z.string().default("__e.sourcetype || 'dottedJson'"),
  dataSourceCategoryExpression: z.string().default("'security'"),
  dataSourceNameExpression: z.string().default(
    "__e.__dataSourceName || 'cribl'",
  ),
  dataSourceVendorExpression: z.string().default(
    "__e.__dataSourceVendor || 'cribl'",
  ),
  eventTypeExpression: z.string().default(""),
  host: z.string().default("C.os.hostname()"),
  source: z.string().default("cribl"),
  sourceType: z.string().default("hecRawParser"),
  dataSourceCategory: z.string().default("security"),
  dataSourceName: z.string().default("cribl"),
  dataSourceVendor: z.string().default("cribl"),
  eventType: z.string().default(""),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSentinelOneAiSiem$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSentinelOneAiSiem$outboundSchema.default(
    "block",
  ),
  pqMode: ModeSentinelOneAiSiem$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSentinelOneAiSiem$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinelOneAiSiem$ {
  /** @deprecated use `OutputSentinelOneAiSiem$inboundSchema` instead. */
  export const inboundSchema = OutputSentinelOneAiSiem$inboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiem$outboundSchema` instead. */
  export const outboundSchema = OutputSentinelOneAiSiem$outboundSchema;
  /** @deprecated use `OutputSentinelOneAiSiem$Outbound` instead. */
  export type Outbound = OutputSentinelOneAiSiem$Outbound;
}

export function outputSentinelOneAiSiemToJSON(
  outputSentinelOneAiSiem: OutputSentinelOneAiSiem,
): string {
  return JSON.stringify(
    OutputSentinelOneAiSiem$outboundSchema.parse(outputSentinelOneAiSiem),
  );
}

export function outputSentinelOneAiSiemFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinelOneAiSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSentinelOneAiSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinelOneAiSiem' from JSON`,
  );
}

/** @internal */
export const TypeDynatraceOtlp$inboundSchema: z.ZodNativeEnum<
  typeof TypeDynatraceOtlp
> = z.nativeEnum(TypeDynatraceOtlp);

/** @internal */
export const TypeDynatraceOtlp$outboundSchema: z.ZodNativeEnum<
  typeof TypeDynatraceOtlp
> = TypeDynatraceOtlp$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeDynatraceOtlp$ {
  /** @deprecated use `TypeDynatraceOtlp$inboundSchema` instead. */
  export const inboundSchema = TypeDynatraceOtlp$inboundSchema;
  /** @deprecated use `TypeDynatraceOtlp$outboundSchema` instead. */
  export const outboundSchema = TypeDynatraceOtlp$outboundSchema;
}

/** @internal */
export const ProtocolHTTP$inboundSchema: z.ZodNativeEnum<typeof ProtocolHTTP> =
  z.nativeEnum(ProtocolHTTP);

/** @internal */
export const ProtocolHTTP$outboundSchema: z.ZodNativeEnum<typeof ProtocolHTTP> =
  ProtocolHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProtocolHTTP$ {
  /** @deprecated use `ProtocolHTTP$inboundSchema` instead. */
  export const inboundSchema = ProtocolHTTP$inboundSchema;
  /** @deprecated use `ProtocolHTTP$outboundSchema` instead. */
  export const outboundSchema = ProtocolHTTP$outboundSchema;
}

/** @internal */
export const OTLPVersionHTTP$inboundSchema: z.ZodNativeEnum<
  typeof OTLPVersionHTTP
> = z.nativeEnum(OTLPVersionHTTP);

/** @internal */
export const OTLPVersionHTTP$outboundSchema: z.ZodNativeEnum<
  typeof OTLPVersionHTTP
> = OTLPVersionHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OTLPVersionHTTP$ {
  /** @deprecated use `OTLPVersionHTTP$inboundSchema` instead. */
  export const inboundSchema = OTLPVersionHTTP$inboundSchema;
  /** @deprecated use `OTLPVersionHTTP$outboundSchema` instead. */
  export const outboundSchema = OTLPVersionHTTP$outboundSchema;
}

/** @internal */
export const CreateOutputCompressCompressionHTTP$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressCompressionHTTP
> = z.nativeEnum(CreateOutputCompressCompressionHTTP);

/** @internal */
export const CreateOutputCompressCompressionHTTP$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputCompressCompressionHTTP> =
    CreateOutputCompressCompressionHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressCompressionHTTP$ {
  /** @deprecated use `CreateOutputCompressCompressionHTTP$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputCompressCompressionHTTP$inboundSchema;
  /** @deprecated use `CreateOutputCompressCompressionHTTP$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputCompressCompressionHTTP$outboundSchema;
}

/** @internal */
export const HTTPCompressCompressionHTTP$inboundSchema: z.ZodNativeEnum<
  typeof HTTPCompressCompressionHTTP
> = z.nativeEnum(HTTPCompressCompressionHTTP);

/** @internal */
export const HTTPCompressCompressionHTTP$outboundSchema: z.ZodNativeEnum<
  typeof HTTPCompressCompressionHTTP
> = HTTPCompressCompressionHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HTTPCompressCompressionHTTP$ {
  /** @deprecated use `HTTPCompressCompressionHTTP$inboundSchema` instead. */
  export const inboundSchema = HTTPCompressCompressionHTTP$inboundSchema;
  /** @deprecated use `HTTPCompressCompressionHTTP$outboundSchema` instead. */
  export const outboundSchema = HTTPCompressCompressionHTTP$outboundSchema;
}

/** @internal */
export const CreateOutputMetadatumHTTP$inboundSchema: z.ZodType<
  CreateOutputMetadatumHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type CreateOutputMetadatumHTTP$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const CreateOutputMetadatumHTTP$outboundSchema: z.ZodType<
  CreateOutputMetadatumHTTP$Outbound,
  z.ZodTypeDef,
  CreateOutputMetadatumHTTP
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMetadatumHTTP$ {
  /** @deprecated use `CreateOutputMetadatumHTTP$inboundSchema` instead. */
  export const inboundSchema = CreateOutputMetadatumHTTP$inboundSchema;
  /** @deprecated use `CreateOutputMetadatumHTTP$outboundSchema` instead. */
  export const outboundSchema = CreateOutputMetadatumHTTP$outboundSchema;
  /** @deprecated use `CreateOutputMetadatumHTTP$Outbound` instead. */
  export type Outbound = CreateOutputMetadatumHTTP$Outbound;
}

export function createOutputMetadatumHTTPToJSON(
  createOutputMetadatumHTTP: CreateOutputMetadatumHTTP,
): string {
  return JSON.stringify(
    CreateOutputMetadatumHTTP$outboundSchema.parse(createOutputMetadatumHTTP),
  );
}

export function createOutputMetadatumHTTPFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputMetadatumHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputMetadatumHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputMetadatumHTTP' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeHTTP
> = z.nativeEnum(FailedRequestLoggingModeHTTP);

/** @internal */
export const FailedRequestLoggingModeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeHTTP
> = FailedRequestLoggingModeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeHTTP$ {
  /** @deprecated use `FailedRequestLoggingModeHTTP$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeHTTP$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeHTTP$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingModeHTTP$outboundSchema;
}

/** @internal */
export const EndpointType$inboundSchema: z.ZodNativeEnum<typeof EndpointType> =
  z.nativeEnum(EndpointType);

/** @internal */
export const EndpointType$outboundSchema: z.ZodNativeEnum<typeof EndpointType> =
  EndpointType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointType$ {
  /** @deprecated use `EndpointType$inboundSchema` instead. */
  export const inboundSchema = EndpointType$inboundSchema;
  /** @deprecated use `EndpointType$outboundSchema` instead. */
  export const outboundSchema = EndpointType$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorHTTP$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorHTTP
> = z.nativeEnum(BackpressureBehaviorHTTP);

/** @internal */
export const BackpressureBehaviorHTTP$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorHTTP
> = BackpressureBehaviorHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorHTTP$ {
  /** @deprecated use `BackpressureBehaviorHTTP$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorHTTP$inboundSchema;
  /** @deprecated use `BackpressureBehaviorHTTP$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorHTTP$outboundSchema;
}

/** @internal */
export const ExtraHTTPHeaderHTTP$inboundSchema: z.ZodType<
  ExtraHTTPHeaderHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHTTPHeaderHTTP$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHTTPHeaderHTTP$outboundSchema: z.ZodType<
  ExtraHTTPHeaderHTTP$Outbound,
  z.ZodTypeDef,
  ExtraHTTPHeaderHTTP
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHTTPHeaderHTTP$ {
  /** @deprecated use `ExtraHTTPHeaderHTTP$inboundSchema` instead. */
  export const inboundSchema = ExtraHTTPHeaderHTTP$inboundSchema;
  /** @deprecated use `ExtraHTTPHeaderHTTP$outboundSchema` instead. */
  export const outboundSchema = ExtraHTTPHeaderHTTP$outboundSchema;
  /** @deprecated use `ExtraHTTPHeaderHTTP$Outbound` instead. */
  export type Outbound = ExtraHTTPHeaderHTTP$Outbound;
}

export function extraHTTPHeaderHTTPToJSON(
  extraHTTPHeaderHTTP: ExtraHTTPHeaderHTTP,
): string {
  return JSON.stringify(
    ExtraHTTPHeaderHTTP$outboundSchema.parse(extraHTTPHeaderHTTP),
  );
}

export function extraHTTPHeaderHTTPFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHTTPHeaderHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHTTPHeaderHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHTTPHeaderHTTP' from JSON`,
  );
}

/** @internal */
export const ResponseRetrySettingHTTP$inboundSchema: z.ZodType<
  ResponseRetrySettingHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingHTTP$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingHTTP$outboundSchema: z.ZodType<
  ResponseRetrySettingHTTP$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingHTTP
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingHTTP$ {
  /** @deprecated use `ResponseRetrySettingHTTP$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingHTTP$inboundSchema;
  /** @deprecated use `ResponseRetrySettingHTTP$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingHTTP$outboundSchema;
  /** @deprecated use `ResponseRetrySettingHTTP$Outbound` instead. */
  export type Outbound = ResponseRetrySettingHTTP$Outbound;
}

export function responseRetrySettingHTTPToJSON(
  responseRetrySettingHTTP: ResponseRetrySettingHTTP,
): string {
  return JSON.stringify(
    ResponseRetrySettingHTTP$outboundSchema.parse(responseRetrySettingHTTP),
  );
}

export function responseRetrySettingHTTPFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingHTTP' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsHTTP$inboundSchema: z.ZodType<
  TimeoutRetrySettingsHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsHTTP$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsHTTP$outboundSchema: z.ZodType<
  TimeoutRetrySettingsHTTP$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsHTTP
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsHTTP$ {
  /** @deprecated use `TimeoutRetrySettingsHTTP$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsHTTP$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsHTTP$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsHTTP$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsHTTP$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsHTTP$Outbound;
}

export function timeoutRetrySettingsHTTPToJSON(
  timeoutRetrySettingsHTTP: TimeoutRetrySettingsHTTP,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsHTTP$outboundSchema.parse(timeoutRetrySettingsHTTP),
  );
}

export function timeoutRetrySettingsHTTPFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsHTTP' from JSON`,
  );
}

/** @internal */
export const PqCompressCompressionHTTP$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionHTTP
> = z.nativeEnum(PqCompressCompressionHTTP);

/** @internal */
export const PqCompressCompressionHTTP$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionHTTP
> = PqCompressCompressionHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionHTTP$ {
  /** @deprecated use `PqCompressCompressionHTTP$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionHTTP$inboundSchema;
  /** @deprecated use `PqCompressCompressionHTTP$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionHTTP$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorHTTP$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorHTTP
> = z.nativeEnum(QueueFullBehaviorHTTP);

/** @internal */
export const QueueFullBehaviorHTTP$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorHTTP
> = QueueFullBehaviorHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorHTTP$ {
  /** @deprecated use `QueueFullBehaviorHTTP$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorHTTP$inboundSchema;
  /** @deprecated use `QueueFullBehaviorHTTP$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorHTTP$outboundSchema;
}

/** @internal */
export const CreateOutputModeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeHTTP
> = z.nativeEnum(CreateOutputModeHTTP);

/** @internal */
export const CreateOutputModeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeHTTP
> = CreateOutputModeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeHTTP$ {
  /** @deprecated use `CreateOutputModeHTTP$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeHTTP$inboundSchema;
  /** @deprecated use `CreateOutputModeHTTP$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeHTTP$outboundSchema;
}

/** @internal */
export const PqControlsHTTP$inboundSchema: z.ZodType<
  PqControlsHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsHTTP$Outbound = {};

/** @internal */
export const PqControlsHTTP$outboundSchema: z.ZodType<
  PqControlsHTTP$Outbound,
  z.ZodTypeDef,
  PqControlsHTTP
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsHTTP$ {
  /** @deprecated use `PqControlsHTTP$inboundSchema` instead. */
  export const inboundSchema = PqControlsHTTP$inboundSchema;
  /** @deprecated use `PqControlsHTTP$outboundSchema` instead. */
  export const outboundSchema = PqControlsHTTP$outboundSchema;
  /** @deprecated use `PqControlsHTTP$Outbound` instead. */
  export type Outbound = PqControlsHTTP$Outbound;
}

export function pqControlsHTTPToJSON(pqControlsHTTP: PqControlsHTTP): string {
  return JSON.stringify(PqControlsHTTP$outboundSchema.parse(pqControlsHTTP));
}

export function pqControlsHTTPFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsHTTP' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceOtlp$inboundSchema: z.ZodType<
  OutputDynatraceOtlp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeDynatraceOtlp$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: ProtocolHTTP$inboundSchema.default("http"),
  endpoint: z.string().default(
    "https://{your-environment-id}.live.dynatrace.com/api/v2/otlp",
  ),
  otlpVersion: OTLPVersionHTTP$inboundSchema.default("1.3.1"),
  compress: CreateOutputCompressCompressionHTTP$inboundSchema.default("gzip"),
  httpCompress: HTTPCompressCompressionHTTP$inboundSchema.default("gzip"),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => CreateOutputMetadatumHTTP$inboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(2048),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode: FailedRequestLoggingModeHTTP$inboundSchema.default(
    "none",
  ),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  endpointType: EndpointType$inboundSchema.default("saas"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("Authorization"),
  onBackpressure: BackpressureBehaviorHTTP$inboundSchema.default("block"),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHTTPHeaderHTTP$inboundSchema))
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingHTTP$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsHTTP$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionHTTP$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorHTTP$inboundSchema.default("block"),
  pqMode: CreateOutputModeHTTP$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsHTTP$inboundSchema).optional(),
});

/** @internal */
export type OutputDynatraceOtlp$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  endpoint: string;
  otlpVersion: string;
  compress: string;
  httpCompress: string;
  httpTracesEndpointOverride?: string | undefined;
  httpMetricsEndpointOverride?: string | undefined;
  httpLogsEndpointOverride?: string | undefined;
  metadata?: Array<CreateOutputMetadatumHTTP$Outbound> | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  timeoutSec: number;
  flushPeriodSec: number;
  failedRequestLoggingMode: string;
  connectionTimeout: number;
  keepAliveTime: number;
  keepAlive: boolean;
  endpointType: string;
  tokenSecret: string;
  authTokenName: string;
  onBackpressure: string;
  description?: string | undefined;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  extraHttpHeaders?: Array<ExtraHTTPHeaderHTTP$Outbound> | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingHTTP$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsHTTP$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsHTTP$Outbound | undefined;
};

/** @internal */
export const OutputDynatraceOtlp$outboundSchema: z.ZodType<
  OutputDynatraceOtlp$Outbound,
  z.ZodTypeDef,
  OutputDynatraceOtlp
> = z.object({
  id: z.string(),
  type: TypeDynatraceOtlp$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: ProtocolHTTP$outboundSchema.default("http"),
  endpoint: z.string().default(
    "https://{your-environment-id}.live.dynatrace.com/api/v2/otlp",
  ),
  otlpVersion: OTLPVersionHTTP$outboundSchema.default("1.3.1"),
  compress: CreateOutputCompressCompressionHTTP$outboundSchema.default("gzip"),
  httpCompress: HTTPCompressCompressionHTTP$outboundSchema.default("gzip"),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => CreateOutputMetadatumHTTP$outboundSchema))
    .optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(2048),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode: FailedRequestLoggingModeHTTP$outboundSchema.default(
    "none",
  ),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  endpointType: EndpointType$outboundSchema.default("saas"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("Authorization"),
  onBackpressure: BackpressureBehaviorHTTP$outboundSchema.default("block"),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHTTPHeaderHTTP$outboundSchema))
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingHTTP$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsHTTP$outboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionHTTP$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorHTTP$outboundSchema.default("block"),
  pqMode: CreateOutputModeHTTP$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsHTTP$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceOtlp$ {
  /** @deprecated use `OutputDynatraceOtlp$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceOtlp$inboundSchema;
  /** @deprecated use `OutputDynatraceOtlp$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceOtlp$outboundSchema;
  /** @deprecated use `OutputDynatraceOtlp$Outbound` instead. */
  export type Outbound = OutputDynatraceOtlp$Outbound;
}

export function outputDynatraceOtlpToJSON(
  outputDynatraceOtlp: OutputDynatraceOtlp,
): string {
  return JSON.stringify(
    OutputDynatraceOtlp$outboundSchema.parse(outputDynatraceOtlp),
  );
}

export function outputDynatraceOtlpFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceOtlp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDynatraceOtlp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceOtlp' from JSON`,
  );
}

/** @internal */
export const TypeDynatraceHTTP$inboundSchema: z.ZodNativeEnum<
  typeof TypeDynatraceHTTP
> = z.nativeEnum(TypeDynatraceHTTP);

/** @internal */
export const TypeDynatraceHTTP$outboundSchema: z.ZodNativeEnum<
  typeof TypeDynatraceHTTP
> = TypeDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeDynatraceHTTP$ {
  /** @deprecated use `TypeDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = TypeDynatraceHTTP$inboundSchema;
  /** @deprecated use `TypeDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = TypeDynatraceHTTP$outboundSchema;
}

/** @internal */
export const Method$inboundSchema: z.ZodNativeEnum<typeof Method> = z
  .nativeEnum(Method);

/** @internal */
export const Method$outboundSchema: z.ZodNativeEnum<typeof Method> =
  Method$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Method$ {
  /** @deprecated use `Method$inboundSchema` instead. */
  export const inboundSchema = Method$inboundSchema;
  /** @deprecated use `Method$outboundSchema` instead. */
  export const outboundSchema = Method$outboundSchema;
}

/** @internal */
export const ExtraHTTPHeaderDynatraceHTTP$inboundSchema: z.ZodType<
  ExtraHTTPHeaderDynatraceHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHTTPHeaderDynatraceHTTP$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHTTPHeaderDynatraceHTTP$outboundSchema: z.ZodType<
  ExtraHTTPHeaderDynatraceHTTP$Outbound,
  z.ZodTypeDef,
  ExtraHTTPHeaderDynatraceHTTP
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHTTPHeaderDynatraceHTTP$ {
  /** @deprecated use `ExtraHTTPHeaderDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = ExtraHTTPHeaderDynatraceHTTP$inboundSchema;
  /** @deprecated use `ExtraHTTPHeaderDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = ExtraHTTPHeaderDynatraceHTTP$outboundSchema;
  /** @deprecated use `ExtraHTTPHeaderDynatraceHTTP$Outbound` instead. */
  export type Outbound = ExtraHTTPHeaderDynatraceHTTP$Outbound;
}

export function extraHTTPHeaderDynatraceHTTPToJSON(
  extraHTTPHeaderDynatraceHTTP: ExtraHTTPHeaderDynatraceHTTP,
): string {
  return JSON.stringify(
    ExtraHTTPHeaderDynatraceHTTP$outboundSchema.parse(
      extraHTTPHeaderDynatraceHTTP,
    ),
  );
}

export function extraHTTPHeaderDynatraceHTTPFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHTTPHeaderDynatraceHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHTTPHeaderDynatraceHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHTTPHeaderDynatraceHTTP' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeDynatraceHTTP$inboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeDynatraceHTTP> = z.nativeEnum(
    FailedRequestLoggingModeDynatraceHTTP,
  );

/** @internal */
export const FailedRequestLoggingModeDynatraceHTTP$outboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeDynatraceHTTP> =
    FailedRequestLoggingModeDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeDynatraceHTTP$ {
  /** @deprecated use `FailedRequestLoggingModeDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema =
    FailedRequestLoggingModeDynatraceHTTP$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeDynatraceHTTP$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingDynatraceHTTP$inboundSchema: z.ZodType<
  ResponseRetrySettingDynatraceHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingDynatraceHTTP$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingDynatraceHTTP$outboundSchema: z.ZodType<
  ResponseRetrySettingDynatraceHTTP$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingDynatraceHTTP
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingDynatraceHTTP$ {
  /** @deprecated use `ResponseRetrySettingDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingDynatraceHTTP$inboundSchema;
  /** @deprecated use `ResponseRetrySettingDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema =
    ResponseRetrySettingDynatraceHTTP$outboundSchema;
  /** @deprecated use `ResponseRetrySettingDynatraceHTTP$Outbound` instead. */
  export type Outbound = ResponseRetrySettingDynatraceHTTP$Outbound;
}

export function responseRetrySettingDynatraceHTTPToJSON(
  responseRetrySettingDynatraceHTTP: ResponseRetrySettingDynatraceHTTP,
): string {
  return JSON.stringify(
    ResponseRetrySettingDynatraceHTTP$outboundSchema.parse(
      responseRetrySettingDynatraceHTTP,
    ),
  );
}

export function responseRetrySettingDynatraceHTTPFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingDynatraceHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingDynatraceHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingDynatraceHTTP' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsDynatraceHTTP$inboundSchema: z.ZodType<
  TimeoutRetrySettingsDynatraceHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsDynatraceHTTP$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsDynatraceHTTP$outboundSchema: z.ZodType<
  TimeoutRetrySettingsDynatraceHTTP$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsDynatraceHTTP
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsDynatraceHTTP$ {
  /** @deprecated use `TimeoutRetrySettingsDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsDynatraceHTTP$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema =
    TimeoutRetrySettingsDynatraceHTTP$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsDynatraceHTTP$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsDynatraceHTTP$Outbound;
}

export function timeoutRetrySettingsDynatraceHTTPToJSON(
  timeoutRetrySettingsDynatraceHTTP: TimeoutRetrySettingsDynatraceHTTP,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsDynatraceHTTP$outboundSchema.parse(
      timeoutRetrySettingsDynatraceHTTP,
    ),
  );
}

export function timeoutRetrySettingsDynatraceHTTPFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsDynatraceHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsDynatraceHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsDynatraceHTTP' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorDynatraceHTTP$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorDynatraceHTTP
> = z.nativeEnum(BackpressureBehaviorDynatraceHTTP);

/** @internal */
export const BackpressureBehaviorDynatraceHTTP$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorDynatraceHTTP
> = BackpressureBehaviorDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorDynatraceHTTP$ {
  /** @deprecated use `BackpressureBehaviorDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorDynatraceHTTP$inboundSchema;
  /** @deprecated use `BackpressureBehaviorDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorDynatraceHTTP$outboundSchema;
}

/** @internal */
export const AuthenticationTypeDynatraceHTTP$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeDynatraceHTTP
> = z.nativeEnum(AuthenticationTypeDynatraceHTTP);

/** @internal */
export const AuthenticationTypeDynatraceHTTP$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeDynatraceHTTP
> = AuthenticationTypeDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationTypeDynatraceHTTP$ {
  /** @deprecated use `AuthenticationTypeDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = AuthenticationTypeDynatraceHTTP$inboundSchema;
  /** @deprecated use `AuthenticationTypeDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = AuthenticationTypeDynatraceHTTP$outboundSchema;
}

/** @internal */
export const FormatDynatraceHTTP$inboundSchema: z.ZodNativeEnum<
  typeof FormatDynatraceHTTP
> = z.nativeEnum(FormatDynatraceHTTP);

/** @internal */
export const FormatDynatraceHTTP$outboundSchema: z.ZodNativeEnum<
  typeof FormatDynatraceHTTP
> = FormatDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatDynatraceHTTP$ {
  /** @deprecated use `FormatDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = FormatDynatraceHTTP$inboundSchema;
  /** @deprecated use `FormatDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = FormatDynatraceHTTP$outboundSchema;
}

/** @internal */
export const Endpoint$inboundSchema: z.ZodNativeEnum<typeof Endpoint> = z
  .nativeEnum(Endpoint);

/** @internal */
export const Endpoint$outboundSchema: z.ZodNativeEnum<typeof Endpoint> =
  Endpoint$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Endpoint$ {
  /** @deprecated use `Endpoint$inboundSchema` instead. */
  export const inboundSchema = Endpoint$inboundSchema;
  /** @deprecated use `Endpoint$outboundSchema` instead. */
  export const outboundSchema = Endpoint$outboundSchema;
}

/** @internal */
export const TelemetryType$inboundSchema: z.ZodNativeEnum<
  typeof TelemetryType
> = z.nativeEnum(TelemetryType);

/** @internal */
export const TelemetryType$outboundSchema: z.ZodNativeEnum<
  typeof TelemetryType
> = TelemetryType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TelemetryType$ {
  /** @deprecated use `TelemetryType$inboundSchema` instead. */
  export const inboundSchema = TelemetryType$inboundSchema;
  /** @deprecated use `TelemetryType$outboundSchema` instead. */
  export const outboundSchema = TelemetryType$outboundSchema;
}

/** @internal */
export const CompressionDynatraceHTTP$inboundSchema: z.ZodNativeEnum<
  typeof CompressionDynatraceHTTP
> = z.nativeEnum(CompressionDynatraceHTTP);

/** @internal */
export const CompressionDynatraceHTTP$outboundSchema: z.ZodNativeEnum<
  typeof CompressionDynatraceHTTP
> = CompressionDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionDynatraceHTTP$ {
  /** @deprecated use `CompressionDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = CompressionDynatraceHTTP$inboundSchema;
  /** @deprecated use `CompressionDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = CompressionDynatraceHTTP$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorDynatraceHTTP$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorDynatraceHTTP
> = z.nativeEnum(QueueFullBehaviorDynatraceHTTP);

/** @internal */
export const QueueFullBehaviorDynatraceHTTP$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorDynatraceHTTP
> = QueueFullBehaviorDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorDynatraceHTTP$ {
  /** @deprecated use `QueueFullBehaviorDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorDynatraceHTTP$inboundSchema;
  /** @deprecated use `QueueFullBehaviorDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorDynatraceHTTP$outboundSchema;
}

/** @internal */
export const ModeDynatraceHTTP$inboundSchema: z.ZodNativeEnum<
  typeof ModeDynatraceHTTP
> = z.nativeEnum(ModeDynatraceHTTP);

/** @internal */
export const ModeDynatraceHTTP$outboundSchema: z.ZodNativeEnum<
  typeof ModeDynatraceHTTP
> = ModeDynatraceHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeDynatraceHTTP$ {
  /** @deprecated use `ModeDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = ModeDynatraceHTTP$inboundSchema;
  /** @deprecated use `ModeDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = ModeDynatraceHTTP$outboundSchema;
}

/** @internal */
export const PqControlsDynatraceHTTP$inboundSchema: z.ZodType<
  PqControlsDynatraceHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsDynatraceHTTP$Outbound = {};

/** @internal */
export const PqControlsDynatraceHTTP$outboundSchema: z.ZodType<
  PqControlsDynatraceHTTP$Outbound,
  z.ZodTypeDef,
  PqControlsDynatraceHTTP
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsDynatraceHTTP$ {
  /** @deprecated use `PqControlsDynatraceHTTP$inboundSchema` instead. */
  export const inboundSchema = PqControlsDynatraceHTTP$inboundSchema;
  /** @deprecated use `PqControlsDynatraceHTTP$outboundSchema` instead. */
  export const outboundSchema = PqControlsDynatraceHTTP$outboundSchema;
  /** @deprecated use `PqControlsDynatraceHTTP$Outbound` instead. */
  export type Outbound = PqControlsDynatraceHTTP$Outbound;
}

export function pqControlsDynatraceHTTPToJSON(
  pqControlsDynatraceHTTP: PqControlsDynatraceHTTP,
): string {
  return JSON.stringify(
    PqControlsDynatraceHTTP$outboundSchema.parse(pqControlsDynatraceHTTP),
  );
}

export function pqControlsDynatraceHTTPFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsDynatraceHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsDynatraceHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsDynatraceHTTP' from JSON`,
  );
}

/** @internal */
export const OutputDynatraceHttp$inboundSchema: z.ZodType<
  OutputDynatraceHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeDynatraceHTTP$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method$inboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHTTPHeaderDynatraceHTTP$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeDynatraceHTTP$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingDynatraceHTTP$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsDynatraceHTTP$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorDynatraceHTTP$inboundSchema.default(
    "block",
  ),
  authType: AuthenticationTypeDynatraceHTTP$inboundSchema.default("token"),
  format: FormatDynatraceHTTP$inboundSchema.default("json_array"),
  endpoint: Endpoint$inboundSchema.default("cloud"),
  telemetryType: TelemetryType$inboundSchema.default("logs"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionDynatraceHTTP$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorDynatraceHTTP$inboundSchema.default(
    "block",
  ),
  pqMode: ModeDynatraceHTTP$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsDynatraceHTTP$inboundSchema).optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  environmentId: z.string().optional(),
  activeGateDomain: z.string().optional(),
  url: z.string().optional(),
});

/** @internal */
export type OutputDynatraceHttp$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHTTPHeaderDynatraceHTTP$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingDynatraceHTTP$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsDynatraceHTTP$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  format: string;
  endpoint: string;
  telemetryType: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsDynatraceHTTP$Outbound | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  environmentId?: string | undefined;
  activeGateDomain?: string | undefined;
  url?: string | undefined;
};

/** @internal */
export const OutputDynatraceHttp$outboundSchema: z.ZodType<
  OutputDynatraceHttp$Outbound,
  z.ZodTypeDef,
  OutputDynatraceHttp
> = z.object({
  id: z.string(),
  type: TypeDynatraceHTTP$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method$outboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHTTPHeaderDynatraceHTTP$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeDynatraceHTTP$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingDynatraceHTTP$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsDynatraceHTTP$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorDynatraceHTTP$outboundSchema.default(
    "block",
  ),
  authType: AuthenticationTypeDynatraceHTTP$outboundSchema.default("token"),
  format: FormatDynatraceHTTP$outboundSchema.default("json_array"),
  endpoint: Endpoint$outboundSchema.default("cloud"),
  telemetryType: TelemetryType$outboundSchema.default("logs"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionDynatraceHTTP$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorDynatraceHTTP$outboundSchema.default(
    "block",
  ),
  pqMode: ModeDynatraceHTTP$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsDynatraceHTTP$outboundSchema).optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  environmentId: z.string().optional(),
  activeGateDomain: z.string().optional(),
  url: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDynatraceHttp$ {
  /** @deprecated use `OutputDynatraceHttp$inboundSchema` instead. */
  export const inboundSchema = OutputDynatraceHttp$inboundSchema;
  /** @deprecated use `OutputDynatraceHttp$outboundSchema` instead. */
  export const outboundSchema = OutputDynatraceHttp$outboundSchema;
  /** @deprecated use `OutputDynatraceHttp$Outbound` instead. */
  export type Outbound = OutputDynatraceHttp$Outbound;
}

export function outputDynatraceHttpToJSON(
  outputDynatraceHttp: OutputDynatraceHttp,
): string {
  return JSON.stringify(
    OutputDynatraceHttp$outboundSchema.parse(outputDynatraceHttp),
  );
}

export function outputDynatraceHttpFromJSON(
  jsonString: string,
): SafeParseResult<OutputDynatraceHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDynatraceHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDynatraceHttp' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeNetflow$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeNetflow
> = z.nativeEnum(CreateOutputTypeNetflow);

/** @internal */
export const CreateOutputTypeNetflow$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeNetflow
> = CreateOutputTypeNetflow$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeNetflow$ {
  /** @deprecated use `CreateOutputTypeNetflow$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeNetflow$inboundSchema;
  /** @deprecated use `CreateOutputTypeNetflow$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeNetflow$outboundSchema;
}

/** @internal */
export const HostNetflow$inboundSchema: z.ZodType<
  HostNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  port: z.number().default(2055),
});

/** @internal */
export type HostNetflow$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const HostNetflow$outboundSchema: z.ZodType<
  HostNetflow$Outbound,
  z.ZodTypeDef,
  HostNetflow
> = z.object({
  host: z.string(),
  port: z.number().default(2055),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HostNetflow$ {
  /** @deprecated use `HostNetflow$inboundSchema` instead. */
  export const inboundSchema = HostNetflow$inboundSchema;
  /** @deprecated use `HostNetflow$outboundSchema` instead. */
  export const outboundSchema = HostNetflow$outboundSchema;
  /** @deprecated use `HostNetflow$Outbound` instead. */
  export type Outbound = HostNetflow$Outbound;
}

export function hostNetflowToJSON(hostNetflow: HostNetflow): string {
  return JSON.stringify(HostNetflow$outboundSchema.parse(hostNetflow));
}

export function hostNetflowFromJSON(
  jsonString: string,
): SafeParseResult<HostNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HostNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HostNetflow' from JSON`,
  );
}

/** @internal */
export const OutputNetflow$inboundSchema: z.ZodType<
  OutputNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeNetflow$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => HostNetflow$inboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/** @internal */
export type OutputNetflow$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  hosts: Array<HostNetflow$Outbound>;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
};

/** @internal */
export const OutputNetflow$outboundSchema: z.ZodType<
  OutputNetflow$Outbound,
  z.ZodTypeDef,
  OutputNetflow
> = z.object({
  id: z.string(),
  type: CreateOutputTypeNetflow$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => HostNetflow$outboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNetflow$ {
  /** @deprecated use `OutputNetflow$inboundSchema` instead. */
  export const inboundSchema = OutputNetflow$inboundSchema;
  /** @deprecated use `OutputNetflow$outboundSchema` instead. */
  export const outboundSchema = OutputNetflow$outboundSchema;
  /** @deprecated use `OutputNetflow$Outbound` instead. */
  export type Outbound = OutputNetflow$Outbound;
}

export function outputNetflowToJSON(outputNetflow: OutputNetflow): string {
  return JSON.stringify(OutputNetflow$outboundSchema.parse(outputNetflow));
}

export function outputNetflowFromJSON(
  jsonString: string,
): SafeParseResult<OutputNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNetflow' from JSON`,
  );
}

/** @internal */
export const TypeClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof TypeClickHouse
> = z.nativeEnum(TypeClickHouse);

/** @internal */
export const TypeClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof TypeClickHouse
> = TypeClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeClickHouse$ {
  /** @deprecated use `TypeClickHouse$inboundSchema` instead. */
  export const inboundSchema = TypeClickHouse$inboundSchema;
  /** @deprecated use `TypeClickHouse$outboundSchema` instead. */
  export const outboundSchema = TypeClickHouse$outboundSchema;
}

/** @internal */
export const AuthenticationTypeClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeClickHouse
> = z.nativeEnum(AuthenticationTypeClickHouse);

/** @internal */
export const AuthenticationTypeClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeClickHouse
> = AuthenticationTypeClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationTypeClickHouse$ {
  /** @deprecated use `AuthenticationTypeClickHouse$inboundSchema` instead. */
  export const inboundSchema = AuthenticationTypeClickHouse$inboundSchema;
  /** @deprecated use `AuthenticationTypeClickHouse$outboundSchema` instead. */
  export const outboundSchema = AuthenticationTypeClickHouse$outboundSchema;
}

/** @internal */
export const FormatClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof FormatClickHouse
> = z.nativeEnum(FormatClickHouse);

/** @internal */
export const FormatClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof FormatClickHouse
> = FormatClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatClickHouse$ {
  /** @deprecated use `FormatClickHouse$inboundSchema` instead. */
  export const inboundSchema = FormatClickHouse$inboundSchema;
  /** @deprecated use `FormatClickHouse$outboundSchema` instead. */
  export const outboundSchema = FormatClickHouse$outboundSchema;
}

/** @internal */
export const MappingType$inboundSchema: z.ZodNativeEnum<typeof MappingType> = z
  .nativeEnum(MappingType);

/** @internal */
export const MappingType$outboundSchema: z.ZodNativeEnum<typeof MappingType> =
  MappingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MappingType$ {
  /** @deprecated use `MappingType$inboundSchema` instead. */
  export const inboundSchema = MappingType$inboundSchema;
  /** @deprecated use `MappingType$outboundSchema` instead. */
  export const outboundSchema = MappingType$outboundSchema;
}

/** @internal */
export const MinimumTLSVersionClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionClickHouse
> = z.nativeEnum(MinimumTLSVersionClickHouse);

/** @internal */
export const MinimumTLSVersionClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionClickHouse
> = MinimumTLSVersionClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionClickHouse$ {
  /** @deprecated use `MinimumTLSVersionClickHouse$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionClickHouse$inboundSchema;
  /** @deprecated use `MinimumTLSVersionClickHouse$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionClickHouse$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionClickHouse
> = z.nativeEnum(MaximumTLSVersionClickHouse);

/** @internal */
export const MaximumTLSVersionClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionClickHouse
> = MaximumTLSVersionClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionClickHouse$ {
  /** @deprecated use `MaximumTLSVersionClickHouse$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionClickHouse$inboundSchema;
  /** @deprecated use `MaximumTLSVersionClickHouse$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionClickHouse$outboundSchema;
}

/** @internal */
export const TLSSettingsClientSideClickHouse$inboundSchema: z.ZodType<
  TLSSettingsClientSideClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: MinimumTLSVersionClickHouse$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionClickHouse$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsClientSideClickHouse$Outbound = {
  disabled: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsClientSideClickHouse$outboundSchema: z.ZodType<
  TLSSettingsClientSideClickHouse$Outbound,
  z.ZodTypeDef,
  TLSSettingsClientSideClickHouse
> = z.object({
  disabled: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: MinimumTLSVersionClickHouse$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionClickHouse$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsClientSideClickHouse$ {
  /** @deprecated use `TLSSettingsClientSideClickHouse$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsClientSideClickHouse$inboundSchema;
  /** @deprecated use `TLSSettingsClientSideClickHouse$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsClientSideClickHouse$outboundSchema;
  /** @deprecated use `TLSSettingsClientSideClickHouse$Outbound` instead. */
  export type Outbound = TLSSettingsClientSideClickHouse$Outbound;
}

export function tlsSettingsClientSideClickHouseToJSON(
  tlsSettingsClientSideClickHouse: TLSSettingsClientSideClickHouse,
): string {
  return JSON.stringify(
    TLSSettingsClientSideClickHouse$outboundSchema.parse(
      tlsSettingsClientSideClickHouse,
    ),
  );
}

export function tlsSettingsClientSideClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsClientSideClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsClientSideClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsClientSideClickHouse' from JSON`,
  );
}

/** @internal */
export const ExtraHttpHeaderClickHouse$inboundSchema: z.ZodType<
  ExtraHttpHeaderClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderClickHouse$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderClickHouse$outboundSchema: z.ZodType<
  ExtraHttpHeaderClickHouse$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderClickHouse
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderClickHouse$ {
  /** @deprecated use `ExtraHttpHeaderClickHouse$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderClickHouse$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderClickHouse$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderClickHouse$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderClickHouse$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderClickHouse$Outbound;
}

export function extraHttpHeaderClickHouseToJSON(
  extraHttpHeaderClickHouse: ExtraHttpHeaderClickHouse,
): string {
  return JSON.stringify(
    ExtraHttpHeaderClickHouse$outboundSchema.parse(extraHttpHeaderClickHouse),
  );
}

export function extraHttpHeaderClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderClickHouse' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeClickHouse
> = z.nativeEnum(FailedRequestLoggingModeClickHouse);

/** @internal */
export const FailedRequestLoggingModeClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeClickHouse
> = FailedRequestLoggingModeClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeClickHouse$ {
  /** @deprecated use `FailedRequestLoggingModeClickHouse$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeClickHouse$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeClickHouse$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeClickHouse$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingClickHouse$inboundSchema: z.ZodType<
  ResponseRetrySettingClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingClickHouse$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingClickHouse$outboundSchema: z.ZodType<
  ResponseRetrySettingClickHouse$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingClickHouse
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingClickHouse$ {
  /** @deprecated use `ResponseRetrySettingClickHouse$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingClickHouse$inboundSchema;
  /** @deprecated use `ResponseRetrySettingClickHouse$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingClickHouse$outboundSchema;
  /** @deprecated use `ResponseRetrySettingClickHouse$Outbound` instead. */
  export type Outbound = ResponseRetrySettingClickHouse$Outbound;
}

export function responseRetrySettingClickHouseToJSON(
  responseRetrySettingClickHouse: ResponseRetrySettingClickHouse,
): string {
  return JSON.stringify(
    ResponseRetrySettingClickHouse$outboundSchema.parse(
      responseRetrySettingClickHouse,
    ),
  );
}

export function responseRetrySettingClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingClickHouse' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsClickHouse$inboundSchema: z.ZodType<
  TimeoutRetrySettingsClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsClickHouse$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsClickHouse$outboundSchema: z.ZodType<
  TimeoutRetrySettingsClickHouse$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsClickHouse
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsClickHouse$ {
  /** @deprecated use `TimeoutRetrySettingsClickHouse$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsClickHouse$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsClickHouse$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsClickHouse$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsClickHouse$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsClickHouse$Outbound;
}

export function timeoutRetrySettingsClickHouseToJSON(
  timeoutRetrySettingsClickHouse: TimeoutRetrySettingsClickHouse,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsClickHouse$outboundSchema.parse(
      timeoutRetrySettingsClickHouse,
    ),
  );
}

export function timeoutRetrySettingsClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsClickHouse' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorClickHouse
> = z.nativeEnum(BackpressureBehaviorClickHouse);

/** @internal */
export const BackpressureBehaviorClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorClickHouse
> = BackpressureBehaviorClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorClickHouse$ {
  /** @deprecated use `BackpressureBehaviorClickHouse$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorClickHouse$inboundSchema;
  /** @deprecated use `BackpressureBehaviorClickHouse$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorClickHouse$outboundSchema;
}

/** @internal */
export const OauthParamClickHouse$inboundSchema: z.ZodType<
  OauthParamClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthParamClickHouse$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthParamClickHouse$outboundSchema: z.ZodType<
  OauthParamClickHouse$Outbound,
  z.ZodTypeDef,
  OauthParamClickHouse
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthParamClickHouse$ {
  /** @deprecated use `OauthParamClickHouse$inboundSchema` instead. */
  export const inboundSchema = OauthParamClickHouse$inboundSchema;
  /** @deprecated use `OauthParamClickHouse$outboundSchema` instead. */
  export const outboundSchema = OauthParamClickHouse$outboundSchema;
  /** @deprecated use `OauthParamClickHouse$Outbound` instead. */
  export type Outbound = OauthParamClickHouse$Outbound;
}

export function oauthParamClickHouseToJSON(
  oauthParamClickHouse: OauthParamClickHouse,
): string {
  return JSON.stringify(
    OauthParamClickHouse$outboundSchema.parse(oauthParamClickHouse),
  );
}

export function oauthParamClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<OauthParamClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthParamClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthParamClickHouse' from JSON`,
  );
}

/** @internal */
export const OauthHeaderClickHouse$inboundSchema: z.ZodType<
  OauthHeaderClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthHeaderClickHouse$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthHeaderClickHouse$outboundSchema: z.ZodType<
  OauthHeaderClickHouse$Outbound,
  z.ZodTypeDef,
  OauthHeaderClickHouse
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthHeaderClickHouse$ {
  /** @deprecated use `OauthHeaderClickHouse$inboundSchema` instead. */
  export const inboundSchema = OauthHeaderClickHouse$inboundSchema;
  /** @deprecated use `OauthHeaderClickHouse$outboundSchema` instead. */
  export const outboundSchema = OauthHeaderClickHouse$outboundSchema;
  /** @deprecated use `OauthHeaderClickHouse$Outbound` instead. */
  export type Outbound = OauthHeaderClickHouse$Outbound;
}

export function oauthHeaderClickHouseToJSON(
  oauthHeaderClickHouse: OauthHeaderClickHouse,
): string {
  return JSON.stringify(
    OauthHeaderClickHouse$outboundSchema.parse(oauthHeaderClickHouse),
  );
}

export function oauthHeaderClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<OauthHeaderClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthHeaderClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthHeaderClickHouse' from JSON`,
  );
}

/** @internal */
export const ColumnMapping$inboundSchema: z.ZodType<
  ColumnMapping,
  z.ZodTypeDef,
  unknown
> = z.object({
  columnName: z.string(),
  columnType: z.string().optional(),
  columnValueExpression: z.string(),
});

/** @internal */
export type ColumnMapping$Outbound = {
  columnName: string;
  columnType?: string | undefined;
  columnValueExpression: string;
};

/** @internal */
export const ColumnMapping$outboundSchema: z.ZodType<
  ColumnMapping$Outbound,
  z.ZodTypeDef,
  ColumnMapping
> = z.object({
  columnName: z.string(),
  columnType: z.string().optional(),
  columnValueExpression: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ColumnMapping$ {
  /** @deprecated use `ColumnMapping$inboundSchema` instead. */
  export const inboundSchema = ColumnMapping$inboundSchema;
  /** @deprecated use `ColumnMapping$outboundSchema` instead. */
  export const outboundSchema = ColumnMapping$outboundSchema;
  /** @deprecated use `ColumnMapping$Outbound` instead. */
  export type Outbound = ColumnMapping$Outbound;
}

export function columnMappingToJSON(columnMapping: ColumnMapping): string {
  return JSON.stringify(ColumnMapping$outboundSchema.parse(columnMapping));
}

export function columnMappingFromJSON(
  jsonString: string,
): SafeParseResult<ColumnMapping, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ColumnMapping$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ColumnMapping' from JSON`,
  );
}

/** @internal */
export const CompressionClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof CompressionClickHouse
> = z.nativeEnum(CompressionClickHouse);

/** @internal */
export const CompressionClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof CompressionClickHouse
> = CompressionClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionClickHouse$ {
  /** @deprecated use `CompressionClickHouse$inboundSchema` instead. */
  export const inboundSchema = CompressionClickHouse$inboundSchema;
  /** @deprecated use `CompressionClickHouse$outboundSchema` instead. */
  export const outboundSchema = CompressionClickHouse$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorClickHouse
> = z.nativeEnum(QueueFullBehaviorClickHouse);

/** @internal */
export const QueueFullBehaviorClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorClickHouse
> = QueueFullBehaviorClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorClickHouse$ {
  /** @deprecated use `QueueFullBehaviorClickHouse$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorClickHouse$inboundSchema;
  /** @deprecated use `QueueFullBehaviorClickHouse$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorClickHouse$outboundSchema;
}

/** @internal */
export const ModeClickHouse$inboundSchema: z.ZodNativeEnum<
  typeof ModeClickHouse
> = z.nativeEnum(ModeClickHouse);

/** @internal */
export const ModeClickHouse$outboundSchema: z.ZodNativeEnum<
  typeof ModeClickHouse
> = ModeClickHouse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeClickHouse$ {
  /** @deprecated use `ModeClickHouse$inboundSchema` instead. */
  export const inboundSchema = ModeClickHouse$inboundSchema;
  /** @deprecated use `ModeClickHouse$outboundSchema` instead. */
  export const outboundSchema = ModeClickHouse$outboundSchema;
}

/** @internal */
export const PqControlsClickHouse$inboundSchema: z.ZodType<
  PqControlsClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsClickHouse$Outbound = {};

/** @internal */
export const PqControlsClickHouse$outboundSchema: z.ZodType<
  PqControlsClickHouse$Outbound,
  z.ZodTypeDef,
  PqControlsClickHouse
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsClickHouse$ {
  /** @deprecated use `PqControlsClickHouse$inboundSchema` instead. */
  export const inboundSchema = PqControlsClickHouse$inboundSchema;
  /** @deprecated use `PqControlsClickHouse$outboundSchema` instead. */
  export const outboundSchema = PqControlsClickHouse$outboundSchema;
  /** @deprecated use `PqControlsClickHouse$Outbound` instead. */
  export type Outbound = PqControlsClickHouse$Outbound;
}

export function pqControlsClickHouseToJSON(
  pqControlsClickHouse: PqControlsClickHouse,
): string {
  return JSON.stringify(
    PqControlsClickHouse$outboundSchema.parse(pqControlsClickHouse),
  );
}

export function pqControlsClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsClickHouse' from JSON`,
  );
}

/** @internal */
export const OutputClickHouse$inboundSchema: z.ZodType<
  OutputClickHouse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeClickHouse$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  authType: AuthenticationTypeClickHouse$inboundSchema.default("none"),
  database: z.string(),
  tableName: z.string(),
  format: FormatClickHouse$inboundSchema.default(
    "json-compact-each-row-with-names",
  ),
  mappingType: MappingType$inboundSchema.default("automatic"),
  asyncInserts: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsClientSideClickHouse$inboundSchema).optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderClickHouse$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeClickHouse$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingClickHouse$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsClickHouse$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  dumpFormatErrorsToDisk: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorClickHouse$inboundSchema.default("block"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamClickHouse$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderClickHouse$inboundSchema))
    .optional(),
  sqlUsername: z.string().optional(),
  waitForAsyncInserts: z.boolean().default(true),
  excludeMappingFields: z.array(z.string()).optional(),
  describeTable: z.string().optional(),
  columnMappings: z.array(z.lazy(() => ColumnMapping$inboundSchema)).optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionClickHouse$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorClickHouse$inboundSchema.default("block"),
  pqMode: ModeClickHouse$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsClickHouse$inboundSchema).optional(),
});

/** @internal */
export type OutputClickHouse$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  authType: string;
  database: string;
  tableName: string;
  format: string;
  mappingType: string;
  asyncInserts: boolean;
  tls?: TLSSettingsClientSideClickHouse$Outbound | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderClickHouse$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingClickHouse$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsClickHouse$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  dumpFormatErrorsToDisk: boolean;
  onBackpressure: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OauthParamClickHouse$Outbound> | undefined;
  oauthHeaders?: Array<OauthHeaderClickHouse$Outbound> | undefined;
  sqlUsername?: string | undefined;
  waitForAsyncInserts: boolean;
  excludeMappingFields?: Array<string> | undefined;
  describeTable?: string | undefined;
  columnMappings?: Array<ColumnMapping$Outbound> | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsClickHouse$Outbound | undefined;
};

/** @internal */
export const OutputClickHouse$outboundSchema: z.ZodType<
  OutputClickHouse$Outbound,
  z.ZodTypeDef,
  OutputClickHouse
> = z.object({
  id: z.string(),
  type: TypeClickHouse$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  authType: AuthenticationTypeClickHouse$outboundSchema.default("none"),
  database: z.string(),
  tableName: z.string(),
  format: FormatClickHouse$outboundSchema.default(
    "json-compact-each-row-with-names",
  ),
  mappingType: MappingType$outboundSchema.default("automatic"),
  asyncInserts: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsClientSideClickHouse$outboundSchema).optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderClickHouse$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeClickHouse$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingClickHouse$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsClickHouse$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  dumpFormatErrorsToDisk: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorClickHouse$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamClickHouse$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderClickHouse$outboundSchema))
    .optional(),
  sqlUsername: z.string().optional(),
  waitForAsyncInserts: z.boolean().default(true),
  excludeMappingFields: z.array(z.string()).optional(),
  describeTable: z.string().optional(),
  columnMappings: z.array(z.lazy(() => ColumnMapping$outboundSchema))
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionClickHouse$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorClickHouse$outboundSchema.default("block"),
  pqMode: ModeClickHouse$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsClickHouse$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputClickHouse$ {
  /** @deprecated use `OutputClickHouse$inboundSchema` instead. */
  export const inboundSchema = OutputClickHouse$inboundSchema;
  /** @deprecated use `OutputClickHouse$outboundSchema` instead. */
  export const outboundSchema = OutputClickHouse$outboundSchema;
  /** @deprecated use `OutputClickHouse$Outbound` instead. */
  export type Outbound = OutputClickHouse$Outbound;
}

export function outputClickHouseToJSON(
  outputClickHouse: OutputClickHouse,
): string {
  return JSON.stringify(
    OutputClickHouse$outboundSchema.parse(outputClickHouse),
  );
}

export function outputClickHouseFromJSON(
  jsonString: string,
): SafeParseResult<OutputClickHouse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputClickHouse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputClickHouse' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSecurityLake
> = z.nativeEnum(CreateOutputTypeSecurityLake);

/** @internal */
export const CreateOutputTypeSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSecurityLake
> = CreateOutputTypeSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeSecurityLake$ {
  /** @deprecated use `CreateOutputTypeSecurityLake$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeSecurityLake$inboundSchema;
  /** @deprecated use `CreateOutputTypeSecurityLake$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeSecurityLake$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationMethodSecurityLake$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodSecurityLake> = z
    .nativeEnum(CreateOutputAuthenticationMethodSecurityLake);

/** @internal */
export const CreateOutputAuthenticationMethodSecurityLake$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodSecurityLake> =
    CreateOutputAuthenticationMethodSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationMethodSecurityLake$ {
  /** @deprecated use `CreateOutputAuthenticationMethodSecurityLake$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputAuthenticationMethodSecurityLake$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationMethodSecurityLake$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationMethodSecurityLake$outboundSchema;
}

/** @internal */
export const CreateOutputSignatureVersionSecurityLake$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputSignatureVersionSecurityLake> = z
    .nativeEnum(CreateOutputSignatureVersionSecurityLake);

/** @internal */
export const CreateOutputSignatureVersionSecurityLake$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputSignatureVersionSecurityLake> =
    CreateOutputSignatureVersionSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputSignatureVersionSecurityLake$ {
  /** @deprecated use `CreateOutputSignatureVersionSecurityLake$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputSignatureVersionSecurityLake$inboundSchema;
  /** @deprecated use `CreateOutputSignatureVersionSecurityLake$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputSignatureVersionSecurityLake$outboundSchema;
}

/** @internal */
export const ObjectACLSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof ObjectACLSecurityLake
> = z.nativeEnum(ObjectACLSecurityLake);

/** @internal */
export const ObjectACLSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof ObjectACLSecurityLake
> = ObjectACLSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectACLSecurityLake$ {
  /** @deprecated use `ObjectACLSecurityLake$inboundSchema` instead. */
  export const inboundSchema = ObjectACLSecurityLake$inboundSchema;
  /** @deprecated use `ObjectACLSecurityLake$outboundSchema` instead. */
  export const outboundSchema = ObjectACLSecurityLake$outboundSchema;
}

/** @internal */
export const StorageClassSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof StorageClassSecurityLake
> = z.nativeEnum(StorageClassSecurityLake);

/** @internal */
export const StorageClassSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof StorageClassSecurityLake
> = StorageClassSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StorageClassSecurityLake$ {
  /** @deprecated use `StorageClassSecurityLake$inboundSchema` instead. */
  export const inboundSchema = StorageClassSecurityLake$inboundSchema;
  /** @deprecated use `StorageClassSecurityLake$outboundSchema` instead. */
  export const outboundSchema = StorageClassSecurityLake$outboundSchema;
}

/** @internal */
export const ServerSideEncryptionForUploadedObjectsSecurityLake$inboundSchema:
  z.ZodNativeEnum<typeof ServerSideEncryptionForUploadedObjectsSecurityLake> = z
    .nativeEnum(ServerSideEncryptionForUploadedObjectsSecurityLake);

/** @internal */
export const ServerSideEncryptionForUploadedObjectsSecurityLake$outboundSchema:
  z.ZodNativeEnum<typeof ServerSideEncryptionForUploadedObjectsSecurityLake> =
    ServerSideEncryptionForUploadedObjectsSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServerSideEncryptionForUploadedObjectsSecurityLake$ {
  /** @deprecated use `ServerSideEncryptionForUploadedObjectsSecurityLake$inboundSchema` instead. */
  export const inboundSchema =
    ServerSideEncryptionForUploadedObjectsSecurityLake$inboundSchema;
  /** @deprecated use `ServerSideEncryptionForUploadedObjectsSecurityLake$outboundSchema` instead. */
  export const outboundSchema =
    ServerSideEncryptionForUploadedObjectsSecurityLake$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSecurityLake
> = z.nativeEnum(BackpressureBehaviorSecurityLake);

/** @internal */
export const BackpressureBehaviorSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSecurityLake
> = BackpressureBehaviorSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSecurityLake$ {
  /** @deprecated use `BackpressureBehaviorSecurityLake$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSecurityLake$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSecurityLake$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSecurityLake$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionSecurityLake
> = z.nativeEnum(DiskSpaceProtectionSecurityLake);

/** @internal */
export const DiskSpaceProtectionSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionSecurityLake
> = DiskSpaceProtectionSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionSecurityLake$ {
  /** @deprecated use `DiskSpaceProtectionSecurityLake$inboundSchema` instead. */
  export const inboundSchema = DiskSpaceProtectionSecurityLake$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionSecurityLake$outboundSchema` instead. */
  export const outboundSchema = DiskSpaceProtectionSecurityLake$outboundSchema;
}

/** @internal */
export const ParquetVersionSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionSecurityLake
> = z.nativeEnum(ParquetVersionSecurityLake);

/** @internal */
export const ParquetVersionSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionSecurityLake
> = ParquetVersionSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ParquetVersionSecurityLake$ {
  /** @deprecated use `ParquetVersionSecurityLake$inboundSchema` instead. */
  export const inboundSchema = ParquetVersionSecurityLake$inboundSchema;
  /** @deprecated use `ParquetVersionSecurityLake$outboundSchema` instead. */
  export const outboundSchema = ParquetVersionSecurityLake$outboundSchema;
}

/** @internal */
export const DataPageVersionSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionSecurityLake
> = z.nativeEnum(DataPageVersionSecurityLake);

/** @internal */
export const DataPageVersionSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionSecurityLake
> = DataPageVersionSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataPageVersionSecurityLake$ {
  /** @deprecated use `DataPageVersionSecurityLake$inboundSchema` instead. */
  export const inboundSchema = DataPageVersionSecurityLake$inboundSchema;
  /** @deprecated use `DataPageVersionSecurityLake$outboundSchema` instead. */
  export const outboundSchema = DataPageVersionSecurityLake$outboundSchema;
}

/** @internal */
export const KeyValueMetadatumSecurityLake$inboundSchema: z.ZodType<
  KeyValueMetadatumSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type KeyValueMetadatumSecurityLake$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const KeyValueMetadatumSecurityLake$outboundSchema: z.ZodType<
  KeyValueMetadatumSecurityLake$Outbound,
  z.ZodTypeDef,
  KeyValueMetadatumSecurityLake
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KeyValueMetadatumSecurityLake$ {
  /** @deprecated use `KeyValueMetadatumSecurityLake$inboundSchema` instead. */
  export const inboundSchema = KeyValueMetadatumSecurityLake$inboundSchema;
  /** @deprecated use `KeyValueMetadatumSecurityLake$outboundSchema` instead. */
  export const outboundSchema = KeyValueMetadatumSecurityLake$outboundSchema;
  /** @deprecated use `KeyValueMetadatumSecurityLake$Outbound` instead. */
  export type Outbound = KeyValueMetadatumSecurityLake$Outbound;
}

export function keyValueMetadatumSecurityLakeToJSON(
  keyValueMetadatumSecurityLake: KeyValueMetadatumSecurityLake,
): string {
  return JSON.stringify(
    KeyValueMetadatumSecurityLake$outboundSchema.parse(
      keyValueMetadatumSecurityLake,
    ),
  );
}

export function keyValueMetadatumSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<KeyValueMetadatumSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KeyValueMetadatumSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KeyValueMetadatumSecurityLake' from JSON`,
  );
}

/** @internal */
export const OutputSecurityLake$inboundSchema: z.ZodType<
  OutputSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSecurityLake$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod:
    CreateOutputAuthenticationMethodSecurityLake$inboundSchema.default("auto"),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionSecurityLake$inboundSchema
    .default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  objectACL: ObjectACLSecurityLake$inboundSchema.default("private"),
  storageClass: StorageClassSecurityLake$inboundSchema.optional(),
  serverSideEncryption:
    ServerSideEncryptionForUploadedObjectsSecurityLake$inboundSchema.optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  baseFileName: z.string().default("`CriblOut`"),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorSecurityLake$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionSecurityLake$inboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  accountId: z.string(),
  customSource: z.string(),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionSecurityLake$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: DataPageVersionSecurityLake$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumSecurityLake$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  parquetSchema: z.string().optional(),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputSecurityLake$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region: string;
  awsSecretKey?: string | undefined;
  awsAuthenticationMethod: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn: string;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  stagePath: string;
  addIdToStagePath: boolean;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  kmsKeyId?: string | undefined;
  removeEmptyDirs: boolean;
  baseFileName: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  verifyPermissions: boolean;
  maxClosingFilesToBackpressure: number;
  accountId: string;
  customSource: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<KeyValueMetadatumSecurityLake$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  emptyDirCleanupSec: number;
  parquetSchema?: string | undefined;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputSecurityLake$outboundSchema: z.ZodType<
  OutputSecurityLake$Outbound,
  z.ZodTypeDef,
  OutputSecurityLake
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSecurityLake$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod:
    CreateOutputAuthenticationMethodSecurityLake$outboundSchema.default("auto"),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionSecurityLake$outboundSchema
    .default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  objectACL: ObjectACLSecurityLake$outboundSchema.default("private"),
  storageClass: StorageClassSecurityLake$outboundSchema.optional(),
  serverSideEncryption:
    ServerSideEncryptionForUploadedObjectsSecurityLake$outboundSchema
      .optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  baseFileName: z.string().default("`CriblOut`"),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorSecurityLake$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionSecurityLake$outboundSchema
    .default("block"),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  accountId: z.string(),
  customSource: z.string(),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionSecurityLake$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: DataPageVersionSecurityLake$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumSecurityLake$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  parquetSchema: z.string().optional(),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSecurityLake$ {
  /** @deprecated use `OutputSecurityLake$inboundSchema` instead. */
  export const inboundSchema = OutputSecurityLake$inboundSchema;
  /** @deprecated use `OutputSecurityLake$outboundSchema` instead. */
  export const outboundSchema = OutputSecurityLake$outboundSchema;
  /** @deprecated use `OutputSecurityLake$Outbound` instead. */
  export type Outbound = OutputSecurityLake$Outbound;
}

export function outputSecurityLakeToJSON(
  outputSecurityLake: OutputSecurityLake,
): string {
  return JSON.stringify(
    OutputSecurityLake$outboundSchema.parse(outputSecurityLake),
  );
}

export function outputSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<OutputSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSecurityLake' from JSON`,
  );
}

/** @internal */
export const TypeDlS3$inboundSchema: z.ZodNativeEnum<typeof TypeDlS3> = z
  .nativeEnum(TypeDlS3);

/** @internal */
export const TypeDlS3$outboundSchema: z.ZodNativeEnum<typeof TypeDlS3> =
  TypeDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeDlS3$ {
  /** @deprecated use `TypeDlS3$inboundSchema` instead. */
  export const inboundSchema = TypeDlS3$inboundSchema;
  /** @deprecated use `TypeDlS3$outboundSchema` instead. */
  export const outboundSchema = TypeDlS3$outboundSchema;
}

/** @internal */
export const AuthenticationMethodDlS3$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodDlS3
> = z.nativeEnum(AuthenticationMethodDlS3);

/** @internal */
export const AuthenticationMethodDlS3$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodDlS3
> = AuthenticationMethodDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodDlS3$ {
  /** @deprecated use `AuthenticationMethodDlS3$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodDlS3$inboundSchema;
  /** @deprecated use `AuthenticationMethodDlS3$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodDlS3$outboundSchema;
}

/** @internal */
export const SignatureVersionDlS3$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionDlS3
> = z.nativeEnum(SignatureVersionDlS3);

/** @internal */
export const SignatureVersionDlS3$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionDlS3
> = SignatureVersionDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionDlS3$ {
  /** @deprecated use `SignatureVersionDlS3$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionDlS3$inboundSchema;
  /** @deprecated use `SignatureVersionDlS3$outboundSchema` instead. */
  export const outboundSchema = SignatureVersionDlS3$outboundSchema;
}

/** @internal */
export const ObjectACLDlS3$inboundSchema: z.ZodNativeEnum<
  typeof ObjectACLDlS3
> = z.nativeEnum(ObjectACLDlS3);

/** @internal */
export const ObjectACLDlS3$outboundSchema: z.ZodNativeEnum<
  typeof ObjectACLDlS3
> = ObjectACLDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectACLDlS3$ {
  /** @deprecated use `ObjectACLDlS3$inboundSchema` instead. */
  export const inboundSchema = ObjectACLDlS3$inboundSchema;
  /** @deprecated use `ObjectACLDlS3$outboundSchema` instead. */
  export const outboundSchema = ObjectACLDlS3$outboundSchema;
}

/** @internal */
export const StorageClassDlS3$inboundSchema: z.ZodNativeEnum<
  typeof StorageClassDlS3
> = z.nativeEnum(StorageClassDlS3);

/** @internal */
export const StorageClassDlS3$outboundSchema: z.ZodNativeEnum<
  typeof StorageClassDlS3
> = StorageClassDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StorageClassDlS3$ {
  /** @deprecated use `StorageClassDlS3$inboundSchema` instead. */
  export const inboundSchema = StorageClassDlS3$inboundSchema;
  /** @deprecated use `StorageClassDlS3$outboundSchema` instead. */
  export const outboundSchema = StorageClassDlS3$outboundSchema;
}

/** @internal */
export const ServerSideEncryptionForUploadedObjectsDlS3$inboundSchema:
  z.ZodNativeEnum<typeof ServerSideEncryptionForUploadedObjectsDlS3> = z
    .nativeEnum(ServerSideEncryptionForUploadedObjectsDlS3);

/** @internal */
export const ServerSideEncryptionForUploadedObjectsDlS3$outboundSchema:
  z.ZodNativeEnum<typeof ServerSideEncryptionForUploadedObjectsDlS3> =
    ServerSideEncryptionForUploadedObjectsDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServerSideEncryptionForUploadedObjectsDlS3$ {
  /** @deprecated use `ServerSideEncryptionForUploadedObjectsDlS3$inboundSchema` instead. */
  export const inboundSchema =
    ServerSideEncryptionForUploadedObjectsDlS3$inboundSchema;
  /** @deprecated use `ServerSideEncryptionForUploadedObjectsDlS3$outboundSchema` instead. */
  export const outboundSchema =
    ServerSideEncryptionForUploadedObjectsDlS3$outboundSchema;
}

/** @internal */
export const DataFormatDlS3$inboundSchema: z.ZodNativeEnum<
  typeof DataFormatDlS3
> = z.nativeEnum(DataFormatDlS3);

/** @internal */
export const DataFormatDlS3$outboundSchema: z.ZodNativeEnum<
  typeof DataFormatDlS3
> = DataFormatDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFormatDlS3$ {
  /** @deprecated use `DataFormatDlS3$inboundSchema` instead. */
  export const inboundSchema = DataFormatDlS3$inboundSchema;
  /** @deprecated use `DataFormatDlS3$outboundSchema` instead. */
  export const outboundSchema = DataFormatDlS3$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorDlS3$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorDlS3
> = z.nativeEnum(BackpressureBehaviorDlS3);

/** @internal */
export const BackpressureBehaviorDlS3$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorDlS3
> = BackpressureBehaviorDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorDlS3$ {
  /** @deprecated use `BackpressureBehaviorDlS3$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorDlS3$inboundSchema;
  /** @deprecated use `BackpressureBehaviorDlS3$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorDlS3$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionDlS3$inboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionDlS3
> = z.nativeEnum(DiskSpaceProtectionDlS3);

/** @internal */
export const DiskSpaceProtectionDlS3$outboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionDlS3
> = DiskSpaceProtectionDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionDlS3$ {
  /** @deprecated use `DiskSpaceProtectionDlS3$inboundSchema` instead. */
  export const inboundSchema = DiskSpaceProtectionDlS3$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionDlS3$outboundSchema` instead. */
  export const outboundSchema = DiskSpaceProtectionDlS3$outboundSchema;
}

/** @internal */
export const CompressionDlS3$inboundSchema: z.ZodNativeEnum<
  typeof CompressionDlS3
> = z.nativeEnum(CompressionDlS3);

/** @internal */
export const CompressionDlS3$outboundSchema: z.ZodNativeEnum<
  typeof CompressionDlS3
> = CompressionDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionDlS3$ {
  /** @deprecated use `CompressionDlS3$inboundSchema` instead. */
  export const inboundSchema = CompressionDlS3$inboundSchema;
  /** @deprecated use `CompressionDlS3$outboundSchema` instead. */
  export const outboundSchema = CompressionDlS3$outboundSchema;
}

/** @internal */
export const CompressionLevelDlS3$inboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelDlS3
> = z.nativeEnum(CompressionLevelDlS3);

/** @internal */
export const CompressionLevelDlS3$outboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelDlS3
> = CompressionLevelDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionLevelDlS3$ {
  /** @deprecated use `CompressionLevelDlS3$inboundSchema` instead. */
  export const inboundSchema = CompressionLevelDlS3$inboundSchema;
  /** @deprecated use `CompressionLevelDlS3$outboundSchema` instead. */
  export const outboundSchema = CompressionLevelDlS3$outboundSchema;
}

/** @internal */
export const ParquetVersionDlS3$inboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionDlS3
> = z.nativeEnum(ParquetVersionDlS3);

/** @internal */
export const ParquetVersionDlS3$outboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionDlS3
> = ParquetVersionDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ParquetVersionDlS3$ {
  /** @deprecated use `ParquetVersionDlS3$inboundSchema` instead. */
  export const inboundSchema = ParquetVersionDlS3$inboundSchema;
  /** @deprecated use `ParquetVersionDlS3$outboundSchema` instead. */
  export const outboundSchema = ParquetVersionDlS3$outboundSchema;
}

/** @internal */
export const DataPageVersionDlS3$inboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionDlS3
> = z.nativeEnum(DataPageVersionDlS3);

/** @internal */
export const DataPageVersionDlS3$outboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionDlS3
> = DataPageVersionDlS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataPageVersionDlS3$ {
  /** @deprecated use `DataPageVersionDlS3$inboundSchema` instead. */
  export const inboundSchema = DataPageVersionDlS3$inboundSchema;
  /** @deprecated use `DataPageVersionDlS3$outboundSchema` instead. */
  export const outboundSchema = DataPageVersionDlS3$outboundSchema;
}

/** @internal */
export const KeyValueMetadatumDlS3$inboundSchema: z.ZodType<
  KeyValueMetadatumDlS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type KeyValueMetadatumDlS3$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const KeyValueMetadatumDlS3$outboundSchema: z.ZodType<
  KeyValueMetadatumDlS3$Outbound,
  z.ZodTypeDef,
  KeyValueMetadatumDlS3
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KeyValueMetadatumDlS3$ {
  /** @deprecated use `KeyValueMetadatumDlS3$inboundSchema` instead. */
  export const inboundSchema = KeyValueMetadatumDlS3$inboundSchema;
  /** @deprecated use `KeyValueMetadatumDlS3$outboundSchema` instead. */
  export const outboundSchema = KeyValueMetadatumDlS3$outboundSchema;
  /** @deprecated use `KeyValueMetadatumDlS3$Outbound` instead. */
  export type Outbound = KeyValueMetadatumDlS3$Outbound;
}

export function keyValueMetadatumDlS3ToJSON(
  keyValueMetadatumDlS3: KeyValueMetadatumDlS3,
): string {
  return JSON.stringify(
    KeyValueMetadatumDlS3$outboundSchema.parse(keyValueMetadatumDlS3),
  );
}

export function keyValueMetadatumDlS3FromJSON(
  jsonString: string,
): SafeParseResult<KeyValueMetadatumDlS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KeyValueMetadatumDlS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KeyValueMetadatumDlS3' from JSON`,
  );
}

/** @internal */
export const OutputDlS3$inboundSchema: z.ZodType<
  OutputDlS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeDlS3$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: AuthenticationMethodDlS3$inboundSchema.default(
    "auto",
  ),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionDlS3$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: ObjectACLDlS3$inboundSchema.default("private"),
  storageClass: StorageClassDlS3$inboundSchema.optional(),
  serverSideEncryption: ServerSideEncryptionForUploadedObjectsDlS3$inboundSchema
    .optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  format: DataFormatDlS3$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorDlS3$inboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionDlS3$inboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  partitioningFields: z.array(z.string()).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: CompressionDlS3$inboundSchema.default("gzip"),
  compressionLevel: CompressionLevelDlS3$inboundSchema.default("best_speed"),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionDlS3$inboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: DataPageVersionDlS3$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(z.lazy(() => KeyValueMetadatumDlS3$inboundSchema))
    .optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputDlS3$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region?: string | undefined;
  awsSecretKey?: string | undefined;
  awsAuthenticationMethod: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  stagePath: string;
  addIdToStagePath: boolean;
  destPath: string;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  kmsKeyId?: string | undefined;
  removeEmptyDirs: boolean;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  verifyPermissions: boolean;
  maxClosingFilesToBackpressure: number;
  partitioningFields?: Array<string> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<KeyValueMetadatumDlS3$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputDlS3$outboundSchema: z.ZodType<
  OutputDlS3$Outbound,
  z.ZodTypeDef,
  OutputDlS3
> = z.object({
  id: z.string(),
  type: TypeDlS3$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: AuthenticationMethodDlS3$outboundSchema.default(
    "auto",
  ),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionDlS3$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: ObjectACLDlS3$outboundSchema.default("private"),
  storageClass: StorageClassDlS3$outboundSchema.optional(),
  serverSideEncryption:
    ServerSideEncryptionForUploadedObjectsDlS3$outboundSchema.optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  format: DataFormatDlS3$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorDlS3$outboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionDlS3$outboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  partitioningFields: z.array(z.string()).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: CompressionDlS3$outboundSchema.default("gzip"),
  compressionLevel: CompressionLevelDlS3$outboundSchema.default("best_speed"),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionDlS3$outboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: DataPageVersionDlS3$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(z.lazy(() => KeyValueMetadatumDlS3$outboundSchema))
    .optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDlS3$ {
  /** @deprecated use `OutputDlS3$inboundSchema` instead. */
  export const inboundSchema = OutputDlS3$inboundSchema;
  /** @deprecated use `OutputDlS3$outboundSchema` instead. */
  export const outboundSchema = OutputDlS3$outboundSchema;
  /** @deprecated use `OutputDlS3$Outbound` instead. */
  export type Outbound = OutputDlS3$Outbound;
}

export function outputDlS3ToJSON(outputDlS3: OutputDlS3): string {
  return JSON.stringify(OutputDlS3$outboundSchema.parse(outputDlS3));
}

export function outputDlS3FromJSON(
  jsonString: string,
): SafeParseResult<OutputDlS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDlS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDlS3' from JSON`,
  );
}

/** @internal */
export const TypeCrowdstrikeNextGenSiem$inboundSchema: z.ZodNativeEnum<
  typeof TypeCrowdstrikeNextGenSiem
> = z.nativeEnum(TypeCrowdstrikeNextGenSiem);

/** @internal */
export const TypeCrowdstrikeNextGenSiem$outboundSchema: z.ZodNativeEnum<
  typeof TypeCrowdstrikeNextGenSiem
> = TypeCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeCrowdstrikeNextGenSiem$ {
  /** @deprecated use `TypeCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema = TypeCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `TypeCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema = TypeCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderCrowdstrikeNextGenSiem$inboundSchema: z.ZodType<
  ExtraHttpHeaderCrowdstrikeNextGenSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderCrowdstrikeNextGenSiem$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderCrowdstrikeNextGenSiem$outboundSchema: z.ZodType<
  ExtraHttpHeaderCrowdstrikeNextGenSiem$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderCrowdstrikeNextGenSiem
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderCrowdstrikeNextGenSiem$ {
  /** @deprecated use `ExtraHttpHeaderCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    ExtraHttpHeaderCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    ExtraHttpHeaderCrowdstrikeNextGenSiem$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderCrowdstrikeNextGenSiem$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderCrowdstrikeNextGenSiem$Outbound;
}

export function extraHttpHeaderCrowdstrikeNextGenSiemToJSON(
  extraHttpHeaderCrowdstrikeNextGenSiem: ExtraHttpHeaderCrowdstrikeNextGenSiem,
): string {
  return JSON.stringify(
    ExtraHttpHeaderCrowdstrikeNextGenSiem$outboundSchema.parse(
      extraHttpHeaderCrowdstrikeNextGenSiem,
    ),
  );
}

export function extraHttpHeaderCrowdstrikeNextGenSiemFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderCrowdstrikeNextGenSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ExtraHttpHeaderCrowdstrikeNextGenSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderCrowdstrikeNextGenSiem' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeCrowdstrikeNextGenSiem$inboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeCrowdstrikeNextGenSiem> = z
    .nativeEnum(FailedRequestLoggingModeCrowdstrikeNextGenSiem);

/** @internal */
export const FailedRequestLoggingModeCrowdstrikeNextGenSiem$outboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeCrowdstrikeNextGenSiem> =
    FailedRequestLoggingModeCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeCrowdstrikeNextGenSiem$ {
  /** @deprecated use `FailedRequestLoggingModeCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    FailedRequestLoggingModeCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const RequestFormatCrowdstrikeNextGenSiem$inboundSchema: z.ZodNativeEnum<
  typeof RequestFormatCrowdstrikeNextGenSiem
> = z.nativeEnum(RequestFormatCrowdstrikeNextGenSiem);

/** @internal */
export const RequestFormatCrowdstrikeNextGenSiem$outboundSchema:
  z.ZodNativeEnum<typeof RequestFormatCrowdstrikeNextGenSiem> =
    RequestFormatCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestFormatCrowdstrikeNextGenSiem$ {
  /** @deprecated use `RequestFormatCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    RequestFormatCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `RequestFormatCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    RequestFormatCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const AuthenticationMethodCrowdstrikeNextGenSiem$inboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodCrowdstrikeNextGenSiem> = z
    .nativeEnum(AuthenticationMethodCrowdstrikeNextGenSiem);

/** @internal */
export const AuthenticationMethodCrowdstrikeNextGenSiem$outboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodCrowdstrikeNextGenSiem> =
    AuthenticationMethodCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodCrowdstrikeNextGenSiem$ {
  /** @deprecated use `AuthenticationMethodCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    AuthenticationMethodCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `AuthenticationMethodCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingCrowdstrikeNextGenSiem$inboundSchema:
  z.ZodType<ResponseRetrySettingCrowdstrikeNextGenSiem, z.ZodTypeDef, unknown> =
    z.object({
      httpStatus: z.number(),
      initialBackoff: z.number().default(1000),
      backoffRate: z.number().default(2),
      maxBackoff: z.number().default(10000),
    });

/** @internal */
export type ResponseRetrySettingCrowdstrikeNextGenSiem$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingCrowdstrikeNextGenSiem$outboundSchema:
  z.ZodType<
    ResponseRetrySettingCrowdstrikeNextGenSiem$Outbound,
    z.ZodTypeDef,
    ResponseRetrySettingCrowdstrikeNextGenSiem
  > = z.object({
    httpStatus: z.number(),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingCrowdstrikeNextGenSiem$ {
  /** @deprecated use `ResponseRetrySettingCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    ResponseRetrySettingCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `ResponseRetrySettingCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    ResponseRetrySettingCrowdstrikeNextGenSiem$outboundSchema;
  /** @deprecated use `ResponseRetrySettingCrowdstrikeNextGenSiem$Outbound` instead. */
  export type Outbound = ResponseRetrySettingCrowdstrikeNextGenSiem$Outbound;
}

export function responseRetrySettingCrowdstrikeNextGenSiemToJSON(
  responseRetrySettingCrowdstrikeNextGenSiem:
    ResponseRetrySettingCrowdstrikeNextGenSiem,
): string {
  return JSON.stringify(
    ResponseRetrySettingCrowdstrikeNextGenSiem$outboundSchema.parse(
      responseRetrySettingCrowdstrikeNextGenSiem,
    ),
  );
}

export function responseRetrySettingCrowdstrikeNextGenSiemFromJSON(
  jsonString: string,
): SafeParseResult<
  ResponseRetrySettingCrowdstrikeNextGenSiem,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ResponseRetrySettingCrowdstrikeNextGenSiem$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ResponseRetrySettingCrowdstrikeNextGenSiem' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsCrowdstrikeNextGenSiem$inboundSchema:
  z.ZodType<TimeoutRetrySettingsCrowdstrikeNextGenSiem, z.ZodTypeDef, unknown> =
    z.object({
      timeoutRetry: z.boolean().default(false),
      initialBackoff: z.number().default(1000),
      backoffRate: z.number().default(2),
      maxBackoff: z.number().default(10000),
    });

/** @internal */
export type TimeoutRetrySettingsCrowdstrikeNextGenSiem$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsCrowdstrikeNextGenSiem$outboundSchema:
  z.ZodType<
    TimeoutRetrySettingsCrowdstrikeNextGenSiem$Outbound,
    z.ZodTypeDef,
    TimeoutRetrySettingsCrowdstrikeNextGenSiem
  > = z.object({
    timeoutRetry: z.boolean().default(false),
    initialBackoff: z.number().default(1000),
    backoffRate: z.number().default(2),
    maxBackoff: z.number().default(10000),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsCrowdstrikeNextGenSiem$ {
  /** @deprecated use `TimeoutRetrySettingsCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    TimeoutRetrySettingsCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    TimeoutRetrySettingsCrowdstrikeNextGenSiem$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsCrowdstrikeNextGenSiem$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsCrowdstrikeNextGenSiem$Outbound;
}

export function timeoutRetrySettingsCrowdstrikeNextGenSiemToJSON(
  timeoutRetrySettingsCrowdstrikeNextGenSiem:
    TimeoutRetrySettingsCrowdstrikeNextGenSiem,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsCrowdstrikeNextGenSiem$outboundSchema.parse(
      timeoutRetrySettingsCrowdstrikeNextGenSiem,
    ),
  );
}

export function timeoutRetrySettingsCrowdstrikeNextGenSiemFromJSON(
  jsonString: string,
): SafeParseResult<
  TimeoutRetrySettingsCrowdstrikeNextGenSiem,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      TimeoutRetrySettingsCrowdstrikeNextGenSiem$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'TimeoutRetrySettingsCrowdstrikeNextGenSiem' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorCrowdstrikeNextGenSiem$inboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorCrowdstrikeNextGenSiem> = z
    .nativeEnum(BackpressureBehaviorCrowdstrikeNextGenSiem);

/** @internal */
export const BackpressureBehaviorCrowdstrikeNextGenSiem$outboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorCrowdstrikeNextGenSiem> =
    BackpressureBehaviorCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorCrowdstrikeNextGenSiem$ {
  /** @deprecated use `BackpressureBehaviorCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    BackpressureBehaviorCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `BackpressureBehaviorCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const CompressionCrowdstrikeNextGenSiem$inboundSchema: z.ZodNativeEnum<
  typeof CompressionCrowdstrikeNextGenSiem
> = z.nativeEnum(CompressionCrowdstrikeNextGenSiem);

/** @internal */
export const CompressionCrowdstrikeNextGenSiem$outboundSchema: z.ZodNativeEnum<
  typeof CompressionCrowdstrikeNextGenSiem
> = CompressionCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionCrowdstrikeNextGenSiem$ {
  /** @deprecated use `CompressionCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema = CompressionCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `CompressionCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    CompressionCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorCrowdstrikeNextGenSiem$inboundSchema:
  z.ZodNativeEnum<typeof QueueFullBehaviorCrowdstrikeNextGenSiem> = z
    .nativeEnum(QueueFullBehaviorCrowdstrikeNextGenSiem);

/** @internal */
export const QueueFullBehaviorCrowdstrikeNextGenSiem$outboundSchema:
  z.ZodNativeEnum<typeof QueueFullBehaviorCrowdstrikeNextGenSiem> =
    QueueFullBehaviorCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorCrowdstrikeNextGenSiem$ {
  /** @deprecated use `QueueFullBehaviorCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema =
    QueueFullBehaviorCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `QueueFullBehaviorCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema =
    QueueFullBehaviorCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const ModeCrowdstrikeNextGenSiem$inboundSchema: z.ZodNativeEnum<
  typeof ModeCrowdstrikeNextGenSiem
> = z.nativeEnum(ModeCrowdstrikeNextGenSiem);

/** @internal */
export const ModeCrowdstrikeNextGenSiem$outboundSchema: z.ZodNativeEnum<
  typeof ModeCrowdstrikeNextGenSiem
> = ModeCrowdstrikeNextGenSiem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeCrowdstrikeNextGenSiem$ {
  /** @deprecated use `ModeCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema = ModeCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `ModeCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema = ModeCrowdstrikeNextGenSiem$outboundSchema;
}

/** @internal */
export const PqControlsCrowdstrikeNextGenSiem$inboundSchema: z.ZodType<
  PqControlsCrowdstrikeNextGenSiem,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsCrowdstrikeNextGenSiem$Outbound = {};

/** @internal */
export const PqControlsCrowdstrikeNextGenSiem$outboundSchema: z.ZodType<
  PqControlsCrowdstrikeNextGenSiem$Outbound,
  z.ZodTypeDef,
  PqControlsCrowdstrikeNextGenSiem
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsCrowdstrikeNextGenSiem$ {
  /** @deprecated use `PqControlsCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema = PqControlsCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `PqControlsCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema = PqControlsCrowdstrikeNextGenSiem$outboundSchema;
  /** @deprecated use `PqControlsCrowdstrikeNextGenSiem$Outbound` instead. */
  export type Outbound = PqControlsCrowdstrikeNextGenSiem$Outbound;
}

export function pqControlsCrowdstrikeNextGenSiemToJSON(
  pqControlsCrowdstrikeNextGenSiem: PqControlsCrowdstrikeNextGenSiem,
): string {
  return JSON.stringify(
    PqControlsCrowdstrikeNextGenSiem$outboundSchema.parse(
      pqControlsCrowdstrikeNextGenSiem,
    ),
  );
}

export function pqControlsCrowdstrikeNextGenSiemFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsCrowdstrikeNextGenSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsCrowdstrikeNextGenSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsCrowdstrikeNextGenSiem' from JSON`,
  );
}

/** @internal */
export const OutputCrowdstrikeNextGenSiem$inboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiem,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeCrowdstrikeNextGenSiem$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderCrowdstrikeNextGenSiem$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode:
    FailedRequestLoggingModeCrowdstrikeNextGenSiem$inboundSchema.default(
      "none",
    ),
  safeHeaders: z.array(z.string()).optional(),
  format: RequestFormatCrowdstrikeNextGenSiem$inboundSchema.default("raw"),
  authType: AuthenticationMethodCrowdstrikeNextGenSiem$inboundSchema.default(
    "manual",
  ),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingCrowdstrikeNextGenSiem$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsCrowdstrikeNextGenSiem$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorCrowdstrikeNextGenSiem$inboundSchema
    .default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionCrowdstrikeNextGenSiem$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorCrowdstrikeNextGenSiem$inboundSchema
    .default("block"),
  pqMode: ModeCrowdstrikeNextGenSiem$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsCrowdstrikeNextGenSiem$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputCrowdstrikeNextGenSiem$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<ExtraHttpHeaderCrowdstrikeNextGenSiem$Outbound>
    | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  format: string;
  authType: string;
  responseRetrySettings?:
    | Array<ResponseRetrySettingCrowdstrikeNextGenSiem$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | TimeoutRetrySettingsCrowdstrikeNextGenSiem$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsCrowdstrikeNextGenSiem$Outbound | undefined;
};

/** @internal */
export const OutputCrowdstrikeNextGenSiem$outboundSchema: z.ZodType<
  OutputCrowdstrikeNextGenSiem$Outbound,
  z.ZodTypeDef,
  OutputCrowdstrikeNextGenSiem
> = z.object({
  id: z.string(),
  type: TypeCrowdstrikeNextGenSiem$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderCrowdstrikeNextGenSiem$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode:
    FailedRequestLoggingModeCrowdstrikeNextGenSiem$outboundSchema.default(
      "none",
    ),
  safeHeaders: z.array(z.string()).optional(),
  format: RequestFormatCrowdstrikeNextGenSiem$outboundSchema.default("raw"),
  authType: AuthenticationMethodCrowdstrikeNextGenSiem$outboundSchema.default(
    "manual",
  ),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingCrowdstrikeNextGenSiem$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsCrowdstrikeNextGenSiem$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorCrowdstrikeNextGenSiem$outboundSchema
    .default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionCrowdstrikeNextGenSiem$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorCrowdstrikeNextGenSiem$outboundSchema
    .default("block"),
  pqMode: ModeCrowdstrikeNextGenSiem$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsCrowdstrikeNextGenSiem$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCrowdstrikeNextGenSiem$ {
  /** @deprecated use `OutputCrowdstrikeNextGenSiem$inboundSchema` instead. */
  export const inboundSchema = OutputCrowdstrikeNextGenSiem$inboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiem$outboundSchema` instead. */
  export const outboundSchema = OutputCrowdstrikeNextGenSiem$outboundSchema;
  /** @deprecated use `OutputCrowdstrikeNextGenSiem$Outbound` instead. */
  export type Outbound = OutputCrowdstrikeNextGenSiem$Outbound;
}

export function outputCrowdstrikeNextGenSiemToJSON(
  outputCrowdstrikeNextGenSiem: OutputCrowdstrikeNextGenSiem,
): string {
  return JSON.stringify(
    OutputCrowdstrikeNextGenSiem$outboundSchema.parse(
      outputCrowdstrikeNextGenSiem,
    ),
  );
}

export function outputCrowdstrikeNextGenSiemFromJSON(
  jsonString: string,
): SafeParseResult<OutputCrowdstrikeNextGenSiem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputCrowdstrikeNextGenSiem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputCrowdstrikeNextGenSiem' from JSON`,
  );
}

/** @internal */
export const TypeHumioHec$inboundSchema: z.ZodNativeEnum<typeof TypeHumioHec> =
  z.nativeEnum(TypeHumioHec);

/** @internal */
export const TypeHumioHec$outboundSchema: z.ZodNativeEnum<typeof TypeHumioHec> =
  TypeHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeHumioHec$ {
  /** @deprecated use `TypeHumioHec$inboundSchema` instead. */
  export const inboundSchema = TypeHumioHec$inboundSchema;
  /** @deprecated use `TypeHumioHec$outboundSchema` instead. */
  export const outboundSchema = TypeHumioHec$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderHumioHec$inboundSchema: z.ZodType<
  ExtraHttpHeaderHumioHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderHumioHec$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderHumioHec$outboundSchema: z.ZodType<
  ExtraHttpHeaderHumioHec$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderHumioHec
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderHumioHec$ {
  /** @deprecated use `ExtraHttpHeaderHumioHec$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderHumioHec$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderHumioHec$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderHumioHec$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderHumioHec$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderHumioHec$Outbound;
}

export function extraHttpHeaderHumioHecToJSON(
  extraHttpHeaderHumioHec: ExtraHttpHeaderHumioHec,
): string {
  return JSON.stringify(
    ExtraHttpHeaderHumioHec$outboundSchema.parse(extraHttpHeaderHumioHec),
  );
}

export function extraHttpHeaderHumioHecFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderHumioHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderHumioHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderHumioHec' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeHumioHec$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeHumioHec
> = z.nativeEnum(FailedRequestLoggingModeHumioHec);

/** @internal */
export const FailedRequestLoggingModeHumioHec$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeHumioHec
> = FailedRequestLoggingModeHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeHumioHec$ {
  /** @deprecated use `FailedRequestLoggingModeHumioHec$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeHumioHec$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeHumioHec$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingModeHumioHec$outboundSchema;
}

/** @internal */
export const RequestFormatHumioHec$inboundSchema: z.ZodNativeEnum<
  typeof RequestFormatHumioHec
> = z.nativeEnum(RequestFormatHumioHec);

/** @internal */
export const RequestFormatHumioHec$outboundSchema: z.ZodNativeEnum<
  typeof RequestFormatHumioHec
> = RequestFormatHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestFormatHumioHec$ {
  /** @deprecated use `RequestFormatHumioHec$inboundSchema` instead. */
  export const inboundSchema = RequestFormatHumioHec$inboundSchema;
  /** @deprecated use `RequestFormatHumioHec$outboundSchema` instead. */
  export const outboundSchema = RequestFormatHumioHec$outboundSchema;
}

/** @internal */
export const AuthenticationMethodHumioHec$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodHumioHec
> = z.nativeEnum(AuthenticationMethodHumioHec);

/** @internal */
export const AuthenticationMethodHumioHec$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodHumioHec
> = AuthenticationMethodHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodHumioHec$ {
  /** @deprecated use `AuthenticationMethodHumioHec$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodHumioHec$inboundSchema;
  /** @deprecated use `AuthenticationMethodHumioHec$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodHumioHec$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingHumioHec$inboundSchema: z.ZodType<
  ResponseRetrySettingHumioHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingHumioHec$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingHumioHec$outboundSchema: z.ZodType<
  ResponseRetrySettingHumioHec$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingHumioHec
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingHumioHec$ {
  /** @deprecated use `ResponseRetrySettingHumioHec$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingHumioHec$inboundSchema;
  /** @deprecated use `ResponseRetrySettingHumioHec$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingHumioHec$outboundSchema;
  /** @deprecated use `ResponseRetrySettingHumioHec$Outbound` instead. */
  export type Outbound = ResponseRetrySettingHumioHec$Outbound;
}

export function responseRetrySettingHumioHecToJSON(
  responseRetrySettingHumioHec: ResponseRetrySettingHumioHec,
): string {
  return JSON.stringify(
    ResponseRetrySettingHumioHec$outboundSchema.parse(
      responseRetrySettingHumioHec,
    ),
  );
}

export function responseRetrySettingHumioHecFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingHumioHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingHumioHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingHumioHec' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsHumioHec$inboundSchema: z.ZodType<
  TimeoutRetrySettingsHumioHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsHumioHec$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsHumioHec$outboundSchema: z.ZodType<
  TimeoutRetrySettingsHumioHec$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsHumioHec
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsHumioHec$ {
  /** @deprecated use `TimeoutRetrySettingsHumioHec$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsHumioHec$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsHumioHec$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsHumioHec$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsHumioHec$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsHumioHec$Outbound;
}

export function timeoutRetrySettingsHumioHecToJSON(
  timeoutRetrySettingsHumioHec: TimeoutRetrySettingsHumioHec,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsHumioHec$outboundSchema.parse(
      timeoutRetrySettingsHumioHec,
    ),
  );
}

export function timeoutRetrySettingsHumioHecFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsHumioHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsHumioHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsHumioHec' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorHumioHec$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorHumioHec
> = z.nativeEnum(BackpressureBehaviorHumioHec);

/** @internal */
export const BackpressureBehaviorHumioHec$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorHumioHec
> = BackpressureBehaviorHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorHumioHec$ {
  /** @deprecated use `BackpressureBehaviorHumioHec$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorHumioHec$inboundSchema;
  /** @deprecated use `BackpressureBehaviorHumioHec$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorHumioHec$outboundSchema;
}

/** @internal */
export const CompressionHumioHec$inboundSchema: z.ZodNativeEnum<
  typeof CompressionHumioHec
> = z.nativeEnum(CompressionHumioHec);

/** @internal */
export const CompressionHumioHec$outboundSchema: z.ZodNativeEnum<
  typeof CompressionHumioHec
> = CompressionHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionHumioHec$ {
  /** @deprecated use `CompressionHumioHec$inboundSchema` instead. */
  export const inboundSchema = CompressionHumioHec$inboundSchema;
  /** @deprecated use `CompressionHumioHec$outboundSchema` instead. */
  export const outboundSchema = CompressionHumioHec$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorHumioHec$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorHumioHec
> = z.nativeEnum(QueueFullBehaviorHumioHec);

/** @internal */
export const QueueFullBehaviorHumioHec$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorHumioHec
> = QueueFullBehaviorHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorHumioHec$ {
  /** @deprecated use `QueueFullBehaviorHumioHec$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorHumioHec$inboundSchema;
  /** @deprecated use `QueueFullBehaviorHumioHec$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorHumioHec$outboundSchema;
}

/** @internal */
export const ModeHumioHec$inboundSchema: z.ZodNativeEnum<typeof ModeHumioHec> =
  z.nativeEnum(ModeHumioHec);

/** @internal */
export const ModeHumioHec$outboundSchema: z.ZodNativeEnum<typeof ModeHumioHec> =
  ModeHumioHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeHumioHec$ {
  /** @deprecated use `ModeHumioHec$inboundSchema` instead. */
  export const inboundSchema = ModeHumioHec$inboundSchema;
  /** @deprecated use `ModeHumioHec$outboundSchema` instead. */
  export const outboundSchema = ModeHumioHec$outboundSchema;
}

/** @internal */
export const PqControlsHumioHec$inboundSchema: z.ZodType<
  PqControlsHumioHec,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsHumioHec$Outbound = {};

/** @internal */
export const PqControlsHumioHec$outboundSchema: z.ZodType<
  PqControlsHumioHec$Outbound,
  z.ZodTypeDef,
  PqControlsHumioHec
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsHumioHec$ {
  /** @deprecated use `PqControlsHumioHec$inboundSchema` instead. */
  export const inboundSchema = PqControlsHumioHec$inboundSchema;
  /** @deprecated use `PqControlsHumioHec$outboundSchema` instead. */
  export const outboundSchema = PqControlsHumioHec$outboundSchema;
  /** @deprecated use `PqControlsHumioHec$Outbound` instead. */
  export type Outbound = PqControlsHumioHec$Outbound;
}

export function pqControlsHumioHecToJSON(
  pqControlsHumioHec: PqControlsHumioHec,
): string {
  return JSON.stringify(
    PqControlsHumioHec$outboundSchema.parse(pqControlsHumioHec),
  );
}

export function pqControlsHumioHecFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsHumioHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsHumioHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsHumioHec' from JSON`,
  );
}

/** @internal */
export const OutputHumioHec$inboundSchema: z.ZodType<
  OutputHumioHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeHumioHec$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string().default("https://cloud.us.humio.com/api/v1/ingest/hec"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeaderHumioHec$inboundSchema))
    .optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode: FailedRequestLoggingModeHumioHec$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  format: RequestFormatHumioHec$inboundSchema.default("JSON"),
  authType: AuthenticationMethodHumioHec$inboundSchema.default("manual"),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingHumioHec$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsHumioHec$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorHumioHec$inboundSchema.default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionHumioHec$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorHumioHec$inboundSchema.default("block"),
  pqMode: ModeHumioHec$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsHumioHec$inboundSchema).optional(),
});

/** @internal */
export type OutputHumioHec$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderHumioHec$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  format: string;
  authType: string;
  responseRetrySettings?:
    | Array<ResponseRetrySettingHumioHec$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsHumioHec$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsHumioHec$Outbound | undefined;
};

/** @internal */
export const OutputHumioHec$outboundSchema: z.ZodType<
  OutputHumioHec$Outbound,
  z.ZodTypeDef,
  OutputHumioHec
> = z.object({
  id: z.string(),
  type: TypeHumioHec$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string().default("https://cloud.us.humio.com/api/v1/ingest/hec"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderHumioHec$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(true),
  failedRequestLoggingMode: FailedRequestLoggingModeHumioHec$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  format: RequestFormatHumioHec$outboundSchema.default("JSON"),
  authType: AuthenticationMethodHumioHec$outboundSchema.default("manual"),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingHumioHec$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsHumioHec$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorHumioHec$outboundSchema.default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionHumioHec$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorHumioHec$outboundSchema.default("block"),
  pqMode: ModeHumioHec$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsHumioHec$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHumioHec$ {
  /** @deprecated use `OutputHumioHec$inboundSchema` instead. */
  export const inboundSchema = OutputHumioHec$inboundSchema;
  /** @deprecated use `OutputHumioHec$outboundSchema` instead. */
  export const outboundSchema = OutputHumioHec$outboundSchema;
  /** @deprecated use `OutputHumioHec$Outbound` instead. */
  export type Outbound = OutputHumioHec$Outbound;
}

export function outputHumioHecToJSON(outputHumioHec: OutputHumioHec): string {
  return JSON.stringify(OutputHumioHec$outboundSchema.parse(outputHumioHec));
}

export function outputHumioHecFromJSON(
  jsonString: string,
): SafeParseResult<OutputHumioHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHumioHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHumioHec' from JSON`,
  );
}

/** @internal */
export const TypeServiceNow$inboundSchema: z.ZodNativeEnum<
  typeof TypeServiceNow
> = z.nativeEnum(TypeServiceNow);

/** @internal */
export const TypeServiceNow$outboundSchema: z.ZodNativeEnum<
  typeof TypeServiceNow
> = TypeServiceNow$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeServiceNow$ {
  /** @deprecated use `TypeServiceNow$inboundSchema` instead. */
  export const inboundSchema = TypeServiceNow$inboundSchema;
  /** @deprecated use `TypeServiceNow$outboundSchema` instead. */
  export const outboundSchema = TypeServiceNow$outboundSchema;
}

/** @internal */
export const OTLPVersion131$inboundSchema: z.ZodNativeEnum<
  typeof OTLPVersion131
> = z.nativeEnum(OTLPVersion131);

/** @internal */
export const OTLPVersion131$outboundSchema: z.ZodNativeEnum<
  typeof OTLPVersion131
> = OTLPVersion131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OTLPVersion131$ {
  /** @deprecated use `OTLPVersion131$inboundSchema` instead. */
  export const inboundSchema = OTLPVersion131$inboundSchema;
  /** @deprecated use `OTLPVersion131$outboundSchema` instead. */
  export const outboundSchema = OTLPVersion131$outboundSchema;
}

/** @internal */
export const Protocol131$inboundSchema: z.ZodNativeEnum<typeof Protocol131> = z
  .nativeEnum(Protocol131);

/** @internal */
export const Protocol131$outboundSchema: z.ZodNativeEnum<typeof Protocol131> =
  Protocol131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Protocol131$ {
  /** @deprecated use `Protocol131$inboundSchema` instead. */
  export const inboundSchema = Protocol131$inboundSchema;
  /** @deprecated use `Protocol131$outboundSchema` instead. */
  export const outboundSchema = Protocol131$outboundSchema;
}

/** @internal */
export const CompressCompression131$inboundSchema: z.ZodNativeEnum<
  typeof CompressCompression131
> = z.nativeEnum(CompressCompression131);

/** @internal */
export const CompressCompression131$outboundSchema: z.ZodNativeEnum<
  typeof CompressCompression131
> = CompressCompression131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressCompression131$ {
  /** @deprecated use `CompressCompression131$inboundSchema` instead. */
  export const inboundSchema = CompressCompression131$inboundSchema;
  /** @deprecated use `CompressCompression131$outboundSchema` instead. */
  export const outboundSchema = CompressCompression131$outboundSchema;
}

/** @internal */
export const HttpCompressCompression131$inboundSchema: z.ZodNativeEnum<
  typeof HttpCompressCompression131
> = z.nativeEnum(HttpCompressCompression131);

/** @internal */
export const HttpCompressCompression131$outboundSchema: z.ZodNativeEnum<
  typeof HttpCompressCompression131
> = HttpCompressCompression131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HttpCompressCompression131$ {
  /** @deprecated use `HttpCompressCompression131$inboundSchema` instead. */
  export const inboundSchema = HttpCompressCompression131$inboundSchema;
  /** @deprecated use `HttpCompressCompression131$outboundSchema` instead. */
  export const outboundSchema = HttpCompressCompression131$outboundSchema;
}

/** @internal */
export const Metadatum131$inboundSchema: z.ZodType<
  Metadatum131,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type Metadatum131$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const Metadatum131$outboundSchema: z.ZodType<
  Metadatum131$Outbound,
  z.ZodTypeDef,
  Metadatum131
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Metadatum131$ {
  /** @deprecated use `Metadatum131$inboundSchema` instead. */
  export const inboundSchema = Metadatum131$inboundSchema;
  /** @deprecated use `Metadatum131$outboundSchema` instead. */
  export const outboundSchema = Metadatum131$outboundSchema;
  /** @deprecated use `Metadatum131$Outbound` instead. */
  export type Outbound = Metadatum131$Outbound;
}

export function metadatum131ToJSON(metadatum131: Metadatum131): string {
  return JSON.stringify(Metadatum131$outboundSchema.parse(metadatum131));
}

export function metadatum131FromJSON(
  jsonString: string,
): SafeParseResult<Metadatum131, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadatum131$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadatum131' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingMode131$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingMode131
> = z.nativeEnum(FailedRequestLoggingMode131);

/** @internal */
export const FailedRequestLoggingMode131$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingMode131
> = FailedRequestLoggingMode131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingMode131$ {
  /** @deprecated use `FailedRequestLoggingMode131$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingMode131$inboundSchema;
  /** @deprecated use `FailedRequestLoggingMode131$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingMode131$outboundSchema;
}

/** @internal */
export const BackpressureBehavior131$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehavior131
> = z.nativeEnum(BackpressureBehavior131);

/** @internal */
export const BackpressureBehavior131$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehavior131
> = BackpressureBehavior131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehavior131$ {
  /** @deprecated use `BackpressureBehavior131$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehavior131$inboundSchema;
  /** @deprecated use `BackpressureBehavior131$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehavior131$outboundSchema;
}

/** @internal */
export const ExtraHttpHeader131$inboundSchema: z.ZodType<
  ExtraHttpHeader131,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeader131$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeader131$outboundSchema: z.ZodType<
  ExtraHttpHeader131$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeader131
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeader131$ {
  /** @deprecated use `ExtraHttpHeader131$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeader131$inboundSchema;
  /** @deprecated use `ExtraHttpHeader131$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeader131$outboundSchema;
  /** @deprecated use `ExtraHttpHeader131$Outbound` instead. */
  export type Outbound = ExtraHttpHeader131$Outbound;
}

export function extraHttpHeader131ToJSON(
  extraHttpHeader131: ExtraHttpHeader131,
): string {
  return JSON.stringify(
    ExtraHttpHeader131$outboundSchema.parse(extraHttpHeader131),
  );
}

export function extraHttpHeader131FromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeader131, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeader131$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeader131' from JSON`,
  );
}

/** @internal */
export const ResponseRetrySetting131$inboundSchema: z.ZodType<
  ResponseRetrySetting131,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySetting131$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySetting131$outboundSchema: z.ZodType<
  ResponseRetrySetting131$Outbound,
  z.ZodTypeDef,
  ResponseRetrySetting131
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySetting131$ {
  /** @deprecated use `ResponseRetrySetting131$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySetting131$inboundSchema;
  /** @deprecated use `ResponseRetrySetting131$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySetting131$outboundSchema;
  /** @deprecated use `ResponseRetrySetting131$Outbound` instead. */
  export type Outbound = ResponseRetrySetting131$Outbound;
}

export function responseRetrySetting131ToJSON(
  responseRetrySetting131: ResponseRetrySetting131,
): string {
  return JSON.stringify(
    ResponseRetrySetting131$outboundSchema.parse(responseRetrySetting131),
  );
}

export function responseRetrySetting131FromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySetting131, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySetting131$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySetting131' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettings131$inboundSchema: z.ZodType<
  TimeoutRetrySettings131,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettings131$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettings131$outboundSchema: z.ZodType<
  TimeoutRetrySettings131$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettings131
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettings131$ {
  /** @deprecated use `TimeoutRetrySettings131$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettings131$inboundSchema;
  /** @deprecated use `TimeoutRetrySettings131$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettings131$outboundSchema;
  /** @deprecated use `TimeoutRetrySettings131$Outbound` instead. */
  export type Outbound = TimeoutRetrySettings131$Outbound;
}

export function timeoutRetrySettings131ToJSON(
  timeoutRetrySettings131: TimeoutRetrySettings131,
): string {
  return JSON.stringify(
    TimeoutRetrySettings131$outboundSchema.parse(timeoutRetrySettings131),
  );
}

export function timeoutRetrySettings131FromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettings131, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettings131$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettings131' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersion131$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersion131
> = z.nativeEnum(MinimumTLSVersion131);

/** @internal */
export const MinimumTLSVersion131$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersion131
> = MinimumTLSVersion131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersion131$ {
  /** @deprecated use `MinimumTLSVersion131$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersion131$inboundSchema;
  /** @deprecated use `MinimumTLSVersion131$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersion131$outboundSchema;
}

/** @internal */
export const MaximumTLSVersion131$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersion131
> = z.nativeEnum(MaximumTLSVersion131);

/** @internal */
export const MaximumTLSVersion131$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersion131
> = MaximumTLSVersion131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersion131$ {
  /** @deprecated use `MaximumTLSVersion131$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersion131$inboundSchema;
  /** @deprecated use `MaximumTLSVersion131$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersion131$outboundSchema;
}

/** @internal */
export const TLSSettingsClientSide131$inboundSchema: z.ZodType<
  TLSSettingsClientSide131,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: MinimumTLSVersion131$inboundSchema.optional(),
  maxVersion: MaximumTLSVersion131$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsClientSide131$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsClientSide131$outboundSchema: z.ZodType<
  TLSSettingsClientSide131$Outbound,
  z.ZodTypeDef,
  TLSSettingsClientSide131
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: MinimumTLSVersion131$outboundSchema.optional(),
  maxVersion: MaximumTLSVersion131$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsClientSide131$ {
  /** @deprecated use `TLSSettingsClientSide131$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsClientSide131$inboundSchema;
  /** @deprecated use `TLSSettingsClientSide131$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsClientSide131$outboundSchema;
  /** @deprecated use `TLSSettingsClientSide131$Outbound` instead. */
  export type Outbound = TLSSettingsClientSide131$Outbound;
}

export function tlsSettingsClientSide131ToJSON(
  tlsSettingsClientSide131: TLSSettingsClientSide131,
): string {
  return JSON.stringify(
    TLSSettingsClientSide131$outboundSchema.parse(tlsSettingsClientSide131),
  );
}

export function tlsSettingsClientSide131FromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsClientSide131, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsClientSide131$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsClientSide131' from JSON`,
  );
}

/** @internal */
export const PqCompressCompression131$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompression131
> = z.nativeEnum(PqCompressCompression131);

/** @internal */
export const PqCompressCompression131$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompression131
> = PqCompressCompression131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompression131$ {
  /** @deprecated use `PqCompressCompression131$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompression131$inboundSchema;
  /** @deprecated use `PqCompressCompression131$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompression131$outboundSchema;
}

/** @internal */
export const QueueFullBehavior131$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehavior131
> = z.nativeEnum(QueueFullBehavior131);

/** @internal */
export const QueueFullBehavior131$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehavior131
> = QueueFullBehavior131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehavior131$ {
  /** @deprecated use `QueueFullBehavior131$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehavior131$inboundSchema;
  /** @deprecated use `QueueFullBehavior131$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehavior131$outboundSchema;
}

/** @internal */
export const Mode131$inboundSchema: z.ZodNativeEnum<typeof Mode131> = z
  .nativeEnum(Mode131);

/** @internal */
export const Mode131$outboundSchema: z.ZodNativeEnum<typeof Mode131> =
  Mode131$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Mode131$ {
  /** @deprecated use `Mode131$inboundSchema` instead. */
  export const inboundSchema = Mode131$inboundSchema;
  /** @deprecated use `Mode131$outboundSchema` instead. */
  export const outboundSchema = Mode131$outboundSchema;
}

/** @internal */
export const PqControls131$inboundSchema: z.ZodType<
  PqControls131,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControls131$Outbound = {};

/** @internal */
export const PqControls131$outboundSchema: z.ZodType<
  PqControls131$Outbound,
  z.ZodTypeDef,
  PqControls131
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControls131$ {
  /** @deprecated use `PqControls131$inboundSchema` instead. */
  export const inboundSchema = PqControls131$inboundSchema;
  /** @deprecated use `PqControls131$outboundSchema` instead. */
  export const outboundSchema = PqControls131$outboundSchema;
  /** @deprecated use `PqControls131$Outbound` instead. */
  export type Outbound = PqControls131$Outbound;
}

export function pqControls131ToJSON(pqControls131: PqControls131): string {
  return JSON.stringify(PqControls131$outboundSchema.parse(pqControls131));
}

export function pqControls131FromJSON(
  jsonString: string,
): SafeParseResult<PqControls131, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControls131$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControls131' from JSON`,
  );
}

/** @internal */
export const OutputServiceNow$inboundSchema: z.ZodType<
  OutputServiceNow,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeServiceNow$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string().default("ingest.lightstep.com:443"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("lightstep-access-token"),
  otlpVersion: OTLPVersion131$inboundSchema.default("1.3.1"),
  maxPayloadSizeKB: z.number().default(2048),
  protocol: Protocol131$inboundSchema.default("grpc"),
  compress: CompressCompression131$inboundSchema.default("gzip"),
  httpCompress: HttpCompressCompression131$inboundSchema.default("gzip"),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => Metadatum131$inboundSchema)).optional(),
  concurrency: z.number().default(5),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode: FailedRequestLoggingMode131$inboundSchema.default(
    "none",
  ),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: BackpressureBehavior131$inboundSchema.default("block"),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeader131$inboundSchema))
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySetting131$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettings131$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsClientSide131$inboundSchema).optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompression131$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehavior131$inboundSchema.default("block"),
  pqMode: Mode131$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControls131$inboundSchema).optional(),
});

/** @internal */
export type OutputServiceNow$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  endpoint: string;
  tokenSecret: string;
  authTokenName: string;
  otlpVersion: string;
  maxPayloadSizeKB: number;
  protocol: string;
  compress: string;
  httpCompress: string;
  httpTracesEndpointOverride?: string | undefined;
  httpMetricsEndpointOverride?: string | undefined;
  httpLogsEndpointOverride?: string | undefined;
  metadata?: Array<Metadatum131$Outbound> | undefined;
  concurrency: number;
  timeoutSec: number;
  flushPeriodSec: number;
  failedRequestLoggingMode: string;
  connectionTimeout: number;
  keepAliveTime: number;
  keepAlive: boolean;
  onBackpressure: string;
  description?: string | undefined;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  extraHttpHeaders?: Array<ExtraHttpHeader131$Outbound> | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySetting131$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettings131$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  tls?: TLSSettingsClientSide131$Outbound | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControls131$Outbound | undefined;
};

/** @internal */
export const OutputServiceNow$outboundSchema: z.ZodType<
  OutputServiceNow$Outbound,
  z.ZodTypeDef,
  OutputServiceNow
> = z.object({
  id: z.string(),
  type: TypeServiceNow$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string().default("ingest.lightstep.com:443"),
  tokenSecret: z.string(),
  authTokenName: z.string().default("lightstep-access-token"),
  otlpVersion: OTLPVersion131$outboundSchema.default("1.3.1"),
  maxPayloadSizeKB: z.number().default(2048),
  protocol: Protocol131$outboundSchema.default("grpc"),
  compress: CompressCompression131$outboundSchema.default("gzip"),
  httpCompress: HttpCompressCompression131$outboundSchema.default("gzip"),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(z.lazy(() => Metadatum131$outboundSchema)).optional(),
  concurrency: z.number().default(5),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode: FailedRequestLoggingMode131$outboundSchema.default(
    "none",
  ),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: BackpressureBehavior131$outboundSchema.default("block"),
  description: z.string().optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeader131$outboundSchema))
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySetting131$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettings131$outboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsClientSide131$outboundSchema).optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompression131$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehavior131$outboundSchema.default("block"),
  pqMode: Mode131$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControls131$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputServiceNow$ {
  /** @deprecated use `OutputServiceNow$inboundSchema` instead. */
  export const inboundSchema = OutputServiceNow$inboundSchema;
  /** @deprecated use `OutputServiceNow$outboundSchema` instead. */
  export const outboundSchema = OutputServiceNow$outboundSchema;
  /** @deprecated use `OutputServiceNow$Outbound` instead. */
  export type Outbound = OutputServiceNow$Outbound;
}

export function outputServiceNowToJSON(
  outputServiceNow: OutputServiceNow,
): string {
  return JSON.stringify(
    OutputServiceNow$outboundSchema.parse(outputServiceNow),
  );
}

export function outputServiceNowFromJSON(
  jsonString: string,
): SafeParseResult<OutputServiceNow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputServiceNow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputServiceNow' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeOpenTelemetry
> = z.nativeEnum(CreateOutputTypeOpenTelemetry);

/** @internal */
export const CreateOutputTypeOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeOpenTelemetry
> = CreateOutputTypeOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeOpenTelemetry$ {
  /** @deprecated use `CreateOutputTypeOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputTypeOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputProtocolOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputProtocolOpenTelemetry
> = z.nativeEnum(CreateOutputProtocolOpenTelemetry);

/** @internal */
export const CreateOutputProtocolOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputProtocolOpenTelemetry
> = CreateOutputProtocolOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputProtocolOpenTelemetry$ {
  /** @deprecated use `CreateOutputProtocolOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateOutputProtocolOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputProtocolOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputProtocolOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputOTLPVersionOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputOTLPVersionOpenTelemetry> = z.nativeEnum(
    CreateOutputOTLPVersionOpenTelemetry,
  );

/** @internal */
export const CreateOutputOTLPVersionOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputOTLPVersionOpenTelemetry> =
    CreateOutputOTLPVersionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputOTLPVersionOpenTelemetry$ {
  /** @deprecated use `CreateOutputOTLPVersionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputOTLPVersionOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputOTLPVersionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputOTLPVersionOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputCompressCompressionOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputCompressCompressionOpenTelemetry> = z
    .nativeEnum(CreateOutputCompressCompressionOpenTelemetry);

/** @internal */
export const CreateOutputCompressCompressionOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputCompressCompressionOpenTelemetry> =
    CreateOutputCompressCompressionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressCompressionOpenTelemetry$ {
  /** @deprecated use `CreateOutputCompressCompressionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputCompressCompressionOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputCompressCompressionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputCompressCompressionOpenTelemetry$outboundSchema;
}

/** @internal */
export const HttpCompressCompressionOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof HttpCompressCompressionOpenTelemetry> = z.nativeEnum(
    HttpCompressCompressionOpenTelemetry,
  );

/** @internal */
export const HttpCompressCompressionOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof HttpCompressCompressionOpenTelemetry> =
    HttpCompressCompressionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HttpCompressCompressionOpenTelemetry$ {
  /** @deprecated use `HttpCompressCompressionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    HttpCompressCompressionOpenTelemetry$inboundSchema;
  /** @deprecated use `HttpCompressCompressionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    HttpCompressCompressionOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationTypeOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationTypeOpenTelemetry> = z
    .nativeEnum(CreateOutputAuthenticationTypeOpenTelemetry);

/** @internal */
export const CreateOutputAuthenticationTypeOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationTypeOpenTelemetry> =
    CreateOutputAuthenticationTypeOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationTypeOpenTelemetry$ {
  /** @deprecated use `CreateOutputAuthenticationTypeOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputAuthenticationTypeOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationTypeOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationTypeOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputMetadatumOpenTelemetry$inboundSchema: z.ZodType<
  CreateOutputMetadatumOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type CreateOutputMetadatumOpenTelemetry$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const CreateOutputMetadatumOpenTelemetry$outboundSchema: z.ZodType<
  CreateOutputMetadatumOpenTelemetry$Outbound,
  z.ZodTypeDef,
  CreateOutputMetadatumOpenTelemetry
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMetadatumOpenTelemetry$ {
  /** @deprecated use `CreateOutputMetadatumOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateOutputMetadatumOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputMetadatumOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMetadatumOpenTelemetry$outboundSchema;
  /** @deprecated use `CreateOutputMetadatumOpenTelemetry$Outbound` instead. */
  export type Outbound = CreateOutputMetadatumOpenTelemetry$Outbound;
}

export function createOutputMetadatumOpenTelemetryToJSON(
  createOutputMetadatumOpenTelemetry: CreateOutputMetadatumOpenTelemetry,
): string {
  return JSON.stringify(
    CreateOutputMetadatumOpenTelemetry$outboundSchema.parse(
      createOutputMetadatumOpenTelemetry,
    ),
  );
}

export function createOutputMetadatumOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputMetadatumOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputMetadatumOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputMetadatumOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeOpenTelemetry> = z.nativeEnum(
    FailedRequestLoggingModeOpenTelemetry,
  );

/** @internal */
export const FailedRequestLoggingModeOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeOpenTelemetry> =
    FailedRequestLoggingModeOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeOpenTelemetry$ {
  /** @deprecated use `FailedRequestLoggingModeOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    FailedRequestLoggingModeOpenTelemetry$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeOpenTelemetry$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorOpenTelemetry
> = z.nativeEnum(BackpressureBehaviorOpenTelemetry);

/** @internal */
export const BackpressureBehaviorOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorOpenTelemetry
> = BackpressureBehaviorOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorOpenTelemetry$ {
  /** @deprecated use `BackpressureBehaviorOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorOpenTelemetry$inboundSchema;
  /** @deprecated use `BackpressureBehaviorOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputOauthParamOpenTelemetry$inboundSchema: z.ZodType<
  CreateOutputOauthParamOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateOutputOauthParamOpenTelemetry$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CreateOutputOauthParamOpenTelemetry$outboundSchema: z.ZodType<
  CreateOutputOauthParamOpenTelemetry$Outbound,
  z.ZodTypeDef,
  CreateOutputOauthParamOpenTelemetry
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputOauthParamOpenTelemetry$ {
  /** @deprecated use `CreateOutputOauthParamOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputOauthParamOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputOauthParamOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputOauthParamOpenTelemetry$outboundSchema;
  /** @deprecated use `CreateOutputOauthParamOpenTelemetry$Outbound` instead. */
  export type Outbound = CreateOutputOauthParamOpenTelemetry$Outbound;
}

export function createOutputOauthParamOpenTelemetryToJSON(
  createOutputOauthParamOpenTelemetry: CreateOutputOauthParamOpenTelemetry,
): string {
  return JSON.stringify(
    CreateOutputOauthParamOpenTelemetry$outboundSchema.parse(
      createOutputOauthParamOpenTelemetry,
    ),
  );
}

export function createOutputOauthParamOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputOauthParamOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputOauthParamOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputOauthParamOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateOutputOauthHeaderOpenTelemetry$inboundSchema: z.ZodType<
  CreateOutputOauthHeaderOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateOutputOauthHeaderOpenTelemetry$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CreateOutputOauthHeaderOpenTelemetry$outboundSchema: z.ZodType<
  CreateOutputOauthHeaderOpenTelemetry$Outbound,
  z.ZodTypeDef,
  CreateOutputOauthHeaderOpenTelemetry
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputOauthHeaderOpenTelemetry$ {
  /** @deprecated use `CreateOutputOauthHeaderOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputOauthHeaderOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputOauthHeaderOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputOauthHeaderOpenTelemetry$outboundSchema;
  /** @deprecated use `CreateOutputOauthHeaderOpenTelemetry$Outbound` instead. */
  export type Outbound = CreateOutputOauthHeaderOpenTelemetry$Outbound;
}

export function createOutputOauthHeaderOpenTelemetryToJSON(
  createOutputOauthHeaderOpenTelemetry: CreateOutputOauthHeaderOpenTelemetry,
): string {
  return JSON.stringify(
    CreateOutputOauthHeaderOpenTelemetry$outboundSchema.parse(
      createOutputOauthHeaderOpenTelemetry,
    ),
  );
}

export function createOutputOauthHeaderOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputOauthHeaderOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputOauthHeaderOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputOauthHeaderOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const ExtraHttpHeaderOpenTelemetry$inboundSchema: z.ZodType<
  ExtraHttpHeaderOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderOpenTelemetry$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderOpenTelemetry$outboundSchema: z.ZodType<
  ExtraHttpHeaderOpenTelemetry$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderOpenTelemetry
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderOpenTelemetry$ {
  /** @deprecated use `ExtraHttpHeaderOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderOpenTelemetry$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderOpenTelemetry$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderOpenTelemetry$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderOpenTelemetry$Outbound;
}

export function extraHttpHeaderOpenTelemetryToJSON(
  extraHttpHeaderOpenTelemetry: ExtraHttpHeaderOpenTelemetry,
): string {
  return JSON.stringify(
    ExtraHttpHeaderOpenTelemetry$outboundSchema.parse(
      extraHttpHeaderOpenTelemetry,
    ),
  );
}

export function extraHttpHeaderOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const ResponseRetrySettingOpenTelemetry$inboundSchema: z.ZodType<
  ResponseRetrySettingOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingOpenTelemetry$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingOpenTelemetry$outboundSchema: z.ZodType<
  ResponseRetrySettingOpenTelemetry$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingOpenTelemetry
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingOpenTelemetry$ {
  /** @deprecated use `ResponseRetrySettingOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingOpenTelemetry$inboundSchema;
  /** @deprecated use `ResponseRetrySettingOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    ResponseRetrySettingOpenTelemetry$outboundSchema;
  /** @deprecated use `ResponseRetrySettingOpenTelemetry$Outbound` instead. */
  export type Outbound = ResponseRetrySettingOpenTelemetry$Outbound;
}

export function responseRetrySettingOpenTelemetryToJSON(
  responseRetrySettingOpenTelemetry: ResponseRetrySettingOpenTelemetry,
): string {
  return JSON.stringify(
    ResponseRetrySettingOpenTelemetry$outboundSchema.parse(
      responseRetrySettingOpenTelemetry,
    ),
  );
}

export function responseRetrySettingOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsOpenTelemetry$inboundSchema: z.ZodType<
  TimeoutRetrySettingsOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsOpenTelemetry$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsOpenTelemetry$outboundSchema: z.ZodType<
  TimeoutRetrySettingsOpenTelemetry$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsOpenTelemetry
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsOpenTelemetry$ {
  /** @deprecated use `TimeoutRetrySettingsOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsOpenTelemetry$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    TimeoutRetrySettingsOpenTelemetry$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsOpenTelemetry$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsOpenTelemetry$Outbound;
}

export function timeoutRetrySettingsOpenTelemetryToJSON(
  timeoutRetrySettingsOpenTelemetry: TimeoutRetrySettingsOpenTelemetry,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsOpenTelemetry$outboundSchema.parse(
      timeoutRetrySettingsOpenTelemetry,
    ),
  );
}

export function timeoutRetrySettingsOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateOutputMinimumTLSVersionOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMinimumTLSVersionOpenTelemetry> = z
    .nativeEnum(CreateOutputMinimumTLSVersionOpenTelemetry);

/** @internal */
export const CreateOutputMinimumTLSVersionOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMinimumTLSVersionOpenTelemetry> =
    CreateOutputMinimumTLSVersionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMinimumTLSVersionOpenTelemetry$ {
  /** @deprecated use `CreateOutputMinimumTLSVersionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputMinimumTLSVersionOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputMinimumTLSVersionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMinimumTLSVersionOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputMaximumTLSVersionOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMaximumTLSVersionOpenTelemetry> = z
    .nativeEnum(CreateOutputMaximumTLSVersionOpenTelemetry);

/** @internal */
export const CreateOutputMaximumTLSVersionOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMaximumTLSVersionOpenTelemetry> =
    CreateOutputMaximumTLSVersionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMaximumTLSVersionOpenTelemetry$ {
  /** @deprecated use `CreateOutputMaximumTLSVersionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputMaximumTLSVersionOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputMaximumTLSVersionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMaximumTLSVersionOpenTelemetry$outboundSchema;
}

/** @internal */
export const TLSSettingsClientSideOpenTelemetry$inboundSchema: z.ZodType<
  TLSSettingsClientSideOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionOpenTelemetry$inboundSchema
    .optional(),
  maxVersion: CreateOutputMaximumTLSVersionOpenTelemetry$inboundSchema
    .optional(),
});

/** @internal */
export type TLSSettingsClientSideOpenTelemetry$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsClientSideOpenTelemetry$outboundSchema: z.ZodType<
  TLSSettingsClientSideOpenTelemetry$Outbound,
  z.ZodTypeDef,
  TLSSettingsClientSideOpenTelemetry
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionOpenTelemetry$outboundSchema
    .optional(),
  maxVersion: CreateOutputMaximumTLSVersionOpenTelemetry$outboundSchema
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsClientSideOpenTelemetry$ {
  /** @deprecated use `TLSSettingsClientSideOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsClientSideOpenTelemetry$inboundSchema;
  /** @deprecated use `TLSSettingsClientSideOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    TLSSettingsClientSideOpenTelemetry$outboundSchema;
  /** @deprecated use `TLSSettingsClientSideOpenTelemetry$Outbound` instead. */
  export type Outbound = TLSSettingsClientSideOpenTelemetry$Outbound;
}

export function tlsSettingsClientSideOpenTelemetryToJSON(
  tlsSettingsClientSideOpenTelemetry: TLSSettingsClientSideOpenTelemetry,
): string {
  return JSON.stringify(
    TLSSettingsClientSideOpenTelemetry$outboundSchema.parse(
      tlsSettingsClientSideOpenTelemetry,
    ),
  );
}

export function tlsSettingsClientSideOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsClientSideOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TLSSettingsClientSideOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsClientSideOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const PqCompressCompressionOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionOpenTelemetry
> = z.nativeEnum(PqCompressCompressionOpenTelemetry);

/** @internal */
export const PqCompressCompressionOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionOpenTelemetry
> = PqCompressCompressionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionOpenTelemetry$ {
  /** @deprecated use `PqCompressCompressionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionOpenTelemetry$inboundSchema;
  /** @deprecated use `PqCompressCompressionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    PqCompressCompressionOpenTelemetry$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorOpenTelemetry
> = z.nativeEnum(QueueFullBehaviorOpenTelemetry);

/** @internal */
export const QueueFullBehaviorOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorOpenTelemetry
> = QueueFullBehaviorOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorOpenTelemetry$ {
  /** @deprecated use `QueueFullBehaviorOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorOpenTelemetry$inboundSchema;
  /** @deprecated use `QueueFullBehaviorOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateOutputModeOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeOpenTelemetry
> = z.nativeEnum(CreateOutputModeOpenTelemetry);

/** @internal */
export const CreateOutputModeOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeOpenTelemetry
> = CreateOutputModeOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeOpenTelemetry$ {
  /** @deprecated use `CreateOutputModeOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateOutputModeOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeOpenTelemetry$outboundSchema;
}

/** @internal */
export const PqControlsOpenTelemetry$inboundSchema: z.ZodType<
  PqControlsOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsOpenTelemetry$Outbound = {};

/** @internal */
export const PqControlsOpenTelemetry$outboundSchema: z.ZodType<
  PqControlsOpenTelemetry$Outbound,
  z.ZodTypeDef,
  PqControlsOpenTelemetry
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsOpenTelemetry$ {
  /** @deprecated use `PqControlsOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = PqControlsOpenTelemetry$inboundSchema;
  /** @deprecated use `PqControlsOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = PqControlsOpenTelemetry$outboundSchema;
  /** @deprecated use `PqControlsOpenTelemetry$Outbound` instead. */
  export type Outbound = PqControlsOpenTelemetry$Outbound;
}

export function pqControlsOpenTelemetryToJSON(
  pqControlsOpenTelemetry: PqControlsOpenTelemetry,
): string {
  return JSON.stringify(
    PqControlsOpenTelemetry$outboundSchema.parse(pqControlsOpenTelemetry),
  );
}

export function pqControlsOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const OutputOpenTelemetry$inboundSchema: z.ZodType<
  OutputOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeOpenTelemetry$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: CreateOutputProtocolOpenTelemetry$inboundSchema.default("grpc"),
  endpoint: z.string(),
  otlpVersion: CreateOutputOTLPVersionOpenTelemetry$inboundSchema.default(
    "0.10.0",
  ),
  compress: CreateOutputCompressCompressionOpenTelemetry$inboundSchema.default(
    "gzip",
  ),
  httpCompress: HttpCompressCompressionOpenTelemetry$inboundSchema.default(
    "gzip",
  ),
  authType: CreateOutputAuthenticationTypeOpenTelemetry$inboundSchema.default(
    "none",
  ),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(
    z.lazy(() => CreateOutputMetadatumOpenTelemetry$inboundSchema),
  ).optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode: FailedRequestLoggingModeOpenTelemetry$inboundSchema
    .default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: BackpressureBehaviorOpenTelemetry$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => CreateOutputOauthParamOpenTelemetry$inboundSchema),
  ).optional(),
  oauthHeaders: z.array(
    z.lazy(() => CreateOutputOauthHeaderOpenTelemetry$inboundSchema),
  ).optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderOpenTelemetry$inboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingOpenTelemetry$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsOpenTelemetry$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsClientSideOpenTelemetry$inboundSchema)
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionOpenTelemetry$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorOpenTelemetry$inboundSchema.default(
    "block",
  ),
  pqMode: CreateOutputModeOpenTelemetry$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsOpenTelemetry$inboundSchema).optional(),
});

/** @internal */
export type OutputOpenTelemetry$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  endpoint: string;
  otlpVersion: string;
  compress: string;
  httpCompress: string;
  authType: string;
  httpTracesEndpointOverride?: string | undefined;
  httpMetricsEndpointOverride?: string | undefined;
  httpLogsEndpointOverride?: string | undefined;
  metadata?: Array<CreateOutputMetadatumOpenTelemetry$Outbound> | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  timeoutSec: number;
  flushPeriodSec: number;
  failedRequestLoggingMode: string;
  connectionTimeout: number;
  keepAliveTime: number;
  keepAlive: boolean;
  onBackpressure: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<CreateOutputOauthParamOpenTelemetry$Outbound> | undefined;
  oauthHeaders?:
    | Array<CreateOutputOauthHeaderOpenTelemetry$Outbound>
    | undefined;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  extraHttpHeaders?: Array<ExtraHttpHeaderOpenTelemetry$Outbound> | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingOpenTelemetry$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsOpenTelemetry$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  tls?: TLSSettingsClientSideOpenTelemetry$Outbound | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsOpenTelemetry$Outbound | undefined;
};

/** @internal */
export const OutputOpenTelemetry$outboundSchema: z.ZodType<
  OutputOpenTelemetry$Outbound,
  z.ZodTypeDef,
  OutputOpenTelemetry
> = z.object({
  id: z.string(),
  type: CreateOutputTypeOpenTelemetry$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: CreateOutputProtocolOpenTelemetry$outboundSchema.default("grpc"),
  endpoint: z.string(),
  otlpVersion: CreateOutputOTLPVersionOpenTelemetry$outboundSchema.default(
    "0.10.0",
  ),
  compress: CreateOutputCompressCompressionOpenTelemetry$outboundSchema.default(
    "gzip",
  ),
  httpCompress: HttpCompressCompressionOpenTelemetry$outboundSchema.default(
    "gzip",
  ),
  authType: CreateOutputAuthenticationTypeOpenTelemetry$outboundSchema.default(
    "none",
  ),
  httpTracesEndpointOverride: z.string().optional(),
  httpMetricsEndpointOverride: z.string().optional(),
  httpLogsEndpointOverride: z.string().optional(),
  metadata: z.array(
    z.lazy(() => CreateOutputMetadatumOpenTelemetry$outboundSchema),
  ).optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  failedRequestLoggingMode: FailedRequestLoggingModeOpenTelemetry$outboundSchema
    .default("none"),
  connectionTimeout: z.number().default(10000),
  keepAliveTime: z.number().default(30),
  keepAlive: z.boolean().default(true),
  onBackpressure: BackpressureBehaviorOpenTelemetry$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => CreateOutputOauthParamOpenTelemetry$outboundSchema),
  ).optional(),
  oauthHeaders: z.array(
    z.lazy(() => CreateOutputOauthHeaderOpenTelemetry$outboundSchema),
  ).optional(),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderOpenTelemetry$outboundSchema),
  ).optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingOpenTelemetry$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsOpenTelemetry$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsClientSideOpenTelemetry$outboundSchema)
    .optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionOpenTelemetry$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorOpenTelemetry$outboundSchema.default(
    "block",
  ),
  pqMode: CreateOutputModeOpenTelemetry$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsOpenTelemetry$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputOpenTelemetry$ {
  /** @deprecated use `OutputOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = OutputOpenTelemetry$inboundSchema;
  /** @deprecated use `OutputOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = OutputOpenTelemetry$outboundSchema;
  /** @deprecated use `OutputOpenTelemetry$Outbound` instead. */
  export type Outbound = OutputOpenTelemetry$Outbound;
}

export function outputOpenTelemetryToJSON(
  outputOpenTelemetry: OutputOpenTelemetry,
): string {
  return JSON.stringify(
    OutputOpenTelemetry$outboundSchema.parse(outputOpenTelemetry),
  );
}

export function outputOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<OutputOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypePrometheus
> = z.nativeEnum(CreateOutputTypePrometheus);

/** @internal */
export const CreateOutputTypePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypePrometheus
> = CreateOutputTypePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypePrometheus$ {
  /** @deprecated use `CreateOutputTypePrometheus$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypePrometheus$inboundSchema;
  /** @deprecated use `CreateOutputTypePrometheus$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypePrometheus$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderPrometheus$inboundSchema: z.ZodType<
  ExtraHttpHeaderPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderPrometheus$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderPrometheus$outboundSchema: z.ZodType<
  ExtraHttpHeaderPrometheus$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderPrometheus
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderPrometheus$ {
  /** @deprecated use `ExtraHttpHeaderPrometheus$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderPrometheus$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderPrometheus$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderPrometheus$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderPrometheus$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderPrometheus$Outbound;
}

export function extraHttpHeaderPrometheusToJSON(
  extraHttpHeaderPrometheus: ExtraHttpHeaderPrometheus,
): string {
  return JSON.stringify(
    ExtraHttpHeaderPrometheus$outboundSchema.parse(extraHttpHeaderPrometheus),
  );
}

export function extraHttpHeaderPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderPrometheus' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModePrometheus
> = z.nativeEnum(FailedRequestLoggingModePrometheus);

/** @internal */
export const FailedRequestLoggingModePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModePrometheus
> = FailedRequestLoggingModePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModePrometheus$ {
  /** @deprecated use `FailedRequestLoggingModePrometheus$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModePrometheus$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModePrometheus$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModePrometheus$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingPrometheus$inboundSchema: z.ZodType<
  ResponseRetrySettingPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingPrometheus$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingPrometheus$outboundSchema: z.ZodType<
  ResponseRetrySettingPrometheus$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingPrometheus
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingPrometheus$ {
  /** @deprecated use `ResponseRetrySettingPrometheus$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingPrometheus$inboundSchema;
  /** @deprecated use `ResponseRetrySettingPrometheus$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingPrometheus$outboundSchema;
  /** @deprecated use `ResponseRetrySettingPrometheus$Outbound` instead. */
  export type Outbound = ResponseRetrySettingPrometheus$Outbound;
}

export function responseRetrySettingPrometheusToJSON(
  responseRetrySettingPrometheus: ResponseRetrySettingPrometheus,
): string {
  return JSON.stringify(
    ResponseRetrySettingPrometheus$outboundSchema.parse(
      responseRetrySettingPrometheus,
    ),
  );
}

export function responseRetrySettingPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingPrometheus' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsPrometheus$inboundSchema: z.ZodType<
  TimeoutRetrySettingsPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsPrometheus$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsPrometheus$outboundSchema: z.ZodType<
  TimeoutRetrySettingsPrometheus$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsPrometheus
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsPrometheus$ {
  /** @deprecated use `TimeoutRetrySettingsPrometheus$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsPrometheus$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsPrometheus$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsPrometheus$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsPrometheus$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsPrometheus$Outbound;
}

export function timeoutRetrySettingsPrometheusToJSON(
  timeoutRetrySettingsPrometheus: TimeoutRetrySettingsPrometheus,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsPrometheus$outboundSchema.parse(
      timeoutRetrySettingsPrometheus,
    ),
  );
}

export function timeoutRetrySettingsPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsPrometheus' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorPrometheus$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorPrometheus
> = z.nativeEnum(BackpressureBehaviorPrometheus);

/** @internal */
export const BackpressureBehaviorPrometheus$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorPrometheus
> = BackpressureBehaviorPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorPrometheus$ {
  /** @deprecated use `BackpressureBehaviorPrometheus$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorPrometheus$inboundSchema;
  /** @deprecated use `BackpressureBehaviorPrometheus$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorPrometheus$outboundSchema;
}

/** @internal */
export const AuthenticationTypePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypePrometheus
> = z.nativeEnum(AuthenticationTypePrometheus);

/** @internal */
export const AuthenticationTypePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypePrometheus
> = AuthenticationTypePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationTypePrometheus$ {
  /** @deprecated use `AuthenticationTypePrometheus$inboundSchema` instead. */
  export const inboundSchema = AuthenticationTypePrometheus$inboundSchema;
  /** @deprecated use `AuthenticationTypePrometheus$outboundSchema` instead. */
  export const outboundSchema = AuthenticationTypePrometheus$outboundSchema;
}

/** @internal */
export const PqCompressCompressionPrometheus$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionPrometheus
> = z.nativeEnum(PqCompressCompressionPrometheus);

/** @internal */
export const PqCompressCompressionPrometheus$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionPrometheus
> = PqCompressCompressionPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionPrometheus$ {
  /** @deprecated use `PqCompressCompressionPrometheus$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionPrometheus$inboundSchema;
  /** @deprecated use `PqCompressCompressionPrometheus$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionPrometheus$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorPrometheus$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorPrometheus
> = z.nativeEnum(QueueFullBehaviorPrometheus);

/** @internal */
export const QueueFullBehaviorPrometheus$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorPrometheus
> = QueueFullBehaviorPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorPrometheus$ {
  /** @deprecated use `QueueFullBehaviorPrometheus$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorPrometheus$inboundSchema;
  /** @deprecated use `QueueFullBehaviorPrometheus$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorPrometheus$outboundSchema;
}

/** @internal */
export const CreateOutputModePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModePrometheus
> = z.nativeEnum(CreateOutputModePrometheus);

/** @internal */
export const CreateOutputModePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModePrometheus
> = CreateOutputModePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModePrometheus$ {
  /** @deprecated use `CreateOutputModePrometheus$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModePrometheus$inboundSchema;
  /** @deprecated use `CreateOutputModePrometheus$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModePrometheus$outboundSchema;
}

/** @internal */
export const PqControlsPrometheus$inboundSchema: z.ZodType<
  PqControlsPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsPrometheus$Outbound = {};

/** @internal */
export const PqControlsPrometheus$outboundSchema: z.ZodType<
  PqControlsPrometheus$Outbound,
  z.ZodTypeDef,
  PqControlsPrometheus
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsPrometheus$ {
  /** @deprecated use `PqControlsPrometheus$inboundSchema` instead. */
  export const inboundSchema = PqControlsPrometheus$inboundSchema;
  /** @deprecated use `PqControlsPrometheus$outboundSchema` instead. */
  export const outboundSchema = PqControlsPrometheus$outboundSchema;
  /** @deprecated use `PqControlsPrometheus$Outbound` instead. */
  export type Outbound = PqControlsPrometheus$Outbound;
}

export function pqControlsPrometheusToJSON(
  pqControlsPrometheus: PqControlsPrometheus,
): string {
  return JSON.stringify(
    PqControlsPrometheus$outboundSchema.parse(pqControlsPrometheus),
  );
}

export function pqControlsPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsPrometheus' from JSON`,
  );
}

/** @internal */
export const OauthParamPrometheus$inboundSchema: z.ZodType<
  OauthParamPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthParamPrometheus$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthParamPrometheus$outboundSchema: z.ZodType<
  OauthParamPrometheus$Outbound,
  z.ZodTypeDef,
  OauthParamPrometheus
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthParamPrometheus$ {
  /** @deprecated use `OauthParamPrometheus$inboundSchema` instead. */
  export const inboundSchema = OauthParamPrometheus$inboundSchema;
  /** @deprecated use `OauthParamPrometheus$outboundSchema` instead. */
  export const outboundSchema = OauthParamPrometheus$outboundSchema;
  /** @deprecated use `OauthParamPrometheus$Outbound` instead. */
  export type Outbound = OauthParamPrometheus$Outbound;
}

export function oauthParamPrometheusToJSON(
  oauthParamPrometheus: OauthParamPrometheus,
): string {
  return JSON.stringify(
    OauthParamPrometheus$outboundSchema.parse(oauthParamPrometheus),
  );
}

export function oauthParamPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<OauthParamPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthParamPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthParamPrometheus' from JSON`,
  );
}

/** @internal */
export const OauthHeaderPrometheus$inboundSchema: z.ZodType<
  OauthHeaderPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthHeaderPrometheus$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthHeaderPrometheus$outboundSchema: z.ZodType<
  OauthHeaderPrometheus$Outbound,
  z.ZodTypeDef,
  OauthHeaderPrometheus
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthHeaderPrometheus$ {
  /** @deprecated use `OauthHeaderPrometheus$inboundSchema` instead. */
  export const inboundSchema = OauthHeaderPrometheus$inboundSchema;
  /** @deprecated use `OauthHeaderPrometheus$outboundSchema` instead. */
  export const outboundSchema = OauthHeaderPrometheus$outboundSchema;
  /** @deprecated use `OauthHeaderPrometheus$Outbound` instead. */
  export type Outbound = OauthHeaderPrometheus$Outbound;
}

export function oauthHeaderPrometheusToJSON(
  oauthHeaderPrometheus: OauthHeaderPrometheus,
): string {
  return JSON.stringify(
    OauthHeaderPrometheus$outboundSchema.parse(oauthHeaderPrometheus),
  );
}

export function oauthHeaderPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<OauthHeaderPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthHeaderPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthHeaderPrometheus' from JSON`,
  );
}

/** @internal */
export const OutputPrometheus$inboundSchema: z.ZodType<
  OutputPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypePrometheus$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  metricRenameExpr: z.string().default("name.replace(/[^a-zA-Z0-9_]/g, '_')"),
  sendMetadata: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderPrometheus$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModePrometheus$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingPrometheus$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsPrometheus$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorPrometheus$inboundSchema.default("block"),
  authType: AuthenticationTypePrometheus$inboundSchema.default("none"),
  description: z.string().optional(),
  metricsFlushPeriodSec: z.number().default(60),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionPrometheus$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorPrometheus$inboundSchema.default("block"),
  pqMode: CreateOutputModePrometheus$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsPrometheus$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamPrometheus$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderPrometheus$inboundSchema))
    .optional(),
});

/** @internal */
export type OutputPrometheus$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  metricRenameExpr: string;
  sendMetadata: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderPrometheus$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingPrometheus$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsPrometheus$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  metricsFlushPeriodSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsPrometheus$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OauthParamPrometheus$Outbound> | undefined;
  oauthHeaders?: Array<OauthHeaderPrometheus$Outbound> | undefined;
};

/** @internal */
export const OutputPrometheus$outboundSchema: z.ZodType<
  OutputPrometheus$Outbound,
  z.ZodTypeDef,
  OutputPrometheus
> = z.object({
  id: z.string(),
  type: CreateOutputTypePrometheus$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  metricRenameExpr: z.string().default("name.replace(/[^a-zA-Z0-9_]/g, '_')"),
  sendMetadata: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderPrometheus$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModePrometheus$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingPrometheus$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsPrometheus$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorPrometheus$outboundSchema.default(
    "block",
  ),
  authType: AuthenticationTypePrometheus$outboundSchema.default("none"),
  description: z.string().optional(),
  metricsFlushPeriodSec: z.number().default(60),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionPrometheus$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorPrometheus$outboundSchema.default("block"),
  pqMode: CreateOutputModePrometheus$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsPrometheus$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamPrometheus$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderPrometheus$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputPrometheus$ {
  /** @deprecated use `OutputPrometheus$inboundSchema` instead. */
  export const inboundSchema = OutputPrometheus$inboundSchema;
  /** @deprecated use `OutputPrometheus$outboundSchema` instead. */
  export const outboundSchema = OutputPrometheus$outboundSchema;
  /** @deprecated use `OutputPrometheus$Outbound` instead. */
  export type Outbound = OutputPrometheus$Outbound;
}

export function outputPrometheusToJSON(
  outputPrometheus: OutputPrometheus,
): string {
  return JSON.stringify(
    OutputPrometheus$outboundSchema.parse(outputPrometheus),
  );
}

export function outputPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<OutputPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputPrometheus' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeLoki$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeLoki
> = z.nativeEnum(CreateOutputTypeLoki);

/** @internal */
export const CreateOutputTypeLoki$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeLoki
> = CreateOutputTypeLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeLoki$ {
  /** @deprecated use `CreateOutputTypeLoki$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeLoki$inboundSchema;
  /** @deprecated use `CreateOutputTypeLoki$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeLoki$outboundSchema;
}

/** @internal */
export const MessageFormat$inboundSchema: z.ZodNativeEnum<
  typeof MessageFormat
> = z.nativeEnum(MessageFormat);

/** @internal */
export const MessageFormat$outboundSchema: z.ZodNativeEnum<
  typeof MessageFormat
> = MessageFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageFormat$ {
  /** @deprecated use `MessageFormat$inboundSchema` instead. */
  export const inboundSchema = MessageFormat$inboundSchema;
  /** @deprecated use `MessageFormat$outboundSchema` instead. */
  export const outboundSchema = MessageFormat$outboundSchema;
}

/** @internal */
export const Label$inboundSchema: z.ZodType<Label, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string().default(""),
    value: z.string(),
  });

/** @internal */
export type Label$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const Label$outboundSchema: z.ZodType<
  Label$Outbound,
  z.ZodTypeDef,
  Label
> = z.object({
  name: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Label$ {
  /** @deprecated use `Label$inboundSchema` instead. */
  export const inboundSchema = Label$inboundSchema;
  /** @deprecated use `Label$outboundSchema` instead. */
  export const outboundSchema = Label$outboundSchema;
  /** @deprecated use `Label$Outbound` instead. */
  export type Outbound = Label$Outbound;
}

export function labelToJSON(label: Label): string {
  return JSON.stringify(Label$outboundSchema.parse(label));
}

export function labelFromJSON(
  jsonString: string,
): SafeParseResult<Label, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Label$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Label' from JSON`,
  );
}

/** @internal */
export const CreateOutputAuthenticationTypeLoki$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAuthenticationTypeLoki
> = z.nativeEnum(CreateOutputAuthenticationTypeLoki);

/** @internal */
export const CreateOutputAuthenticationTypeLoki$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAuthenticationTypeLoki
> = CreateOutputAuthenticationTypeLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationTypeLoki$ {
  /** @deprecated use `CreateOutputAuthenticationTypeLoki$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthenticationTypeLoki$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationTypeLoki$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationTypeLoki$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderLoki$inboundSchema: z.ZodType<
  ExtraHttpHeaderLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderLoki$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderLoki$outboundSchema: z.ZodType<
  ExtraHttpHeaderLoki$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderLoki
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderLoki$ {
  /** @deprecated use `ExtraHttpHeaderLoki$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderLoki$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderLoki$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderLoki$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderLoki$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderLoki$Outbound;
}

export function extraHttpHeaderLokiToJSON(
  extraHttpHeaderLoki: ExtraHttpHeaderLoki,
): string {
  return JSON.stringify(
    ExtraHttpHeaderLoki$outboundSchema.parse(extraHttpHeaderLoki),
  );
}

export function extraHttpHeaderLokiFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderLoki' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeLoki$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeLoki
> = z.nativeEnum(FailedRequestLoggingModeLoki);

/** @internal */
export const FailedRequestLoggingModeLoki$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeLoki
> = FailedRequestLoggingModeLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeLoki$ {
  /** @deprecated use `FailedRequestLoggingModeLoki$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeLoki$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeLoki$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingModeLoki$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingLoki$inboundSchema: z.ZodType<
  ResponseRetrySettingLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingLoki$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingLoki$outboundSchema: z.ZodType<
  ResponseRetrySettingLoki$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingLoki
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingLoki$ {
  /** @deprecated use `ResponseRetrySettingLoki$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingLoki$inboundSchema;
  /** @deprecated use `ResponseRetrySettingLoki$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingLoki$outboundSchema;
  /** @deprecated use `ResponseRetrySettingLoki$Outbound` instead. */
  export type Outbound = ResponseRetrySettingLoki$Outbound;
}

export function responseRetrySettingLokiToJSON(
  responseRetrySettingLoki: ResponseRetrySettingLoki,
): string {
  return JSON.stringify(
    ResponseRetrySettingLoki$outboundSchema.parse(responseRetrySettingLoki),
  );
}

export function responseRetrySettingLokiFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingLoki' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsLoki$inboundSchema: z.ZodType<
  TimeoutRetrySettingsLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsLoki$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsLoki$outboundSchema: z.ZodType<
  TimeoutRetrySettingsLoki$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsLoki
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsLoki$ {
  /** @deprecated use `TimeoutRetrySettingsLoki$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsLoki$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsLoki$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsLoki$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsLoki$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsLoki$Outbound;
}

export function timeoutRetrySettingsLokiToJSON(
  timeoutRetrySettingsLoki: TimeoutRetrySettingsLoki,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsLoki$outboundSchema.parse(timeoutRetrySettingsLoki),
  );
}

export function timeoutRetrySettingsLokiFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsLoki' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorLoki$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorLoki
> = z.nativeEnum(BackpressureBehaviorLoki);

/** @internal */
export const BackpressureBehaviorLoki$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorLoki
> = BackpressureBehaviorLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorLoki$ {
  /** @deprecated use `BackpressureBehaviorLoki$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorLoki$inboundSchema;
  /** @deprecated use `BackpressureBehaviorLoki$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorLoki$outboundSchema;
}

/** @internal */
export const PqCompressCompressionLoki$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionLoki
> = z.nativeEnum(PqCompressCompressionLoki);

/** @internal */
export const PqCompressCompressionLoki$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionLoki
> = PqCompressCompressionLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionLoki$ {
  /** @deprecated use `PqCompressCompressionLoki$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionLoki$inboundSchema;
  /** @deprecated use `PqCompressCompressionLoki$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionLoki$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorLoki$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorLoki
> = z.nativeEnum(QueueFullBehaviorLoki);

/** @internal */
export const QueueFullBehaviorLoki$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorLoki
> = QueueFullBehaviorLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorLoki$ {
  /** @deprecated use `QueueFullBehaviorLoki$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorLoki$inboundSchema;
  /** @deprecated use `QueueFullBehaviorLoki$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorLoki$outboundSchema;
}

/** @internal */
export const CreateOutputModeLoki$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeLoki
> = z.nativeEnum(CreateOutputModeLoki);

/** @internal */
export const CreateOutputModeLoki$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeLoki
> = CreateOutputModeLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeLoki$ {
  /** @deprecated use `CreateOutputModeLoki$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeLoki$inboundSchema;
  /** @deprecated use `CreateOutputModeLoki$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeLoki$outboundSchema;
}

/** @internal */
export const PqControlsLoki$inboundSchema: z.ZodType<
  PqControlsLoki,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsLoki$Outbound = {};

/** @internal */
export const PqControlsLoki$outboundSchema: z.ZodType<
  PqControlsLoki$Outbound,
  z.ZodTypeDef,
  PqControlsLoki
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsLoki$ {
  /** @deprecated use `PqControlsLoki$inboundSchema` instead. */
  export const inboundSchema = PqControlsLoki$inboundSchema;
  /** @deprecated use `PqControlsLoki$outboundSchema` instead. */
  export const outboundSchema = PqControlsLoki$outboundSchema;
  /** @deprecated use `PqControlsLoki$Outbound` instead. */
  export type Outbound = PqControlsLoki$Outbound;
}

export function pqControlsLokiToJSON(pqControlsLoki: PqControlsLoki): string {
  return JSON.stringify(PqControlsLoki$outboundSchema.parse(pqControlsLoki));
}

export function pqControlsLokiFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsLoki' from JSON`,
  );
}

/** @internal */
export const OutputLoki$inboundSchema: z.ZodType<
  OutputLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeLoki$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  message: z.string().optional(),
  messageFormat: MessageFormat$inboundSchema.default("protobuf"),
  labels: z.array(z.lazy(() => Label$inboundSchema)).optional(),
  authType: CreateOutputAuthenticationTypeLoki$inboundSchema.default("none"),
  concurrency: z.number().default(1),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(15),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeaderLoki$inboundSchema))
    .optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeLoki$inboundSchema.default(
    "none",
  ),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingLoki$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsLoki$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorLoki$inboundSchema.default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  compress: z.boolean().default(true),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionLoki$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorLoki$inboundSchema.default("block"),
  pqMode: CreateOutputModeLoki$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsLoki$inboundSchema).optional(),
});

/** @internal */
export type OutputLoki$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  message?: string | undefined;
  messageFormat: string;
  labels?: Array<Label$Outbound> | undefined;
  authType: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderLoki$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingLoki$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsLoki$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  compress: boolean;
  token?: string | undefined;
  textSecret?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsLoki$Outbound | undefined;
};

/** @internal */
export const OutputLoki$outboundSchema: z.ZodType<
  OutputLoki$Outbound,
  z.ZodTypeDef,
  OutputLoki
> = z.object({
  id: z.string(),
  type: CreateOutputTypeLoki$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  message: z.string().optional(),
  messageFormat: MessageFormat$outboundSchema.default("protobuf"),
  labels: z.array(z.lazy(() => Label$outboundSchema)).optional(),
  authType: CreateOutputAuthenticationTypeLoki$outboundSchema.default("none"),
  concurrency: z.number().default(1),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(15),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeaderLoki$outboundSchema))
    .optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeLoki$outboundSchema.default(
    "none",
  ),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingLoki$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsLoki$outboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorLoki$outboundSchema.default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  compress: z.boolean().default(true),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionLoki$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorLoki$outboundSchema.default("block"),
  pqMode: CreateOutputModeLoki$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsLoki$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputLoki$ {
  /** @deprecated use `OutputLoki$inboundSchema` instead. */
  export const inboundSchema = OutputLoki$inboundSchema;
  /** @deprecated use `OutputLoki$outboundSchema` instead. */
  export const outboundSchema = OutputLoki$outboundSchema;
  /** @deprecated use `OutputLoki$Outbound` instead. */
  export type Outbound = OutputLoki$Outbound;
}

export function outputLokiToJSON(outputLoki: OutputLoki): string {
  return JSON.stringify(OutputLoki$outboundSchema.parse(outputLoki));
}

export function outputLokiFromJSON(
  jsonString: string,
): SafeParseResult<OutputLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputLoki' from JSON`,
  );
}

/** @internal */
export const TypeSumoLogic$inboundSchema: z.ZodNativeEnum<
  typeof TypeSumoLogic
> = z.nativeEnum(TypeSumoLogic);

/** @internal */
export const TypeSumoLogic$outboundSchema: z.ZodNativeEnum<
  typeof TypeSumoLogic
> = TypeSumoLogic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSumoLogic$ {
  /** @deprecated use `TypeSumoLogic$inboundSchema` instead. */
  export const inboundSchema = TypeSumoLogic$inboundSchema;
  /** @deprecated use `TypeSumoLogic$outboundSchema` instead. */
  export const outboundSchema = TypeSumoLogic$outboundSchema;
}

/** @internal */
export const DataFormatSumoLogic$inboundSchema: z.ZodNativeEnum<
  typeof DataFormatSumoLogic
> = z.nativeEnum(DataFormatSumoLogic);

/** @internal */
export const DataFormatSumoLogic$outboundSchema: z.ZodNativeEnum<
  typeof DataFormatSumoLogic
> = DataFormatSumoLogic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFormatSumoLogic$ {
  /** @deprecated use `DataFormatSumoLogic$inboundSchema` instead. */
  export const inboundSchema = DataFormatSumoLogic$inboundSchema;
  /** @deprecated use `DataFormatSumoLogic$outboundSchema` instead. */
  export const outboundSchema = DataFormatSumoLogic$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderSumoLogic$inboundSchema: z.ZodType<
  ExtraHttpHeaderSumoLogic,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderSumoLogic$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderSumoLogic$outboundSchema: z.ZodType<
  ExtraHttpHeaderSumoLogic$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderSumoLogic
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderSumoLogic$ {
  /** @deprecated use `ExtraHttpHeaderSumoLogic$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderSumoLogic$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderSumoLogic$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderSumoLogic$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderSumoLogic$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderSumoLogic$Outbound;
}

export function extraHttpHeaderSumoLogicToJSON(
  extraHttpHeaderSumoLogic: ExtraHttpHeaderSumoLogic,
): string {
  return JSON.stringify(
    ExtraHttpHeaderSumoLogic$outboundSchema.parse(extraHttpHeaderSumoLogic),
  );
}

export function extraHttpHeaderSumoLogicFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderSumoLogic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderSumoLogic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderSumoLogic' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeSumoLogic$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeSumoLogic
> = z.nativeEnum(FailedRequestLoggingModeSumoLogic);

/** @internal */
export const FailedRequestLoggingModeSumoLogic$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeSumoLogic
> = FailedRequestLoggingModeSumoLogic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeSumoLogic$ {
  /** @deprecated use `FailedRequestLoggingModeSumoLogic$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeSumoLogic$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeSumoLogic$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeSumoLogic$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingSumoLogic$inboundSchema: z.ZodType<
  ResponseRetrySettingSumoLogic,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingSumoLogic$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingSumoLogic$outboundSchema: z.ZodType<
  ResponseRetrySettingSumoLogic$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingSumoLogic
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingSumoLogic$ {
  /** @deprecated use `ResponseRetrySettingSumoLogic$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingSumoLogic$inboundSchema;
  /** @deprecated use `ResponseRetrySettingSumoLogic$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingSumoLogic$outboundSchema;
  /** @deprecated use `ResponseRetrySettingSumoLogic$Outbound` instead. */
  export type Outbound = ResponseRetrySettingSumoLogic$Outbound;
}

export function responseRetrySettingSumoLogicToJSON(
  responseRetrySettingSumoLogic: ResponseRetrySettingSumoLogic,
): string {
  return JSON.stringify(
    ResponseRetrySettingSumoLogic$outboundSchema.parse(
      responseRetrySettingSumoLogic,
    ),
  );
}

export function responseRetrySettingSumoLogicFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingSumoLogic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingSumoLogic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingSumoLogic' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsSumoLogic$inboundSchema: z.ZodType<
  TimeoutRetrySettingsSumoLogic,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsSumoLogic$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsSumoLogic$outboundSchema: z.ZodType<
  TimeoutRetrySettingsSumoLogic$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsSumoLogic
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsSumoLogic$ {
  /** @deprecated use `TimeoutRetrySettingsSumoLogic$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsSumoLogic$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSumoLogic$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsSumoLogic$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSumoLogic$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsSumoLogic$Outbound;
}

export function timeoutRetrySettingsSumoLogicToJSON(
  timeoutRetrySettingsSumoLogic: TimeoutRetrySettingsSumoLogic,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsSumoLogic$outboundSchema.parse(
      timeoutRetrySettingsSumoLogic,
    ),
  );
}

export function timeoutRetrySettingsSumoLogicFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsSumoLogic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsSumoLogic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsSumoLogic' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorSumoLogic$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSumoLogic
> = z.nativeEnum(BackpressureBehaviorSumoLogic);

/** @internal */
export const BackpressureBehaviorSumoLogic$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSumoLogic
> = BackpressureBehaviorSumoLogic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSumoLogic$ {
  /** @deprecated use `BackpressureBehaviorSumoLogic$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSumoLogic$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSumoLogic$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSumoLogic$outboundSchema;
}

/** @internal */
export const CompressionSumoLogic$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSumoLogic
> = z.nativeEnum(CompressionSumoLogic);

/** @internal */
export const CompressionSumoLogic$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSumoLogic
> = CompressionSumoLogic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSumoLogic$ {
  /** @deprecated use `CompressionSumoLogic$inboundSchema` instead. */
  export const inboundSchema = CompressionSumoLogic$inboundSchema;
  /** @deprecated use `CompressionSumoLogic$outboundSchema` instead. */
  export const outboundSchema = CompressionSumoLogic$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSumoLogic$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSumoLogic
> = z.nativeEnum(QueueFullBehaviorSumoLogic);

/** @internal */
export const QueueFullBehaviorSumoLogic$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSumoLogic
> = QueueFullBehaviorSumoLogic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSumoLogic$ {
  /** @deprecated use `QueueFullBehaviorSumoLogic$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSumoLogic$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSumoLogic$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorSumoLogic$outboundSchema;
}

/** @internal */
export const ModeSumoLogic$inboundSchema: z.ZodNativeEnum<
  typeof ModeSumoLogic
> = z.nativeEnum(ModeSumoLogic);

/** @internal */
export const ModeSumoLogic$outboundSchema: z.ZodNativeEnum<
  typeof ModeSumoLogic
> = ModeSumoLogic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSumoLogic$ {
  /** @deprecated use `ModeSumoLogic$inboundSchema` instead. */
  export const inboundSchema = ModeSumoLogic$inboundSchema;
  /** @deprecated use `ModeSumoLogic$outboundSchema` instead. */
  export const outboundSchema = ModeSumoLogic$outboundSchema;
}

/** @internal */
export const PqControlsSumoLogic$inboundSchema: z.ZodType<
  PqControlsSumoLogic,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSumoLogic$Outbound = {};

/** @internal */
export const PqControlsSumoLogic$outboundSchema: z.ZodType<
  PqControlsSumoLogic$Outbound,
  z.ZodTypeDef,
  PqControlsSumoLogic
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSumoLogic$ {
  /** @deprecated use `PqControlsSumoLogic$inboundSchema` instead. */
  export const inboundSchema = PqControlsSumoLogic$inboundSchema;
  /** @deprecated use `PqControlsSumoLogic$outboundSchema` instead. */
  export const outboundSchema = PqControlsSumoLogic$outboundSchema;
  /** @deprecated use `PqControlsSumoLogic$Outbound` instead. */
  export type Outbound = PqControlsSumoLogic$Outbound;
}

export function pqControlsSumoLogicToJSON(
  pqControlsSumoLogic: PqControlsSumoLogic,
): string {
  return JSON.stringify(
    PqControlsSumoLogic$outboundSchema.parse(pqControlsSumoLogic),
  );
}

export function pqControlsSumoLogicFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSumoLogic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSumoLogic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSumoLogic' from JSON`,
  );
}

/** @internal */
export const OutputSumoLogic$inboundSchema: z.ZodType<
  OutputSumoLogic,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSumoLogic$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  customSource: z.string().optional(),
  customCategory: z.string().optional(),
  format: DataFormatSumoLogic$inboundSchema.default("json"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderSumoLogic$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeSumoLogic$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSumoLogic$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsSumoLogic$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSumoLogic$inboundSchema.default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSumoLogic$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSumoLogic$inboundSchema.default("block"),
  pqMode: ModeSumoLogic$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSumoLogic$inboundSchema).optional(),
});

/** @internal */
export type OutputSumoLogic$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  customSource?: string | undefined;
  customCategory?: string | undefined;
  format: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderSumoLogic$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingSumoLogic$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsSumoLogic$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSumoLogic$Outbound | undefined;
};

/** @internal */
export const OutputSumoLogic$outboundSchema: z.ZodType<
  OutputSumoLogic$Outbound,
  z.ZodTypeDef,
  OutputSumoLogic
> = z.object({
  id: z.string(),
  type: TypeSumoLogic$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  customSource: z.string().optional(),
  customCategory: z.string().optional(),
  format: DataFormatSumoLogic$outboundSchema.default("json"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderSumoLogic$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeSumoLogic$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSumoLogic$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsSumoLogic$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSumoLogic$outboundSchema.default("block"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSumoLogic$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSumoLogic$outboundSchema.default("block"),
  pqMode: ModeSumoLogic$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSumoLogic$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSumoLogic$ {
  /** @deprecated use `OutputSumoLogic$inboundSchema` instead. */
  export const inboundSchema = OutputSumoLogic$inboundSchema;
  /** @deprecated use `OutputSumoLogic$outboundSchema` instead. */
  export const outboundSchema = OutputSumoLogic$outboundSchema;
  /** @deprecated use `OutputSumoLogic$Outbound` instead. */
  export type Outbound = OutputSumoLogic$Outbound;
}

export function outputSumoLogicToJSON(
  outputSumoLogic: OutputSumoLogic,
): string {
  return JSON.stringify(OutputSumoLogic$outboundSchema.parse(outputSumoLogic));
}

export function outputSumoLogicFromJSON(
  jsonString: string,
): SafeParseResult<OutputSumoLogic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSumoLogic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSumoLogic' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeSnmp$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSnmp
> = z.nativeEnum(CreateOutputTypeSnmp);

/** @internal */
export const CreateOutputTypeSnmp$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSnmp
> = CreateOutputTypeSnmp$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeSnmp$ {
  /** @deprecated use `CreateOutputTypeSnmp$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeSnmp$inboundSchema;
  /** @deprecated use `CreateOutputTypeSnmp$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeSnmp$outboundSchema;
}

/** @internal */
export const HostSnmp$inboundSchema: z.ZodType<
  HostSnmp,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  port: z.number().default(162),
});

/** @internal */
export type HostSnmp$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const HostSnmp$outboundSchema: z.ZodType<
  HostSnmp$Outbound,
  z.ZodTypeDef,
  HostSnmp
> = z.object({
  host: z.string(),
  port: z.number().default(162),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HostSnmp$ {
  /** @deprecated use `HostSnmp$inboundSchema` instead. */
  export const inboundSchema = HostSnmp$inboundSchema;
  /** @deprecated use `HostSnmp$outboundSchema` instead. */
  export const outboundSchema = HostSnmp$outboundSchema;
  /** @deprecated use `HostSnmp$Outbound` instead. */
  export type Outbound = HostSnmp$Outbound;
}

export function hostSnmpToJSON(hostSnmp: HostSnmp): string {
  return JSON.stringify(HostSnmp$outboundSchema.parse(hostSnmp));
}

export function hostSnmpFromJSON(
  jsonString: string,
): SafeParseResult<HostSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HostSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HostSnmp' from JSON`,
  );
}

/** @internal */
export const OutputSnmp$inboundSchema: z.ZodType<
  OutputSnmp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSnmp$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => HostSnmp$inboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/** @internal */
export type OutputSnmp$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  hosts: Array<HostSnmp$Outbound>;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
};

/** @internal */
export const OutputSnmp$outboundSchema: z.ZodType<
  OutputSnmp$Outbound,
  z.ZodTypeDef,
  OutputSnmp
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSnmp$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => HostSnmp$outboundSchema)),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSnmp$ {
  /** @deprecated use `OutputSnmp$inboundSchema` instead. */
  export const inboundSchema = OutputSnmp$inboundSchema;
  /** @deprecated use `OutputSnmp$outboundSchema` instead. */
  export const outboundSchema = OutputSnmp$outboundSchema;
  /** @deprecated use `OutputSnmp$Outbound` instead. */
  export type Outbound = OutputSnmp$Outbound;
}

export function outputSnmpToJSON(outputSnmp: OutputSnmp): string {
  return JSON.stringify(OutputSnmp$outboundSchema.parse(outputSnmp));
}

export function outputSnmpFromJSON(
  jsonString: string,
): SafeParseResult<OutputSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSnmp' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSqs
> = z.nativeEnum(CreateOutputTypeSqs);

/** @internal */
export const CreateOutputTypeSqs$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSqs
> = CreateOutputTypeSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeSqs$ {
  /** @deprecated use `CreateOutputTypeSqs$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeSqs$inboundSchema;
  /** @deprecated use `CreateOutputTypeSqs$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeSqs$outboundSchema;
}

/** @internal */
export const CreateOutputQueueType$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputQueueType
> = z.nativeEnum(CreateOutputQueueType);

/** @internal */
export const CreateOutputQueueType$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputQueueType
> = CreateOutputQueueType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputQueueType$ {
  /** @deprecated use `CreateOutputQueueType$inboundSchema` instead. */
  export const inboundSchema = CreateOutputQueueType$inboundSchema;
  /** @deprecated use `CreateOutputQueueType$outboundSchema` instead. */
  export const outboundSchema = CreateOutputQueueType$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationMethodSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAuthenticationMethodSqs
> = z.nativeEnum(CreateOutputAuthenticationMethodSqs);

/** @internal */
export const CreateOutputAuthenticationMethodSqs$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodSqs> =
    CreateOutputAuthenticationMethodSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationMethodSqs$ {
  /** @deprecated use `CreateOutputAuthenticationMethodSqs$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputAuthenticationMethodSqs$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationMethodSqs$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationMethodSqs$outboundSchema;
}

/** @internal */
export const CreateOutputSignatureVersionSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSignatureVersionSqs
> = z.nativeEnum(CreateOutputSignatureVersionSqs);

/** @internal */
export const CreateOutputSignatureVersionSqs$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSignatureVersionSqs
> = CreateOutputSignatureVersionSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputSignatureVersionSqs$ {
  /** @deprecated use `CreateOutputSignatureVersionSqs$inboundSchema` instead. */
  export const inboundSchema = CreateOutputSignatureVersionSqs$inboundSchema;
  /** @deprecated use `CreateOutputSignatureVersionSqs$outboundSchema` instead. */
  export const outboundSchema = CreateOutputSignatureVersionSqs$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorSqs$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSqs
> = z.nativeEnum(BackpressureBehaviorSqs);

/** @internal */
export const BackpressureBehaviorSqs$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSqs
> = BackpressureBehaviorSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSqs$ {
  /** @deprecated use `BackpressureBehaviorSqs$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSqs$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSqs$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSqs$outboundSchema;
}

/** @internal */
export const PqCompressCompressionSqs$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionSqs
> = z.nativeEnum(PqCompressCompressionSqs);

/** @internal */
export const PqCompressCompressionSqs$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionSqs
> = PqCompressCompressionSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionSqs$ {
  /** @deprecated use `PqCompressCompressionSqs$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionSqs$inboundSchema;
  /** @deprecated use `PqCompressCompressionSqs$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionSqs$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSqs$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSqs
> = z.nativeEnum(QueueFullBehaviorSqs);

/** @internal */
export const QueueFullBehaviorSqs$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSqs
> = QueueFullBehaviorSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSqs$ {
  /** @deprecated use `QueueFullBehaviorSqs$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSqs$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSqs$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorSqs$outboundSchema;
}

/** @internal */
export const CreateOutputModeSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeSqs
> = z.nativeEnum(CreateOutputModeSqs);

/** @internal */
export const CreateOutputModeSqs$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeSqs
> = CreateOutputModeSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeSqs$ {
  /** @deprecated use `CreateOutputModeSqs$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeSqs$inboundSchema;
  /** @deprecated use `CreateOutputModeSqs$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeSqs$outboundSchema;
}

/** @internal */
export const PqControlsSqs$inboundSchema: z.ZodType<
  PqControlsSqs,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSqs$Outbound = {};

/** @internal */
export const PqControlsSqs$outboundSchema: z.ZodType<
  PqControlsSqs$Outbound,
  z.ZodTypeDef,
  PqControlsSqs
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSqs$ {
  /** @deprecated use `PqControlsSqs$inboundSchema` instead. */
  export const inboundSchema = PqControlsSqs$inboundSchema;
  /** @deprecated use `PqControlsSqs$outboundSchema` instead. */
  export const outboundSchema = PqControlsSqs$outboundSchema;
  /** @deprecated use `PqControlsSqs$Outbound` instead. */
  export type Outbound = PqControlsSqs$Outbound;
}

export function pqControlsSqsToJSON(pqControlsSqs: PqControlsSqs): string {
  return JSON.stringify(PqControlsSqs$outboundSchema.parse(pqControlsSqs));
}

export function pqControlsSqsFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSqs' from JSON`,
  );
}

/** @internal */
export const OutputSqs$inboundSchema: z.ZodType<
  OutputSqs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSqs$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  queueName: z.string(),
  queueType: CreateOutputQueueType$inboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  messageGroupId: z.string().default("cribl"),
  createQueue: z.boolean().default(true),
  awsAuthenticationMethod: CreateOutputAuthenticationMethodSqs$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionSqs$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.number().default(1),
  maxInProgress: z.number().default(10),
  onBackpressure: BackpressureBehaviorSqs$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionSqs$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSqs$inboundSchema.default("block"),
  pqMode: CreateOutputModeSqs$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSqs$inboundSchema).optional(),
});

/** @internal */
export type OutputSqs$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  messageGroupId: string;
  createQueue: boolean;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  maxQueueSize: number;
  maxRecordSizeKB: number;
  flushPeriodSec: number;
  maxInProgress: number;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSqs$Outbound | undefined;
};

/** @internal */
export const OutputSqs$outboundSchema: z.ZodType<
  OutputSqs$Outbound,
  z.ZodTypeDef,
  OutputSqs
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSqs$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  queueName: z.string(),
  queueType: CreateOutputQueueType$outboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  messageGroupId: z.string().default("cribl"),
  createQueue: z.boolean().default(true),
  awsAuthenticationMethod: CreateOutputAuthenticationMethodSqs$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionSqs$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.number().default(1),
  maxInProgress: z.number().default(10),
  onBackpressure: BackpressureBehaviorSqs$outboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionSqs$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSqs$outboundSchema.default("block"),
  pqMode: CreateOutputModeSqs$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSqs$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSqs$ {
  /** @deprecated use `OutputSqs$inboundSchema` instead. */
  export const inboundSchema = OutputSqs$inboundSchema;
  /** @deprecated use `OutputSqs$outboundSchema` instead. */
  export const outboundSchema = OutputSqs$outboundSchema;
  /** @deprecated use `OutputSqs$Outbound` instead. */
  export type Outbound = OutputSqs$Outbound;
}

export function outputSqsToJSON(outputSqs: OutputSqs): string {
  return JSON.stringify(OutputSqs$outboundSchema.parse(outputSqs));
}

export function outputSqsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSqs' from JSON`,
  );
}

/** @internal */
export const TypeSns$inboundSchema: z.ZodNativeEnum<typeof TypeSns> = z
  .nativeEnum(TypeSns);

/** @internal */
export const TypeSns$outboundSchema: z.ZodNativeEnum<typeof TypeSns> =
  TypeSns$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSns$ {
  /** @deprecated use `TypeSns$inboundSchema` instead. */
  export const inboundSchema = TypeSns$inboundSchema;
  /** @deprecated use `TypeSns$outboundSchema` instead. */
  export const outboundSchema = TypeSns$outboundSchema;
}

/** @internal */
export const AuthenticationMethodSns$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSns
> = z.nativeEnum(AuthenticationMethodSns);

/** @internal */
export const AuthenticationMethodSns$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSns
> = AuthenticationMethodSns$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodSns$ {
  /** @deprecated use `AuthenticationMethodSns$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodSns$inboundSchema;
  /** @deprecated use `AuthenticationMethodSns$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodSns$outboundSchema;
}

/** @internal */
export const SignatureVersionSns$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionSns
> = z.nativeEnum(SignatureVersionSns);

/** @internal */
export const SignatureVersionSns$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionSns
> = SignatureVersionSns$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionSns$ {
  /** @deprecated use `SignatureVersionSns$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionSns$inboundSchema;
  /** @deprecated use `SignatureVersionSns$outboundSchema` instead. */
  export const outboundSchema = SignatureVersionSns$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorSns$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSns
> = z.nativeEnum(BackpressureBehaviorSns);

/** @internal */
export const BackpressureBehaviorSns$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSns
> = BackpressureBehaviorSns$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSns$ {
  /** @deprecated use `BackpressureBehaviorSns$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSns$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSns$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSns$outboundSchema;
}

/** @internal */
export const CompressionSns$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSns
> = z.nativeEnum(CompressionSns);

/** @internal */
export const CompressionSns$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSns
> = CompressionSns$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSns$ {
  /** @deprecated use `CompressionSns$inboundSchema` instead. */
  export const inboundSchema = CompressionSns$inboundSchema;
  /** @deprecated use `CompressionSns$outboundSchema` instead. */
  export const outboundSchema = CompressionSns$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSns$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSns
> = z.nativeEnum(QueueFullBehaviorSns);

/** @internal */
export const QueueFullBehaviorSns$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSns
> = QueueFullBehaviorSns$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSns$ {
  /** @deprecated use `QueueFullBehaviorSns$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSns$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSns$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorSns$outboundSchema;
}

/** @internal */
export const ModeSns$inboundSchema: z.ZodNativeEnum<typeof ModeSns> = z
  .nativeEnum(ModeSns);

/** @internal */
export const ModeSns$outboundSchema: z.ZodNativeEnum<typeof ModeSns> =
  ModeSns$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSns$ {
  /** @deprecated use `ModeSns$inboundSchema` instead. */
  export const inboundSchema = ModeSns$inboundSchema;
  /** @deprecated use `ModeSns$outboundSchema` instead. */
  export const outboundSchema = ModeSns$outboundSchema;
}

/** @internal */
export const PqControlsSns$inboundSchema: z.ZodType<
  PqControlsSns,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSns$Outbound = {};

/** @internal */
export const PqControlsSns$outboundSchema: z.ZodType<
  PqControlsSns$Outbound,
  z.ZodTypeDef,
  PqControlsSns
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSns$ {
  /** @deprecated use `PqControlsSns$inboundSchema` instead. */
  export const inboundSchema = PqControlsSns$inboundSchema;
  /** @deprecated use `PqControlsSns$outboundSchema` instead. */
  export const outboundSchema = PqControlsSns$outboundSchema;
  /** @deprecated use `PqControlsSns$Outbound` instead. */
  export type Outbound = PqControlsSns$Outbound;
}

export function pqControlsSnsToJSON(pqControlsSns: PqControlsSns): string {
  return JSON.stringify(PqControlsSns$outboundSchema.parse(pqControlsSns));
}

export function pqControlsSnsFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSns' from JSON`,
  );
}

/** @internal */
export const OutputSns$inboundSchema: z.ZodType<
  OutputSns,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSns$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicArn: z.string(),
  messageGroupId: z.string(),
  maxRetries: z.number().optional(),
  awsAuthenticationMethod: AuthenticationMethodSns$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionSns$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  onBackpressure: BackpressureBehaviorSns$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSns$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSns$inboundSchema.default("block"),
  pqMode: ModeSns$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSns$inboundSchema).optional(),
});

/** @internal */
export type OutputSns$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  topicArn: string;
  messageGroupId: string;
  maxRetries?: number | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSns$Outbound | undefined;
};

/** @internal */
export const OutputSns$outboundSchema: z.ZodType<
  OutputSns$Outbound,
  z.ZodTypeDef,
  OutputSns
> = z.object({
  id: z.string(),
  type: TypeSns$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicArn: z.string(),
  messageGroupId: z.string(),
  maxRetries: z.number().optional(),
  awsAuthenticationMethod: AuthenticationMethodSns$outboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionSns$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  onBackpressure: BackpressureBehaviorSns$outboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSns$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSns$outboundSchema.default("block"),
  pqMode: ModeSns$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSns$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSns$ {
  /** @deprecated use `OutputSns$inboundSchema` instead. */
  export const inboundSchema = OutputSns$inboundSchema;
  /** @deprecated use `OutputSns$outboundSchema` instead. */
  export const outboundSchema = OutputSns$outboundSchema;
  /** @deprecated use `OutputSns$Outbound` instead. */
  export type Outbound = OutputSns$Outbound;
}

export function outputSnsToJSON(outputSns: OutputSns): string {
  return JSON.stringify(OutputSns$outboundSchema.parse(outputSns));
}

export function outputSnsFromJSON(
  jsonString: string,
): SafeParseResult<OutputSns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSns' from JSON`,
  );
}

/** @internal */
export const TypeRouter$inboundSchema: z.ZodNativeEnum<typeof TypeRouter> = z
  .nativeEnum(TypeRouter);

/** @internal */
export const TypeRouter$outboundSchema: z.ZodNativeEnum<typeof TypeRouter> =
  TypeRouter$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeRouter$ {
  /** @deprecated use `TypeRouter$inboundSchema` instead. */
  export const inboundSchema = TypeRouter$inboundSchema;
  /** @deprecated use `TypeRouter$outboundSchema` instead. */
  export const outboundSchema = TypeRouter$outboundSchema;
}

/** @internal */
export const CreateOutputRule$inboundSchema: z.ZodType<
  CreateOutputRule,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  output: z.string(),
  description: z.string().optional(),
  final: z.boolean().default(true),
});

/** @internal */
export type CreateOutputRule$Outbound = {
  filter: string;
  output: string;
  description?: string | undefined;
  final: boolean;
};

/** @internal */
export const CreateOutputRule$outboundSchema: z.ZodType<
  CreateOutputRule$Outbound,
  z.ZodTypeDef,
  CreateOutputRule
> = z.object({
  filter: z.string(),
  output: z.string(),
  description: z.string().optional(),
  final: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputRule$ {
  /** @deprecated use `CreateOutputRule$inboundSchema` instead. */
  export const inboundSchema = CreateOutputRule$inboundSchema;
  /** @deprecated use `CreateOutputRule$outboundSchema` instead. */
  export const outboundSchema = CreateOutputRule$outboundSchema;
  /** @deprecated use `CreateOutputRule$Outbound` instead. */
  export type Outbound = CreateOutputRule$Outbound;
}

export function createOutputRuleToJSON(
  createOutputRule: CreateOutputRule,
): string {
  return JSON.stringify(
    CreateOutputRule$outboundSchema.parse(createOutputRule),
  );
}

export function createOutputRuleFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputRule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputRule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputRule' from JSON`,
  );
}

/** @internal */
export const OutputRouter$inboundSchema: z.ZodType<
  OutputRouter,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeRouter$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  rules: z.array(z.lazy(() => CreateOutputRule$inboundSchema)),
  description: z.string().optional(),
});

/** @internal */
export type OutputRouter$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  rules: Array<CreateOutputRule$Outbound>;
  description?: string | undefined;
};

/** @internal */
export const OutputRouter$outboundSchema: z.ZodType<
  OutputRouter$Outbound,
  z.ZodTypeDef,
  OutputRouter
> = z.object({
  id: z.string(),
  type: TypeRouter$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  rules: z.array(z.lazy(() => CreateOutputRule$outboundSchema)),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputRouter$ {
  /** @deprecated use `OutputRouter$inboundSchema` instead. */
  export const inboundSchema = OutputRouter$inboundSchema;
  /** @deprecated use `OutputRouter$outboundSchema` instead. */
  export const outboundSchema = OutputRouter$outboundSchema;
  /** @deprecated use `OutputRouter$Outbound` instead. */
  export type Outbound = OutputRouter$Outbound;
}

export function outputRouterToJSON(outputRouter: OutputRouter): string {
  return JSON.stringify(OutputRouter$outboundSchema.parse(outputRouter));
}

export function outputRouterFromJSON(
  jsonString: string,
): SafeParseResult<OutputRouter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputRouter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputRouter' from JSON`,
  );
}

/** @internal */
export const TypeGraphite$inboundSchema: z.ZodNativeEnum<typeof TypeGraphite> =
  z.nativeEnum(TypeGraphite);

/** @internal */
export const TypeGraphite$outboundSchema: z.ZodNativeEnum<typeof TypeGraphite> =
  TypeGraphite$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeGraphite$ {
  /** @deprecated use `TypeGraphite$inboundSchema` instead. */
  export const inboundSchema = TypeGraphite$inboundSchema;
  /** @deprecated use `TypeGraphite$outboundSchema` instead. */
  export const outboundSchema = TypeGraphite$outboundSchema;
}

/** @internal */
export const DestinationProtocolGraphite$inboundSchema: z.ZodNativeEnum<
  typeof DestinationProtocolGraphite
> = z.nativeEnum(DestinationProtocolGraphite);

/** @internal */
export const DestinationProtocolGraphite$outboundSchema: z.ZodNativeEnum<
  typeof DestinationProtocolGraphite
> = DestinationProtocolGraphite$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DestinationProtocolGraphite$ {
  /** @deprecated use `DestinationProtocolGraphite$inboundSchema` instead. */
  export const inboundSchema = DestinationProtocolGraphite$inboundSchema;
  /** @deprecated use `DestinationProtocolGraphite$outboundSchema` instead. */
  export const outboundSchema = DestinationProtocolGraphite$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorGraphite$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorGraphite
> = z.nativeEnum(BackpressureBehaviorGraphite);

/** @internal */
export const BackpressureBehaviorGraphite$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorGraphite
> = BackpressureBehaviorGraphite$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorGraphite$ {
  /** @deprecated use `BackpressureBehaviorGraphite$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorGraphite$inboundSchema;
  /** @deprecated use `BackpressureBehaviorGraphite$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorGraphite$outboundSchema;
}

/** @internal */
export const CompressionGraphite$inboundSchema: z.ZodNativeEnum<
  typeof CompressionGraphite
> = z.nativeEnum(CompressionGraphite);

/** @internal */
export const CompressionGraphite$outboundSchema: z.ZodNativeEnum<
  typeof CompressionGraphite
> = CompressionGraphite$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionGraphite$ {
  /** @deprecated use `CompressionGraphite$inboundSchema` instead. */
  export const inboundSchema = CompressionGraphite$inboundSchema;
  /** @deprecated use `CompressionGraphite$outboundSchema` instead. */
  export const outboundSchema = CompressionGraphite$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorGraphite$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorGraphite
> = z.nativeEnum(QueueFullBehaviorGraphite);

/** @internal */
export const QueueFullBehaviorGraphite$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorGraphite
> = QueueFullBehaviorGraphite$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorGraphite$ {
  /** @deprecated use `QueueFullBehaviorGraphite$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorGraphite$inboundSchema;
  /** @deprecated use `QueueFullBehaviorGraphite$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorGraphite$outboundSchema;
}

/** @internal */
export const ModeGraphite$inboundSchema: z.ZodNativeEnum<typeof ModeGraphite> =
  z.nativeEnum(ModeGraphite);

/** @internal */
export const ModeGraphite$outboundSchema: z.ZodNativeEnum<typeof ModeGraphite> =
  ModeGraphite$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeGraphite$ {
  /** @deprecated use `ModeGraphite$inboundSchema` instead. */
  export const inboundSchema = ModeGraphite$inboundSchema;
  /** @deprecated use `ModeGraphite$outboundSchema` instead. */
  export const outboundSchema = ModeGraphite$outboundSchema;
}

/** @internal */
export const PqControlsGraphite$inboundSchema: z.ZodType<
  PqControlsGraphite,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsGraphite$Outbound = {};

/** @internal */
export const PqControlsGraphite$outboundSchema: z.ZodType<
  PqControlsGraphite$Outbound,
  z.ZodTypeDef,
  PqControlsGraphite
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsGraphite$ {
  /** @deprecated use `PqControlsGraphite$inboundSchema` instead. */
  export const inboundSchema = PqControlsGraphite$inboundSchema;
  /** @deprecated use `PqControlsGraphite$outboundSchema` instead. */
  export const outboundSchema = PqControlsGraphite$outboundSchema;
  /** @deprecated use `PqControlsGraphite$Outbound` instead. */
  export type Outbound = PqControlsGraphite$Outbound;
}

export function pqControlsGraphiteToJSON(
  pqControlsGraphite: PqControlsGraphite,
): string {
  return JSON.stringify(
    PqControlsGraphite$outboundSchema.parse(pqControlsGraphite),
  );
}

export function pqControlsGraphiteFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsGraphite, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsGraphite$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsGraphite' from JSON`,
  );
}

/** @internal */
export const OutputGraphite$inboundSchema: z.ZodType<
  OutputGraphite,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeGraphite$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: DestinationProtocolGraphite$inboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: BackpressureBehaviorGraphite$inboundSchema.default("block"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionGraphite$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGraphite$inboundSchema.default("block"),
  pqMode: ModeGraphite$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGraphite$inboundSchema).optional(),
});

/** @internal */
export type OutputGraphite$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  host: string;
  port: number;
  mtu: number;
  flushPeriodSec: number;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  onBackpressure: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsGraphite$Outbound | undefined;
};

/** @internal */
export const OutputGraphite$outboundSchema: z.ZodType<
  OutputGraphite$Outbound,
  z.ZodTypeDef,
  OutputGraphite
> = z.object({
  id: z.string(),
  type: TypeGraphite$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: DestinationProtocolGraphite$outboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: BackpressureBehaviorGraphite$outboundSchema.default("block"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionGraphite$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGraphite$outboundSchema.default("block"),
  pqMode: ModeGraphite$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGraphite$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGraphite$ {
  /** @deprecated use `OutputGraphite$inboundSchema` instead. */
  export const inboundSchema = OutputGraphite$inboundSchema;
  /** @deprecated use `OutputGraphite$outboundSchema` instead. */
  export const outboundSchema = OutputGraphite$outboundSchema;
  /** @deprecated use `OutputGraphite$Outbound` instead. */
  export type Outbound = OutputGraphite$Outbound;
}

export function outputGraphiteToJSON(outputGraphite: OutputGraphite): string {
  return JSON.stringify(OutputGraphite$outboundSchema.parse(outputGraphite));
}

export function outputGraphiteFromJSON(
  jsonString: string,
): SafeParseResult<OutputGraphite, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGraphite$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGraphite' from JSON`,
  );
}

/** @internal */
export const TypeStatsdExt$inboundSchema: z.ZodNativeEnum<
  typeof TypeStatsdExt
> = z.nativeEnum(TypeStatsdExt);

/** @internal */
export const TypeStatsdExt$outboundSchema: z.ZodNativeEnum<
  typeof TypeStatsdExt
> = TypeStatsdExt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeStatsdExt$ {
  /** @deprecated use `TypeStatsdExt$inboundSchema` instead. */
  export const inboundSchema = TypeStatsdExt$inboundSchema;
  /** @deprecated use `TypeStatsdExt$outboundSchema` instead. */
  export const outboundSchema = TypeStatsdExt$outboundSchema;
}

/** @internal */
export const DestinationProtocolStatsdExt$inboundSchema: z.ZodNativeEnum<
  typeof DestinationProtocolStatsdExt
> = z.nativeEnum(DestinationProtocolStatsdExt);

/** @internal */
export const DestinationProtocolStatsdExt$outboundSchema: z.ZodNativeEnum<
  typeof DestinationProtocolStatsdExt
> = DestinationProtocolStatsdExt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DestinationProtocolStatsdExt$ {
  /** @deprecated use `DestinationProtocolStatsdExt$inboundSchema` instead. */
  export const inboundSchema = DestinationProtocolStatsdExt$inboundSchema;
  /** @deprecated use `DestinationProtocolStatsdExt$outboundSchema` instead. */
  export const outboundSchema = DestinationProtocolStatsdExt$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorStatsdExt$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorStatsdExt
> = z.nativeEnum(BackpressureBehaviorStatsdExt);

/** @internal */
export const BackpressureBehaviorStatsdExt$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorStatsdExt
> = BackpressureBehaviorStatsdExt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorStatsdExt$ {
  /** @deprecated use `BackpressureBehaviorStatsdExt$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorStatsdExt$inboundSchema;
  /** @deprecated use `BackpressureBehaviorStatsdExt$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorStatsdExt$outboundSchema;
}

/** @internal */
export const CompressionStatsdExt$inboundSchema: z.ZodNativeEnum<
  typeof CompressionStatsdExt
> = z.nativeEnum(CompressionStatsdExt);

/** @internal */
export const CompressionStatsdExt$outboundSchema: z.ZodNativeEnum<
  typeof CompressionStatsdExt
> = CompressionStatsdExt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionStatsdExt$ {
  /** @deprecated use `CompressionStatsdExt$inboundSchema` instead. */
  export const inboundSchema = CompressionStatsdExt$inboundSchema;
  /** @deprecated use `CompressionStatsdExt$outboundSchema` instead. */
  export const outboundSchema = CompressionStatsdExt$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorStatsdExt$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorStatsdExt
> = z.nativeEnum(QueueFullBehaviorStatsdExt);

/** @internal */
export const QueueFullBehaviorStatsdExt$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorStatsdExt
> = QueueFullBehaviorStatsdExt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorStatsdExt$ {
  /** @deprecated use `QueueFullBehaviorStatsdExt$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorStatsdExt$inboundSchema;
  /** @deprecated use `QueueFullBehaviorStatsdExt$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorStatsdExt$outboundSchema;
}

/** @internal */
export const ModeStatsdExt$inboundSchema: z.ZodNativeEnum<
  typeof ModeStatsdExt
> = z.nativeEnum(ModeStatsdExt);

/** @internal */
export const ModeStatsdExt$outboundSchema: z.ZodNativeEnum<
  typeof ModeStatsdExt
> = ModeStatsdExt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeStatsdExt$ {
  /** @deprecated use `ModeStatsdExt$inboundSchema` instead. */
  export const inboundSchema = ModeStatsdExt$inboundSchema;
  /** @deprecated use `ModeStatsdExt$outboundSchema` instead. */
  export const outboundSchema = ModeStatsdExt$outboundSchema;
}

/** @internal */
export const PqControlsStatsdExt$inboundSchema: z.ZodType<
  PqControlsStatsdExt,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsStatsdExt$Outbound = {};

/** @internal */
export const PqControlsStatsdExt$outboundSchema: z.ZodType<
  PqControlsStatsdExt$Outbound,
  z.ZodTypeDef,
  PqControlsStatsdExt
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsStatsdExt$ {
  /** @deprecated use `PqControlsStatsdExt$inboundSchema` instead. */
  export const inboundSchema = PqControlsStatsdExt$inboundSchema;
  /** @deprecated use `PqControlsStatsdExt$outboundSchema` instead. */
  export const outboundSchema = PqControlsStatsdExt$outboundSchema;
  /** @deprecated use `PqControlsStatsdExt$Outbound` instead. */
  export type Outbound = PqControlsStatsdExt$Outbound;
}

export function pqControlsStatsdExtToJSON(
  pqControlsStatsdExt: PqControlsStatsdExt,
): string {
  return JSON.stringify(
    PqControlsStatsdExt$outboundSchema.parse(pqControlsStatsdExt),
  );
}

export function pqControlsStatsdExtFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsStatsdExt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsStatsdExt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsStatsdExt' from JSON`,
  );
}

/** @internal */
export const OutputStatsdExt$inboundSchema: z.ZodType<
  OutputStatsdExt,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeStatsdExt$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: DestinationProtocolStatsdExt$inboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: BackpressureBehaviorStatsdExt$inboundSchema.default("block"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionStatsdExt$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorStatsdExt$inboundSchema.default("block"),
  pqMode: ModeStatsdExt$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsStatsdExt$inboundSchema).optional(),
});

/** @internal */
export type OutputStatsdExt$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  host: string;
  port: number;
  mtu: number;
  flushPeriodSec: number;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  onBackpressure: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsStatsdExt$Outbound | undefined;
};

/** @internal */
export const OutputStatsdExt$outboundSchema: z.ZodType<
  OutputStatsdExt$Outbound,
  z.ZodTypeDef,
  OutputStatsdExt
> = z.object({
  id: z.string(),
  type: TypeStatsdExt$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: DestinationProtocolStatsdExt$outboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: BackpressureBehaviorStatsdExt$outboundSchema.default("block"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionStatsdExt$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorStatsdExt$outboundSchema.default("block"),
  pqMode: ModeStatsdExt$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsStatsdExt$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsdExt$ {
  /** @deprecated use `OutputStatsdExt$inboundSchema` instead. */
  export const inboundSchema = OutputStatsdExt$inboundSchema;
  /** @deprecated use `OutputStatsdExt$outboundSchema` instead. */
  export const outboundSchema = OutputStatsdExt$outboundSchema;
  /** @deprecated use `OutputStatsdExt$Outbound` instead. */
  export type Outbound = OutputStatsdExt$Outbound;
}

export function outputStatsdExtToJSON(
  outputStatsdExt: OutputStatsdExt,
): string {
  return JSON.stringify(OutputStatsdExt$outboundSchema.parse(outputStatsdExt));
}

export function outputStatsdExtFromJSON(
  jsonString: string,
): SafeParseResult<OutputStatsdExt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputStatsdExt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputStatsdExt' from JSON`,
  );
}

/** @internal */
export const TypeStatsd$inboundSchema: z.ZodNativeEnum<typeof TypeStatsd> = z
  .nativeEnum(TypeStatsd);

/** @internal */
export const TypeStatsd$outboundSchema: z.ZodNativeEnum<typeof TypeStatsd> =
  TypeStatsd$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeStatsd$ {
  /** @deprecated use `TypeStatsd$inboundSchema` instead. */
  export const inboundSchema = TypeStatsd$inboundSchema;
  /** @deprecated use `TypeStatsd$outboundSchema` instead. */
  export const outboundSchema = TypeStatsd$outboundSchema;
}

/** @internal */
export const DestinationProtocolStatsd$inboundSchema: z.ZodNativeEnum<
  typeof DestinationProtocolStatsd
> = z.nativeEnum(DestinationProtocolStatsd);

/** @internal */
export const DestinationProtocolStatsd$outboundSchema: z.ZodNativeEnum<
  typeof DestinationProtocolStatsd
> = DestinationProtocolStatsd$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DestinationProtocolStatsd$ {
  /** @deprecated use `DestinationProtocolStatsd$inboundSchema` instead. */
  export const inboundSchema = DestinationProtocolStatsd$inboundSchema;
  /** @deprecated use `DestinationProtocolStatsd$outboundSchema` instead. */
  export const outboundSchema = DestinationProtocolStatsd$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorStatsd$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorStatsd
> = z.nativeEnum(BackpressureBehaviorStatsd);

/** @internal */
export const BackpressureBehaviorStatsd$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorStatsd
> = BackpressureBehaviorStatsd$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorStatsd$ {
  /** @deprecated use `BackpressureBehaviorStatsd$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorStatsd$inboundSchema;
  /** @deprecated use `BackpressureBehaviorStatsd$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorStatsd$outboundSchema;
}

/** @internal */
export const CompressionStatsd$inboundSchema: z.ZodNativeEnum<
  typeof CompressionStatsd
> = z.nativeEnum(CompressionStatsd);

/** @internal */
export const CompressionStatsd$outboundSchema: z.ZodNativeEnum<
  typeof CompressionStatsd
> = CompressionStatsd$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionStatsd$ {
  /** @deprecated use `CompressionStatsd$inboundSchema` instead. */
  export const inboundSchema = CompressionStatsd$inboundSchema;
  /** @deprecated use `CompressionStatsd$outboundSchema` instead. */
  export const outboundSchema = CompressionStatsd$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorStatsd$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorStatsd
> = z.nativeEnum(QueueFullBehaviorStatsd);

/** @internal */
export const QueueFullBehaviorStatsd$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorStatsd
> = QueueFullBehaviorStatsd$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorStatsd$ {
  /** @deprecated use `QueueFullBehaviorStatsd$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorStatsd$inboundSchema;
  /** @deprecated use `QueueFullBehaviorStatsd$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorStatsd$outboundSchema;
}

/** @internal */
export const ModeStatsd$inboundSchema: z.ZodNativeEnum<typeof ModeStatsd> = z
  .nativeEnum(ModeStatsd);

/** @internal */
export const ModeStatsd$outboundSchema: z.ZodNativeEnum<typeof ModeStatsd> =
  ModeStatsd$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeStatsd$ {
  /** @deprecated use `ModeStatsd$inboundSchema` instead. */
  export const inboundSchema = ModeStatsd$inboundSchema;
  /** @deprecated use `ModeStatsd$outboundSchema` instead. */
  export const outboundSchema = ModeStatsd$outboundSchema;
}

/** @internal */
export const PqControlsStatsd$inboundSchema: z.ZodType<
  PqControlsStatsd,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsStatsd$Outbound = {};

/** @internal */
export const PqControlsStatsd$outboundSchema: z.ZodType<
  PqControlsStatsd$Outbound,
  z.ZodTypeDef,
  PqControlsStatsd
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsStatsd$ {
  /** @deprecated use `PqControlsStatsd$inboundSchema` instead. */
  export const inboundSchema = PqControlsStatsd$inboundSchema;
  /** @deprecated use `PqControlsStatsd$outboundSchema` instead. */
  export const outboundSchema = PqControlsStatsd$outboundSchema;
  /** @deprecated use `PqControlsStatsd$Outbound` instead. */
  export type Outbound = PqControlsStatsd$Outbound;
}

export function pqControlsStatsdToJSON(
  pqControlsStatsd: PqControlsStatsd,
): string {
  return JSON.stringify(
    PqControlsStatsd$outboundSchema.parse(pqControlsStatsd),
  );
}

export function pqControlsStatsdFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsStatsd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsStatsd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsStatsd' from JSON`,
  );
}

/** @internal */
export const OutputStatsd$inboundSchema: z.ZodType<
  OutputStatsd,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeStatsd$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: DestinationProtocolStatsd$inboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: BackpressureBehaviorStatsd$inboundSchema.default("block"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionStatsd$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorStatsd$inboundSchema.default("block"),
  pqMode: ModeStatsd$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsStatsd$inboundSchema).optional(),
});

/** @internal */
export type OutputStatsd$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol: string;
  host: string;
  port: number;
  mtu: number;
  flushPeriodSec: number;
  dnsResolvePeriodSec: number;
  description?: string | undefined;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  onBackpressure: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsStatsd$Outbound | undefined;
};

/** @internal */
export const OutputStatsd$outboundSchema: z.ZodType<
  OutputStatsd$Outbound,
  z.ZodTypeDef,
  OutputStatsd
> = z.object({
  id: z.string(),
  type: TypeStatsd$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: DestinationProtocolStatsd$outboundSchema.default("udp"),
  host: z.string(),
  port: z.number().default(8125),
  mtu: z.number().default(512),
  flushPeriodSec: z.number().default(1),
  dnsResolvePeriodSec: z.number().default(0),
  description: z.string().optional(),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  onBackpressure: BackpressureBehaviorStatsd$outboundSchema.default("block"),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionStatsd$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorStatsd$outboundSchema.default("block"),
  pqMode: ModeStatsd$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsStatsd$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputStatsd$ {
  /** @deprecated use `OutputStatsd$inboundSchema` instead. */
  export const inboundSchema = OutputStatsd$inboundSchema;
  /** @deprecated use `OutputStatsd$outboundSchema` instead. */
  export const outboundSchema = OutputStatsd$outboundSchema;
  /** @deprecated use `OutputStatsd$Outbound` instead. */
  export type Outbound = OutputStatsd$Outbound;
}

export function outputStatsdToJSON(outputStatsd: OutputStatsd): string {
  return JSON.stringify(OutputStatsd$outboundSchema.parse(outputStatsd));
}

export function outputStatsdFromJSON(
  jsonString: string,
): SafeParseResult<OutputStatsd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputStatsd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputStatsd' from JSON`,
  );
}

/** @internal */
export const OutputMinioType$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioType
> = z.nativeEnum(OutputMinioType);

/** @internal */
export const OutputMinioType$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioType
> = OutputMinioType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioType$ {
  /** @deprecated use `OutputMinioType$inboundSchema` instead. */
  export const inboundSchema = OutputMinioType$inboundSchema;
  /** @deprecated use `OutputMinioType$outboundSchema` instead. */
  export const outboundSchema = OutputMinioType$outboundSchema;
}

/** @internal */
export const OutputMinioAuthenticationMethod$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioAuthenticationMethod
> = z.nativeEnum(OutputMinioAuthenticationMethod);

/** @internal */
export const OutputMinioAuthenticationMethod$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioAuthenticationMethod
> = OutputMinioAuthenticationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioAuthenticationMethod$ {
  /** @deprecated use `OutputMinioAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OutputMinioAuthenticationMethod$inboundSchema;
  /** @deprecated use `OutputMinioAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OutputMinioAuthenticationMethod$outboundSchema;
}

/** @internal */
export const OutputMinioSignatureVersion$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioSignatureVersion
> = z.nativeEnum(OutputMinioSignatureVersion);

/** @internal */
export const OutputMinioSignatureVersion$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioSignatureVersion
> = OutputMinioSignatureVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioSignatureVersion$ {
  /** @deprecated use `OutputMinioSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMinioSignatureVersion$inboundSchema;
  /** @deprecated use `OutputMinioSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMinioSignatureVersion$outboundSchema;
}

/** @internal */
export const OutputMinioObjectACL$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioObjectACL
> = z.nativeEnum(OutputMinioObjectACL);

/** @internal */
export const OutputMinioObjectACL$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioObjectACL
> = OutputMinioObjectACL$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioObjectACL$ {
  /** @deprecated use `OutputMinioObjectACL$inboundSchema` instead. */
  export const inboundSchema = OutputMinioObjectACL$inboundSchema;
  /** @deprecated use `OutputMinioObjectACL$outboundSchema` instead. */
  export const outboundSchema = OutputMinioObjectACL$outboundSchema;
}

/** @internal */
export const OutputMinioStorageClass$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioStorageClass
> = z.nativeEnum(OutputMinioStorageClass);

/** @internal */
export const OutputMinioStorageClass$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioStorageClass
> = OutputMinioStorageClass$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioStorageClass$ {
  /** @deprecated use `OutputMinioStorageClass$inboundSchema` instead. */
  export const inboundSchema = OutputMinioStorageClass$inboundSchema;
  /** @deprecated use `OutputMinioStorageClass$outboundSchema` instead. */
  export const outboundSchema = OutputMinioStorageClass$outboundSchema;
}

/** @internal */
export const ServerSideEncryption$inboundSchema: z.ZodNativeEnum<
  typeof ServerSideEncryption
> = z.nativeEnum(ServerSideEncryption);

/** @internal */
export const ServerSideEncryption$outboundSchema: z.ZodNativeEnum<
  typeof ServerSideEncryption
> = ServerSideEncryption$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServerSideEncryption$ {
  /** @deprecated use `ServerSideEncryption$inboundSchema` instead. */
  export const inboundSchema = ServerSideEncryption$inboundSchema;
  /** @deprecated use `ServerSideEncryption$outboundSchema` instead. */
  export const outboundSchema = ServerSideEncryption$outboundSchema;
}

/** @internal */
export const OutputMinioDataFormat$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioDataFormat
> = z.nativeEnum(OutputMinioDataFormat);

/** @internal */
export const OutputMinioDataFormat$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioDataFormat
> = OutputMinioDataFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioDataFormat$ {
  /** @deprecated use `OutputMinioDataFormat$inboundSchema` instead. */
  export const inboundSchema = OutputMinioDataFormat$inboundSchema;
  /** @deprecated use `OutputMinioDataFormat$outboundSchema` instead. */
  export const outboundSchema = OutputMinioDataFormat$outboundSchema;
}

/** @internal */
export const OutputMinioBackpressureBehavior$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioBackpressureBehavior
> = z.nativeEnum(OutputMinioBackpressureBehavior);

/** @internal */
export const OutputMinioBackpressureBehavior$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioBackpressureBehavior
> = OutputMinioBackpressureBehavior$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioBackpressureBehavior$ {
  /** @deprecated use `OutputMinioBackpressureBehavior$inboundSchema` instead. */
  export const inboundSchema = OutputMinioBackpressureBehavior$inboundSchema;
  /** @deprecated use `OutputMinioBackpressureBehavior$outboundSchema` instead. */
  export const outboundSchema = OutputMinioBackpressureBehavior$outboundSchema;
}

/** @internal */
export const OutputMinioDiskSpaceProtection$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioDiskSpaceProtection
> = z.nativeEnum(OutputMinioDiskSpaceProtection);

/** @internal */
export const OutputMinioDiskSpaceProtection$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioDiskSpaceProtection
> = OutputMinioDiskSpaceProtection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioDiskSpaceProtection$ {
  /** @deprecated use `OutputMinioDiskSpaceProtection$inboundSchema` instead. */
  export const inboundSchema = OutputMinioDiskSpaceProtection$inboundSchema;
  /** @deprecated use `OutputMinioDiskSpaceProtection$outboundSchema` instead. */
  export const outboundSchema = OutputMinioDiskSpaceProtection$outboundSchema;
}

/** @internal */
export const OutputMinioCompression$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioCompression
> = z.nativeEnum(OutputMinioCompression);

/** @internal */
export const OutputMinioCompression$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioCompression
> = OutputMinioCompression$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioCompression$ {
  /** @deprecated use `OutputMinioCompression$inboundSchema` instead. */
  export const inboundSchema = OutputMinioCompression$inboundSchema;
  /** @deprecated use `OutputMinioCompression$outboundSchema` instead. */
  export const outboundSchema = OutputMinioCompression$outboundSchema;
}

/** @internal */
export const OutputMinioCompressionLevel$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioCompressionLevel
> = z.nativeEnum(OutputMinioCompressionLevel);

/** @internal */
export const OutputMinioCompressionLevel$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioCompressionLevel
> = OutputMinioCompressionLevel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioCompressionLevel$ {
  /** @deprecated use `OutputMinioCompressionLevel$inboundSchema` instead. */
  export const inboundSchema = OutputMinioCompressionLevel$inboundSchema;
  /** @deprecated use `OutputMinioCompressionLevel$outboundSchema` instead. */
  export const outboundSchema = OutputMinioCompressionLevel$outboundSchema;
}

/** @internal */
export const OutputMinioParquetVersion$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioParquetVersion
> = z.nativeEnum(OutputMinioParquetVersion);

/** @internal */
export const OutputMinioParquetVersion$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioParquetVersion
> = OutputMinioParquetVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioParquetVersion$ {
  /** @deprecated use `OutputMinioParquetVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMinioParquetVersion$inboundSchema;
  /** @deprecated use `OutputMinioParquetVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMinioParquetVersion$outboundSchema;
}

/** @internal */
export const OutputMinioDataPageVersion$inboundSchema: z.ZodNativeEnum<
  typeof OutputMinioDataPageVersion
> = z.nativeEnum(OutputMinioDataPageVersion);

/** @internal */
export const OutputMinioDataPageVersion$outboundSchema: z.ZodNativeEnum<
  typeof OutputMinioDataPageVersion
> = OutputMinioDataPageVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioDataPageVersion$ {
  /** @deprecated use `OutputMinioDataPageVersion$inboundSchema` instead. */
  export const inboundSchema = OutputMinioDataPageVersion$inboundSchema;
  /** @deprecated use `OutputMinioDataPageVersion$outboundSchema` instead. */
  export const outboundSchema = OutputMinioDataPageVersion$outboundSchema;
}

/** @internal */
export const OutputMinioKeyValueMetadatum$inboundSchema: z.ZodType<
  OutputMinioKeyValueMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type OutputMinioKeyValueMetadatum$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const OutputMinioKeyValueMetadatum$outboundSchema: z.ZodType<
  OutputMinioKeyValueMetadatum$Outbound,
  z.ZodTypeDef,
  OutputMinioKeyValueMetadatum
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinioKeyValueMetadatum$ {
  /** @deprecated use `OutputMinioKeyValueMetadatum$inboundSchema` instead. */
  export const inboundSchema = OutputMinioKeyValueMetadatum$inboundSchema;
  /** @deprecated use `OutputMinioKeyValueMetadatum$outboundSchema` instead. */
  export const outboundSchema = OutputMinioKeyValueMetadatum$outboundSchema;
  /** @deprecated use `OutputMinioKeyValueMetadatum$Outbound` instead. */
  export type Outbound = OutputMinioKeyValueMetadatum$Outbound;
}

export function outputMinioKeyValueMetadatumToJSON(
  outputMinioKeyValueMetadatum: OutputMinioKeyValueMetadatum,
): string {
  return JSON.stringify(
    OutputMinioKeyValueMetadatum$outboundSchema.parse(
      outputMinioKeyValueMetadatum,
    ),
  );
}

export function outputMinioKeyValueMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<OutputMinioKeyValueMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMinioKeyValueMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMinioKeyValueMetadatum' from JSON`,
  );
}

/** @internal */
export const OutputMinio$inboundSchema: z.ZodType<
  OutputMinio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: OutputMinioType$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string(),
  bucket: z.string(),
  awsAuthenticationMethod: OutputMinioAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().optional(),
  signatureVersion: OutputMinioSignatureVersion$inboundSchema.default("v4"),
  objectACL: OutputMinioObjectACL$inboundSchema.default("private"),
  storageClass: OutputMinioStorageClass$inboundSchema.optional(),
  serverSideEncryption: ServerSideEncryption$inboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  verifyPermissions: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputMinioDataFormat$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputMinioBackpressureBehavior$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputMinioDiskSpaceProtection$inboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputMinioCompression$inboundSchema.default("gzip"),
  compressionLevel: OutputMinioCompressionLevel$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputMinioParquetVersion$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputMinioDataPageVersion$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputMinioKeyValueMetadatum$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputMinio$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  endpoint: string;
  bucket: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  stagePath: string;
  addIdToStagePath: boolean;
  destPath?: string | undefined;
  signatureVersion: string;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  verifyPermissions: boolean;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<OutputMinioKeyValueMetadatum$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputMinio$outboundSchema: z.ZodType<
  OutputMinio$Outbound,
  z.ZodTypeDef,
  OutputMinio
> = z.object({
  id: z.string(),
  type: OutputMinioType$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  endpoint: z.string(),
  bucket: z.string(),
  awsAuthenticationMethod: OutputMinioAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().optional(),
  signatureVersion: OutputMinioSignatureVersion$outboundSchema.default("v4"),
  objectACL: OutputMinioObjectACL$outboundSchema.default("private"),
  storageClass: OutputMinioStorageClass$outboundSchema.optional(),
  serverSideEncryption: ServerSideEncryption$outboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  verifyPermissions: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: OutputMinioDataFormat$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: OutputMinioBackpressureBehavior$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: OutputMinioDiskSpaceProtection$outboundSchema.default(
    "block",
  ),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: OutputMinioCompression$outboundSchema.default("gzip"),
  compressionLevel: OutputMinioCompressionLevel$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: OutputMinioParquetVersion$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: OutputMinioDataPageVersion$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => OutputMinioKeyValueMetadatum$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMinio$ {
  /** @deprecated use `OutputMinio$inboundSchema` instead. */
  export const inboundSchema = OutputMinio$inboundSchema;
  /** @deprecated use `OutputMinio$outboundSchema` instead. */
  export const outboundSchema = OutputMinio$outboundSchema;
  /** @deprecated use `OutputMinio$Outbound` instead. */
  export type Outbound = OutputMinio$Outbound;
}

export function outputMinioToJSON(outputMinio: OutputMinio): string {
  return JSON.stringify(OutputMinio$outboundSchema.parse(outputMinio));
}

export function outputMinioFromJSON(
  jsonString: string,
): SafeParseResult<OutputMinio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMinio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMinio' from JSON`,
  );
}

/** @internal */
export const TypeCloudwatch$inboundSchema: z.ZodNativeEnum<
  typeof TypeCloudwatch
> = z.nativeEnum(TypeCloudwatch);

/** @internal */
export const TypeCloudwatch$outboundSchema: z.ZodNativeEnum<
  typeof TypeCloudwatch
> = TypeCloudwatch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeCloudwatch$ {
  /** @deprecated use `TypeCloudwatch$inboundSchema` instead. */
  export const inboundSchema = TypeCloudwatch$inboundSchema;
  /** @deprecated use `TypeCloudwatch$outboundSchema` instead. */
  export const outboundSchema = TypeCloudwatch$outboundSchema;
}

/** @internal */
export const AuthenticationMethodCloudwatch$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodCloudwatch
> = z.nativeEnum(AuthenticationMethodCloudwatch);

/** @internal */
export const AuthenticationMethodCloudwatch$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodCloudwatch
> = AuthenticationMethodCloudwatch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodCloudwatch$ {
  /** @deprecated use `AuthenticationMethodCloudwatch$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodCloudwatch$inboundSchema;
  /** @deprecated use `AuthenticationMethodCloudwatch$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodCloudwatch$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorCloudwatch$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorCloudwatch
> = z.nativeEnum(BackpressureBehaviorCloudwatch);

/** @internal */
export const BackpressureBehaviorCloudwatch$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorCloudwatch
> = BackpressureBehaviorCloudwatch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorCloudwatch$ {
  /** @deprecated use `BackpressureBehaviorCloudwatch$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorCloudwatch$inboundSchema;
  /** @deprecated use `BackpressureBehaviorCloudwatch$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorCloudwatch$outboundSchema;
}

/** @internal */
export const CompressionCloudwatch$inboundSchema: z.ZodNativeEnum<
  typeof CompressionCloudwatch
> = z.nativeEnum(CompressionCloudwatch);

/** @internal */
export const CompressionCloudwatch$outboundSchema: z.ZodNativeEnum<
  typeof CompressionCloudwatch
> = CompressionCloudwatch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionCloudwatch$ {
  /** @deprecated use `CompressionCloudwatch$inboundSchema` instead. */
  export const inboundSchema = CompressionCloudwatch$inboundSchema;
  /** @deprecated use `CompressionCloudwatch$outboundSchema` instead. */
  export const outboundSchema = CompressionCloudwatch$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorCloudwatch$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorCloudwatch
> = z.nativeEnum(QueueFullBehaviorCloudwatch);

/** @internal */
export const QueueFullBehaviorCloudwatch$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorCloudwatch
> = QueueFullBehaviorCloudwatch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorCloudwatch$ {
  /** @deprecated use `QueueFullBehaviorCloudwatch$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorCloudwatch$inboundSchema;
  /** @deprecated use `QueueFullBehaviorCloudwatch$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorCloudwatch$outboundSchema;
}

/** @internal */
export const ModeCloudwatch$inboundSchema: z.ZodNativeEnum<
  typeof ModeCloudwatch
> = z.nativeEnum(ModeCloudwatch);

/** @internal */
export const ModeCloudwatch$outboundSchema: z.ZodNativeEnum<
  typeof ModeCloudwatch
> = ModeCloudwatch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeCloudwatch$ {
  /** @deprecated use `ModeCloudwatch$inboundSchema` instead. */
  export const inboundSchema = ModeCloudwatch$inboundSchema;
  /** @deprecated use `ModeCloudwatch$outboundSchema` instead. */
  export const outboundSchema = ModeCloudwatch$outboundSchema;
}

/** @internal */
export const PqControlsCloudwatch$inboundSchema: z.ZodType<
  PqControlsCloudwatch,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsCloudwatch$Outbound = {};

/** @internal */
export const PqControlsCloudwatch$outboundSchema: z.ZodType<
  PqControlsCloudwatch$Outbound,
  z.ZodTypeDef,
  PqControlsCloudwatch
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsCloudwatch$ {
  /** @deprecated use `PqControlsCloudwatch$inboundSchema` instead. */
  export const inboundSchema = PqControlsCloudwatch$inboundSchema;
  /** @deprecated use `PqControlsCloudwatch$outboundSchema` instead. */
  export const outboundSchema = PqControlsCloudwatch$outboundSchema;
  /** @deprecated use `PqControlsCloudwatch$Outbound` instead. */
  export type Outbound = PqControlsCloudwatch$Outbound;
}

export function pqControlsCloudwatchToJSON(
  pqControlsCloudwatch: PqControlsCloudwatch,
): string {
  return JSON.stringify(
    PqControlsCloudwatch$outboundSchema.parse(pqControlsCloudwatch),
  );
}

export function pqControlsCloudwatchFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsCloudwatch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsCloudwatch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsCloudwatch' from JSON`,
  );
}

/** @internal */
export const OutputCloudwatch$inboundSchema: z.ZodType<
  OutputCloudwatch,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeCloudwatch$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logGroupName: z.string(),
  logStreamName: z.string(),
  awsAuthenticationMethod: AuthenticationMethodCloudwatch$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  onBackpressure: BackpressureBehaviorCloudwatch$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionCloudwatch$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorCloudwatch$inboundSchema.default("block"),
  pqMode: ModeCloudwatch$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsCloudwatch$inboundSchema).optional(),
});

/** @internal */
export type OutputCloudwatch$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  logGroupName: string;
  logStreamName: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  maxQueueSize: number;
  maxRecordSizeKB: number;
  flushPeriodSec: number;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsCloudwatch$Outbound | undefined;
};

/** @internal */
export const OutputCloudwatch$outboundSchema: z.ZodType<
  OutputCloudwatch$Outbound,
  z.ZodTypeDef,
  OutputCloudwatch
> = z.object({
  id: z.string(),
  type: TypeCloudwatch$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logGroupName: z.string(),
  logStreamName: z.string(),
  awsAuthenticationMethod: AuthenticationMethodCloudwatch$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxQueueSize: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  onBackpressure: BackpressureBehaviorCloudwatch$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionCloudwatch$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorCloudwatch$outboundSchema.default("block"),
  pqMode: ModeCloudwatch$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsCloudwatch$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputCloudwatch$ {
  /** @deprecated use `OutputCloudwatch$inboundSchema` instead. */
  export const inboundSchema = OutputCloudwatch$inboundSchema;
  /** @deprecated use `OutputCloudwatch$outboundSchema` instead. */
  export const outboundSchema = OutputCloudwatch$outboundSchema;
  /** @deprecated use `OutputCloudwatch$Outbound` instead. */
  export type Outbound = OutputCloudwatch$Outbound;
}

export function outputCloudwatchToJSON(
  outputCloudwatch: OutputCloudwatch,
): string {
  return JSON.stringify(
    OutputCloudwatch$outboundSchema.parse(outputCloudwatch),
  );
}

export function outputCloudwatchFromJSON(
  jsonString: string,
): SafeParseResult<OutputCloudwatch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputCloudwatch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputCloudwatch' from JSON`,
  );
}

/** @internal */
export const TypeInfluxdb$inboundSchema: z.ZodNativeEnum<typeof TypeInfluxdb> =
  z.nativeEnum(TypeInfluxdb);

/** @internal */
export const TypeInfluxdb$outboundSchema: z.ZodNativeEnum<typeof TypeInfluxdb> =
  TypeInfluxdb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeInfluxdb$ {
  /** @deprecated use `TypeInfluxdb$inboundSchema` instead. */
  export const inboundSchema = TypeInfluxdb$inboundSchema;
  /** @deprecated use `TypeInfluxdb$outboundSchema` instead. */
  export const outboundSchema = TypeInfluxdb$outboundSchema;
}

/** @internal */
export const TimestampPrecision$inboundSchema: z.ZodNativeEnum<
  typeof TimestampPrecision
> = z.nativeEnum(TimestampPrecision);

/** @internal */
export const TimestampPrecision$outboundSchema: z.ZodNativeEnum<
  typeof TimestampPrecision
> = TimestampPrecision$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimestampPrecision$ {
  /** @deprecated use `TimestampPrecision$inboundSchema` instead. */
  export const inboundSchema = TimestampPrecision$inboundSchema;
  /** @deprecated use `TimestampPrecision$outboundSchema` instead. */
  export const outboundSchema = TimestampPrecision$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderInfluxdb$inboundSchema: z.ZodType<
  ExtraHttpHeaderInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderInfluxdb$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderInfluxdb$outboundSchema: z.ZodType<
  ExtraHttpHeaderInfluxdb$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderInfluxdb
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderInfluxdb$ {
  /** @deprecated use `ExtraHttpHeaderInfluxdb$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderInfluxdb$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderInfluxdb$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderInfluxdb$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderInfluxdb$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderInfluxdb$Outbound;
}

export function extraHttpHeaderInfluxdbToJSON(
  extraHttpHeaderInfluxdb: ExtraHttpHeaderInfluxdb,
): string {
  return JSON.stringify(
    ExtraHttpHeaderInfluxdb$outboundSchema.parse(extraHttpHeaderInfluxdb),
  );
}

export function extraHttpHeaderInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderInfluxdb' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeInfluxdb$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeInfluxdb
> = z.nativeEnum(FailedRequestLoggingModeInfluxdb);

/** @internal */
export const FailedRequestLoggingModeInfluxdb$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeInfluxdb
> = FailedRequestLoggingModeInfluxdb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeInfluxdb$ {
  /** @deprecated use `FailedRequestLoggingModeInfluxdb$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeInfluxdb$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeInfluxdb$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingModeInfluxdb$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingInfluxdb$inboundSchema: z.ZodType<
  ResponseRetrySettingInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingInfluxdb$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingInfluxdb$outboundSchema: z.ZodType<
  ResponseRetrySettingInfluxdb$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingInfluxdb
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingInfluxdb$ {
  /** @deprecated use `ResponseRetrySettingInfluxdb$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingInfluxdb$inboundSchema;
  /** @deprecated use `ResponseRetrySettingInfluxdb$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingInfluxdb$outboundSchema;
  /** @deprecated use `ResponseRetrySettingInfluxdb$Outbound` instead. */
  export type Outbound = ResponseRetrySettingInfluxdb$Outbound;
}

export function responseRetrySettingInfluxdbToJSON(
  responseRetrySettingInfluxdb: ResponseRetrySettingInfluxdb,
): string {
  return JSON.stringify(
    ResponseRetrySettingInfluxdb$outboundSchema.parse(
      responseRetrySettingInfluxdb,
    ),
  );
}

export function responseRetrySettingInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingInfluxdb' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsInfluxdb$inboundSchema: z.ZodType<
  TimeoutRetrySettingsInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsInfluxdb$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsInfluxdb$outboundSchema: z.ZodType<
  TimeoutRetrySettingsInfluxdb$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsInfluxdb
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsInfluxdb$ {
  /** @deprecated use `TimeoutRetrySettingsInfluxdb$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsInfluxdb$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsInfluxdb$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsInfluxdb$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsInfluxdb$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsInfluxdb$Outbound;
}

export function timeoutRetrySettingsInfluxdbToJSON(
  timeoutRetrySettingsInfluxdb: TimeoutRetrySettingsInfluxdb,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsInfluxdb$outboundSchema.parse(
      timeoutRetrySettingsInfluxdb,
    ),
  );
}

export function timeoutRetrySettingsInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsInfluxdb' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorInfluxdb$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorInfluxdb
> = z.nativeEnum(BackpressureBehaviorInfluxdb);

/** @internal */
export const BackpressureBehaviorInfluxdb$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorInfluxdb
> = BackpressureBehaviorInfluxdb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorInfluxdb$ {
  /** @deprecated use `BackpressureBehaviorInfluxdb$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorInfluxdb$inboundSchema;
  /** @deprecated use `BackpressureBehaviorInfluxdb$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorInfluxdb$outboundSchema;
}

/** @internal */
export const AuthenticationTypeInfluxdb$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeInfluxdb
> = z.nativeEnum(AuthenticationTypeInfluxdb);

/** @internal */
export const AuthenticationTypeInfluxdb$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeInfluxdb
> = AuthenticationTypeInfluxdb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationTypeInfluxdb$ {
  /** @deprecated use `AuthenticationTypeInfluxdb$inboundSchema` instead. */
  export const inboundSchema = AuthenticationTypeInfluxdb$inboundSchema;
  /** @deprecated use `AuthenticationTypeInfluxdb$outboundSchema` instead. */
  export const outboundSchema = AuthenticationTypeInfluxdb$outboundSchema;
}

/** @internal */
export const CompressionInfluxdb$inboundSchema: z.ZodNativeEnum<
  typeof CompressionInfluxdb
> = z.nativeEnum(CompressionInfluxdb);

/** @internal */
export const CompressionInfluxdb$outboundSchema: z.ZodNativeEnum<
  typeof CompressionInfluxdb
> = CompressionInfluxdb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionInfluxdb$ {
  /** @deprecated use `CompressionInfluxdb$inboundSchema` instead. */
  export const inboundSchema = CompressionInfluxdb$inboundSchema;
  /** @deprecated use `CompressionInfluxdb$outboundSchema` instead. */
  export const outboundSchema = CompressionInfluxdb$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorInfluxdb$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorInfluxdb
> = z.nativeEnum(QueueFullBehaviorInfluxdb);

/** @internal */
export const QueueFullBehaviorInfluxdb$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorInfluxdb
> = QueueFullBehaviorInfluxdb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorInfluxdb$ {
  /** @deprecated use `QueueFullBehaviorInfluxdb$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorInfluxdb$inboundSchema;
  /** @deprecated use `QueueFullBehaviorInfluxdb$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorInfluxdb$outboundSchema;
}

/** @internal */
export const ModeInfluxdb$inboundSchema: z.ZodNativeEnum<typeof ModeInfluxdb> =
  z.nativeEnum(ModeInfluxdb);

/** @internal */
export const ModeInfluxdb$outboundSchema: z.ZodNativeEnum<typeof ModeInfluxdb> =
  ModeInfluxdb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeInfluxdb$ {
  /** @deprecated use `ModeInfluxdb$inboundSchema` instead. */
  export const inboundSchema = ModeInfluxdb$inboundSchema;
  /** @deprecated use `ModeInfluxdb$outboundSchema` instead. */
  export const outboundSchema = ModeInfluxdb$outboundSchema;
}

/** @internal */
export const PqControlsInfluxdb$inboundSchema: z.ZodType<
  PqControlsInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsInfluxdb$Outbound = {};

/** @internal */
export const PqControlsInfluxdb$outboundSchema: z.ZodType<
  PqControlsInfluxdb$Outbound,
  z.ZodTypeDef,
  PqControlsInfluxdb
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsInfluxdb$ {
  /** @deprecated use `PqControlsInfluxdb$inboundSchema` instead. */
  export const inboundSchema = PqControlsInfluxdb$inboundSchema;
  /** @deprecated use `PqControlsInfluxdb$outboundSchema` instead. */
  export const outboundSchema = PqControlsInfluxdb$outboundSchema;
  /** @deprecated use `PqControlsInfluxdb$Outbound` instead. */
  export type Outbound = PqControlsInfluxdb$Outbound;
}

export function pqControlsInfluxdbToJSON(
  pqControlsInfluxdb: PqControlsInfluxdb,
): string {
  return JSON.stringify(
    PqControlsInfluxdb$outboundSchema.parse(pqControlsInfluxdb),
  );
}

export function pqControlsInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsInfluxdb' from JSON`,
  );
}

/** @internal */
export const OauthParamInfluxdb$inboundSchema: z.ZodType<
  OauthParamInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthParamInfluxdb$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthParamInfluxdb$outboundSchema: z.ZodType<
  OauthParamInfluxdb$Outbound,
  z.ZodTypeDef,
  OauthParamInfluxdb
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthParamInfluxdb$ {
  /** @deprecated use `OauthParamInfluxdb$inboundSchema` instead. */
  export const inboundSchema = OauthParamInfluxdb$inboundSchema;
  /** @deprecated use `OauthParamInfluxdb$outboundSchema` instead. */
  export const outboundSchema = OauthParamInfluxdb$outboundSchema;
  /** @deprecated use `OauthParamInfluxdb$Outbound` instead. */
  export type Outbound = OauthParamInfluxdb$Outbound;
}

export function oauthParamInfluxdbToJSON(
  oauthParamInfluxdb: OauthParamInfluxdb,
): string {
  return JSON.stringify(
    OauthParamInfluxdb$outboundSchema.parse(oauthParamInfluxdb),
  );
}

export function oauthParamInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<OauthParamInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthParamInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthParamInfluxdb' from JSON`,
  );
}

/** @internal */
export const OauthHeaderInfluxdb$inboundSchema: z.ZodType<
  OauthHeaderInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthHeaderInfluxdb$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthHeaderInfluxdb$outboundSchema: z.ZodType<
  OauthHeaderInfluxdb$Outbound,
  z.ZodTypeDef,
  OauthHeaderInfluxdb
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthHeaderInfluxdb$ {
  /** @deprecated use `OauthHeaderInfluxdb$inboundSchema` instead. */
  export const inboundSchema = OauthHeaderInfluxdb$inboundSchema;
  /** @deprecated use `OauthHeaderInfluxdb$outboundSchema` instead. */
  export const outboundSchema = OauthHeaderInfluxdb$outboundSchema;
  /** @deprecated use `OauthHeaderInfluxdb$Outbound` instead. */
  export type Outbound = OauthHeaderInfluxdb$Outbound;
}

export function oauthHeaderInfluxdbToJSON(
  oauthHeaderInfluxdb: OauthHeaderInfluxdb,
): string {
  return JSON.stringify(
    OauthHeaderInfluxdb$outboundSchema.parse(oauthHeaderInfluxdb),
  );
}

export function oauthHeaderInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<OauthHeaderInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthHeaderInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthHeaderInfluxdb' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdb$inboundSchema: z.ZodType<
  OutputInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeInfluxdb$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeaderInfluxdb$inboundSchema))
    .optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeInfluxdb$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingInfluxdb$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsInfluxdb$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorInfluxdb$inboundSchema.default("block"),
  authType: AuthenticationTypeInfluxdb$inboundSchema.default("none"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionInfluxdb$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorInfluxdb$inboundSchema.default("block"),
  pqMode: ModeInfluxdb$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsInfluxdb$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamInfluxdb$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderInfluxdb$inboundSchema))
    .optional(),
});

/** @internal */
export type OutputInfluxdb$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderInfluxdb$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingInfluxdb$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsInfluxdb$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsInfluxdb$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OauthParamInfluxdb$Outbound> | undefined;
  oauthHeaders?: Array<OauthHeaderInfluxdb$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdb$outboundSchema: z.ZodType<
  OutputInfluxdb$Outbound,
  z.ZodTypeDef,
  OutputInfluxdb
> = z.object({
  id: z.string(),
  type: TypeInfluxdb$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderInfluxdb$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeInfluxdb$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingInfluxdb$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsInfluxdb$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorInfluxdb$outboundSchema.default("block"),
  authType: AuthenticationTypeInfluxdb$outboundSchema.default("none"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionInfluxdb$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorInfluxdb$outboundSchema.default("block"),
  pqMode: ModeInfluxdb$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsInfluxdb$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamInfluxdb$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderInfluxdb$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputInfluxdb$ {
  /** @deprecated use `OutputInfluxdb$inboundSchema` instead. */
  export const inboundSchema = OutputInfluxdb$inboundSchema;
  /** @deprecated use `OutputInfluxdb$outboundSchema` instead. */
  export const outboundSchema = OutputInfluxdb$outboundSchema;
  /** @deprecated use `OutputInfluxdb$Outbound` instead. */
  export type Outbound = OutputInfluxdb$Outbound;
}

export function outputInfluxdbToJSON(outputInfluxdb: OutputInfluxdb): string {
  return JSON.stringify(OutputInfluxdb$outboundSchema.parse(outputInfluxdb));
}

export function outputInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdb' from JSON`,
  );
}

/** @internal */
export const TypeNewrelicEvents$inboundSchema: z.ZodNativeEnum<
  typeof TypeNewrelicEvents
> = z.nativeEnum(TypeNewrelicEvents);

/** @internal */
export const TypeNewrelicEvents$outboundSchema: z.ZodNativeEnum<
  typeof TypeNewrelicEvents
> = TypeNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeNewrelicEvents$ {
  /** @deprecated use `TypeNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = TypeNewrelicEvents$inboundSchema;
  /** @deprecated use `TypeNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = TypeNewrelicEvents$outboundSchema;
}

/** @internal */
export const RegionNewrelicEvents$inboundSchema: z.ZodNativeEnum<
  typeof RegionNewrelicEvents
> = z.nativeEnum(RegionNewrelicEvents);

/** @internal */
export const RegionNewrelicEvents$outboundSchema: z.ZodNativeEnum<
  typeof RegionNewrelicEvents
> = RegionNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RegionNewrelicEvents$ {
  /** @deprecated use `RegionNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = RegionNewrelicEvents$inboundSchema;
  /** @deprecated use `RegionNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = RegionNewrelicEvents$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderNewrelicEvents$inboundSchema: z.ZodType<
  ExtraHttpHeaderNewrelicEvents,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderNewrelicEvents$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderNewrelicEvents$outboundSchema: z.ZodType<
  ExtraHttpHeaderNewrelicEvents$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderNewrelicEvents
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderNewrelicEvents$ {
  /** @deprecated use `ExtraHttpHeaderNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderNewrelicEvents$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderNewrelicEvents$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderNewrelicEvents$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderNewrelicEvents$Outbound;
}

export function extraHttpHeaderNewrelicEventsToJSON(
  extraHttpHeaderNewrelicEvents: ExtraHttpHeaderNewrelicEvents,
): string {
  return JSON.stringify(
    ExtraHttpHeaderNewrelicEvents$outboundSchema.parse(
      extraHttpHeaderNewrelicEvents,
    ),
  );
}

export function extraHttpHeaderNewrelicEventsFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderNewrelicEvents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderNewrelicEvents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderNewrelicEvents' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeNewrelicEvents$inboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeNewrelicEvents> = z.nativeEnum(
    FailedRequestLoggingModeNewrelicEvents,
  );

/** @internal */
export const FailedRequestLoggingModeNewrelicEvents$outboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeNewrelicEvents> =
    FailedRequestLoggingModeNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeNewrelicEvents$ {
  /** @deprecated use `FailedRequestLoggingModeNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema =
    FailedRequestLoggingModeNewrelicEvents$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeNewrelicEvents$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingNewrelicEvents$inboundSchema: z.ZodType<
  ResponseRetrySettingNewrelicEvents,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingNewrelicEvents$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingNewrelicEvents$outboundSchema: z.ZodType<
  ResponseRetrySettingNewrelicEvents$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingNewrelicEvents
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingNewrelicEvents$ {
  /** @deprecated use `ResponseRetrySettingNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingNewrelicEvents$inboundSchema;
  /** @deprecated use `ResponseRetrySettingNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema =
    ResponseRetrySettingNewrelicEvents$outboundSchema;
  /** @deprecated use `ResponseRetrySettingNewrelicEvents$Outbound` instead. */
  export type Outbound = ResponseRetrySettingNewrelicEvents$Outbound;
}

export function responseRetrySettingNewrelicEventsToJSON(
  responseRetrySettingNewrelicEvents: ResponseRetrySettingNewrelicEvents,
): string {
  return JSON.stringify(
    ResponseRetrySettingNewrelicEvents$outboundSchema.parse(
      responseRetrySettingNewrelicEvents,
    ),
  );
}

export function responseRetrySettingNewrelicEventsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingNewrelicEvents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ResponseRetrySettingNewrelicEvents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingNewrelicEvents' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsNewrelicEvents$inboundSchema: z.ZodType<
  TimeoutRetrySettingsNewrelicEvents,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsNewrelicEvents$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsNewrelicEvents$outboundSchema: z.ZodType<
  TimeoutRetrySettingsNewrelicEvents$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsNewrelicEvents
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsNewrelicEvents$ {
  /** @deprecated use `TimeoutRetrySettingsNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsNewrelicEvents$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema =
    TimeoutRetrySettingsNewrelicEvents$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsNewrelicEvents$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsNewrelicEvents$Outbound;
}

export function timeoutRetrySettingsNewrelicEventsToJSON(
  timeoutRetrySettingsNewrelicEvents: TimeoutRetrySettingsNewrelicEvents,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsNewrelicEvents$outboundSchema.parse(
      timeoutRetrySettingsNewrelicEvents,
    ),
  );
}

export function timeoutRetrySettingsNewrelicEventsFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsNewrelicEvents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TimeoutRetrySettingsNewrelicEvents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsNewrelicEvents' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorNewrelicEvents$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorNewrelicEvents
> = z.nativeEnum(BackpressureBehaviorNewrelicEvents);

/** @internal */
export const BackpressureBehaviorNewrelicEvents$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorNewrelicEvents
> = BackpressureBehaviorNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorNewrelicEvents$ {
  /** @deprecated use `BackpressureBehaviorNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorNewrelicEvents$inboundSchema;
  /** @deprecated use `BackpressureBehaviorNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorNewrelicEvents$outboundSchema;
}

/** @internal */
export const AuthenticationMethodNewrelicEvents$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodNewrelicEvents
> = z.nativeEnum(AuthenticationMethodNewrelicEvents);

/** @internal */
export const AuthenticationMethodNewrelicEvents$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodNewrelicEvents
> = AuthenticationMethodNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodNewrelicEvents$ {
  /** @deprecated use `AuthenticationMethodNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodNewrelicEvents$inboundSchema;
  /** @deprecated use `AuthenticationMethodNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodNewrelicEvents$outboundSchema;
}

/** @internal */
export const CompressionNewrelicEvents$inboundSchema: z.ZodNativeEnum<
  typeof CompressionNewrelicEvents
> = z.nativeEnum(CompressionNewrelicEvents);

/** @internal */
export const CompressionNewrelicEvents$outboundSchema: z.ZodNativeEnum<
  typeof CompressionNewrelicEvents
> = CompressionNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionNewrelicEvents$ {
  /** @deprecated use `CompressionNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = CompressionNewrelicEvents$inboundSchema;
  /** @deprecated use `CompressionNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = CompressionNewrelicEvents$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorNewrelicEvents$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorNewrelicEvents
> = z.nativeEnum(QueueFullBehaviorNewrelicEvents);

/** @internal */
export const QueueFullBehaviorNewrelicEvents$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorNewrelicEvents
> = QueueFullBehaviorNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorNewrelicEvents$ {
  /** @deprecated use `QueueFullBehaviorNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorNewrelicEvents$inboundSchema;
  /** @deprecated use `QueueFullBehaviorNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorNewrelicEvents$outboundSchema;
}

/** @internal */
export const ModeNewrelicEvents$inboundSchema: z.ZodNativeEnum<
  typeof ModeNewrelicEvents
> = z.nativeEnum(ModeNewrelicEvents);

/** @internal */
export const ModeNewrelicEvents$outboundSchema: z.ZodNativeEnum<
  typeof ModeNewrelicEvents
> = ModeNewrelicEvents$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeNewrelicEvents$ {
  /** @deprecated use `ModeNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = ModeNewrelicEvents$inboundSchema;
  /** @deprecated use `ModeNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = ModeNewrelicEvents$outboundSchema;
}

/** @internal */
export const PqControlsNewrelicEvents$inboundSchema: z.ZodType<
  PqControlsNewrelicEvents,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsNewrelicEvents$Outbound = {};

/** @internal */
export const PqControlsNewrelicEvents$outboundSchema: z.ZodType<
  PqControlsNewrelicEvents$Outbound,
  z.ZodTypeDef,
  PqControlsNewrelicEvents
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsNewrelicEvents$ {
  /** @deprecated use `PqControlsNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = PqControlsNewrelicEvents$inboundSchema;
  /** @deprecated use `PqControlsNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = PqControlsNewrelicEvents$outboundSchema;
  /** @deprecated use `PqControlsNewrelicEvents$Outbound` instead. */
  export type Outbound = PqControlsNewrelicEvents$Outbound;
}

export function pqControlsNewrelicEventsToJSON(
  pqControlsNewrelicEvents: PqControlsNewrelicEvents,
): string {
  return JSON.stringify(
    PqControlsNewrelicEvents$outboundSchema.parse(pqControlsNewrelicEvents),
  );
}

export function pqControlsNewrelicEventsFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsNewrelicEvents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsNewrelicEvents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsNewrelicEvents' from JSON`,
  );
}

/** @internal */
export const OutputNewrelicEvents$inboundSchema: z.ZodType<
  OutputNewrelicEvents,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeNewrelicEvents$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: RegionNewrelicEvents$inboundSchema.default("US"),
  accountId: z.string(),
  eventType: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderNewrelicEvents$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeNewrelicEvents$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingNewrelicEvents$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsNewrelicEvents$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorNewrelicEvents$inboundSchema.default(
    "block",
  ),
  authType: AuthenticationMethodNewrelicEvents$inboundSchema.default("manual"),
  description: z.string().optional(),
  customUrl: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionNewrelicEvents$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorNewrelicEvents$inboundSchema.default(
    "block",
  ),
  pqMode: ModeNewrelicEvents$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsNewrelicEvents$inboundSchema).optional(),
  apiKey: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputNewrelicEvents$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  region: string;
  accountId: string;
  eventType: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderNewrelicEvents$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingNewrelicEvents$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | TimeoutRetrySettingsNewrelicEvents$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  customUrl?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsNewrelicEvents$Outbound | undefined;
  apiKey?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputNewrelicEvents$outboundSchema: z.ZodType<
  OutputNewrelicEvents$Outbound,
  z.ZodTypeDef,
  OutputNewrelicEvents
> = z.object({
  id: z.string(),
  type: TypeNewrelicEvents$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  region: RegionNewrelicEvents$outboundSchema.default("US"),
  accountId: z.string(),
  eventType: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderNewrelicEvents$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode:
    FailedRequestLoggingModeNewrelicEvents$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingNewrelicEvents$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsNewrelicEvents$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorNewrelicEvents$outboundSchema.default(
    "block",
  ),
  authType: AuthenticationMethodNewrelicEvents$outboundSchema.default("manual"),
  description: z.string().optional(),
  customUrl: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionNewrelicEvents$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorNewrelicEvents$outboundSchema.default(
    "block",
  ),
  pqMode: ModeNewrelicEvents$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsNewrelicEvents$outboundSchema).optional(),
  apiKey: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputNewrelicEvents$ {
  /** @deprecated use `OutputNewrelicEvents$inboundSchema` instead. */
  export const inboundSchema = OutputNewrelicEvents$inboundSchema;
  /** @deprecated use `OutputNewrelicEvents$outboundSchema` instead. */
  export const outboundSchema = OutputNewrelicEvents$outboundSchema;
  /** @deprecated use `OutputNewrelicEvents$Outbound` instead. */
  export type Outbound = OutputNewrelicEvents$Outbound;
}

export function outputNewrelicEventsToJSON(
  outputNewrelicEvents: OutputNewrelicEvents,
): string {
  return JSON.stringify(
    OutputNewrelicEvents$outboundSchema.parse(outputNewrelicEvents),
  );
}

export function outputNewrelicEventsFromJSON(
  jsonString: string,
): SafeParseResult<OutputNewrelicEvents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNewrelicEvents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNewrelicEvents' from JSON`,
  );
}

/** @internal */
export const TypeElasticCloud$inboundSchema: z.ZodNativeEnum<
  typeof TypeElasticCloud
> = z.nativeEnum(TypeElasticCloud);

/** @internal */
export const TypeElasticCloud$outboundSchema: z.ZodNativeEnum<
  typeof TypeElasticCloud
> = TypeElasticCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeElasticCloud$ {
  /** @deprecated use `TypeElasticCloud$inboundSchema` instead. */
  export const inboundSchema = TypeElasticCloud$inboundSchema;
  /** @deprecated use `TypeElasticCloud$outboundSchema` instead. */
  export const outboundSchema = TypeElasticCloud$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderElasticCloud$inboundSchema: z.ZodType<
  ExtraHttpHeaderElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderElasticCloud$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderElasticCloud$outboundSchema: z.ZodType<
  ExtraHttpHeaderElasticCloud$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderElasticCloud
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderElasticCloud$ {
  /** @deprecated use `ExtraHttpHeaderElasticCloud$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderElasticCloud$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderElasticCloud$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderElasticCloud$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderElasticCloud$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderElasticCloud$Outbound;
}

export function extraHttpHeaderElasticCloudToJSON(
  extraHttpHeaderElasticCloud: ExtraHttpHeaderElasticCloud,
): string {
  return JSON.stringify(
    ExtraHttpHeaderElasticCloud$outboundSchema.parse(
      extraHttpHeaderElasticCloud,
    ),
  );
}

export function extraHttpHeaderElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderElasticCloud' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeElasticCloud$inboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeElasticCloud> = z.nativeEnum(
    FailedRequestLoggingModeElasticCloud,
  );

/** @internal */
export const FailedRequestLoggingModeElasticCloud$outboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeElasticCloud> =
    FailedRequestLoggingModeElasticCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeElasticCloud$ {
  /** @deprecated use `FailedRequestLoggingModeElasticCloud$inboundSchema` instead. */
  export const inboundSchema =
    FailedRequestLoggingModeElasticCloud$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeElasticCloud$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeElasticCloud$outboundSchema;
}

/** @internal */
export const ExtraParamElasticCloud$inboundSchema: z.ZodType<
  ExtraParamElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type ExtraParamElasticCloud$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const ExtraParamElasticCloud$outboundSchema: z.ZodType<
  ExtraParamElasticCloud$Outbound,
  z.ZodTypeDef,
  ExtraParamElasticCloud
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraParamElasticCloud$ {
  /** @deprecated use `ExtraParamElasticCloud$inboundSchema` instead. */
  export const inboundSchema = ExtraParamElasticCloud$inboundSchema;
  /** @deprecated use `ExtraParamElasticCloud$outboundSchema` instead. */
  export const outboundSchema = ExtraParamElasticCloud$outboundSchema;
  /** @deprecated use `ExtraParamElasticCloud$Outbound` instead. */
  export type Outbound = ExtraParamElasticCloud$Outbound;
}

export function extraParamElasticCloudToJSON(
  extraParamElasticCloud: ExtraParamElasticCloud,
): string {
  return JSON.stringify(
    ExtraParamElasticCloud$outboundSchema.parse(extraParamElasticCloud),
  );
}

export function extraParamElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<ExtraParamElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraParamElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraParamElasticCloud' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodElasticCloud$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodElasticCloud
> = z.nativeEnum(AuthenticationMethodElasticCloud);

/** @internal */
export const AuthenticationMethodElasticCloud$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodElasticCloud
> = AuthenticationMethodElasticCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodElasticCloud$ {
  /** @deprecated use `AuthenticationMethodElasticCloud$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodElasticCloud$inboundSchema;
  /** @deprecated use `AuthenticationMethodElasticCloud$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodElasticCloud$outboundSchema;
}

/** @internal */
export const AuthElasticCloud$inboundSchema: z.ZodType<
  AuthElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  authType: AuthenticationMethodElasticCloud$inboundSchema.default("manual"),
});

/** @internal */
export type AuthElasticCloud$Outbound = {
  disabled: boolean;
  authType: string;
};

/** @internal */
export const AuthElasticCloud$outboundSchema: z.ZodType<
  AuthElasticCloud$Outbound,
  z.ZodTypeDef,
  AuthElasticCloud
> = z.object({
  disabled: z.boolean().default(false),
  authType: AuthenticationMethodElasticCloud$outboundSchema.default("manual"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthElasticCloud$ {
  /** @deprecated use `AuthElasticCloud$inboundSchema` instead. */
  export const inboundSchema = AuthElasticCloud$inboundSchema;
  /** @deprecated use `AuthElasticCloud$outboundSchema` instead. */
  export const outboundSchema = AuthElasticCloud$outboundSchema;
  /** @deprecated use `AuthElasticCloud$Outbound` instead. */
  export type Outbound = AuthElasticCloud$Outbound;
}

export function authElasticCloudToJSON(
  authElasticCloud: AuthElasticCloud,
): string {
  return JSON.stringify(
    AuthElasticCloud$outboundSchema.parse(authElasticCloud),
  );
}

export function authElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<AuthElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthElasticCloud' from JSON`,
  );
}

/** @internal */
export const ResponseRetrySettingElasticCloud$inboundSchema: z.ZodType<
  ResponseRetrySettingElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingElasticCloud$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingElasticCloud$outboundSchema: z.ZodType<
  ResponseRetrySettingElasticCloud$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingElasticCloud
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingElasticCloud$ {
  /** @deprecated use `ResponseRetrySettingElasticCloud$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingElasticCloud$inboundSchema;
  /** @deprecated use `ResponseRetrySettingElasticCloud$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingElasticCloud$outboundSchema;
  /** @deprecated use `ResponseRetrySettingElasticCloud$Outbound` instead. */
  export type Outbound = ResponseRetrySettingElasticCloud$Outbound;
}

export function responseRetrySettingElasticCloudToJSON(
  responseRetrySettingElasticCloud: ResponseRetrySettingElasticCloud,
): string {
  return JSON.stringify(
    ResponseRetrySettingElasticCloud$outboundSchema.parse(
      responseRetrySettingElasticCloud,
    ),
  );
}

export function responseRetrySettingElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingElasticCloud' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsElasticCloud$inboundSchema: z.ZodType<
  TimeoutRetrySettingsElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsElasticCloud$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsElasticCloud$outboundSchema: z.ZodType<
  TimeoutRetrySettingsElasticCloud$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsElasticCloud
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsElasticCloud$ {
  /** @deprecated use `TimeoutRetrySettingsElasticCloud$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsElasticCloud$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsElasticCloud$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsElasticCloud$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsElasticCloud$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsElasticCloud$Outbound;
}

export function timeoutRetrySettingsElasticCloudToJSON(
  timeoutRetrySettingsElasticCloud: TimeoutRetrySettingsElasticCloud,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsElasticCloud$outboundSchema.parse(
      timeoutRetrySettingsElasticCloud,
    ),
  );
}

export function timeoutRetrySettingsElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsElasticCloud' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorElasticCloud$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorElasticCloud
> = z.nativeEnum(BackpressureBehaviorElasticCloud);

/** @internal */
export const BackpressureBehaviorElasticCloud$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorElasticCloud
> = BackpressureBehaviorElasticCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorElasticCloud$ {
  /** @deprecated use `BackpressureBehaviorElasticCloud$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorElasticCloud$inboundSchema;
  /** @deprecated use `BackpressureBehaviorElasticCloud$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorElasticCloud$outboundSchema;
}

/** @internal */
export const CompressionElasticCloud$inboundSchema: z.ZodNativeEnum<
  typeof CompressionElasticCloud
> = z.nativeEnum(CompressionElasticCloud);

/** @internal */
export const CompressionElasticCloud$outboundSchema: z.ZodNativeEnum<
  typeof CompressionElasticCloud
> = CompressionElasticCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionElasticCloud$ {
  /** @deprecated use `CompressionElasticCloud$inboundSchema` instead. */
  export const inboundSchema = CompressionElasticCloud$inboundSchema;
  /** @deprecated use `CompressionElasticCloud$outboundSchema` instead. */
  export const outboundSchema = CompressionElasticCloud$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorElasticCloud$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorElasticCloud
> = z.nativeEnum(QueueFullBehaviorElasticCloud);

/** @internal */
export const QueueFullBehaviorElasticCloud$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorElasticCloud
> = QueueFullBehaviorElasticCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorElasticCloud$ {
  /** @deprecated use `QueueFullBehaviorElasticCloud$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorElasticCloud$inboundSchema;
  /** @deprecated use `QueueFullBehaviorElasticCloud$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorElasticCloud$outboundSchema;
}

/** @internal */
export const ModeElasticCloud$inboundSchema: z.ZodNativeEnum<
  typeof ModeElasticCloud
> = z.nativeEnum(ModeElasticCloud);

/** @internal */
export const ModeElasticCloud$outboundSchema: z.ZodNativeEnum<
  typeof ModeElasticCloud
> = ModeElasticCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeElasticCloud$ {
  /** @deprecated use `ModeElasticCloud$inboundSchema` instead. */
  export const inboundSchema = ModeElasticCloud$inboundSchema;
  /** @deprecated use `ModeElasticCloud$outboundSchema` instead. */
  export const outboundSchema = ModeElasticCloud$outboundSchema;
}

/** @internal */
export const PqControlsElasticCloud$inboundSchema: z.ZodType<
  PqControlsElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsElasticCloud$Outbound = {};

/** @internal */
export const PqControlsElasticCloud$outboundSchema: z.ZodType<
  PqControlsElasticCloud$Outbound,
  z.ZodTypeDef,
  PqControlsElasticCloud
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsElasticCloud$ {
  /** @deprecated use `PqControlsElasticCloud$inboundSchema` instead. */
  export const inboundSchema = PqControlsElasticCloud$inboundSchema;
  /** @deprecated use `PqControlsElasticCloud$outboundSchema` instead. */
  export const outboundSchema = PqControlsElasticCloud$outboundSchema;
  /** @deprecated use `PqControlsElasticCloud$Outbound` instead. */
  export type Outbound = PqControlsElasticCloud$Outbound;
}

export function pqControlsElasticCloudToJSON(
  pqControlsElasticCloud: PqControlsElasticCloud,
): string {
  return JSON.stringify(
    PqControlsElasticCloud$outboundSchema.parse(pqControlsElasticCloud),
  );
}

export function pqControlsElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsElasticCloud' from JSON`,
  );
}

/** @internal */
export const OutputElasticCloud$inboundSchema: z.ZodType<
  OutputElasticCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeElasticCloud$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  index: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderElasticCloud$inboundSchema),
  ).optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeElasticCloud$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  extraParams: z.array(z.lazy(() => ExtraParamElasticCloud$inboundSchema))
    .optional(),
  auth: z.lazy(() => AuthElasticCloud$inboundSchema).optional(),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(true),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingElasticCloud$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsElasticCloud$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorElasticCloud$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionElasticCloud$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorElasticCloud$inboundSchema.default(
    "block",
  ),
  pqMode: ModeElasticCloud$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsElasticCloud$inboundSchema).optional(),
});

/** @internal */
export type OutputElasticCloud$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  index: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderElasticCloud$Outbound> | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  extraParams?: Array<ExtraParamElasticCloud$Outbound> | undefined;
  auth?: AuthElasticCloud$Outbound | undefined;
  elasticPipeline?: string | undefined;
  includeDocId: boolean;
  responseRetrySettings?:
    | Array<ResponseRetrySettingElasticCloud$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsElasticCloud$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsElasticCloud$Outbound | undefined;
};

/** @internal */
export const OutputElasticCloud$outboundSchema: z.ZodType<
  OutputElasticCloud$Outbound,
  z.ZodTypeDef,
  OutputElasticCloud
> = z.object({
  id: z.string(),
  type: TypeElasticCloud$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  index: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderElasticCloud$outboundSchema),
  ).optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeElasticCloud$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  extraParams: z.array(z.lazy(() => ExtraParamElasticCloud$outboundSchema))
    .optional(),
  auth: z.lazy(() => AuthElasticCloud$outboundSchema).optional(),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(true),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingElasticCloud$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsElasticCloud$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorElasticCloud$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionElasticCloud$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorElasticCloud$outboundSchema.default(
    "block",
  ),
  pqMode: ModeElasticCloud$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsElasticCloud$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElasticCloud$ {
  /** @deprecated use `OutputElasticCloud$inboundSchema` instead. */
  export const inboundSchema = OutputElasticCloud$inboundSchema;
  /** @deprecated use `OutputElasticCloud$outboundSchema` instead. */
  export const outboundSchema = OutputElasticCloud$outboundSchema;
  /** @deprecated use `OutputElasticCloud$Outbound` instead. */
  export type Outbound = OutputElasticCloud$Outbound;
}

export function outputElasticCloudToJSON(
  outputElasticCloud: OutputElasticCloud,
): string {
  return JSON.stringify(
    OutputElasticCloud$outboundSchema.parse(outputElasticCloud),
  );
}

export function outputElasticCloudFromJSON(
  jsonString: string,
): SafeParseResult<OutputElasticCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElasticCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElasticCloud' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeElastic$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeElastic
> = z.nativeEnum(CreateOutputTypeElastic);

/** @internal */
export const CreateOutputTypeElastic$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeElastic
> = CreateOutputTypeElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeElastic$ {
  /** @deprecated use `CreateOutputTypeElastic$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeElastic$inboundSchema;
  /** @deprecated use `CreateOutputTypeElastic$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeElastic$outboundSchema;
}

/** @internal */
export const CreateOutputExtraHttpHeaderElastic$inboundSchema: z.ZodType<
  CreateOutputExtraHttpHeaderElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type CreateOutputExtraHttpHeaderElastic$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const CreateOutputExtraHttpHeaderElastic$outboundSchema: z.ZodType<
  CreateOutputExtraHttpHeaderElastic$Outbound,
  z.ZodTypeDef,
  CreateOutputExtraHttpHeaderElastic
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputExtraHttpHeaderElastic$ {
  /** @deprecated use `CreateOutputExtraHttpHeaderElastic$inboundSchema` instead. */
  export const inboundSchema = CreateOutputExtraHttpHeaderElastic$inboundSchema;
  /** @deprecated use `CreateOutputExtraHttpHeaderElastic$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputExtraHttpHeaderElastic$outboundSchema;
  /** @deprecated use `CreateOutputExtraHttpHeaderElastic$Outbound` instead. */
  export type Outbound = CreateOutputExtraHttpHeaderElastic$Outbound;
}

export function createOutputExtraHttpHeaderElasticToJSON(
  createOutputExtraHttpHeaderElastic: CreateOutputExtraHttpHeaderElastic,
): string {
  return JSON.stringify(
    CreateOutputExtraHttpHeaderElastic$outboundSchema.parse(
      createOutputExtraHttpHeaderElastic,
    ),
  );
}

export function createOutputExtraHttpHeaderElasticFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputExtraHttpHeaderElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputExtraHttpHeaderElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputExtraHttpHeaderElastic' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeElastic$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeElastic
> = z.nativeEnum(FailedRequestLoggingModeElastic);

/** @internal */
export const FailedRequestLoggingModeElastic$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeElastic
> = FailedRequestLoggingModeElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeElastic$ {
  /** @deprecated use `FailedRequestLoggingModeElastic$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeElastic$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeElastic$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingModeElastic$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingElastic$inboundSchema: z.ZodType<
  ResponseRetrySettingElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingElastic$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingElastic$outboundSchema: z.ZodType<
  ResponseRetrySettingElastic$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingElastic
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingElastic$ {
  /** @deprecated use `ResponseRetrySettingElastic$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingElastic$inboundSchema;
  /** @deprecated use `ResponseRetrySettingElastic$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingElastic$outboundSchema;
  /** @deprecated use `ResponseRetrySettingElastic$Outbound` instead. */
  export type Outbound = ResponseRetrySettingElastic$Outbound;
}

export function responseRetrySettingElasticToJSON(
  responseRetrySettingElastic: ResponseRetrySettingElastic,
): string {
  return JSON.stringify(
    ResponseRetrySettingElastic$outboundSchema.parse(
      responseRetrySettingElastic,
    ),
  );
}

export function responseRetrySettingElasticFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingElastic' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsElastic$inboundSchema: z.ZodType<
  TimeoutRetrySettingsElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsElastic$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsElastic$outboundSchema: z.ZodType<
  TimeoutRetrySettingsElastic$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsElastic
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsElastic$ {
  /** @deprecated use `TimeoutRetrySettingsElastic$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsElastic$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsElastic$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsElastic$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsElastic$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsElastic$Outbound;
}

export function timeoutRetrySettingsElasticToJSON(
  timeoutRetrySettingsElastic: TimeoutRetrySettingsElastic,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsElastic$outboundSchema.parse(
      timeoutRetrySettingsElastic,
    ),
  );
}

export function timeoutRetrySettingsElasticFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsElastic' from JSON`,
  );
}

/** @internal */
export const ExtraParamElastic$inboundSchema: z.ZodType<
  ExtraParamElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type ExtraParamElastic$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const ExtraParamElastic$outboundSchema: z.ZodType<
  ExtraParamElastic$Outbound,
  z.ZodTypeDef,
  ExtraParamElastic
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraParamElastic$ {
  /** @deprecated use `ExtraParamElastic$inboundSchema` instead. */
  export const inboundSchema = ExtraParamElastic$inboundSchema;
  /** @deprecated use `ExtraParamElastic$outboundSchema` instead. */
  export const outboundSchema = ExtraParamElastic$outboundSchema;
  /** @deprecated use `ExtraParamElastic$Outbound` instead. */
  export type Outbound = ExtraParamElastic$Outbound;
}

export function extraParamElasticToJSON(
  extraParamElastic: ExtraParamElastic,
): string {
  return JSON.stringify(
    ExtraParamElastic$outboundSchema.parse(extraParamElastic),
  );
}

export function extraParamElasticFromJSON(
  jsonString: string,
): SafeParseResult<ExtraParamElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraParamElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraParamElastic' from JSON`,
  );
}

/** @internal */
export const AuthAuthenticationMethodElastic$inboundSchema: z.ZodNativeEnum<
  typeof AuthAuthenticationMethodElastic
> = z.nativeEnum(AuthAuthenticationMethodElastic);

/** @internal */
export const AuthAuthenticationMethodElastic$outboundSchema: z.ZodNativeEnum<
  typeof AuthAuthenticationMethodElastic
> = AuthAuthenticationMethodElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthAuthenticationMethodElastic$ {
  /** @deprecated use `AuthAuthenticationMethodElastic$inboundSchema` instead. */
  export const inboundSchema = AuthAuthenticationMethodElastic$inboundSchema;
  /** @deprecated use `AuthAuthenticationMethodElastic$outboundSchema` instead. */
  export const outboundSchema = AuthAuthenticationMethodElastic$outboundSchema;
}

/** @internal */
export const AuthElastic$inboundSchema: z.ZodType<
  AuthElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  authType: AuthAuthenticationMethodElastic$inboundSchema.default("manual"),
});

/** @internal */
export type AuthElastic$Outbound = {
  disabled: boolean;
  authType: string;
};

/** @internal */
export const AuthElastic$outboundSchema: z.ZodType<
  AuthElastic$Outbound,
  z.ZodTypeDef,
  AuthElastic
> = z.object({
  disabled: z.boolean().default(true),
  authType: AuthAuthenticationMethodElastic$outboundSchema.default("manual"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthElastic$ {
  /** @deprecated use `AuthElastic$inboundSchema` instead. */
  export const inboundSchema = AuthElastic$inboundSchema;
  /** @deprecated use `AuthElastic$outboundSchema` instead. */
  export const outboundSchema = AuthElastic$outboundSchema;
  /** @deprecated use `AuthElastic$Outbound` instead. */
  export type Outbound = AuthElastic$Outbound;
}

export function authElasticToJSON(authElastic: AuthElastic): string {
  return JSON.stringify(AuthElastic$outboundSchema.parse(authElastic));
}

export function authElasticFromJSON(
  jsonString: string,
): SafeParseResult<AuthElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthElastic' from JSON`,
  );
}

/** @internal */
export const ElasticVersion$inboundSchema: z.ZodNativeEnum<
  typeof ElasticVersion
> = z.nativeEnum(ElasticVersion);

/** @internal */
export const ElasticVersion$outboundSchema: z.ZodNativeEnum<
  typeof ElasticVersion
> = ElasticVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ElasticVersion$ {
  /** @deprecated use `ElasticVersion$inboundSchema` instead. */
  export const inboundSchema = ElasticVersion$inboundSchema;
  /** @deprecated use `ElasticVersion$outboundSchema` instead. */
  export const outboundSchema = ElasticVersion$outboundSchema;
}

/** @internal */
export const WriteAction$inboundSchema: z.ZodNativeEnum<typeof WriteAction> = z
  .nativeEnum(WriteAction);

/** @internal */
export const WriteAction$outboundSchema: z.ZodNativeEnum<typeof WriteAction> =
  WriteAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WriteAction$ {
  /** @deprecated use `WriteAction$inboundSchema` instead. */
  export const inboundSchema = WriteAction$inboundSchema;
  /** @deprecated use `WriteAction$outboundSchema` instead. */
  export const outboundSchema = WriteAction$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorElastic$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorElastic
> = z.nativeEnum(BackpressureBehaviorElastic);

/** @internal */
export const BackpressureBehaviorElastic$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorElastic
> = BackpressureBehaviorElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorElastic$ {
  /** @deprecated use `BackpressureBehaviorElastic$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorElastic$inboundSchema;
  /** @deprecated use `BackpressureBehaviorElastic$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorElastic$outboundSchema;
}

/** @internal */
export const Url$inboundSchema: z.ZodType<Url, z.ZodTypeDef, unknown> = z
  .object({
    url: z.string(),
    weight: z.number().default(1),
  });

/** @internal */
export type Url$Outbound = {
  url: string;
  weight: number;
};

/** @internal */
export const Url$outboundSchema: z.ZodType<Url$Outbound, z.ZodTypeDef, Url> = z
  .object({
    url: z.string(),
    weight: z.number().default(1),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Url$ {
  /** @deprecated use `Url$inboundSchema` instead. */
  export const inboundSchema = Url$inboundSchema;
  /** @deprecated use `Url$outboundSchema` instead. */
  export const outboundSchema = Url$outboundSchema;
  /** @deprecated use `Url$Outbound` instead. */
  export type Outbound = Url$Outbound;
}

export function urlToJSON(url: Url): string {
  return JSON.stringify(Url$outboundSchema.parse(url));
}

export function urlFromJSON(
  jsonString: string,
): SafeParseResult<Url, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Url$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Url' from JSON`,
  );
}

/** @internal */
export const PqCompressCompressionElastic$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionElastic
> = z.nativeEnum(PqCompressCompressionElastic);

/** @internal */
export const PqCompressCompressionElastic$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionElastic
> = PqCompressCompressionElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionElastic$ {
  /** @deprecated use `PqCompressCompressionElastic$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionElastic$inboundSchema;
  /** @deprecated use `PqCompressCompressionElastic$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionElastic$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorElastic$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorElastic
> = z.nativeEnum(QueueFullBehaviorElastic);

/** @internal */
export const QueueFullBehaviorElastic$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorElastic
> = QueueFullBehaviorElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorElastic$ {
  /** @deprecated use `QueueFullBehaviorElastic$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorElastic$inboundSchema;
  /** @deprecated use `QueueFullBehaviorElastic$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorElastic$outboundSchema;
}

/** @internal */
export const CreateOutputModeElastic$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeElastic
> = z.nativeEnum(CreateOutputModeElastic);

/** @internal */
export const CreateOutputModeElastic$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeElastic
> = CreateOutputModeElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeElastic$ {
  /** @deprecated use `CreateOutputModeElastic$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeElastic$inboundSchema;
  /** @deprecated use `CreateOutputModeElastic$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeElastic$outboundSchema;
}

/** @internal */
export const PqControlsElastic$inboundSchema: z.ZodType<
  PqControlsElastic,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsElastic$Outbound = {};

/** @internal */
export const PqControlsElastic$outboundSchema: z.ZodType<
  PqControlsElastic$Outbound,
  z.ZodTypeDef,
  PqControlsElastic
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsElastic$ {
  /** @deprecated use `PqControlsElastic$inboundSchema` instead. */
  export const inboundSchema = PqControlsElastic$inboundSchema;
  /** @deprecated use `PqControlsElastic$outboundSchema` instead. */
  export const outboundSchema = PqControlsElastic$outboundSchema;
  /** @deprecated use `PqControlsElastic$Outbound` instead. */
  export type Outbound = PqControlsElastic$Outbound;
}

export function pqControlsElasticToJSON(
  pqControlsElastic: PqControlsElastic,
): string {
  return JSON.stringify(
    PqControlsElastic$outboundSchema.parse(pqControlsElastic),
  );
}

export function pqControlsElasticFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsElastic' from JSON`,
  );
}

/** @internal */
export const OutputElastic$inboundSchema: z.ZodType<
  OutputElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeElastic$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().default(true),
  index: z.string(),
  docType: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => CreateOutputExtraHttpHeaderElastic$inboundSchema),
  ).optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeElastic$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingElastic$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsElastic$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  extraParams: z.array(z.lazy(() => ExtraParamElastic$inboundSchema))
    .optional(),
  auth: z.lazy(() => AuthElastic$inboundSchema).optional(),
  elasticVersion: ElasticVersion$inboundSchema.default("auto"),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(false),
  writeAction: WriteAction$inboundSchema.default("create"),
  retryPartialErrors: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorElastic$inboundSchema.default("block"),
  description: z.string().optional(),
  url: z.string().optional(),
  useRoundRobinDns: z.boolean().default(false),
  excludeSelf: z.boolean().default(false),
  urls: z.array(z.lazy(() => Url$inboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionElastic$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorElastic$inboundSchema.default("block"),
  pqMode: CreateOutputModeElastic$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsElastic$inboundSchema).optional(),
});

/** @internal */
export type OutputElastic$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  loadBalanced: boolean;
  index: string;
  docType?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?:
    | Array<CreateOutputExtraHttpHeaderElastic$Outbound>
    | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingElastic$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsElastic$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  extraParams?: Array<ExtraParamElastic$Outbound> | undefined;
  auth?: AuthElastic$Outbound | undefined;
  elasticVersion: string;
  elasticPipeline?: string | undefined;
  includeDocId: boolean;
  writeAction: string;
  retryPartialErrors: boolean;
  onBackpressure: string;
  description?: string | undefined;
  url?: string | undefined;
  useRoundRobinDns: boolean;
  excludeSelf: boolean;
  urls?: Array<Url$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsElastic$Outbound | undefined;
};

/** @internal */
export const OutputElastic$outboundSchema: z.ZodType<
  OutputElastic$Outbound,
  z.ZodTypeDef,
  OutputElastic
> = z.object({
  id: z.string(),
  type: CreateOutputTypeElastic$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().default(true),
  index: z.string(),
  docType: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => CreateOutputExtraHttpHeaderElastic$outboundSchema),
  ).optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeElastic$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingElastic$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsElastic$outboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  extraParams: z.array(z.lazy(() => ExtraParamElastic$outboundSchema))
    .optional(),
  auth: z.lazy(() => AuthElastic$outboundSchema).optional(),
  elasticVersion: ElasticVersion$outboundSchema.default("auto"),
  elasticPipeline: z.string().optional(),
  includeDocId: z.boolean().default(false),
  writeAction: WriteAction$outboundSchema.default("create"),
  retryPartialErrors: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorElastic$outboundSchema.default("block"),
  description: z.string().optional(),
  url: z.string().optional(),
  useRoundRobinDns: z.boolean().default(false),
  excludeSelf: z.boolean().default(false),
  urls: z.array(z.lazy(() => Url$outboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionElastic$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorElastic$outboundSchema.default("block"),
  pqMode: CreateOutputModeElastic$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsElastic$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputElastic$ {
  /** @deprecated use `OutputElastic$inboundSchema` instead. */
  export const inboundSchema = OutputElastic$inboundSchema;
  /** @deprecated use `OutputElastic$outboundSchema` instead. */
  export const outboundSchema = OutputElastic$outboundSchema;
  /** @deprecated use `OutputElastic$Outbound` instead. */
  export type Outbound = OutputElastic$Outbound;
}

export function outputElasticToJSON(outputElastic: OutputElastic): string {
  return JSON.stringify(OutputElastic$outboundSchema.parse(outputElastic));
}

export function outputElasticFromJSON(
  jsonString: string,
): SafeParseResult<OutputElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputElastic' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeMsk
> = z.nativeEnum(CreateOutputTypeMsk);

/** @internal */
export const CreateOutputTypeMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeMsk
> = CreateOutputTypeMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeMsk$ {
  /** @deprecated use `CreateOutputTypeMsk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeMsk$inboundSchema;
  /** @deprecated use `CreateOutputTypeMsk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeMsk$outboundSchema;
}

/** @internal */
export const AcknowledgmentsMsk$inboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsMsk
> = z.nativeEnum(AcknowledgmentsMsk);

/** @internal */
export const AcknowledgmentsMsk$outboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsMsk
> = AcknowledgmentsMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AcknowledgmentsMsk$ {
  /** @deprecated use `AcknowledgmentsMsk$inboundSchema` instead. */
  export const inboundSchema = AcknowledgmentsMsk$inboundSchema;
  /** @deprecated use `AcknowledgmentsMsk$outboundSchema` instead. */
  export const outboundSchema = AcknowledgmentsMsk$outboundSchema;
}

/** @internal */
export const RecordDataFormatMsk$inboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatMsk
> = z.nativeEnum(RecordDataFormatMsk);

/** @internal */
export const RecordDataFormatMsk$outboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatMsk
> = RecordDataFormatMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordDataFormatMsk$ {
  /** @deprecated use `RecordDataFormatMsk$inboundSchema` instead. */
  export const inboundSchema = RecordDataFormatMsk$inboundSchema;
  /** @deprecated use `RecordDataFormatMsk$outboundSchema` instead. */
  export const outboundSchema = RecordDataFormatMsk$outboundSchema;
}

/** @internal */
export const CreateOutputCompressionMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionMsk
> = z.nativeEnum(CreateOutputCompressionMsk);

/** @internal */
export const CreateOutputCompressionMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionMsk
> = CreateOutputCompressionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressionMsk$ {
  /** @deprecated use `CreateOutputCompressionMsk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputCompressionMsk$inboundSchema;
  /** @deprecated use `CreateOutputCompressionMsk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputCompressionMsk$outboundSchema;
}

/** @internal */
export const CreateOutputAuthMsk$inboundSchema: z.ZodType<
  CreateOutputAuthMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type CreateOutputAuthMsk$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const CreateOutputAuthMsk$outboundSchema: z.ZodType<
  CreateOutputAuthMsk$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthMsk
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthMsk$ {
  /** @deprecated use `CreateOutputAuthMsk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthMsk$inboundSchema;
  /** @deprecated use `CreateOutputAuthMsk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAuthMsk$outboundSchema;
  /** @deprecated use `CreateOutputAuthMsk$Outbound` instead. */
  export type Outbound = CreateOutputAuthMsk$Outbound;
}

export function createOutputAuthMskToJSON(
  createOutputAuthMsk: CreateOutputAuthMsk,
): string {
  return JSON.stringify(
    CreateOutputAuthMsk$outboundSchema.parse(createOutputAuthMsk),
  );
}

export function createOutputAuthMskFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputAuthMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputAuthMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputAuthMsk' from JSON`,
  );
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk> =
    z.nativeEnum(CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk);

/** @internal */
export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk> =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk> =
    z.nativeEnum(CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk);

/** @internal */
export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk> =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema
        .optional(),
    maxVersion:
      CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema
        .optional(),
  });

/** @internal */
export type CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound,
    z.ZodTypeDef,
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateOutputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema
        .optional(),
    maxVersion:
      CreateOutputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound` instead. */
  export type Outbound =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound;
}

export function createOutputKafkaSchemaRegistryTLSSettingsClientSideMskToJSON(
  createOutputKafkaSchemaRegistryTLSSettingsClientSideMsk:
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk,
): string {
  return JSON.stringify(
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema
      .parse(createOutputKafkaSchemaRegistryTLSSettingsClientSideMsk),
  );
}

export function createOutputKafkaSchemaRegistryTLSSettingsClientSideMskFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk' from JSON`,
  );
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryAuthenticationMsk$inboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryAuthenticationMsk,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateOutputAuthMsk$inboundSchema).optional(),
    tls: z.lazy(() =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/** @internal */
export type CreateOutputKafkaSchemaRegistryAuthenticationMsk$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: CreateOutputAuthMsk$Outbound | undefined;
  tls?:
    | CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound
    | undefined;
  defaultKeySchemaId?: number | undefined;
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const CreateOutputKafkaSchemaRegistryAuthenticationMsk$outboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryAuthenticationMsk$Outbound,
    z.ZodTypeDef,
    CreateOutputKafkaSchemaRegistryAuthenticationMsk
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateOutputAuthMsk$outboundSchema).optional(),
    tls: z.lazy(() =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryAuthenticationMsk$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryAuthenticationMsk$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryAuthenticationMsk$outboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationMsk$Outbound` instead. */
  export type Outbound =
    CreateOutputKafkaSchemaRegistryAuthenticationMsk$Outbound;
}

export function createOutputKafkaSchemaRegistryAuthenticationMskToJSON(
  createOutputKafkaSchemaRegistryAuthenticationMsk:
    CreateOutputKafkaSchemaRegistryAuthenticationMsk,
): string {
  return JSON.stringify(
    CreateOutputKafkaSchemaRegistryAuthenticationMsk$outboundSchema.parse(
      createOutputKafkaSchemaRegistryAuthenticationMsk,
    ),
  );
}

export function createOutputKafkaSchemaRegistryAuthenticationMskFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputKafkaSchemaRegistryAuthenticationMsk,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputKafkaSchemaRegistryAuthenticationMsk$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateOutputKafkaSchemaRegistryAuthenticationMsk' from JSON`,
  );
}

/** @internal */
export const CreateOutputAuthenticationMethodMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAuthenticationMethodMsk
> = z.nativeEnum(CreateOutputAuthenticationMethodMsk);

/** @internal */
export const CreateOutputAuthenticationMethodMsk$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodMsk> =
    CreateOutputAuthenticationMethodMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationMethodMsk$ {
  /** @deprecated use `CreateOutputAuthenticationMethodMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputAuthenticationMethodMsk$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationMethodMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationMethodMsk$outboundSchema;
}

/** @internal */
export const CreateOutputSignatureVersionMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSignatureVersionMsk
> = z.nativeEnum(CreateOutputSignatureVersionMsk);

/** @internal */
export const CreateOutputSignatureVersionMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSignatureVersionMsk
> = CreateOutputSignatureVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputSignatureVersionMsk$ {
  /** @deprecated use `CreateOutputSignatureVersionMsk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputSignatureVersionMsk$inboundSchema;
  /** @deprecated use `CreateOutputSignatureVersionMsk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputSignatureVersionMsk$outboundSchema;
}

/** @internal */
export const CreateOutputMinimumTLSVersionMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMinimumTLSVersionMsk
> = z.nativeEnum(CreateOutputMinimumTLSVersionMsk);

/** @internal */
export const CreateOutputMinimumTLSVersionMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMinimumTLSVersionMsk
> = CreateOutputMinimumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMinimumTLSVersionMsk$ {
  /** @deprecated use `CreateOutputMinimumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputMinimumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateOutputMinimumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputMinimumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateOutputMaximumTLSVersionMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMaximumTLSVersionMsk
> = z.nativeEnum(CreateOutputMaximumTLSVersionMsk);

/** @internal */
export const CreateOutputMaximumTLSVersionMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMaximumTLSVersionMsk
> = CreateOutputMaximumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMaximumTLSVersionMsk$ {
  /** @deprecated use `CreateOutputMaximumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputMaximumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateOutputMaximumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputMaximumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateOutputTLSSettingsClientSideMsk$inboundSchema: z.ZodType<
  CreateOutputTLSSettingsClientSideMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionMsk$inboundSchema.optional(),
  maxVersion: CreateOutputMaximumTLSVersionMsk$inboundSchema.optional(),
});

/** @internal */
export type CreateOutputTLSSettingsClientSideMsk$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateOutputTLSSettingsClientSideMsk$outboundSchema: z.ZodType<
  CreateOutputTLSSettingsClientSideMsk$Outbound,
  z.ZodTypeDef,
  CreateOutputTLSSettingsClientSideMsk
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionMsk$outboundSchema.optional(),
  maxVersion: CreateOutputMaximumTLSVersionMsk$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTLSSettingsClientSideMsk$ {
  /** @deprecated use `CreateOutputTLSSettingsClientSideMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputTLSSettingsClientSideMsk$inboundSchema;
  /** @deprecated use `CreateOutputTLSSettingsClientSideMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputTLSSettingsClientSideMsk$outboundSchema;
  /** @deprecated use `CreateOutputTLSSettingsClientSideMsk$Outbound` instead. */
  export type Outbound = CreateOutputTLSSettingsClientSideMsk$Outbound;
}

export function createOutputTLSSettingsClientSideMskToJSON(
  createOutputTLSSettingsClientSideMsk: CreateOutputTLSSettingsClientSideMsk,
): string {
  return JSON.stringify(
    CreateOutputTLSSettingsClientSideMsk$outboundSchema.parse(
      createOutputTLSSettingsClientSideMsk,
    ),
  );
}

export function createOutputTLSSettingsClientSideMskFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputTLSSettingsClientSideMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputTLSSettingsClientSideMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputTLSSettingsClientSideMsk' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorMsk$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorMsk
> = z.nativeEnum(BackpressureBehaviorMsk);

/** @internal */
export const BackpressureBehaviorMsk$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorMsk
> = BackpressureBehaviorMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorMsk$ {
  /** @deprecated use `BackpressureBehaviorMsk$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorMsk$inboundSchema;
  /** @deprecated use `BackpressureBehaviorMsk$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorMsk$outboundSchema;
}

/** @internal */
export const PqCompressCompressionMsk$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionMsk
> = z.nativeEnum(PqCompressCompressionMsk);

/** @internal */
export const PqCompressCompressionMsk$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionMsk
> = PqCompressCompressionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionMsk$ {
  /** @deprecated use `PqCompressCompressionMsk$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionMsk$inboundSchema;
  /** @deprecated use `PqCompressCompressionMsk$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionMsk$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorMsk$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorMsk
> = z.nativeEnum(QueueFullBehaviorMsk);

/** @internal */
export const QueueFullBehaviorMsk$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorMsk
> = QueueFullBehaviorMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorMsk$ {
  /** @deprecated use `QueueFullBehaviorMsk$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorMsk$inboundSchema;
  /** @deprecated use `QueueFullBehaviorMsk$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorMsk$outboundSchema;
}

/** @internal */
export const CreateOutputModeMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeMsk
> = z.nativeEnum(CreateOutputModeMsk);

/** @internal */
export const CreateOutputModeMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeMsk
> = CreateOutputModeMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeMsk$ {
  /** @deprecated use `CreateOutputModeMsk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeMsk$inboundSchema;
  /** @deprecated use `CreateOutputModeMsk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeMsk$outboundSchema;
}

/** @internal */
export const PqControlsMsk$inboundSchema: z.ZodType<
  PqControlsMsk,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsMsk$Outbound = {};

/** @internal */
export const PqControlsMsk$outboundSchema: z.ZodType<
  PqControlsMsk$Outbound,
  z.ZodTypeDef,
  PqControlsMsk
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsMsk$ {
  /** @deprecated use `PqControlsMsk$inboundSchema` instead. */
  export const inboundSchema = PqControlsMsk$inboundSchema;
  /** @deprecated use `PqControlsMsk$outboundSchema` instead. */
  export const outboundSchema = PqControlsMsk$outboundSchema;
  /** @deprecated use `PqControlsMsk$Outbound` instead. */
  export type Outbound = PqControlsMsk$Outbound;
}

export function pqControlsMskToJSON(pqControlsMsk: PqControlsMsk): string {
  return JSON.stringify(PqControlsMsk$outboundSchema.parse(pqControlsMsk));
}

export function pqControlsMskFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsMsk' from JSON`,
  );
}

/** @internal */
export const OutputMsk$inboundSchema: z.ZodType<
  OutputMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeMsk$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: AcknowledgmentsMsk$inboundSchema.default(1),
  format: RecordDataFormatMsk$inboundSchema.default("json"),
  compression: CreateOutputCompressionMsk$inboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateOutputKafkaSchemaRegistryAuthenticationMsk$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: CreateOutputAuthenticationMethodMsk$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionMsk$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => CreateOutputTLSSettingsClientSideMsk$inboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorMsk$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionMsk$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorMsk$inboundSchema.default("block"),
  pqMode: CreateOutputModeMsk$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsMsk$inboundSchema).optional(),
});

/** @internal */
export type OutputMsk$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  topic: string;
  ack: number;
  format: string;
  compression: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  kafkaSchemaRegistry?:
    | CreateOutputKafkaSchemaRegistryAuthenticationMsk$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  tls?: CreateOutputTLSSettingsClientSideMsk$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  protobufLibraryId?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsMsk$Outbound | undefined;
};

/** @internal */
export const OutputMsk$outboundSchema: z.ZodType<
  OutputMsk$Outbound,
  z.ZodTypeDef,
  OutputMsk
> = z.object({
  id: z.string(),
  type: CreateOutputTypeMsk$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: AcknowledgmentsMsk$outboundSchema.default(1),
  format: RecordDataFormatMsk$outboundSchema.default("json"),
  compression: CreateOutputCompressionMsk$outboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateOutputKafkaSchemaRegistryAuthenticationMsk$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: CreateOutputAuthenticationMethodMsk$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionMsk$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => CreateOutputTLSSettingsClientSideMsk$outboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorMsk$outboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionMsk$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorMsk$outboundSchema.default("block"),
  pqMode: CreateOutputModeMsk$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsMsk$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMsk$ {
  /** @deprecated use `OutputMsk$inboundSchema` instead. */
  export const inboundSchema = OutputMsk$inboundSchema;
  /** @deprecated use `OutputMsk$outboundSchema` instead. */
  export const outboundSchema = OutputMsk$outboundSchema;
  /** @deprecated use `OutputMsk$Outbound` instead. */
  export type Outbound = OutputMsk$Outbound;
}

export function outputMskToJSON(outputMsk: OutputMsk): string {
  return JSON.stringify(OutputMsk$outboundSchema.parse(outputMsk));
}

export function outputMskFromJSON(
  jsonString: string,
): SafeParseResult<OutputMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputMsk' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeConfluentCloud
> = z.nativeEnum(CreateOutputTypeConfluentCloud);

/** @internal */
export const CreateOutputTypeConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeConfluentCloud
> = CreateOutputTypeConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeConfluentCloud$ {
  /** @deprecated use `CreateOutputTypeConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputTypeConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputMinimumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMinimumTLSVersionConfluentCloud> = z
    .nativeEnum(CreateOutputMinimumTLSVersionConfluentCloud);

/** @internal */
export const CreateOutputMinimumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMinimumTLSVersionConfluentCloud> =
    CreateOutputMinimumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMinimumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateOutputMinimumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputMinimumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputMinimumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMinimumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputMaximumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMaximumTLSVersionConfluentCloud> = z
    .nativeEnum(CreateOutputMaximumTLSVersionConfluentCloud);

/** @internal */
export const CreateOutputMaximumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMaximumTLSVersionConfluentCloud> =
    CreateOutputMaximumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMaximumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateOutputMaximumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputMaximumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputMaximumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMaximumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputTLSSettingsClientSideConfluentCloud$inboundSchema:
  z.ZodType<
    CreateOutputTLSSettingsClientSideConfluentCloud,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(false),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: CreateOutputMinimumTLSVersionConfluentCloud$inboundSchema
      .optional(),
    maxVersion: CreateOutputMaximumTLSVersionConfluentCloud$inboundSchema
      .optional(),
  });

/** @internal */
export type CreateOutputTLSSettingsClientSideConfluentCloud$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateOutputTLSSettingsClientSideConfluentCloud$outboundSchema:
  z.ZodType<
    CreateOutputTLSSettingsClientSideConfluentCloud$Outbound,
    z.ZodTypeDef,
    CreateOutputTLSSettingsClientSideConfluentCloud
  > = z.object({
    disabled: z.boolean().default(false),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: CreateOutputMinimumTLSVersionConfluentCloud$outboundSchema
      .optional(),
    maxVersion: CreateOutputMaximumTLSVersionConfluentCloud$outboundSchema
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTLSSettingsClientSideConfluentCloud$ {
  /** @deprecated use `CreateOutputTLSSettingsClientSideConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputTLSSettingsClientSideConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputTLSSettingsClientSideConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputTLSSettingsClientSideConfluentCloud$outboundSchema;
  /** @deprecated use `CreateOutputTLSSettingsClientSideConfluentCloud$Outbound` instead. */
  export type Outbound =
    CreateOutputTLSSettingsClientSideConfluentCloud$Outbound;
}

export function createOutputTLSSettingsClientSideConfluentCloudToJSON(
  createOutputTLSSettingsClientSideConfluentCloud:
    CreateOutputTLSSettingsClientSideConfluentCloud,
): string {
  return JSON.stringify(
    CreateOutputTLSSettingsClientSideConfluentCloud$outboundSchema.parse(
      createOutputTLSSettingsClientSideConfluentCloud,
    ),
  );
}

export function createOutputTLSSettingsClientSideConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputTLSSettingsClientSideConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputTLSSettingsClientSideConfluentCloud$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateOutputTLSSettingsClientSideConfluentCloud' from JSON`,
  );
}

/** @internal */
export const AcknowledgmentsConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsConfluentCloud
> = z.nativeEnum(AcknowledgmentsConfluentCloud);

/** @internal */
export const AcknowledgmentsConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsConfluentCloud
> = AcknowledgmentsConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AcknowledgmentsConfluentCloud$ {
  /** @deprecated use `AcknowledgmentsConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = AcknowledgmentsConfluentCloud$inboundSchema;
  /** @deprecated use `AcknowledgmentsConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = AcknowledgmentsConfluentCloud$outboundSchema;
}

/** @internal */
export const RecordDataFormatConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatConfluentCloud
> = z.nativeEnum(RecordDataFormatConfluentCloud);

/** @internal */
export const RecordDataFormatConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatConfluentCloud
> = RecordDataFormatConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordDataFormatConfluentCloud$ {
  /** @deprecated use `RecordDataFormatConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = RecordDataFormatConfluentCloud$inboundSchema;
  /** @deprecated use `RecordDataFormatConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = RecordDataFormatConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputCompressionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputCompressionConfluentCloud> = z.nativeEnum(
    CreateOutputCompressionConfluentCloud,
  );

/** @internal */
export const CreateOutputCompressionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputCompressionConfluentCloud> =
    CreateOutputCompressionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressionConfluentCloud$ {
  /** @deprecated use `CreateOutputCompressionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputCompressionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputCompressionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputCompressionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputAuthConfluentCloud$inboundSchema: z.ZodType<
  CreateOutputAuthConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type CreateOutputAuthConfluentCloud$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const CreateOutputAuthConfluentCloud$outboundSchema: z.ZodType<
  CreateOutputAuthConfluentCloud$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthConfluentCloud
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthConfluentCloud$ {
  /** @deprecated use `CreateOutputAuthConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputAuthConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAuthConfluentCloud$outboundSchema;
  /** @deprecated use `CreateOutputAuthConfluentCloud$Outbound` instead. */
  export type Outbound = CreateOutputAuthConfluentCloud$Outbound;
}

export function createOutputAuthConfluentCloudToJSON(
  createOutputAuthConfluentCloud: CreateOutputAuthConfluentCloud,
): string {
  return JSON.stringify(
    CreateOutputAuthConfluentCloud$outboundSchema.parse(
      createOutputAuthConfluentCloud,
    ),
  );
}

export function createOutputAuthConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputAuthConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputAuthConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputAuthConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
  > = z.nativeEnum(
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud,
  );

/** @internal */
export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
  > =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
  > = z.nativeEnum(
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud,
  );

/** @internal */
export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
  > =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema
        .optional(),
    maxVersion:
      CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema
        .optional(),
  });

/** @internal */
export type CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound =
  {
    disabled: boolean;
    rejectUnauthorized: boolean;
    servername?: string | undefined;
    certificateName?: string | undefined;
    caPath?: string | undefined;
    privKeyPath?: string | undefined;
    certPath?: string | undefined;
    passphrase?: string | undefined;
    minVersion?: string | undefined;
    maxVersion?: string | undefined;
  };

/** @internal */
export const CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound,
    z.ZodTypeDef,
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateOutputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema
        .optional(),
    maxVersion:
      CreateOutputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound` instead. */
  export type Outbound =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound;
}

export function createOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloudToJSON(
  createOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud:
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud,
): string {
  return JSON.stringify(
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema
      .parse(
        createOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud,
      ),
  );
}

export function createOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateOutputAuthConfluentCloud$inboundSchema).optional(),
    tls: z.lazy(() =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/** @internal */
export type CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound =
  {
    disabled: boolean;
    schemaRegistryURL: string;
    connectionTimeout: number;
    requestTimeout: number;
    maxRetries: number;
    auth?: CreateOutputAuthConfluentCloud$Outbound | undefined;
    tls?:
      | CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound
      | undefined;
    defaultKeySchemaId?: number | undefined;
    defaultValueSchemaId?: number | undefined;
  };

/** @internal */
export const CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound,
    z.ZodTypeDef,
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateOutputAuthConfluentCloud$outboundSchema)
      .optional(),
    tls: z.lazy(() =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound` instead. */
  export type Outbound =
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound;
}

export function createOutputKafkaSchemaRegistryAuthenticationConfluentCloudToJSON(
  createOutputKafkaSchemaRegistryAuthenticationConfluentCloud:
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud,
): string {
  return JSON.stringify(
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema
      .parse(createOutputKafkaSchemaRegistryAuthenticationConfluentCloud),
  );
}

export function createOutputKafkaSchemaRegistryAuthenticationConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateOutputSASLMechanismConfluentCloud$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputSASLMechanismConfluentCloud> = z
    .nativeEnum(CreateOutputSASLMechanismConfluentCloud);

/** @internal */
export const CreateOutputSASLMechanismConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputSASLMechanismConfluentCloud> =
    CreateOutputSASLMechanismConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputSASLMechanismConfluentCloud$ {
  /** @deprecated use `CreateOutputSASLMechanismConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputSASLMechanismConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputSASLMechanismConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputSASLMechanismConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationConfluentCloud$inboundSchema: z.ZodType<
  CreateOutputAuthenticationConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateOutputSASLMechanismConfluentCloud$inboundSchema.default(
    "plain",
  ),
});

/** @internal */
export type CreateOutputAuthenticationConfluentCloud$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const CreateOutputAuthenticationConfluentCloud$outboundSchema: z.ZodType<
  CreateOutputAuthenticationConfluentCloud$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthenticationConfluentCloud
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateOutputSASLMechanismConfluentCloud$outboundSchema.default(
    "plain",
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationConfluentCloud$ {
  /** @deprecated use `CreateOutputAuthenticationConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputAuthenticationConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationConfluentCloud$outboundSchema;
  /** @deprecated use `CreateOutputAuthenticationConfluentCloud$Outbound` instead. */
  export type Outbound = CreateOutputAuthenticationConfluentCloud$Outbound;
}

export function createOutputAuthenticationConfluentCloudToJSON(
  createOutputAuthenticationConfluentCloud:
    CreateOutputAuthenticationConfluentCloud,
): string {
  return JSON.stringify(
    CreateOutputAuthenticationConfluentCloud$outboundSchema.parse(
      createOutputAuthenticationConfluentCloud,
    ),
  );
}

export function createOutputAuthenticationConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputAuthenticationConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputAuthenticationConfluentCloud$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateOutputAuthenticationConfluentCloud' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorConfluentCloud
> = z.nativeEnum(BackpressureBehaviorConfluentCloud);

/** @internal */
export const BackpressureBehaviorConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorConfluentCloud
> = BackpressureBehaviorConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorConfluentCloud$ {
  /** @deprecated use `BackpressureBehaviorConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorConfluentCloud$inboundSchema;
  /** @deprecated use `BackpressureBehaviorConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorConfluentCloud$outboundSchema;
}

/** @internal */
export const PqCompressCompressionConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionConfluentCloud
> = z.nativeEnum(PqCompressCompressionConfluentCloud);

/** @internal */
export const PqCompressCompressionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof PqCompressCompressionConfluentCloud> =
    PqCompressCompressionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionConfluentCloud$ {
  /** @deprecated use `PqCompressCompressionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    PqCompressCompressionConfluentCloud$inboundSchema;
  /** @deprecated use `PqCompressCompressionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    PqCompressCompressionConfluentCloud$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorConfluentCloud
> = z.nativeEnum(QueueFullBehaviorConfluentCloud);

/** @internal */
export const QueueFullBehaviorConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorConfluentCloud
> = QueueFullBehaviorConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorConfluentCloud$ {
  /** @deprecated use `QueueFullBehaviorConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorConfluentCloud$inboundSchema;
  /** @deprecated use `QueueFullBehaviorConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateOutputModeConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeConfluentCloud
> = z.nativeEnum(CreateOutputModeConfluentCloud);

/** @internal */
export const CreateOutputModeConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeConfluentCloud
> = CreateOutputModeConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeConfluentCloud$ {
  /** @deprecated use `CreateOutputModeConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeConfluentCloud$inboundSchema;
  /** @deprecated use `CreateOutputModeConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeConfluentCloud$outboundSchema;
}

/** @internal */
export const PqControlsConfluentCloud$inboundSchema: z.ZodType<
  PqControlsConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsConfluentCloud$Outbound = {};

/** @internal */
export const PqControlsConfluentCloud$outboundSchema: z.ZodType<
  PqControlsConfluentCloud$Outbound,
  z.ZodTypeDef,
  PqControlsConfluentCloud
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsConfluentCloud$ {
  /** @deprecated use `PqControlsConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = PqControlsConfluentCloud$inboundSchema;
  /** @deprecated use `PqControlsConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = PqControlsConfluentCloud$outboundSchema;
  /** @deprecated use `PqControlsConfluentCloud$Outbound` instead. */
  export type Outbound = PqControlsConfluentCloud$Outbound;
}

export function pqControlsConfluentCloudToJSON(
  pqControlsConfluentCloud: PqControlsConfluentCloud,
): string {
  return JSON.stringify(
    PqControlsConfluentCloud$outboundSchema.parse(pqControlsConfluentCloud),
  );
}

export function pqControlsConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsConfluentCloud' from JSON`,
  );
}

/** @internal */
export const OutputConfluentCloud$inboundSchema: z.ZodType<
  OutputConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeConfluentCloud$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() =>
    CreateOutputTLSSettingsClientSideConfluentCloud$inboundSchema
  ).optional(),
  topic: z.string(),
  ack: AcknowledgmentsConfluentCloud$inboundSchema.default(1),
  format: RecordDataFormatConfluentCloud$inboundSchema.default("json"),
  compression: CreateOutputCompressionConfluentCloud$inboundSchema.default(
    "gzip",
  ),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateOutputAuthenticationConfluentCloud$inboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorConfluentCloud$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionConfluentCloud$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorConfluentCloud$inboundSchema.default(
    "block",
  ),
  pqMode: CreateOutputModeConfluentCloud$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsConfluentCloud$inboundSchema).optional(),
});

/** @internal */
export type OutputConfluentCloud$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  tls?: CreateOutputTLSSettingsClientSideConfluentCloud$Outbound | undefined;
  topic: string;
  ack: number;
  format: string;
  compression: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  kafkaSchemaRegistry?:
    | CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: CreateOutputAuthenticationConfluentCloud$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  protobufLibraryId?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsConfluentCloud$Outbound | undefined;
};

/** @internal */
export const OutputConfluentCloud$outboundSchema: z.ZodType<
  OutputConfluentCloud$Outbound,
  z.ZodTypeDef,
  OutputConfluentCloud
> = z.object({
  id: z.string(),
  type: CreateOutputTypeConfluentCloud$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() =>
    CreateOutputTLSSettingsClientSideConfluentCloud$outboundSchema
  ).optional(),
  topic: z.string(),
  ack: AcknowledgmentsConfluentCloud$outboundSchema.default(1),
  format: RecordDataFormatConfluentCloud$outboundSchema.default("json"),
  compression: CreateOutputCompressionConfluentCloud$outboundSchema.default(
    "gzip",
  ),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateOutputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateOutputAuthenticationConfluentCloud$outboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorConfluentCloud$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionConfluentCloud$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: QueueFullBehaviorConfluentCloud$outboundSchema.default(
    "block",
  ),
  pqMode: CreateOutputModeConfluentCloud$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsConfluentCloud$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputConfluentCloud$ {
  /** @deprecated use `OutputConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = OutputConfluentCloud$inboundSchema;
  /** @deprecated use `OutputConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = OutputConfluentCloud$outboundSchema;
  /** @deprecated use `OutputConfluentCloud$Outbound` instead. */
  export type Outbound = OutputConfluentCloud$Outbound;
}

export function outputConfluentCloudToJSON(
  outputConfluentCloud: OutputConfluentCloud,
): string {
  return JSON.stringify(
    OutputConfluentCloud$outboundSchema.parse(outputConfluentCloud),
  );
}

export function outputConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<OutputConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeKafka
> = z.nativeEnum(CreateOutputTypeKafka);

/** @internal */
export const CreateOutputTypeKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeKafka
> = CreateOutputTypeKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeKafka$ {
  /** @deprecated use `CreateOutputTypeKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeKafka$inboundSchema;
  /** @deprecated use `CreateOutputTypeKafka$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeKafka$outboundSchema;
}

/** @internal */
export const AcknowledgmentsKafka$inboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsKafka
> = z.nativeEnum(AcknowledgmentsKafka);

/** @internal */
export const AcknowledgmentsKafka$outboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsKafka
> = AcknowledgmentsKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AcknowledgmentsKafka$ {
  /** @deprecated use `AcknowledgmentsKafka$inboundSchema` instead. */
  export const inboundSchema = AcknowledgmentsKafka$inboundSchema;
  /** @deprecated use `AcknowledgmentsKafka$outboundSchema` instead. */
  export const outboundSchema = AcknowledgmentsKafka$outboundSchema;
}

/** @internal */
export const RecordDataFormatKafka$inboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatKafka
> = z.nativeEnum(RecordDataFormatKafka);

/** @internal */
export const RecordDataFormatKafka$outboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatKafka
> = RecordDataFormatKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordDataFormatKafka$ {
  /** @deprecated use `RecordDataFormatKafka$inboundSchema` instead. */
  export const inboundSchema = RecordDataFormatKafka$inboundSchema;
  /** @deprecated use `RecordDataFormatKafka$outboundSchema` instead. */
  export const outboundSchema = RecordDataFormatKafka$outboundSchema;
}

/** @internal */
export const CreateOutputCompressionKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionKafka
> = z.nativeEnum(CreateOutputCompressionKafka);

/** @internal */
export const CreateOutputCompressionKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionKafka
> = CreateOutputCompressionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressionKafka$ {
  /** @deprecated use `CreateOutputCompressionKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputCompressionKafka$inboundSchema;
  /** @deprecated use `CreateOutputCompressionKafka$outboundSchema` instead. */
  export const outboundSchema = CreateOutputCompressionKafka$outboundSchema;
}

/** @internal */
export const CreateOutputAuthKafka$inboundSchema: z.ZodType<
  CreateOutputAuthKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type CreateOutputAuthKafka$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const CreateOutputAuthKafka$outboundSchema: z.ZodType<
  CreateOutputAuthKafka$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthKafka
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthKafka$ {
  /** @deprecated use `CreateOutputAuthKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthKafka$inboundSchema;
  /** @deprecated use `CreateOutputAuthKafka$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAuthKafka$outboundSchema;
  /** @deprecated use `CreateOutputAuthKafka$Outbound` instead. */
  export type Outbound = CreateOutputAuthKafka$Outbound;
}

export function createOutputAuthKafkaToJSON(
  createOutputAuthKafka: CreateOutputAuthKafka,
): string {
  return JSON.stringify(
    CreateOutputAuthKafka$outboundSchema.parse(createOutputAuthKafka),
  );
}

export function createOutputAuthKafkaFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputAuthKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputAuthKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputAuthKafka' from JSON`,
  );
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka
  > = z.nativeEnum(CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka);

/** @internal */
export const CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka
  > = CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka
  > = z.nativeEnum(CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka);

/** @internal */
export const CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka
  > = CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema
        .optional(),
    maxVersion:
      CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema
        .optional(),
  });

/** @internal */
export type CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound =
  {
    disabled: boolean;
    rejectUnauthorized: boolean;
    servername?: string | undefined;
    certificateName?: string | undefined;
    caPath?: string | undefined;
    privKeyPath?: string | undefined;
    certPath?: string | undefined;
    passphrase?: string | undefined;
    minVersion?: string | undefined;
    maxVersion?: string | undefined;
  };

/** @internal */
export const CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound,
    z.ZodTypeDef,
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateOutputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema
        .optional(),
    maxVersion:
      CreateOutputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound` instead. */
  export type Outbound =
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound;
}

export function createOutputKafkaSchemaRegistryTLSSettingsClientSideKafkaToJSON(
  createOutputKafkaSchemaRegistryTLSSettingsClientSideKafka:
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka,
): string {
  return JSON.stringify(
    CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema
      .parse(createOutputKafkaSchemaRegistryTLSSettingsClientSideKafka),
  );
}

export function createOutputKafkaSchemaRegistryTLSSettingsClientSideKafkaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka' from JSON`,
  );
}

/** @internal */
export const CreateOutputKafkaSchemaRegistryAuthenticationKafka$inboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryAuthenticationKafka,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateOutputAuthKafka$inboundSchema).optional(),
    tls: z.lazy(() =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/** @internal */
export type CreateOutputKafkaSchemaRegistryAuthenticationKafka$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: CreateOutputAuthKafka$Outbound | undefined;
  tls?:
    | CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound
    | undefined;
  defaultKeySchemaId?: number | undefined;
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const CreateOutputKafkaSchemaRegistryAuthenticationKafka$outboundSchema:
  z.ZodType<
    CreateOutputKafkaSchemaRegistryAuthenticationKafka$Outbound,
    z.ZodTypeDef,
    CreateOutputKafkaSchemaRegistryAuthenticationKafka
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateOutputAuthKafka$outboundSchema).optional(),
    tls: z.lazy(() =>
      CreateOutputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema
    ).optional(),
    defaultKeySchemaId: z.number().optional(),
    defaultValueSchemaId: z.number().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputKafkaSchemaRegistryAuthenticationKafka$ {
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputKafkaSchemaRegistryAuthenticationKafka$inboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputKafkaSchemaRegistryAuthenticationKafka$outboundSchema;
  /** @deprecated use `CreateOutputKafkaSchemaRegistryAuthenticationKafka$Outbound` instead. */
  export type Outbound =
    CreateOutputKafkaSchemaRegistryAuthenticationKafka$Outbound;
}

export function createOutputKafkaSchemaRegistryAuthenticationKafkaToJSON(
  createOutputKafkaSchemaRegistryAuthenticationKafka:
    CreateOutputKafkaSchemaRegistryAuthenticationKafka,
): string {
  return JSON.stringify(
    CreateOutputKafkaSchemaRegistryAuthenticationKafka$outboundSchema.parse(
      createOutputKafkaSchemaRegistryAuthenticationKafka,
    ),
  );
}

export function createOutputKafkaSchemaRegistryAuthenticationKafkaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateOutputKafkaSchemaRegistryAuthenticationKafka,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputKafkaSchemaRegistryAuthenticationKafka$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateOutputKafkaSchemaRegistryAuthenticationKafka' from JSON`,
  );
}

/** @internal */
export const CreateOutputSASLMechanismKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSASLMechanismKafka
> = z.nativeEnum(CreateOutputSASLMechanismKafka);

/** @internal */
export const CreateOutputSASLMechanismKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSASLMechanismKafka
> = CreateOutputSASLMechanismKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputSASLMechanismKafka$ {
  /** @deprecated use `CreateOutputSASLMechanismKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputSASLMechanismKafka$inboundSchema;
  /** @deprecated use `CreateOutputSASLMechanismKafka$outboundSchema` instead. */
  export const outboundSchema = CreateOutputSASLMechanismKafka$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationKafka$inboundSchema: z.ZodType<
  CreateOutputAuthenticationKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateOutputSASLMechanismKafka$inboundSchema.default("plain"),
});

/** @internal */
export type CreateOutputAuthenticationKafka$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const CreateOutputAuthenticationKafka$outboundSchema: z.ZodType<
  CreateOutputAuthenticationKafka$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthenticationKafka
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateOutputSASLMechanismKafka$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationKafka$ {
  /** @deprecated use `CreateOutputAuthenticationKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthenticationKafka$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationKafka$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAuthenticationKafka$outboundSchema;
  /** @deprecated use `CreateOutputAuthenticationKafka$Outbound` instead. */
  export type Outbound = CreateOutputAuthenticationKafka$Outbound;
}

export function createOutputAuthenticationKafkaToJSON(
  createOutputAuthenticationKafka: CreateOutputAuthenticationKafka,
): string {
  return JSON.stringify(
    CreateOutputAuthenticationKafka$outboundSchema.parse(
      createOutputAuthenticationKafka,
    ),
  );
}

export function createOutputAuthenticationKafkaFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputAuthenticationKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputAuthenticationKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputAuthenticationKafka' from JSON`,
  );
}

/** @internal */
export const CreateOutputMinimumTLSVersionKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMinimumTLSVersionKafka
> = z.nativeEnum(CreateOutputMinimumTLSVersionKafka);

/** @internal */
export const CreateOutputMinimumTLSVersionKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMinimumTLSVersionKafka
> = CreateOutputMinimumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMinimumTLSVersionKafka$ {
  /** @deprecated use `CreateOutputMinimumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputMinimumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateOutputMinimumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMinimumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateOutputMaximumTLSVersionKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMaximumTLSVersionKafka
> = z.nativeEnum(CreateOutputMaximumTLSVersionKafka);

/** @internal */
export const CreateOutputMaximumTLSVersionKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMaximumTLSVersionKafka
> = CreateOutputMaximumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMaximumTLSVersionKafka$ {
  /** @deprecated use `CreateOutputMaximumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputMaximumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateOutputMaximumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMaximumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateOutputTLSSettingsClientSideKafka$inboundSchema: z.ZodType<
  CreateOutputTLSSettingsClientSideKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionKafka$inboundSchema.optional(),
  maxVersion: CreateOutputMaximumTLSVersionKafka$inboundSchema.optional(),
});

/** @internal */
export type CreateOutputTLSSettingsClientSideKafka$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateOutputTLSSettingsClientSideKafka$outboundSchema: z.ZodType<
  CreateOutputTLSSettingsClientSideKafka$Outbound,
  z.ZodTypeDef,
  CreateOutputTLSSettingsClientSideKafka
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionKafka$outboundSchema.optional(),
  maxVersion: CreateOutputMaximumTLSVersionKafka$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTLSSettingsClientSideKafka$ {
  /** @deprecated use `CreateOutputTLSSettingsClientSideKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputTLSSettingsClientSideKafka$inboundSchema;
  /** @deprecated use `CreateOutputTLSSettingsClientSideKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputTLSSettingsClientSideKafka$outboundSchema;
  /** @deprecated use `CreateOutputTLSSettingsClientSideKafka$Outbound` instead. */
  export type Outbound = CreateOutputTLSSettingsClientSideKafka$Outbound;
}

export function createOutputTLSSettingsClientSideKafkaToJSON(
  createOutputTLSSettingsClientSideKafka:
    CreateOutputTLSSettingsClientSideKafka,
): string {
  return JSON.stringify(
    CreateOutputTLSSettingsClientSideKafka$outboundSchema.parse(
      createOutputTLSSettingsClientSideKafka,
    ),
  );
}

export function createOutputTLSSettingsClientSideKafkaFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputTLSSettingsClientSideKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateOutputTLSSettingsClientSideKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputTLSSettingsClientSideKafka' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorKafka$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorKafka
> = z.nativeEnum(BackpressureBehaviorKafka);

/** @internal */
export const BackpressureBehaviorKafka$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorKafka
> = BackpressureBehaviorKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorKafka$ {
  /** @deprecated use `BackpressureBehaviorKafka$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorKafka$inboundSchema;
  /** @deprecated use `BackpressureBehaviorKafka$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorKafka$outboundSchema;
}

/** @internal */
export const PqCompressCompressionKafka$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionKafka
> = z.nativeEnum(PqCompressCompressionKafka);

/** @internal */
export const PqCompressCompressionKafka$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionKafka
> = PqCompressCompressionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionKafka$ {
  /** @deprecated use `PqCompressCompressionKafka$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionKafka$inboundSchema;
  /** @deprecated use `PqCompressCompressionKafka$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionKafka$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorKafka$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorKafka
> = z.nativeEnum(QueueFullBehaviorKafka);

/** @internal */
export const QueueFullBehaviorKafka$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorKafka
> = QueueFullBehaviorKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorKafka$ {
  /** @deprecated use `QueueFullBehaviorKafka$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorKafka$inboundSchema;
  /** @deprecated use `QueueFullBehaviorKafka$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorKafka$outboundSchema;
}

/** @internal */
export const CreateOutputModeKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeKafka
> = z.nativeEnum(CreateOutputModeKafka);

/** @internal */
export const CreateOutputModeKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeKafka
> = CreateOutputModeKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeKafka$ {
  /** @deprecated use `CreateOutputModeKafka$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeKafka$inboundSchema;
  /** @deprecated use `CreateOutputModeKafka$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeKafka$outboundSchema;
}

/** @internal */
export const PqControlsKafka$inboundSchema: z.ZodType<
  PqControlsKafka,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsKafka$Outbound = {};

/** @internal */
export const PqControlsKafka$outboundSchema: z.ZodType<
  PqControlsKafka$Outbound,
  z.ZodTypeDef,
  PqControlsKafka
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsKafka$ {
  /** @deprecated use `PqControlsKafka$inboundSchema` instead. */
  export const inboundSchema = PqControlsKafka$inboundSchema;
  /** @deprecated use `PqControlsKafka$outboundSchema` instead. */
  export const outboundSchema = PqControlsKafka$outboundSchema;
  /** @deprecated use `PqControlsKafka$Outbound` instead. */
  export type Outbound = PqControlsKafka$Outbound;
}

export function pqControlsKafkaToJSON(
  pqControlsKafka: PqControlsKafka,
): string {
  return JSON.stringify(PqControlsKafka$outboundSchema.parse(pqControlsKafka));
}

export function pqControlsKafkaFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsKafka' from JSON`,
  );
}

/** @internal */
export const OutputKafka$inboundSchema: z.ZodType<
  OutputKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeKafka$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: AcknowledgmentsKafka$inboundSchema.default(1),
  format: RecordDataFormatKafka$inboundSchema.default("json"),
  compression: CreateOutputCompressionKafka$inboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateOutputKafkaSchemaRegistryAuthenticationKafka$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateOutputAuthenticationKafka$inboundSchema).optional(),
  tls: z.lazy(() => CreateOutputTLSSettingsClientSideKafka$inboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorKafka$inboundSchema.default("block"),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionKafka$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorKafka$inboundSchema.default("block"),
  pqMode: CreateOutputModeKafka$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsKafka$inboundSchema).optional(),
});

/** @internal */
export type OutputKafka$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  topic: string;
  ack: number;
  format: string;
  compression: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  kafkaSchemaRegistry?:
    | CreateOutputKafkaSchemaRegistryAuthenticationKafka$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: CreateOutputAuthenticationKafka$Outbound | undefined;
  tls?: CreateOutputTLSSettingsClientSideKafka$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  protobufLibraryId?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsKafka$Outbound | undefined;
};

/** @internal */
export const OutputKafka$outboundSchema: z.ZodType<
  OutputKafka$Outbound,
  z.ZodTypeDef,
  OutputKafka
> = z.object({
  id: z.string(),
  type: CreateOutputTypeKafka$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: AcknowledgmentsKafka$outboundSchema.default(1),
  format: RecordDataFormatKafka$outboundSchema.default("json"),
  compression: CreateOutputCompressionKafka$outboundSchema.default("gzip"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateOutputKafkaSchemaRegistryAuthenticationKafka$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateOutputAuthenticationKafka$outboundSchema).optional(),
  tls: z.lazy(() => CreateOutputTLSSettingsClientSideKafka$outboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorKafka$outboundSchema.default("block"),
  description: z.string().optional(),
  protobufLibraryId: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionKafka$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorKafka$outboundSchema.default("block"),
  pqMode: CreateOutputModeKafka$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsKafka$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKafka$ {
  /** @deprecated use `OutputKafka$inboundSchema` instead. */
  export const inboundSchema = OutputKafka$inboundSchema;
  /** @deprecated use `OutputKafka$outboundSchema` instead. */
  export const outboundSchema = OutputKafka$outboundSchema;
  /** @deprecated use `OutputKafka$Outbound` instead. */
  export type Outbound = OutputKafka$Outbound;
}

export function outputKafkaToJSON(outputKafka: OutputKafka): string {
  return JSON.stringify(OutputKafka$outboundSchema.parse(outputKafka));
}

export function outputKafkaFromJSON(
  jsonString: string,
): SafeParseResult<OutputKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKafka' from JSON`,
  );
}

/** @internal */
export const TypeExabeam$inboundSchema: z.ZodNativeEnum<typeof TypeExabeam> = z
  .nativeEnum(TypeExabeam);

/** @internal */
export const TypeExabeam$outboundSchema: z.ZodNativeEnum<typeof TypeExabeam> =
  TypeExabeam$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeExabeam$ {
  /** @deprecated use `TypeExabeam$inboundSchema` instead. */
  export const inboundSchema = TypeExabeam$inboundSchema;
  /** @deprecated use `TypeExabeam$outboundSchema` instead. */
  export const outboundSchema = TypeExabeam$outboundSchema;
}

/** @internal */
export const SignatureVersionExabeam$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionExabeam
> = z.nativeEnum(SignatureVersionExabeam);

/** @internal */
export const SignatureVersionExabeam$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionExabeam
> = SignatureVersionExabeam$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionExabeam$ {
  /** @deprecated use `SignatureVersionExabeam$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionExabeam$inboundSchema;
  /** @deprecated use `SignatureVersionExabeam$outboundSchema` instead. */
  export const outboundSchema = SignatureVersionExabeam$outboundSchema;
}

/** @internal */
export const ObjectACLExabeam$inboundSchema: z.ZodNativeEnum<
  typeof ObjectACLExabeam
> = z.nativeEnum(ObjectACLExabeam);

/** @internal */
export const ObjectACLExabeam$outboundSchema: z.ZodNativeEnum<
  typeof ObjectACLExabeam
> = ObjectACLExabeam$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectACLExabeam$ {
  /** @deprecated use `ObjectACLExabeam$inboundSchema` instead. */
  export const inboundSchema = ObjectACLExabeam$inboundSchema;
  /** @deprecated use `ObjectACLExabeam$outboundSchema` instead. */
  export const outboundSchema = ObjectACLExabeam$outboundSchema;
}

/** @internal */
export const StorageClassExabeam$inboundSchema: z.ZodNativeEnum<
  typeof StorageClassExabeam
> = z.nativeEnum(StorageClassExabeam);

/** @internal */
export const StorageClassExabeam$outboundSchema: z.ZodNativeEnum<
  typeof StorageClassExabeam
> = StorageClassExabeam$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StorageClassExabeam$ {
  /** @deprecated use `StorageClassExabeam$inboundSchema` instead. */
  export const inboundSchema = StorageClassExabeam$inboundSchema;
  /** @deprecated use `StorageClassExabeam$outboundSchema` instead. */
  export const outboundSchema = StorageClassExabeam$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorExabeam$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorExabeam
> = z.nativeEnum(BackpressureBehaviorExabeam);

/** @internal */
export const BackpressureBehaviorExabeam$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorExabeam
> = BackpressureBehaviorExabeam$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorExabeam$ {
  /** @deprecated use `BackpressureBehaviorExabeam$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorExabeam$inboundSchema;
  /** @deprecated use `BackpressureBehaviorExabeam$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorExabeam$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionExabeam$inboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionExabeam
> = z.nativeEnum(DiskSpaceProtectionExabeam);

/** @internal */
export const DiskSpaceProtectionExabeam$outboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionExabeam
> = DiskSpaceProtectionExabeam$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionExabeam$ {
  /** @deprecated use `DiskSpaceProtectionExabeam$inboundSchema` instead. */
  export const inboundSchema = DiskSpaceProtectionExabeam$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionExabeam$outboundSchema` instead. */
  export const outboundSchema = DiskSpaceProtectionExabeam$outboundSchema;
}

/** @internal */
export const OutputExabeam$inboundSchema: z.ZodType<
  OutputExabeam,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeExabeam$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: SignatureVersionExabeam$inboundSchema.default("v4"),
  objectACL: ObjectACLExabeam$inboundSchema.default("private"),
  storageClass: StorageClassExabeam$inboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  onBackpressure: BackpressureBehaviorExabeam$inboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionExabeam$inboundSchema.default(
    "block",
  ),
  maxFileSizeMB: z.number().default(10),
  encodedConfiguration: z.string().optional(),
  collectorInstanceId: z.string(),
  siteName: z.string().optional(),
  siteId: z.string().optional(),
  timezoneOffset: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  description: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputExabeam$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region: string;
  stagePath: string;
  endpoint: string;
  signatureVersion: string;
  objectACL: string;
  storageClass?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileSizeMB: number;
  encodedConfiguration?: string | undefined;
  collectorInstanceId: string;
  siteName?: string | undefined;
  siteId?: string | undefined;
  timezoneOffset?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecretKey?: string | undefined;
  description?: string | undefined;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputExabeam$outboundSchema: z.ZodType<
  OutputExabeam$Outbound,
  z.ZodTypeDef,
  OutputExabeam
> = z.object({
  id: z.string(),
  type: TypeExabeam$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: SignatureVersionExabeam$outboundSchema.default("v4"),
  objectACL: ObjectACLExabeam$outboundSchema.default("private"),
  storageClass: StorageClassExabeam$outboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  onBackpressure: BackpressureBehaviorExabeam$outboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionExabeam$outboundSchema.default(
    "block",
  ),
  maxFileSizeMB: z.number().default(10),
  encodedConfiguration: z.string().optional(),
  collectorInstanceId: z.string(),
  siteName: z.string().optional(),
  siteId: z.string().optional(),
  timezoneOffset: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  description: z.string().optional(),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputExabeam$ {
  /** @deprecated use `OutputExabeam$inboundSchema` instead. */
  export const inboundSchema = OutputExabeam$inboundSchema;
  /** @deprecated use `OutputExabeam$outboundSchema` instead. */
  export const outboundSchema = OutputExabeam$outboundSchema;
  /** @deprecated use `OutputExabeam$Outbound` instead. */
  export type Outbound = OutputExabeam$Outbound;
}

export function outputExabeamToJSON(outputExabeam: OutputExabeam): string {
  return JSON.stringify(OutputExabeam$outboundSchema.parse(outputExabeam));
}

export function outputExabeamFromJSON(
  jsonString: string,
): SafeParseResult<OutputExabeam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputExabeam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputExabeam' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeGooglePubsub
> = z.nativeEnum(CreateOutputTypeGooglePubsub);

/** @internal */
export const CreateOutputTypeGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeGooglePubsub
> = CreateOutputTypeGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeGooglePubsub$ {
  /** @deprecated use `CreateOutputTypeGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeGooglePubsub$inboundSchema;
  /** @deprecated use `CreateOutputTypeGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeGooglePubsub$outboundSchema;
}

/** @internal */
export const CreateOutputGoogleAuthenticationMethodGooglePubsub$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputGoogleAuthenticationMethodGooglePubsub> = z
    .nativeEnum(CreateOutputGoogleAuthenticationMethodGooglePubsub);

/** @internal */
export const CreateOutputGoogleAuthenticationMethodGooglePubsub$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputGoogleAuthenticationMethodGooglePubsub> =
    CreateOutputGoogleAuthenticationMethodGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputGoogleAuthenticationMethodGooglePubsub$ {
  /** @deprecated use `CreateOutputGoogleAuthenticationMethodGooglePubsub$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputGoogleAuthenticationMethodGooglePubsub$inboundSchema;
  /** @deprecated use `CreateOutputGoogleAuthenticationMethodGooglePubsub$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputGoogleAuthenticationMethodGooglePubsub$outboundSchema;
}

/** @internal */
export const FlushPeriodSecType$inboundSchema: z.ZodNativeEnum<
  typeof FlushPeriodSecType
> = z.nativeEnum(FlushPeriodSecType);

/** @internal */
export const FlushPeriodSecType$outboundSchema: z.ZodNativeEnum<
  typeof FlushPeriodSecType
> = FlushPeriodSecType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FlushPeriodSecType$ {
  /** @deprecated use `FlushPeriodSecType$inboundSchema` instead. */
  export const inboundSchema = FlushPeriodSecType$inboundSchema;
  /** @deprecated use `FlushPeriodSecType$outboundSchema` instead. */
  export const outboundSchema = FlushPeriodSecType$outboundSchema;
}

/** @internal */
export const FlushPeriodSec$inboundSchema: z.ZodType<
  FlushPeriodSec,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: FlushPeriodSecType$inboundSchema.optional(),
  default: z.number().optional(),
});

/** @internal */
export type FlushPeriodSec$Outbound = {
  type?: string | undefined;
  default?: number | undefined;
};

/** @internal */
export const FlushPeriodSec$outboundSchema: z.ZodType<
  FlushPeriodSec$Outbound,
  z.ZodTypeDef,
  FlushPeriodSec
> = z.object({
  type: FlushPeriodSecType$outboundSchema.optional(),
  default: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FlushPeriodSec$ {
  /** @deprecated use `FlushPeriodSec$inboundSchema` instead. */
  export const inboundSchema = FlushPeriodSec$inboundSchema;
  /** @deprecated use `FlushPeriodSec$outboundSchema` instead. */
  export const outboundSchema = FlushPeriodSec$outboundSchema;
  /** @deprecated use `FlushPeriodSec$Outbound` instead. */
  export type Outbound = FlushPeriodSec$Outbound;
}

export function flushPeriodSecToJSON(flushPeriodSec: FlushPeriodSec): string {
  return JSON.stringify(FlushPeriodSec$outboundSchema.parse(flushPeriodSec));
}

export function flushPeriodSecFromJSON(
  jsonString: string,
): SafeParseResult<FlushPeriodSec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FlushPeriodSec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FlushPeriodSec' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorGooglePubsub
> = z.nativeEnum(BackpressureBehaviorGooglePubsub);

/** @internal */
export const BackpressureBehaviorGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorGooglePubsub
> = BackpressureBehaviorGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorGooglePubsub$ {
  /** @deprecated use `BackpressureBehaviorGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorGooglePubsub$inboundSchema;
  /** @deprecated use `BackpressureBehaviorGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorGooglePubsub$outboundSchema;
}

/** @internal */
export const PqCompressCompressionGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionGooglePubsub
> = z.nativeEnum(PqCompressCompressionGooglePubsub);

/** @internal */
export const PqCompressCompressionGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionGooglePubsub
> = PqCompressCompressionGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionGooglePubsub$ {
  /** @deprecated use `PqCompressCompressionGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionGooglePubsub$inboundSchema;
  /** @deprecated use `PqCompressCompressionGooglePubsub$outboundSchema` instead. */
  export const outboundSchema =
    PqCompressCompressionGooglePubsub$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorGooglePubsub
> = z.nativeEnum(QueueFullBehaviorGooglePubsub);

/** @internal */
export const QueueFullBehaviorGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorGooglePubsub
> = QueueFullBehaviorGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorGooglePubsub$ {
  /** @deprecated use `QueueFullBehaviorGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorGooglePubsub$inboundSchema;
  /** @deprecated use `QueueFullBehaviorGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorGooglePubsub$outboundSchema;
}

/** @internal */
export const CreateOutputModeGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeGooglePubsub
> = z.nativeEnum(CreateOutputModeGooglePubsub);

/** @internal */
export const CreateOutputModeGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeGooglePubsub
> = CreateOutputModeGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeGooglePubsub$ {
  /** @deprecated use `CreateOutputModeGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeGooglePubsub$inboundSchema;
  /** @deprecated use `CreateOutputModeGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeGooglePubsub$outboundSchema;
}

/** @internal */
export const PqControlsGooglePubsub$inboundSchema: z.ZodType<
  PqControlsGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsGooglePubsub$Outbound = {};

/** @internal */
export const PqControlsGooglePubsub$outboundSchema: z.ZodType<
  PqControlsGooglePubsub$Outbound,
  z.ZodTypeDef,
  PqControlsGooglePubsub
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsGooglePubsub$ {
  /** @deprecated use `PqControlsGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = PqControlsGooglePubsub$inboundSchema;
  /** @deprecated use `PqControlsGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = PqControlsGooglePubsub$outboundSchema;
  /** @deprecated use `PqControlsGooglePubsub$Outbound` instead. */
  export type Outbound = PqControlsGooglePubsub$Outbound;
}

export function pqControlsGooglePubsubToJSON(
  pqControlsGooglePubsub: PqControlsGooglePubsub,
): string {
  return JSON.stringify(
    PqControlsGooglePubsub$outboundSchema.parse(pqControlsGooglePubsub),
  );
}

export function pqControlsGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsGooglePubsub' from JSON`,
  );
}

/** @internal */
export const OutputGooglePubsub$inboundSchema: z.ZodType<
  OutputGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeGooglePubsub$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicName: z.string(),
  createTopic: z.boolean().default(false),
  orderedDelivery: z.boolean().default(false),
  region: z.string().optional(),
  googleAuthMethod:
    CreateOutputGoogleAuthenticationMethodGooglePubsub$inboundSchema.default(
      "manual",
    ),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  batchSize: z.number().default(1000),
  batchTimeout: z.number().default(100),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.lazy(() => FlushPeriodSec$inboundSchema).optional(),
  maxInProgress: z.number().default(10),
  onBackpressure: BackpressureBehaviorGooglePubsub$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionGooglePubsub$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGooglePubsub$inboundSchema.default(
    "block",
  ),
  pqMode: CreateOutputModeGooglePubsub$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGooglePubsub$inboundSchema).optional(),
});

/** @internal */
export type OutputGooglePubsub$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  topicName: string;
  createTopic: boolean;
  orderedDelivery: boolean;
  region?: string | undefined;
  googleAuthMethod: string;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  batchSize: number;
  batchTimeout: number;
  maxQueueSize: number;
  maxRecordSizeKB: number;
  flushPeriodSec?: FlushPeriodSec$Outbound | undefined;
  maxInProgress: number;
  onBackpressure: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsGooglePubsub$Outbound | undefined;
};

/** @internal */
export const OutputGooglePubsub$outboundSchema: z.ZodType<
  OutputGooglePubsub$Outbound,
  z.ZodTypeDef,
  OutputGooglePubsub
> = z.object({
  id: z.string(),
  type: CreateOutputTypeGooglePubsub$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  topicName: z.string(),
  createTopic: z.boolean().default(false),
  orderedDelivery: z.boolean().default(false),
  region: z.string().optional(),
  googleAuthMethod:
    CreateOutputGoogleAuthenticationMethodGooglePubsub$outboundSchema.default(
      "manual",
    ),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  batchSize: z.number().default(1000),
  batchTimeout: z.number().default(100),
  maxQueueSize: z.number().default(100),
  maxRecordSizeKB: z.number().default(256),
  flushPeriodSec: z.lazy(() => FlushPeriodSec$outboundSchema).optional(),
  maxInProgress: z.number().default(10),
  onBackpressure: BackpressureBehaviorGooglePubsub$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionGooglePubsub$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGooglePubsub$outboundSchema.default(
    "block",
  ),
  pqMode: CreateOutputModeGooglePubsub$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGooglePubsub$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGooglePubsub$ {
  /** @deprecated use `OutputGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = OutputGooglePubsub$inboundSchema;
  /** @deprecated use `OutputGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = OutputGooglePubsub$outboundSchema;
  /** @deprecated use `OutputGooglePubsub$Outbound` instead. */
  export type Outbound = OutputGooglePubsub$Outbound;
}

export function outputGooglePubsubToJSON(
  outputGooglePubsub: OutputGooglePubsub,
): string {
  return JSON.stringify(
    OutputGooglePubsub$outboundSchema.parse(outputGooglePubsub),
  );
}

export function outputGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<OutputGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGooglePubsub' from JSON`,
  );
}

/** @internal */
export const TypeGoogleCloudLogging$inboundSchema: z.ZodNativeEnum<
  typeof TypeGoogleCloudLogging
> = z.nativeEnum(TypeGoogleCloudLogging);

/** @internal */
export const TypeGoogleCloudLogging$outboundSchema: z.ZodNativeEnum<
  typeof TypeGoogleCloudLogging
> = TypeGoogleCloudLogging$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeGoogleCloudLogging$ {
  /** @deprecated use `TypeGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema = TypeGoogleCloudLogging$inboundSchema;
  /** @deprecated use `TypeGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema = TypeGoogleCloudLogging$outboundSchema;
}

/** @internal */
export const LogLocationType$inboundSchema: z.ZodNativeEnum<
  typeof LogLocationType
> = z.nativeEnum(LogLocationType);

/** @internal */
export const LogLocationType$outboundSchema: z.ZodNativeEnum<
  typeof LogLocationType
> = LogLocationType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLocationType$ {
  /** @deprecated use `LogLocationType$inboundSchema` instead. */
  export const inboundSchema = LogLocationType$inboundSchema;
  /** @deprecated use `LogLocationType$outboundSchema` instead. */
  export const outboundSchema = LogLocationType$outboundSchema;
}

/** @internal */
export const PayloadFormat$inboundSchema: z.ZodNativeEnum<
  typeof PayloadFormat
> = z.nativeEnum(PayloadFormat);

/** @internal */
export const PayloadFormat$outboundSchema: z.ZodNativeEnum<
  typeof PayloadFormat
> = PayloadFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadFormat$ {
  /** @deprecated use `PayloadFormat$inboundSchema` instead. */
  export const inboundSchema = PayloadFormat$inboundSchema;
  /** @deprecated use `PayloadFormat$outboundSchema` instead. */
  export const outboundSchema = PayloadFormat$outboundSchema;
}

/** @internal */
export const LogLabel$inboundSchema: z.ZodType<
  LogLabel,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/** @internal */
export type LogLabel$Outbound = {
  label: string;
  valueExpression: string;
};

/** @internal */
export const LogLabel$outboundSchema: z.ZodType<
  LogLabel$Outbound,
  z.ZodTypeDef,
  LogLabel
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLabel$ {
  /** @deprecated use `LogLabel$inboundSchema` instead. */
  export const inboundSchema = LogLabel$inboundSchema;
  /** @deprecated use `LogLabel$outboundSchema` instead. */
  export const outboundSchema = LogLabel$outboundSchema;
  /** @deprecated use `LogLabel$Outbound` instead. */
  export type Outbound = LogLabel$Outbound;
}

export function logLabelToJSON(logLabel: LogLabel): string {
  return JSON.stringify(LogLabel$outboundSchema.parse(logLabel));
}

export function logLabelFromJSON(
  jsonString: string,
): SafeParseResult<LogLabel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LogLabel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LogLabel' from JSON`,
  );
}

/** @internal */
export const ResourceTypeLabel$inboundSchema: z.ZodType<
  ResourceTypeLabel,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/** @internal */
export type ResourceTypeLabel$Outbound = {
  label: string;
  valueExpression: string;
};

/** @internal */
export const ResourceTypeLabel$outboundSchema: z.ZodType<
  ResourceTypeLabel$Outbound,
  z.ZodTypeDef,
  ResourceTypeLabel
> = z.object({
  label: z.string(),
  valueExpression: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceTypeLabel$ {
  /** @deprecated use `ResourceTypeLabel$inboundSchema` instead. */
  export const inboundSchema = ResourceTypeLabel$inboundSchema;
  /** @deprecated use `ResourceTypeLabel$outboundSchema` instead. */
  export const outboundSchema = ResourceTypeLabel$outboundSchema;
  /** @deprecated use `ResourceTypeLabel$Outbound` instead. */
  export type Outbound = ResourceTypeLabel$Outbound;
}

export function resourceTypeLabelToJSON(
  resourceTypeLabel: ResourceTypeLabel,
): string {
  return JSON.stringify(
    ResourceTypeLabel$outboundSchema.parse(resourceTypeLabel),
  );
}

export function resourceTypeLabelFromJSON(
  jsonString: string,
): SafeParseResult<ResourceTypeLabel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResourceTypeLabel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResourceTypeLabel' from JSON`,
  );
}

/** @internal */
export const GoogleAuthenticationMethodGoogleCloudLogging$inboundSchema:
  z.ZodNativeEnum<typeof GoogleAuthenticationMethodGoogleCloudLogging> = z
    .nativeEnum(GoogleAuthenticationMethodGoogleCloudLogging);

/** @internal */
export const GoogleAuthenticationMethodGoogleCloudLogging$outboundSchema:
  z.ZodNativeEnum<typeof GoogleAuthenticationMethodGoogleCloudLogging> =
    GoogleAuthenticationMethodGoogleCloudLogging$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GoogleAuthenticationMethodGoogleCloudLogging$ {
  /** @deprecated use `GoogleAuthenticationMethodGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema =
    GoogleAuthenticationMethodGoogleCloudLogging$inboundSchema;
  /** @deprecated use `GoogleAuthenticationMethodGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema =
    GoogleAuthenticationMethodGoogleCloudLogging$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorGoogleCloudLogging$inboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorGoogleCloudLogging> = z.nativeEnum(
    BackpressureBehaviorGoogleCloudLogging,
  );

/** @internal */
export const BackpressureBehaviorGoogleCloudLogging$outboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorGoogleCloudLogging> =
    BackpressureBehaviorGoogleCloudLogging$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorGoogleCloudLogging$ {
  /** @deprecated use `BackpressureBehaviorGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema =
    BackpressureBehaviorGoogleCloudLogging$inboundSchema;
  /** @deprecated use `BackpressureBehaviorGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorGoogleCloudLogging$outboundSchema;
}

/** @internal */
export const CompressionGoogleCloudLogging$inboundSchema: z.ZodNativeEnum<
  typeof CompressionGoogleCloudLogging
> = z.nativeEnum(CompressionGoogleCloudLogging);

/** @internal */
export const CompressionGoogleCloudLogging$outboundSchema: z.ZodNativeEnum<
  typeof CompressionGoogleCloudLogging
> = CompressionGoogleCloudLogging$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionGoogleCloudLogging$ {
  /** @deprecated use `CompressionGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema = CompressionGoogleCloudLogging$inboundSchema;
  /** @deprecated use `CompressionGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema = CompressionGoogleCloudLogging$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorGoogleCloudLogging$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorGoogleCloudLogging
> = z.nativeEnum(QueueFullBehaviorGoogleCloudLogging);

/** @internal */
export const QueueFullBehaviorGoogleCloudLogging$outboundSchema:
  z.ZodNativeEnum<typeof QueueFullBehaviorGoogleCloudLogging> =
    QueueFullBehaviorGoogleCloudLogging$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorGoogleCloudLogging$ {
  /** @deprecated use `QueueFullBehaviorGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema =
    QueueFullBehaviorGoogleCloudLogging$inboundSchema;
  /** @deprecated use `QueueFullBehaviorGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema =
    QueueFullBehaviorGoogleCloudLogging$outboundSchema;
}

/** @internal */
export const ModeGoogleCloudLogging$inboundSchema: z.ZodNativeEnum<
  typeof ModeGoogleCloudLogging
> = z.nativeEnum(ModeGoogleCloudLogging);

/** @internal */
export const ModeGoogleCloudLogging$outboundSchema: z.ZodNativeEnum<
  typeof ModeGoogleCloudLogging
> = ModeGoogleCloudLogging$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeGoogleCloudLogging$ {
  /** @deprecated use `ModeGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema = ModeGoogleCloudLogging$inboundSchema;
  /** @deprecated use `ModeGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema = ModeGoogleCloudLogging$outboundSchema;
}

/** @internal */
export const PqControlsGoogleCloudLogging$inboundSchema: z.ZodType<
  PqControlsGoogleCloudLogging,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsGoogleCloudLogging$Outbound = {};

/** @internal */
export const PqControlsGoogleCloudLogging$outboundSchema: z.ZodType<
  PqControlsGoogleCloudLogging$Outbound,
  z.ZodTypeDef,
  PqControlsGoogleCloudLogging
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsGoogleCloudLogging$ {
  /** @deprecated use `PqControlsGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema = PqControlsGoogleCloudLogging$inboundSchema;
  /** @deprecated use `PqControlsGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema = PqControlsGoogleCloudLogging$outboundSchema;
  /** @deprecated use `PqControlsGoogleCloudLogging$Outbound` instead. */
  export type Outbound = PqControlsGoogleCloudLogging$Outbound;
}

export function pqControlsGoogleCloudLoggingToJSON(
  pqControlsGoogleCloudLogging: PqControlsGoogleCloudLogging,
): string {
  return JSON.stringify(
    PqControlsGoogleCloudLogging$outboundSchema.parse(
      pqControlsGoogleCloudLogging,
    ),
  );
}

export function pqControlsGoogleCloudLoggingFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsGoogleCloudLogging, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsGoogleCloudLogging$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsGoogleCloudLogging' from JSON`,
  );
}

/** @internal */
export const OutputGoogleCloudLogging$inboundSchema: z.ZodType<
  OutputGoogleCloudLogging,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeGoogleCloudLogging$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logLocationType: LogLocationType$inboundSchema,
  logNameExpression: z.string(),
  payloadFormat: PayloadFormat$inboundSchema.default("text"),
  logLabels: z.array(z.lazy(() => LogLabel$inboundSchema)).optional(),
  resourceTypeExpression: z.string().optional(),
  resourceTypeLabels: z.array(z.lazy(() => ResourceTypeLabel$inboundSchema))
    .optional(),
  severityExpression: z.string().optional(),
  insertIdExpression: z.string().optional(),
  googleAuthMethod: GoogleAuthenticationMethodGoogleCloudLogging$inboundSchema
    .default("manual"),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  concurrency: z.number().default(5),
  connectionTimeout: z.number().default(10000),
  timeoutSec: z.number().default(30),
  throttleRateReqPerSec: z.number().int().optional(),
  requestMethodExpression: z.string().optional(),
  requestUrlExpression: z.string().optional(),
  requestSizeExpression: z.string().optional(),
  statusExpression: z.string().optional(),
  responseSizeExpression: z.string().optional(),
  userAgentExpression: z.string().optional(),
  remoteIpExpression: z.string().optional(),
  serverIpExpression: z.string().optional(),
  refererExpression: z.string().optional(),
  latencyExpression: z.string().optional(),
  cacheLookupExpression: z.string().optional(),
  cacheHitExpression: z.string().optional(),
  cacheValidatedExpression: z.string().optional(),
  cacheFillBytesExpression: z.string().optional(),
  protocolExpression: z.string().optional(),
  idExpression: z.string().optional(),
  producerExpression: z.string().optional(),
  firstExpression: z.string().optional(),
  lastExpression: z.string().optional(),
  fileExpression: z.string().optional(),
  lineExpression: z.string().optional(),
  functionExpression: z.string().optional(),
  uidExpression: z.string().optional(),
  indexExpression: z.string().optional(),
  totalSplitsExpression: z.string().optional(),
  traceExpression: z.string().optional(),
  spanIdExpression: z.string().optional(),
  traceSampledExpression: z.string().optional(),
  onBackpressure: BackpressureBehaviorGoogleCloudLogging$inboundSchema.default(
    "block",
  ),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  logLocationExpression: z.string(),
  payloadExpression: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionGoogleCloudLogging$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGoogleCloudLogging$inboundSchema.default(
    "block",
  ),
  pqMode: ModeGoogleCloudLogging$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGoogleCloudLogging$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputGoogleCloudLogging$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  logLocationType: string;
  logNameExpression: string;
  payloadFormat: string;
  logLabels?: Array<LogLabel$Outbound> | undefined;
  resourceTypeExpression?: string | undefined;
  resourceTypeLabels?: Array<ResourceTypeLabel$Outbound> | undefined;
  severityExpression?: string | undefined;
  insertIdExpression?: string | undefined;
  googleAuthMethod: string;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  flushPeriodSec: number;
  concurrency: number;
  connectionTimeout: number;
  timeoutSec: number;
  throttleRateReqPerSec?: number | undefined;
  requestMethodExpression?: string | undefined;
  requestUrlExpression?: string | undefined;
  requestSizeExpression?: string | undefined;
  statusExpression?: string | undefined;
  responseSizeExpression?: string | undefined;
  userAgentExpression?: string | undefined;
  remoteIpExpression?: string | undefined;
  serverIpExpression?: string | undefined;
  refererExpression?: string | undefined;
  latencyExpression?: string | undefined;
  cacheLookupExpression?: string | undefined;
  cacheHitExpression?: string | undefined;
  cacheValidatedExpression?: string | undefined;
  cacheFillBytesExpression?: string | undefined;
  protocolExpression?: string | undefined;
  idExpression?: string | undefined;
  producerExpression?: string | undefined;
  firstExpression?: string | undefined;
  lastExpression?: string | undefined;
  fileExpression?: string | undefined;
  lineExpression?: string | undefined;
  functionExpression?: string | undefined;
  uidExpression?: string | undefined;
  indexExpression?: string | undefined;
  totalSplitsExpression?: string | undefined;
  traceExpression?: string | undefined;
  spanIdExpression?: string | undefined;
  traceSampledExpression?: string | undefined;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  logLocationExpression: string;
  payloadExpression?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsGoogleCloudLogging$Outbound | undefined;
};

/** @internal */
export const OutputGoogleCloudLogging$outboundSchema: z.ZodType<
  OutputGoogleCloudLogging$Outbound,
  z.ZodTypeDef,
  OutputGoogleCloudLogging
> = z.object({
  id: z.string(),
  type: TypeGoogleCloudLogging$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logLocationType: LogLocationType$outboundSchema,
  logNameExpression: z.string(),
  payloadFormat: PayloadFormat$outboundSchema.default("text"),
  logLabels: z.array(z.lazy(() => LogLabel$outboundSchema)).optional(),
  resourceTypeExpression: z.string().optional(),
  resourceTypeLabels: z.array(z.lazy(() => ResourceTypeLabel$outboundSchema))
    .optional(),
  severityExpression: z.string().optional(),
  insertIdExpression: z.string().optional(),
  googleAuthMethod: GoogleAuthenticationMethodGoogleCloudLogging$outboundSchema
    .default("manual"),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  concurrency: z.number().default(5),
  connectionTimeout: z.number().default(10000),
  timeoutSec: z.number().default(30),
  throttleRateReqPerSec: z.number().int().optional(),
  requestMethodExpression: z.string().optional(),
  requestUrlExpression: z.string().optional(),
  requestSizeExpression: z.string().optional(),
  statusExpression: z.string().optional(),
  responseSizeExpression: z.string().optional(),
  userAgentExpression: z.string().optional(),
  remoteIpExpression: z.string().optional(),
  serverIpExpression: z.string().optional(),
  refererExpression: z.string().optional(),
  latencyExpression: z.string().optional(),
  cacheLookupExpression: z.string().optional(),
  cacheHitExpression: z.string().optional(),
  cacheValidatedExpression: z.string().optional(),
  cacheFillBytesExpression: z.string().optional(),
  protocolExpression: z.string().optional(),
  idExpression: z.string().optional(),
  producerExpression: z.string().optional(),
  firstExpression: z.string().optional(),
  lastExpression: z.string().optional(),
  fileExpression: z.string().optional(),
  lineExpression: z.string().optional(),
  functionExpression: z.string().optional(),
  uidExpression: z.string().optional(),
  indexExpression: z.string().optional(),
  totalSplitsExpression: z.string().optional(),
  traceExpression: z.string().optional(),
  spanIdExpression: z.string().optional(),
  traceSampledExpression: z.string().optional(),
  onBackpressure: BackpressureBehaviorGoogleCloudLogging$outboundSchema.default(
    "block",
  ),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  logLocationExpression: z.string(),
  payloadExpression: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionGoogleCloudLogging$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGoogleCloudLogging$outboundSchema.default(
    "block",
  ),
  pqMode: ModeGoogleCloudLogging$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGoogleCloudLogging$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudLogging$ {
  /** @deprecated use `OutputGoogleCloudLogging$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudLogging$inboundSchema;
  /** @deprecated use `OutputGoogleCloudLogging$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleCloudLogging$outboundSchema;
  /** @deprecated use `OutputGoogleCloudLogging$Outbound` instead. */
  export type Outbound = OutputGoogleCloudLogging$Outbound;
}

export function outputGoogleCloudLoggingToJSON(
  outputGoogleCloudLogging: OutputGoogleCloudLogging,
): string {
  return JSON.stringify(
    OutputGoogleCloudLogging$outboundSchema.parse(outputGoogleCloudLogging),
  );
}

export function outputGoogleCloudLoggingFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleCloudLogging, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGoogleCloudLogging$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleCloudLogging' from JSON`,
  );
}

/** @internal */
export const TypeGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof TypeGoogleCloudStorage
> = z.nativeEnum(TypeGoogleCloudStorage);

/** @internal */
export const TypeGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof TypeGoogleCloudStorage
> = TypeGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeGoogleCloudStorage$ {
  /** @deprecated use `TypeGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = TypeGoogleCloudStorage$inboundSchema;
  /** @deprecated use `TypeGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = TypeGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const SignatureVersionGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionGoogleCloudStorage
> = z.nativeEnum(SignatureVersionGoogleCloudStorage);

/** @internal */
export const SignatureVersionGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionGoogleCloudStorage
> = SignatureVersionGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionGoogleCloudStorage$ {
  /** @deprecated use `SignatureVersionGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionGoogleCloudStorage$inboundSchema;
  /** @deprecated use `SignatureVersionGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema =
    SignatureVersionGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const AuthenticationMethodGoogleCloudStorage$inboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodGoogleCloudStorage> = z.nativeEnum(
    AuthenticationMethodGoogleCloudStorage,
  );

/** @internal */
export const AuthenticationMethodGoogleCloudStorage$outboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodGoogleCloudStorage> =
    AuthenticationMethodGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodGoogleCloudStorage$ {
  /** @deprecated use `AuthenticationMethodGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema =
    AuthenticationMethodGoogleCloudStorage$inboundSchema;
  /** @deprecated use `AuthenticationMethodGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const ObjectACLGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof ObjectACLGoogleCloudStorage
> = z.nativeEnum(ObjectACLGoogleCloudStorage);

/** @internal */
export const ObjectACLGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof ObjectACLGoogleCloudStorage
> = ObjectACLGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectACLGoogleCloudStorage$ {
  /** @deprecated use `ObjectACLGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = ObjectACLGoogleCloudStorage$inboundSchema;
  /** @deprecated use `ObjectACLGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = ObjectACLGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const StorageClassGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof StorageClassGoogleCloudStorage
> = z.nativeEnum(StorageClassGoogleCloudStorage);

/** @internal */
export const StorageClassGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof StorageClassGoogleCloudStorage
> = StorageClassGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StorageClassGoogleCloudStorage$ {
  /** @deprecated use `StorageClassGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = StorageClassGoogleCloudStorage$inboundSchema;
  /** @deprecated use `StorageClassGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = StorageClassGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const DataFormatGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof DataFormatGoogleCloudStorage
> = z.nativeEnum(DataFormatGoogleCloudStorage);

/** @internal */
export const DataFormatGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof DataFormatGoogleCloudStorage
> = DataFormatGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFormatGoogleCloudStorage$ {
  /** @deprecated use `DataFormatGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = DataFormatGoogleCloudStorage$inboundSchema;
  /** @deprecated use `DataFormatGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = DataFormatGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorGoogleCloudStorage$inboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorGoogleCloudStorage> = z.nativeEnum(
    BackpressureBehaviorGoogleCloudStorage,
  );

/** @internal */
export const BackpressureBehaviorGoogleCloudStorage$outboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorGoogleCloudStorage> =
    BackpressureBehaviorGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorGoogleCloudStorage$ {
  /** @deprecated use `BackpressureBehaviorGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema =
    BackpressureBehaviorGoogleCloudStorage$inboundSchema;
  /** @deprecated use `BackpressureBehaviorGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionGoogleCloudStorage$inboundSchema:
  z.ZodNativeEnum<typeof DiskSpaceProtectionGoogleCloudStorage> = z.nativeEnum(
    DiskSpaceProtectionGoogleCloudStorage,
  );

/** @internal */
export const DiskSpaceProtectionGoogleCloudStorage$outboundSchema:
  z.ZodNativeEnum<typeof DiskSpaceProtectionGoogleCloudStorage> =
    DiskSpaceProtectionGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionGoogleCloudStorage$ {
  /** @deprecated use `DiskSpaceProtectionGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema =
    DiskSpaceProtectionGoogleCloudStorage$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema =
    DiskSpaceProtectionGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const CompressionGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof CompressionGoogleCloudStorage
> = z.nativeEnum(CompressionGoogleCloudStorage);

/** @internal */
export const CompressionGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof CompressionGoogleCloudStorage
> = CompressionGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionGoogleCloudStorage$ {
  /** @deprecated use `CompressionGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = CompressionGoogleCloudStorage$inboundSchema;
  /** @deprecated use `CompressionGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = CompressionGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const CompressionLevelGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelGoogleCloudStorage
> = z.nativeEnum(CompressionLevelGoogleCloudStorage);

/** @internal */
export const CompressionLevelGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelGoogleCloudStorage
> = CompressionLevelGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionLevelGoogleCloudStorage$ {
  /** @deprecated use `CompressionLevelGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = CompressionLevelGoogleCloudStorage$inboundSchema;
  /** @deprecated use `CompressionLevelGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema =
    CompressionLevelGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const ParquetVersionGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionGoogleCloudStorage
> = z.nativeEnum(ParquetVersionGoogleCloudStorage);

/** @internal */
export const ParquetVersionGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionGoogleCloudStorage
> = ParquetVersionGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ParquetVersionGoogleCloudStorage$ {
  /** @deprecated use `ParquetVersionGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = ParquetVersionGoogleCloudStorage$inboundSchema;
  /** @deprecated use `ParquetVersionGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = ParquetVersionGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const DataPageVersionGoogleCloudStorage$inboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionGoogleCloudStorage
> = z.nativeEnum(DataPageVersionGoogleCloudStorage);

/** @internal */
export const DataPageVersionGoogleCloudStorage$outboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionGoogleCloudStorage
> = DataPageVersionGoogleCloudStorage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataPageVersionGoogleCloudStorage$ {
  /** @deprecated use `DataPageVersionGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = DataPageVersionGoogleCloudStorage$inboundSchema;
  /** @deprecated use `DataPageVersionGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema =
    DataPageVersionGoogleCloudStorage$outboundSchema;
}

/** @internal */
export const KeyValueMetadatumGoogleCloudStorage$inboundSchema: z.ZodType<
  KeyValueMetadatumGoogleCloudStorage,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type KeyValueMetadatumGoogleCloudStorage$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const KeyValueMetadatumGoogleCloudStorage$outboundSchema: z.ZodType<
  KeyValueMetadatumGoogleCloudStorage$Outbound,
  z.ZodTypeDef,
  KeyValueMetadatumGoogleCloudStorage
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KeyValueMetadatumGoogleCloudStorage$ {
  /** @deprecated use `KeyValueMetadatumGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema =
    KeyValueMetadatumGoogleCloudStorage$inboundSchema;
  /** @deprecated use `KeyValueMetadatumGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema =
    KeyValueMetadatumGoogleCloudStorage$outboundSchema;
  /** @deprecated use `KeyValueMetadatumGoogleCloudStorage$Outbound` instead. */
  export type Outbound = KeyValueMetadatumGoogleCloudStorage$Outbound;
}

export function keyValueMetadatumGoogleCloudStorageToJSON(
  keyValueMetadatumGoogleCloudStorage: KeyValueMetadatumGoogleCloudStorage,
): string {
  return JSON.stringify(
    KeyValueMetadatumGoogleCloudStorage$outboundSchema.parse(
      keyValueMetadatumGoogleCloudStorage,
    ),
  );
}

export function keyValueMetadatumGoogleCloudStorageFromJSON(
  jsonString: string,
): SafeParseResult<KeyValueMetadatumGoogleCloudStorage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      KeyValueMetadatumGoogleCloudStorage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KeyValueMetadatumGoogleCloudStorage' from JSON`,
  );
}

/** @internal */
export const OutputGoogleCloudStorage$inboundSchema: z.ZodType<
  OutputGoogleCloudStorage,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeGoogleCloudStorage$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: SignatureVersionGoogleCloudStorage$inboundSchema.default(
    "v4",
  ),
  awsAuthenticationMethod: AuthenticationMethodGoogleCloudStorage$inboundSchema
    .default("manual"),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  destPath: z.string().default(""),
  verifyPermissions: z.boolean().default(true),
  objectACL: ObjectACLGoogleCloudStorage$inboundSchema.default("private"),
  storageClass: StorageClassGoogleCloudStorage$inboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatGoogleCloudStorage$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorGoogleCloudStorage$inboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionGoogleCloudStorage$inboundSchema
    .default("block"),
  description: z.string().optional(),
  compress: CompressionGoogleCloudStorage$inboundSchema.default("gzip"),
  compressionLevel: CompressionLevelGoogleCloudStorage$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionGoogleCloudStorage$inboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: DataPageVersionGoogleCloudStorage$inboundSchema
    .default("DATA_PAGE_V2"),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumGoogleCloudStorage$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/** @internal */
export type OutputGoogleCloudStorage$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region: string;
  endpoint: string;
  signatureVersion: string;
  awsAuthenticationMethod: string;
  stagePath: string;
  destPath: string;
  verifyPermissions: boolean;
  objectACL: string;
  storageClass?: string | undefined;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  description?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<KeyValueMetadatumGoogleCloudStorage$Outbound>
    | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
  awsApiKey?: string | undefined;
  awsSecretKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const OutputGoogleCloudStorage$outboundSchema: z.ZodType<
  OutputGoogleCloudStorage$Outbound,
  z.ZodTypeDef,
  OutputGoogleCloudStorage
> = z.object({
  id: z.string(),
  type: TypeGoogleCloudStorage$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string(),
  endpoint: z.string().default("https://storage.googleapis.com"),
  signatureVersion: SignatureVersionGoogleCloudStorage$outboundSchema.default(
    "v4",
  ),
  awsAuthenticationMethod: AuthenticationMethodGoogleCloudStorage$outboundSchema
    .default("manual"),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  destPath: z.string().default(""),
  verifyPermissions: z.boolean().default(true),
  objectACL: ObjectACLGoogleCloudStorage$outboundSchema.default("private"),
  storageClass: StorageClassGoogleCloudStorage$outboundSchema.optional(),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatGoogleCloudStorage$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorGoogleCloudStorage$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionGoogleCloudStorage$outboundSchema
    .default("block"),
  description: z.string().optional(),
  compress: CompressionGoogleCloudStorage$outboundSchema.default("gzip"),
  compressionLevel: CompressionLevelGoogleCloudStorage$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionGoogleCloudStorage$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: DataPageVersionGoogleCloudStorage$outboundSchema
    .default("DATA_PAGE_V2"),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumGoogleCloudStorage$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  awsApiKey: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleCloudStorage$ {
  /** @deprecated use `OutputGoogleCloudStorage$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleCloudStorage$inboundSchema;
  /** @deprecated use `OutputGoogleCloudStorage$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleCloudStorage$outboundSchema;
  /** @deprecated use `OutputGoogleCloudStorage$Outbound` instead. */
  export type Outbound = OutputGoogleCloudStorage$Outbound;
}

export function outputGoogleCloudStorageToJSON(
  outputGoogleCloudStorage: OutputGoogleCloudStorage,
): string {
  return JSON.stringify(
    OutputGoogleCloudStorage$outboundSchema.parse(outputGoogleCloudStorage),
  );
}

export function outputGoogleCloudStorageFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleCloudStorage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGoogleCloudStorage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleCloudStorage' from JSON`,
  );
}

/** @internal */
export const TypeGoogleChronicle$inboundSchema: z.ZodNativeEnum<
  typeof TypeGoogleChronicle
> = z.nativeEnum(TypeGoogleChronicle);

/** @internal */
export const TypeGoogleChronicle$outboundSchema: z.ZodNativeEnum<
  typeof TypeGoogleChronicle
> = TypeGoogleChronicle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeGoogleChronicle$ {
  /** @deprecated use `TypeGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = TypeGoogleChronicle$inboundSchema;
  /** @deprecated use `TypeGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = TypeGoogleChronicle$outboundSchema;
}

/** @internal */
export const CreateOutputAPIVersion$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAPIVersion
> = z.nativeEnum(CreateOutputAPIVersion);

/** @internal */
export const CreateOutputAPIVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAPIVersion
> = CreateOutputAPIVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAPIVersion$ {
  /** @deprecated use `CreateOutputAPIVersion$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAPIVersion$inboundSchema;
  /** @deprecated use `CreateOutputAPIVersion$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAPIVersion$outboundSchema;
}

/** @internal */
export const AuthenticationMethodGoogleChronicle$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodGoogleChronicle
> = z.nativeEnum(AuthenticationMethodGoogleChronicle);

/** @internal */
export const AuthenticationMethodGoogleChronicle$outboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodGoogleChronicle> =
    AuthenticationMethodGoogleChronicle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodGoogleChronicle$ {
  /** @deprecated use `AuthenticationMethodGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema =
    AuthenticationMethodGoogleChronicle$inboundSchema;
  /** @deprecated use `AuthenticationMethodGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodGoogleChronicle$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingGoogleChronicle$inboundSchema: z.ZodType<
  ResponseRetrySettingGoogleChronicle,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingGoogleChronicle$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingGoogleChronicle$outboundSchema: z.ZodType<
  ResponseRetrySettingGoogleChronicle$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingGoogleChronicle
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingGoogleChronicle$ {
  /** @deprecated use `ResponseRetrySettingGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema =
    ResponseRetrySettingGoogleChronicle$inboundSchema;
  /** @deprecated use `ResponseRetrySettingGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema =
    ResponseRetrySettingGoogleChronicle$outboundSchema;
  /** @deprecated use `ResponseRetrySettingGoogleChronicle$Outbound` instead. */
  export type Outbound = ResponseRetrySettingGoogleChronicle$Outbound;
}

export function responseRetrySettingGoogleChronicleToJSON(
  responseRetrySettingGoogleChronicle: ResponseRetrySettingGoogleChronicle,
): string {
  return JSON.stringify(
    ResponseRetrySettingGoogleChronicle$outboundSchema.parse(
      responseRetrySettingGoogleChronicle,
    ),
  );
}

export function responseRetrySettingGoogleChronicleFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingGoogleChronicle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ResponseRetrySettingGoogleChronicle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingGoogleChronicle' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsGoogleChronicle$inboundSchema: z.ZodType<
  TimeoutRetrySettingsGoogleChronicle,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsGoogleChronicle$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsGoogleChronicle$outboundSchema: z.ZodType<
  TimeoutRetrySettingsGoogleChronicle$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsGoogleChronicle
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsGoogleChronicle$ {
  /** @deprecated use `TimeoutRetrySettingsGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema =
    TimeoutRetrySettingsGoogleChronicle$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema =
    TimeoutRetrySettingsGoogleChronicle$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsGoogleChronicle$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsGoogleChronicle$Outbound;
}

export function timeoutRetrySettingsGoogleChronicleToJSON(
  timeoutRetrySettingsGoogleChronicle: TimeoutRetrySettingsGoogleChronicle,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsGoogleChronicle$outboundSchema.parse(
      timeoutRetrySettingsGoogleChronicle,
    ),
  );
}

export function timeoutRetrySettingsGoogleChronicleFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsGoogleChronicle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TimeoutRetrySettingsGoogleChronicle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsGoogleChronicle' from JSON`,
  );
}

/** @internal */
export const SendEventsAs$inboundSchema: z.ZodNativeEnum<typeof SendEventsAs> =
  z.nativeEnum(SendEventsAs);

/** @internal */
export const SendEventsAs$outboundSchema: z.ZodNativeEnum<typeof SendEventsAs> =
  SendEventsAs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SendEventsAs$ {
  /** @deprecated use `SendEventsAs$inboundSchema` instead. */
  export const inboundSchema = SendEventsAs$inboundSchema;
  /** @deprecated use `SendEventsAs$outboundSchema` instead. */
  export const outboundSchema = SendEventsAs$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderGoogleChronicle$inboundSchema: z.ZodType<
  ExtraHttpHeaderGoogleChronicle,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderGoogleChronicle$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderGoogleChronicle$outboundSchema: z.ZodType<
  ExtraHttpHeaderGoogleChronicle$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderGoogleChronicle
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderGoogleChronicle$ {
  /** @deprecated use `ExtraHttpHeaderGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderGoogleChronicle$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderGoogleChronicle$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderGoogleChronicle$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderGoogleChronicle$Outbound;
}

export function extraHttpHeaderGoogleChronicleToJSON(
  extraHttpHeaderGoogleChronicle: ExtraHttpHeaderGoogleChronicle,
): string {
  return JSON.stringify(
    ExtraHttpHeaderGoogleChronicle$outboundSchema.parse(
      extraHttpHeaderGoogleChronicle,
    ),
  );
}

export function extraHttpHeaderGoogleChronicleFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderGoogleChronicle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderGoogleChronicle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderGoogleChronicle' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeGoogleChronicle$inboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeGoogleChronicle> = z
    .nativeEnum(FailedRequestLoggingModeGoogleChronicle);

/** @internal */
export const FailedRequestLoggingModeGoogleChronicle$outboundSchema:
  z.ZodNativeEnum<typeof FailedRequestLoggingModeGoogleChronicle> =
    FailedRequestLoggingModeGoogleChronicle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeGoogleChronicle$ {
  /** @deprecated use `FailedRequestLoggingModeGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema =
    FailedRequestLoggingModeGoogleChronicle$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeGoogleChronicle$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorGoogleChronicle$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorGoogleChronicle
> = z.nativeEnum(BackpressureBehaviorGoogleChronicle);

/** @internal */
export const BackpressureBehaviorGoogleChronicle$outboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorGoogleChronicle> =
    BackpressureBehaviorGoogleChronicle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorGoogleChronicle$ {
  /** @deprecated use `BackpressureBehaviorGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema =
    BackpressureBehaviorGoogleChronicle$inboundSchema;
  /** @deprecated use `BackpressureBehaviorGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorGoogleChronicle$outboundSchema;
}

/** @internal */
export const ExtraLogType$inboundSchema: z.ZodType<
  ExtraLogType,
  z.ZodTypeDef,
  unknown
> = z.object({
  logType: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type ExtraLogType$Outbound = {
  logType: string;
  description?: string | undefined;
};

/** @internal */
export const ExtraLogType$outboundSchema: z.ZodType<
  ExtraLogType$Outbound,
  z.ZodTypeDef,
  ExtraLogType
> = z.object({
  logType: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraLogType$ {
  /** @deprecated use `ExtraLogType$inboundSchema` instead. */
  export const inboundSchema = ExtraLogType$inboundSchema;
  /** @deprecated use `ExtraLogType$outboundSchema` instead. */
  export const outboundSchema = ExtraLogType$outboundSchema;
  /** @deprecated use `ExtraLogType$Outbound` instead. */
  export type Outbound = ExtraLogType$Outbound;
}

export function extraLogTypeToJSON(extraLogType: ExtraLogType): string {
  return JSON.stringify(ExtraLogType$outboundSchema.parse(extraLogType));
}

export function extraLogTypeFromJSON(
  jsonString: string,
): SafeParseResult<ExtraLogType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraLogType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraLogType' from JSON`,
  );
}

/** @internal */
export const CustomLabel$inboundSchema: z.ZodType<
  CustomLabel,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  value: z.string(),
});

/** @internal */
export type CustomLabel$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const CustomLabel$outboundSchema: z.ZodType<
  CustomLabel$Outbound,
  z.ZodTypeDef,
  CustomLabel
> = z.object({
  key: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomLabel$ {
  /** @deprecated use `CustomLabel$inboundSchema` instead. */
  export const inboundSchema = CustomLabel$inboundSchema;
  /** @deprecated use `CustomLabel$outboundSchema` instead. */
  export const outboundSchema = CustomLabel$outboundSchema;
  /** @deprecated use `CustomLabel$Outbound` instead. */
  export type Outbound = CustomLabel$Outbound;
}

export function customLabelToJSON(customLabel: CustomLabel): string {
  return JSON.stringify(CustomLabel$outboundSchema.parse(customLabel));
}

export function customLabelFromJSON(
  jsonString: string,
): SafeParseResult<CustomLabel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomLabel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomLabel' from JSON`,
  );
}

/** @internal */
export const CompressionGoogleChronicle$inboundSchema: z.ZodNativeEnum<
  typeof CompressionGoogleChronicle
> = z.nativeEnum(CompressionGoogleChronicle);

/** @internal */
export const CompressionGoogleChronicle$outboundSchema: z.ZodNativeEnum<
  typeof CompressionGoogleChronicle
> = CompressionGoogleChronicle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionGoogleChronicle$ {
  /** @deprecated use `CompressionGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = CompressionGoogleChronicle$inboundSchema;
  /** @deprecated use `CompressionGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = CompressionGoogleChronicle$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorGoogleChronicle$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorGoogleChronicle
> = z.nativeEnum(QueueFullBehaviorGoogleChronicle);

/** @internal */
export const QueueFullBehaviorGoogleChronicle$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorGoogleChronicle
> = QueueFullBehaviorGoogleChronicle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorGoogleChronicle$ {
  /** @deprecated use `QueueFullBehaviorGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorGoogleChronicle$inboundSchema;
  /** @deprecated use `QueueFullBehaviorGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorGoogleChronicle$outboundSchema;
}

/** @internal */
export const ModeGoogleChronicle$inboundSchema: z.ZodNativeEnum<
  typeof ModeGoogleChronicle
> = z.nativeEnum(ModeGoogleChronicle);

/** @internal */
export const ModeGoogleChronicle$outboundSchema: z.ZodNativeEnum<
  typeof ModeGoogleChronicle
> = ModeGoogleChronicle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeGoogleChronicle$ {
  /** @deprecated use `ModeGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = ModeGoogleChronicle$inboundSchema;
  /** @deprecated use `ModeGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = ModeGoogleChronicle$outboundSchema;
}

/** @internal */
export const PqControlsGoogleChronicle$inboundSchema: z.ZodType<
  PqControlsGoogleChronicle,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsGoogleChronicle$Outbound = {};

/** @internal */
export const PqControlsGoogleChronicle$outboundSchema: z.ZodType<
  PqControlsGoogleChronicle$Outbound,
  z.ZodTypeDef,
  PqControlsGoogleChronicle
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsGoogleChronicle$ {
  /** @deprecated use `PqControlsGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = PqControlsGoogleChronicle$inboundSchema;
  /** @deprecated use `PqControlsGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = PqControlsGoogleChronicle$outboundSchema;
  /** @deprecated use `PqControlsGoogleChronicle$Outbound` instead. */
  export type Outbound = PqControlsGoogleChronicle$Outbound;
}

export function pqControlsGoogleChronicleToJSON(
  pqControlsGoogleChronicle: PqControlsGoogleChronicle,
): string {
  return JSON.stringify(
    PqControlsGoogleChronicle$outboundSchema.parse(pqControlsGoogleChronicle),
  );
}

export function pqControlsGoogleChronicleFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsGoogleChronicle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsGoogleChronicle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsGoogleChronicle' from JSON`,
  );
}

/** @internal */
export const OutputGoogleChronicle$inboundSchema: z.ZodType<
  OutputGoogleChronicle,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeGoogleChronicle$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  apiVersion: CreateOutputAPIVersion$inboundSchema.default("v1"),
  authenticationMethod: AuthenticationMethodGoogleChronicle$inboundSchema
    .default("serviceAccount"),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingGoogleChronicle$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsGoogleChronicle$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  logFormatType: SendEventsAs$inboundSchema.default("unstructured"),
  region: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(90),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderGoogleChronicle$inboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    FailedRequestLoggingModeGoogleChronicle$inboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  useRoundRobinDns: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorGoogleChronicle$inboundSchema.default(
    "block",
  ),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  extraLogTypes: z.array(z.lazy(() => ExtraLogType$inboundSchema)).optional(),
  logType: z.string().optional(),
  logTextField: z.string().optional(),
  customerId: z.string().optional(),
  namespace: z.string().optional(),
  customLabels: z.array(z.lazy(() => CustomLabel$inboundSchema)).optional(),
  apiKey: z.string().optional(),
  apiKeySecret: z.string().optional(),
  serviceAccountCredentials: z.string().optional(),
  serviceAccountCredentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionGoogleChronicle$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGoogleChronicle$inboundSchema.default(
    "block",
  ),
  pqMode: ModeGoogleChronicle$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGoogleChronicle$inboundSchema).optional(),
});

/** @internal */
export type OutputGoogleChronicle$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  apiVersion: string;
  authenticationMethod: string;
  responseRetrySettings?:
    | Array<ResponseRetrySettingGoogleChronicle$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | TimeoutRetrySettingsGoogleChronicle$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  logFormatType: string;
  region?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderGoogleChronicle$Outbound> | undefined;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  useRoundRobinDns: boolean;
  onBackpressure: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  extraLogTypes?: Array<ExtraLogType$Outbound> | undefined;
  logType?: string | undefined;
  logTextField?: string | undefined;
  customerId?: string | undefined;
  namespace?: string | undefined;
  customLabels?: Array<CustomLabel$Outbound> | undefined;
  apiKey?: string | undefined;
  apiKeySecret?: string | undefined;
  serviceAccountCredentials?: string | undefined;
  serviceAccountCredentialsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsGoogleChronicle$Outbound | undefined;
};

/** @internal */
export const OutputGoogleChronicle$outboundSchema: z.ZodType<
  OutputGoogleChronicle$Outbound,
  z.ZodTypeDef,
  OutputGoogleChronicle
> = z.object({
  id: z.string(),
  type: TypeGoogleChronicle$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  apiVersion: CreateOutputAPIVersion$outboundSchema.default("v1"),
  authenticationMethod: AuthenticationMethodGoogleChronicle$outboundSchema
    .default("serviceAccount"),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingGoogleChronicle$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsGoogleChronicle$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  logFormatType: SendEventsAs$outboundSchema.default("unstructured"),
  region: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(90),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderGoogleChronicle$outboundSchema),
  ).optional(),
  failedRequestLoggingMode:
    FailedRequestLoggingModeGoogleChronicle$outboundSchema.default("none"),
  safeHeaders: z.array(z.string()).optional(),
  useRoundRobinDns: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorGoogleChronicle$outboundSchema.default(
    "block",
  ),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  extraLogTypes: z.array(z.lazy(() => ExtraLogType$outboundSchema)).optional(),
  logType: z.string().optional(),
  logTextField: z.string().optional(),
  customerId: z.string().optional(),
  namespace: z.string().optional(),
  customLabels: z.array(z.lazy(() => CustomLabel$outboundSchema)).optional(),
  apiKey: z.string().optional(),
  apiKeySecret: z.string().optional(),
  serviceAccountCredentials: z.string().optional(),
  serviceAccountCredentialsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionGoogleChronicle$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorGoogleChronicle$outboundSchema.default(
    "block",
  ),
  pqMode: ModeGoogleChronicle$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsGoogleChronicle$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputGoogleChronicle$ {
  /** @deprecated use `OutputGoogleChronicle$inboundSchema` instead. */
  export const inboundSchema = OutputGoogleChronicle$inboundSchema;
  /** @deprecated use `OutputGoogleChronicle$outboundSchema` instead. */
  export const outboundSchema = OutputGoogleChronicle$outboundSchema;
  /** @deprecated use `OutputGoogleChronicle$Outbound` instead. */
  export type Outbound = OutputGoogleChronicle$Outbound;
}

export function outputGoogleChronicleToJSON(
  outputGoogleChronicle: OutputGoogleChronicle,
): string {
  return JSON.stringify(
    OutputGoogleChronicle$outboundSchema.parse(outputGoogleChronicle),
  );
}

export function outputGoogleChronicleFromJSON(
  jsonString: string,
): SafeParseResult<OutputGoogleChronicle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputGoogleChronicle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputGoogleChronicle' from JSON`,
  );
}

/** @internal */
export const TypeAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof TypeAzureEventhub
> = z.nativeEnum(TypeAzureEventhub);

/** @internal */
export const TypeAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof TypeAzureEventhub
> = TypeAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeAzureEventhub$ {
  /** @deprecated use `TypeAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = TypeAzureEventhub$inboundSchema;
  /** @deprecated use `TypeAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = TypeAzureEventhub$outboundSchema;
}

/** @internal */
export const AcknowledgmentsAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsAzureEventhub
> = z.nativeEnum(AcknowledgmentsAzureEventhub);

/** @internal */
export const AcknowledgmentsAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof AcknowledgmentsAzureEventhub
> = AcknowledgmentsAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AcknowledgmentsAzureEventhub$ {
  /** @deprecated use `AcknowledgmentsAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = AcknowledgmentsAzureEventhub$inboundSchema;
  /** @deprecated use `AcknowledgmentsAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = AcknowledgmentsAzureEventhub$outboundSchema;
}

/** @internal */
export const RecordDataFormatAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatAzureEventhub
> = z.nativeEnum(RecordDataFormatAzureEventhub);

/** @internal */
export const RecordDataFormatAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof RecordDataFormatAzureEventhub
> = RecordDataFormatAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordDataFormatAzureEventhub$ {
  /** @deprecated use `RecordDataFormatAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = RecordDataFormatAzureEventhub$inboundSchema;
  /** @deprecated use `RecordDataFormatAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = RecordDataFormatAzureEventhub$outboundSchema;
}

/** @internal */
export const SASLMechanismAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof SASLMechanismAzureEventhub
> = z.nativeEnum(SASLMechanismAzureEventhub);

/** @internal */
export const SASLMechanismAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof SASLMechanismAzureEventhub
> = SASLMechanismAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SASLMechanismAzureEventhub$ {
  /** @deprecated use `SASLMechanismAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = SASLMechanismAzureEventhub$inboundSchema;
  /** @deprecated use `SASLMechanismAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = SASLMechanismAzureEventhub$outboundSchema;
}

/** @internal */
export const AuthenticationAzureEventhub$inboundSchema: z.ZodType<
  AuthenticationAzureEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: SASLMechanismAzureEventhub$inboundSchema.default("plain"),
});

/** @internal */
export type AuthenticationAzureEventhub$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const AuthenticationAzureEventhub$outboundSchema: z.ZodType<
  AuthenticationAzureEventhub$Outbound,
  z.ZodTypeDef,
  AuthenticationAzureEventhub
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: SASLMechanismAzureEventhub$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationAzureEventhub$ {
  /** @deprecated use `AuthenticationAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = AuthenticationAzureEventhub$inboundSchema;
  /** @deprecated use `AuthenticationAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = AuthenticationAzureEventhub$outboundSchema;
  /** @deprecated use `AuthenticationAzureEventhub$Outbound` instead. */
  export type Outbound = AuthenticationAzureEventhub$Outbound;
}

export function authenticationAzureEventhubToJSON(
  authenticationAzureEventhub: AuthenticationAzureEventhub,
): string {
  return JSON.stringify(
    AuthenticationAzureEventhub$outboundSchema.parse(
      authenticationAzureEventhub,
    ),
  );
}

export function authenticationAzureEventhubFromJSON(
  jsonString: string,
): SafeParseResult<AuthenticationAzureEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthenticationAzureEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthenticationAzureEventhub' from JSON`,
  );
}

/** @internal */
export const TLSSettingsClientSideAzureEventhub$inboundSchema: z.ZodType<
  TLSSettingsClientSideAzureEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/** @internal */
export type TLSSettingsClientSideAzureEventhub$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
};

/** @internal */
export const TLSSettingsClientSideAzureEventhub$outboundSchema: z.ZodType<
  TLSSettingsClientSideAzureEventhub$Outbound,
  z.ZodTypeDef,
  TLSSettingsClientSideAzureEventhub
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsClientSideAzureEventhub$ {
  /** @deprecated use `TLSSettingsClientSideAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsClientSideAzureEventhub$inboundSchema;
  /** @deprecated use `TLSSettingsClientSideAzureEventhub$outboundSchema` instead. */
  export const outboundSchema =
    TLSSettingsClientSideAzureEventhub$outboundSchema;
  /** @deprecated use `TLSSettingsClientSideAzureEventhub$Outbound` instead. */
  export type Outbound = TLSSettingsClientSideAzureEventhub$Outbound;
}

export function tlsSettingsClientSideAzureEventhubToJSON(
  tlsSettingsClientSideAzureEventhub: TLSSettingsClientSideAzureEventhub,
): string {
  return JSON.stringify(
    TLSSettingsClientSideAzureEventhub$outboundSchema.parse(
      tlsSettingsClientSideAzureEventhub,
    ),
  );
}

export function tlsSettingsClientSideAzureEventhubFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsClientSideAzureEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TLSSettingsClientSideAzureEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsClientSideAzureEventhub' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorAzureEventhub
> = z.nativeEnum(BackpressureBehaviorAzureEventhub);

/** @internal */
export const BackpressureBehaviorAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorAzureEventhub
> = BackpressureBehaviorAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorAzureEventhub$ {
  /** @deprecated use `BackpressureBehaviorAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorAzureEventhub$inboundSchema;
  /** @deprecated use `BackpressureBehaviorAzureEventhub$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorAzureEventhub$outboundSchema;
}

/** @internal */
export const CompressionAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof CompressionAzureEventhub
> = z.nativeEnum(CompressionAzureEventhub);

/** @internal */
export const CompressionAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof CompressionAzureEventhub
> = CompressionAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionAzureEventhub$ {
  /** @deprecated use `CompressionAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = CompressionAzureEventhub$inboundSchema;
  /** @deprecated use `CompressionAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = CompressionAzureEventhub$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorAzureEventhub
> = z.nativeEnum(QueueFullBehaviorAzureEventhub);

/** @internal */
export const QueueFullBehaviorAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorAzureEventhub
> = QueueFullBehaviorAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorAzureEventhub$ {
  /** @deprecated use `QueueFullBehaviorAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorAzureEventhub$inboundSchema;
  /** @deprecated use `QueueFullBehaviorAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorAzureEventhub$outboundSchema;
}

/** @internal */
export const ModeAzureEventhub$inboundSchema: z.ZodNativeEnum<
  typeof ModeAzureEventhub
> = z.nativeEnum(ModeAzureEventhub);

/** @internal */
export const ModeAzureEventhub$outboundSchema: z.ZodNativeEnum<
  typeof ModeAzureEventhub
> = ModeAzureEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeAzureEventhub$ {
  /** @deprecated use `ModeAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = ModeAzureEventhub$inboundSchema;
  /** @deprecated use `ModeAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = ModeAzureEventhub$outboundSchema;
}

/** @internal */
export const PqControlsAzureEventhub$inboundSchema: z.ZodType<
  PqControlsAzureEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsAzureEventhub$Outbound = {};

/** @internal */
export const PqControlsAzureEventhub$outboundSchema: z.ZodType<
  PqControlsAzureEventhub$Outbound,
  z.ZodTypeDef,
  PqControlsAzureEventhub
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsAzureEventhub$ {
  /** @deprecated use `PqControlsAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = PqControlsAzureEventhub$inboundSchema;
  /** @deprecated use `PqControlsAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = PqControlsAzureEventhub$outboundSchema;
  /** @deprecated use `PqControlsAzureEventhub$Outbound` instead. */
  export type Outbound = PqControlsAzureEventhub$Outbound;
}

export function pqControlsAzureEventhubToJSON(
  pqControlsAzureEventhub: PqControlsAzureEventhub,
): string {
  return JSON.stringify(
    PqControlsAzureEventhub$outboundSchema.parse(pqControlsAzureEventhub),
  );
}

export function pqControlsAzureEventhubFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsAzureEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsAzureEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsAzureEventhub' from JSON`,
  );
}

/** @internal */
export const OutputAzureEventhub$inboundSchema: z.ZodType<
  OutputAzureEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeAzureEventhub$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: AcknowledgmentsAzureEventhub$inboundSchema.default(1),
  format: RecordDataFormatAzureEventhub$inboundSchema.default("json"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => AuthenticationAzureEventhub$inboundSchema).optional(),
  tls: z.lazy(() => TLSSettingsClientSideAzureEventhub$inboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorAzureEventhub$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionAzureEventhub$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorAzureEventhub$inboundSchema.default(
    "block",
  ),
  pqMode: ModeAzureEventhub$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsAzureEventhub$inboundSchema).optional(),
});

/** @internal */
export type OutputAzureEventhub$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  brokers: Array<string>;
  topic: string;
  ack: number;
  format: string;
  maxRecordSizeKB: number;
  flushEventCount: number;
  flushPeriodSec: number;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: AuthenticationAzureEventhub$Outbound | undefined;
  tls?: TLSSettingsClientSideAzureEventhub$Outbound | undefined;
  onBackpressure: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsAzureEventhub$Outbound | undefined;
};

/** @internal */
export const OutputAzureEventhub$outboundSchema: z.ZodType<
  OutputAzureEventhub$Outbound,
  z.ZodTypeDef,
  OutputAzureEventhub
> = z.object({
  id: z.string(),
  type: TypeAzureEventhub$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  brokers: z.array(z.string()),
  topic: z.string(),
  ack: AcknowledgmentsAzureEventhub$outboundSchema.default(1),
  format: RecordDataFormatAzureEventhub$outboundSchema.default("json"),
  maxRecordSizeKB: z.number().default(768),
  flushEventCount: z.number().default(1000),
  flushPeriodSec: z.number().default(1),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => AuthenticationAzureEventhub$outboundSchema).optional(),
  tls: z.lazy(() => TLSSettingsClientSideAzureEventhub$outboundSchema)
    .optional(),
  onBackpressure: BackpressureBehaviorAzureEventhub$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionAzureEventhub$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorAzureEventhub$outboundSchema.default(
    "block",
  ),
  pqMode: ModeAzureEventhub$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsAzureEventhub$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureEventhub$ {
  /** @deprecated use `OutputAzureEventhub$inboundSchema` instead. */
  export const inboundSchema = OutputAzureEventhub$inboundSchema;
  /** @deprecated use `OutputAzureEventhub$outboundSchema` instead. */
  export const outboundSchema = OutputAzureEventhub$outboundSchema;
  /** @deprecated use `OutputAzureEventhub$Outbound` instead. */
  export type Outbound = OutputAzureEventhub$Outbound;
}

export function outputAzureEventhubToJSON(
  outputAzureEventhub: OutputAzureEventhub,
): string {
  return JSON.stringify(
    OutputAzureEventhub$outboundSchema.parse(outputAzureEventhub),
  );
}

export function outputAzureEventhubFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureEventhub' from JSON`,
  );
}

/** @internal */
export const TypeHoneycomb$inboundSchema: z.ZodNativeEnum<
  typeof TypeHoneycomb
> = z.nativeEnum(TypeHoneycomb);

/** @internal */
export const TypeHoneycomb$outboundSchema: z.ZodNativeEnum<
  typeof TypeHoneycomb
> = TypeHoneycomb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeHoneycomb$ {
  /** @deprecated use `TypeHoneycomb$inboundSchema` instead. */
  export const inboundSchema = TypeHoneycomb$inboundSchema;
  /** @deprecated use `TypeHoneycomb$outboundSchema` instead. */
  export const outboundSchema = TypeHoneycomb$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderHoneycomb$inboundSchema: z.ZodType<
  ExtraHttpHeaderHoneycomb,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderHoneycomb$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderHoneycomb$outboundSchema: z.ZodType<
  ExtraHttpHeaderHoneycomb$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderHoneycomb
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderHoneycomb$ {
  /** @deprecated use `ExtraHttpHeaderHoneycomb$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderHoneycomb$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderHoneycomb$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderHoneycomb$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderHoneycomb$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderHoneycomb$Outbound;
}

export function extraHttpHeaderHoneycombToJSON(
  extraHttpHeaderHoneycomb: ExtraHttpHeaderHoneycomb,
): string {
  return JSON.stringify(
    ExtraHttpHeaderHoneycomb$outboundSchema.parse(extraHttpHeaderHoneycomb),
  );
}

export function extraHttpHeaderHoneycombFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderHoneycomb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderHoneycomb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderHoneycomb' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeHoneycomb$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeHoneycomb
> = z.nativeEnum(FailedRequestLoggingModeHoneycomb);

/** @internal */
export const FailedRequestLoggingModeHoneycomb$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeHoneycomb
> = FailedRequestLoggingModeHoneycomb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeHoneycomb$ {
  /** @deprecated use `FailedRequestLoggingModeHoneycomb$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeHoneycomb$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeHoneycomb$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeHoneycomb$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingHoneycomb$inboundSchema: z.ZodType<
  ResponseRetrySettingHoneycomb,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingHoneycomb$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingHoneycomb$outboundSchema: z.ZodType<
  ResponseRetrySettingHoneycomb$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingHoneycomb
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingHoneycomb$ {
  /** @deprecated use `ResponseRetrySettingHoneycomb$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingHoneycomb$inboundSchema;
  /** @deprecated use `ResponseRetrySettingHoneycomb$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingHoneycomb$outboundSchema;
  /** @deprecated use `ResponseRetrySettingHoneycomb$Outbound` instead. */
  export type Outbound = ResponseRetrySettingHoneycomb$Outbound;
}

export function responseRetrySettingHoneycombToJSON(
  responseRetrySettingHoneycomb: ResponseRetrySettingHoneycomb,
): string {
  return JSON.stringify(
    ResponseRetrySettingHoneycomb$outboundSchema.parse(
      responseRetrySettingHoneycomb,
    ),
  );
}

export function responseRetrySettingHoneycombFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingHoneycomb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingHoneycomb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingHoneycomb' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsHoneycomb$inboundSchema: z.ZodType<
  TimeoutRetrySettingsHoneycomb,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsHoneycomb$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsHoneycomb$outboundSchema: z.ZodType<
  TimeoutRetrySettingsHoneycomb$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsHoneycomb
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsHoneycomb$ {
  /** @deprecated use `TimeoutRetrySettingsHoneycomb$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsHoneycomb$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsHoneycomb$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsHoneycomb$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsHoneycomb$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsHoneycomb$Outbound;
}

export function timeoutRetrySettingsHoneycombToJSON(
  timeoutRetrySettingsHoneycomb: TimeoutRetrySettingsHoneycomb,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsHoneycomb$outboundSchema.parse(
      timeoutRetrySettingsHoneycomb,
    ),
  );
}

export function timeoutRetrySettingsHoneycombFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsHoneycomb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsHoneycomb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsHoneycomb' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorHoneycomb$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorHoneycomb
> = z.nativeEnum(BackpressureBehaviorHoneycomb);

/** @internal */
export const BackpressureBehaviorHoneycomb$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorHoneycomb
> = BackpressureBehaviorHoneycomb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorHoneycomb$ {
  /** @deprecated use `BackpressureBehaviorHoneycomb$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorHoneycomb$inboundSchema;
  /** @deprecated use `BackpressureBehaviorHoneycomb$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorHoneycomb$outboundSchema;
}

/** @internal */
export const AuthenticationMethodHoneycomb$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodHoneycomb
> = z.nativeEnum(AuthenticationMethodHoneycomb);

/** @internal */
export const AuthenticationMethodHoneycomb$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodHoneycomb
> = AuthenticationMethodHoneycomb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodHoneycomb$ {
  /** @deprecated use `AuthenticationMethodHoneycomb$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodHoneycomb$inboundSchema;
  /** @deprecated use `AuthenticationMethodHoneycomb$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodHoneycomb$outboundSchema;
}

/** @internal */
export const CompressionHoneycomb$inboundSchema: z.ZodNativeEnum<
  typeof CompressionHoneycomb
> = z.nativeEnum(CompressionHoneycomb);

/** @internal */
export const CompressionHoneycomb$outboundSchema: z.ZodNativeEnum<
  typeof CompressionHoneycomb
> = CompressionHoneycomb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionHoneycomb$ {
  /** @deprecated use `CompressionHoneycomb$inboundSchema` instead. */
  export const inboundSchema = CompressionHoneycomb$inboundSchema;
  /** @deprecated use `CompressionHoneycomb$outboundSchema` instead. */
  export const outboundSchema = CompressionHoneycomb$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorHoneycomb$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorHoneycomb
> = z.nativeEnum(QueueFullBehaviorHoneycomb);

/** @internal */
export const QueueFullBehaviorHoneycomb$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorHoneycomb
> = QueueFullBehaviorHoneycomb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorHoneycomb$ {
  /** @deprecated use `QueueFullBehaviorHoneycomb$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorHoneycomb$inboundSchema;
  /** @deprecated use `QueueFullBehaviorHoneycomb$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorHoneycomb$outboundSchema;
}

/** @internal */
export const ModeHoneycomb$inboundSchema: z.ZodNativeEnum<
  typeof ModeHoneycomb
> = z.nativeEnum(ModeHoneycomb);

/** @internal */
export const ModeHoneycomb$outboundSchema: z.ZodNativeEnum<
  typeof ModeHoneycomb
> = ModeHoneycomb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeHoneycomb$ {
  /** @deprecated use `ModeHoneycomb$inboundSchema` instead. */
  export const inboundSchema = ModeHoneycomb$inboundSchema;
  /** @deprecated use `ModeHoneycomb$outboundSchema` instead. */
  export const outboundSchema = ModeHoneycomb$outboundSchema;
}

/** @internal */
export const PqControlsHoneycomb$inboundSchema: z.ZodType<
  PqControlsHoneycomb,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsHoneycomb$Outbound = {};

/** @internal */
export const PqControlsHoneycomb$outboundSchema: z.ZodType<
  PqControlsHoneycomb$Outbound,
  z.ZodTypeDef,
  PqControlsHoneycomb
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsHoneycomb$ {
  /** @deprecated use `PqControlsHoneycomb$inboundSchema` instead. */
  export const inboundSchema = PqControlsHoneycomb$inboundSchema;
  /** @deprecated use `PqControlsHoneycomb$outboundSchema` instead. */
  export const outboundSchema = PqControlsHoneycomb$outboundSchema;
  /** @deprecated use `PqControlsHoneycomb$Outbound` instead. */
  export type Outbound = PqControlsHoneycomb$Outbound;
}

export function pqControlsHoneycombToJSON(
  pqControlsHoneycomb: PqControlsHoneycomb,
): string {
  return JSON.stringify(
    PqControlsHoneycomb$outboundSchema.parse(pqControlsHoneycomb),
  );
}

export function pqControlsHoneycombFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsHoneycomb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsHoneycomb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsHoneycomb' from JSON`,
  );
}

/** @internal */
export const OutputHoneycomb$inboundSchema: z.ZodType<
  OutputHoneycomb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeHoneycomb$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dataset: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderHoneycomb$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeHoneycomb$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingHoneycomb$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsHoneycomb$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorHoneycomb$inboundSchema.default("block"),
  authType: AuthenticationMethodHoneycomb$inboundSchema.default("manual"),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionHoneycomb$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorHoneycomb$inboundSchema.default("block"),
  pqMode: ModeHoneycomb$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsHoneycomb$inboundSchema).optional(),
  team: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputHoneycomb$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  dataset: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderHoneycomb$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingHoneycomb$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsHoneycomb$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsHoneycomb$Outbound | undefined;
  team?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputHoneycomb$outboundSchema: z.ZodType<
  OutputHoneycomb$Outbound,
  z.ZodTypeDef,
  OutputHoneycomb
> = z.object({
  id: z.string(),
  type: TypeHoneycomb$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dataset: z.string(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderHoneycomb$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeHoneycomb$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingHoneycomb$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsHoneycomb$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorHoneycomb$outboundSchema.default("block"),
  authType: AuthenticationMethodHoneycomb$outboundSchema.default("manual"),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionHoneycomb$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorHoneycomb$outboundSchema.default("block"),
  pqMode: ModeHoneycomb$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsHoneycomb$outboundSchema).optional(),
  team: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputHoneycomb$ {
  /** @deprecated use `OutputHoneycomb$inboundSchema` instead. */
  export const inboundSchema = OutputHoneycomb$inboundSchema;
  /** @deprecated use `OutputHoneycomb$outboundSchema` instead. */
  export const outboundSchema = OutputHoneycomb$outboundSchema;
  /** @deprecated use `OutputHoneycomb$Outbound` instead. */
  export type Outbound = OutputHoneycomb$Outbound;
}

export function outputHoneycombToJSON(
  outputHoneycomb: OutputHoneycomb,
): string {
  return JSON.stringify(OutputHoneycomb$outboundSchema.parse(outputHoneycomb));
}

export function outputHoneycombFromJSON(
  jsonString: string,
): SafeParseResult<OutputHoneycomb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputHoneycomb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputHoneycomb' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeKinesis$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeKinesis
> = z.nativeEnum(CreateOutputTypeKinesis);

/** @internal */
export const CreateOutputTypeKinesis$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeKinesis
> = CreateOutputTypeKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeKinesis$ {
  /** @deprecated use `CreateOutputTypeKinesis$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeKinesis$inboundSchema;
  /** @deprecated use `CreateOutputTypeKinesis$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeKinesis$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationMethodKinesis$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodKinesis> = z
    .nativeEnum(CreateOutputAuthenticationMethodKinesis);

/** @internal */
export const CreateOutputAuthenticationMethodKinesis$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodKinesis> =
    CreateOutputAuthenticationMethodKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationMethodKinesis$ {
  /** @deprecated use `CreateOutputAuthenticationMethodKinesis$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputAuthenticationMethodKinesis$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationMethodKinesis$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationMethodKinesis$outboundSchema;
}

/** @internal */
export const CreateOutputSignatureVersionKinesis$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSignatureVersionKinesis
> = z.nativeEnum(CreateOutputSignatureVersionKinesis);

/** @internal */
export const CreateOutputSignatureVersionKinesis$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputSignatureVersionKinesis> =
    CreateOutputSignatureVersionKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputSignatureVersionKinesis$ {
  /** @deprecated use `CreateOutputSignatureVersionKinesis$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputSignatureVersionKinesis$inboundSchema;
  /** @deprecated use `CreateOutputSignatureVersionKinesis$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputSignatureVersionKinesis$outboundSchema;
}

/** @internal */
export const CreateOutputCompressionKinesis$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionKinesis
> = z.nativeEnum(CreateOutputCompressionKinesis);

/** @internal */
export const CreateOutputCompressionKinesis$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionKinesis
> = CreateOutputCompressionKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressionKinesis$ {
  /** @deprecated use `CreateOutputCompressionKinesis$inboundSchema` instead. */
  export const inboundSchema = CreateOutputCompressionKinesis$inboundSchema;
  /** @deprecated use `CreateOutputCompressionKinesis$outboundSchema` instead. */
  export const outboundSchema = CreateOutputCompressionKinesis$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorKinesis$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorKinesis
> = z.nativeEnum(BackpressureBehaviorKinesis);

/** @internal */
export const BackpressureBehaviorKinesis$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorKinesis
> = BackpressureBehaviorKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorKinesis$ {
  /** @deprecated use `BackpressureBehaviorKinesis$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorKinesis$inboundSchema;
  /** @deprecated use `BackpressureBehaviorKinesis$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorKinesis$outboundSchema;
}

/** @internal */
export const PqCompressCompressionKinesis$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionKinesis
> = z.nativeEnum(PqCompressCompressionKinesis);

/** @internal */
export const PqCompressCompressionKinesis$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionKinesis
> = PqCompressCompressionKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionKinesis$ {
  /** @deprecated use `PqCompressCompressionKinesis$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionKinesis$inboundSchema;
  /** @deprecated use `PqCompressCompressionKinesis$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionKinesis$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorKinesis$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorKinesis
> = z.nativeEnum(QueueFullBehaviorKinesis);

/** @internal */
export const QueueFullBehaviorKinesis$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorKinesis
> = QueueFullBehaviorKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorKinesis$ {
  /** @deprecated use `QueueFullBehaviorKinesis$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorKinesis$inboundSchema;
  /** @deprecated use `QueueFullBehaviorKinesis$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorKinesis$outboundSchema;
}

/** @internal */
export const CreateOutputModeKinesis$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeKinesis
> = z.nativeEnum(CreateOutputModeKinesis);

/** @internal */
export const CreateOutputModeKinesis$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeKinesis
> = CreateOutputModeKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeKinesis$ {
  /** @deprecated use `CreateOutputModeKinesis$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeKinesis$inboundSchema;
  /** @deprecated use `CreateOutputModeKinesis$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeKinesis$outboundSchema;
}

/** @internal */
export const PqControlsKinesis$inboundSchema: z.ZodType<
  PqControlsKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsKinesis$Outbound = {};

/** @internal */
export const PqControlsKinesis$outboundSchema: z.ZodType<
  PqControlsKinesis$Outbound,
  z.ZodTypeDef,
  PqControlsKinesis
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsKinesis$ {
  /** @deprecated use `PqControlsKinesis$inboundSchema` instead. */
  export const inboundSchema = PqControlsKinesis$inboundSchema;
  /** @deprecated use `PqControlsKinesis$outboundSchema` instead. */
  export const outboundSchema = PqControlsKinesis$outboundSchema;
  /** @deprecated use `PqControlsKinesis$Outbound` instead. */
  export type Outbound = PqControlsKinesis$Outbound;
}

export function pqControlsKinesisToJSON(
  pqControlsKinesis: PqControlsKinesis,
): string {
  return JSON.stringify(
    PqControlsKinesis$outboundSchema.parse(pqControlsKinesis),
  );
}

export function pqControlsKinesisFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsKinesis' from JSON`,
  );
}

/** @internal */
export const OutputKinesis$inboundSchema: z.ZodType<
  OutputKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeKinesis$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  streamName: z.string(),
  awsAuthenticationMethod: CreateOutputAuthenticationMethodKinesis$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionKinesis$inboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  concurrency: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  compression: CreateOutputCompressionKinesis$inboundSchema.default("gzip"),
  useListShards: z.boolean().default(false),
  asNdjson: z.boolean().default(true),
  onBackpressure: BackpressureBehaviorKinesis$inboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionKinesis$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorKinesis$inboundSchema.default("block"),
  pqMode: CreateOutputModeKinesis$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsKinesis$inboundSchema).optional(),
});

/** @internal */
export type OutputKinesis$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  streamName: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  concurrency: number;
  maxRecordSizeKB: number;
  flushPeriodSec: number;
  compression: string;
  useListShards: boolean;
  asNdjson: boolean;
  onBackpressure: string;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsKinesis$Outbound | undefined;
};

/** @internal */
export const OutputKinesis$outboundSchema: z.ZodType<
  OutputKinesis$Outbound,
  z.ZodTypeDef,
  OutputKinesis
> = z.object({
  id: z.string(),
  type: CreateOutputTypeKinesis$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  streamName: z.string(),
  awsAuthenticationMethod:
    CreateOutputAuthenticationMethodKinesis$outboundSchema.default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionKinesis$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  concurrency: z.number().default(5),
  maxRecordSizeKB: z.number().default(1024),
  flushPeriodSec: z.number().default(1),
  compression: CreateOutputCompressionKinesis$outboundSchema.default("gzip"),
  useListShards: z.boolean().default(false),
  asNdjson: z.boolean().default(true),
  onBackpressure: BackpressureBehaviorKinesis$outboundSchema.default("block"),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionKinesis$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorKinesis$outboundSchema.default("block"),
  pqMode: CreateOutputModeKinesis$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsKinesis$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputKinesis$ {
  /** @deprecated use `OutputKinesis$inboundSchema` instead. */
  export const inboundSchema = OutputKinesis$inboundSchema;
  /** @deprecated use `OutputKinesis$outboundSchema` instead. */
  export const outboundSchema = OutputKinesis$outboundSchema;
  /** @deprecated use `OutputKinesis$Outbound` instead. */
  export type Outbound = OutputKinesis$Outbound;
}

export function outputKinesisToJSON(outputKinesis: OutputKinesis): string {
  return JSON.stringify(OutputKinesis$outboundSchema.parse(outputKinesis));
}

export function outputKinesisFromJSON(
  jsonString: string,
): SafeParseResult<OutputKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputKinesis' from JSON`,
  );
}

/** @internal */
export const TypeAzureLogs$inboundSchema: z.ZodNativeEnum<
  typeof TypeAzureLogs
> = z.nativeEnum(TypeAzureLogs);

/** @internal */
export const TypeAzureLogs$outboundSchema: z.ZodNativeEnum<
  typeof TypeAzureLogs
> = TypeAzureLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeAzureLogs$ {
  /** @deprecated use `TypeAzureLogs$inboundSchema` instead. */
  export const inboundSchema = TypeAzureLogs$inboundSchema;
  /** @deprecated use `TypeAzureLogs$outboundSchema` instead. */
  export const outboundSchema = TypeAzureLogs$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderAzureLogs$inboundSchema: z.ZodType<
  ExtraHttpHeaderAzureLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderAzureLogs$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderAzureLogs$outboundSchema: z.ZodType<
  ExtraHttpHeaderAzureLogs$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderAzureLogs
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderAzureLogs$ {
  /** @deprecated use `ExtraHttpHeaderAzureLogs$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderAzureLogs$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderAzureLogs$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderAzureLogs$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderAzureLogs$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderAzureLogs$Outbound;
}

export function extraHttpHeaderAzureLogsToJSON(
  extraHttpHeaderAzureLogs: ExtraHttpHeaderAzureLogs,
): string {
  return JSON.stringify(
    ExtraHttpHeaderAzureLogs$outboundSchema.parse(extraHttpHeaderAzureLogs),
  );
}

export function extraHttpHeaderAzureLogsFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderAzureLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderAzureLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderAzureLogs' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeAzureLogs$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeAzureLogs
> = z.nativeEnum(FailedRequestLoggingModeAzureLogs);

/** @internal */
export const FailedRequestLoggingModeAzureLogs$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeAzureLogs
> = FailedRequestLoggingModeAzureLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeAzureLogs$ {
  /** @deprecated use `FailedRequestLoggingModeAzureLogs$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeAzureLogs$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeAzureLogs$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeAzureLogs$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingAzureLogs$inboundSchema: z.ZodType<
  ResponseRetrySettingAzureLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingAzureLogs$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingAzureLogs$outboundSchema: z.ZodType<
  ResponseRetrySettingAzureLogs$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingAzureLogs
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingAzureLogs$ {
  /** @deprecated use `ResponseRetrySettingAzureLogs$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingAzureLogs$inboundSchema;
  /** @deprecated use `ResponseRetrySettingAzureLogs$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingAzureLogs$outboundSchema;
  /** @deprecated use `ResponseRetrySettingAzureLogs$Outbound` instead. */
  export type Outbound = ResponseRetrySettingAzureLogs$Outbound;
}

export function responseRetrySettingAzureLogsToJSON(
  responseRetrySettingAzureLogs: ResponseRetrySettingAzureLogs,
): string {
  return JSON.stringify(
    ResponseRetrySettingAzureLogs$outboundSchema.parse(
      responseRetrySettingAzureLogs,
    ),
  );
}

export function responseRetrySettingAzureLogsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingAzureLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingAzureLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingAzureLogs' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsAzureLogs$inboundSchema: z.ZodType<
  TimeoutRetrySettingsAzureLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsAzureLogs$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsAzureLogs$outboundSchema: z.ZodType<
  TimeoutRetrySettingsAzureLogs$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsAzureLogs
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsAzureLogs$ {
  /** @deprecated use `TimeoutRetrySettingsAzureLogs$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsAzureLogs$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsAzureLogs$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsAzureLogs$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsAzureLogs$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsAzureLogs$Outbound;
}

export function timeoutRetrySettingsAzureLogsToJSON(
  timeoutRetrySettingsAzureLogs: TimeoutRetrySettingsAzureLogs,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsAzureLogs$outboundSchema.parse(
      timeoutRetrySettingsAzureLogs,
    ),
  );
}

export function timeoutRetrySettingsAzureLogsFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsAzureLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsAzureLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsAzureLogs' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorAzureLogs$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorAzureLogs
> = z.nativeEnum(BackpressureBehaviorAzureLogs);

/** @internal */
export const BackpressureBehaviorAzureLogs$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorAzureLogs
> = BackpressureBehaviorAzureLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorAzureLogs$ {
  /** @deprecated use `BackpressureBehaviorAzureLogs$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorAzureLogs$inboundSchema;
  /** @deprecated use `BackpressureBehaviorAzureLogs$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorAzureLogs$outboundSchema;
}

/** @internal */
export const AuthenticationMethodAzureLogs$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodAzureLogs
> = z.nativeEnum(AuthenticationMethodAzureLogs);

/** @internal */
export const AuthenticationMethodAzureLogs$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodAzureLogs
> = AuthenticationMethodAzureLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodAzureLogs$ {
  /** @deprecated use `AuthenticationMethodAzureLogs$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodAzureLogs$inboundSchema;
  /** @deprecated use `AuthenticationMethodAzureLogs$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodAzureLogs$outboundSchema;
}

/** @internal */
export const CompressionAzureLogs$inboundSchema: z.ZodNativeEnum<
  typeof CompressionAzureLogs
> = z.nativeEnum(CompressionAzureLogs);

/** @internal */
export const CompressionAzureLogs$outboundSchema: z.ZodNativeEnum<
  typeof CompressionAzureLogs
> = CompressionAzureLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionAzureLogs$ {
  /** @deprecated use `CompressionAzureLogs$inboundSchema` instead. */
  export const inboundSchema = CompressionAzureLogs$inboundSchema;
  /** @deprecated use `CompressionAzureLogs$outboundSchema` instead. */
  export const outboundSchema = CompressionAzureLogs$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorAzureLogs$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorAzureLogs
> = z.nativeEnum(QueueFullBehaviorAzureLogs);

/** @internal */
export const QueueFullBehaviorAzureLogs$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorAzureLogs
> = QueueFullBehaviorAzureLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorAzureLogs$ {
  /** @deprecated use `QueueFullBehaviorAzureLogs$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorAzureLogs$inboundSchema;
  /** @deprecated use `QueueFullBehaviorAzureLogs$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorAzureLogs$outboundSchema;
}

/** @internal */
export const ModeAzureLogs$inboundSchema: z.ZodNativeEnum<
  typeof ModeAzureLogs
> = z.nativeEnum(ModeAzureLogs);

/** @internal */
export const ModeAzureLogs$outboundSchema: z.ZodNativeEnum<
  typeof ModeAzureLogs
> = ModeAzureLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeAzureLogs$ {
  /** @deprecated use `ModeAzureLogs$inboundSchema` instead. */
  export const inboundSchema = ModeAzureLogs$inboundSchema;
  /** @deprecated use `ModeAzureLogs$outboundSchema` instead. */
  export const outboundSchema = ModeAzureLogs$outboundSchema;
}

/** @internal */
export const PqControlsAzureLogs$inboundSchema: z.ZodType<
  PqControlsAzureLogs,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsAzureLogs$Outbound = {};

/** @internal */
export const PqControlsAzureLogs$outboundSchema: z.ZodType<
  PqControlsAzureLogs$Outbound,
  z.ZodTypeDef,
  PqControlsAzureLogs
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsAzureLogs$ {
  /** @deprecated use `PqControlsAzureLogs$inboundSchema` instead. */
  export const inboundSchema = PqControlsAzureLogs$inboundSchema;
  /** @deprecated use `PqControlsAzureLogs$outboundSchema` instead. */
  export const outboundSchema = PqControlsAzureLogs$outboundSchema;
  /** @deprecated use `PqControlsAzureLogs$Outbound` instead. */
  export type Outbound = PqControlsAzureLogs$Outbound;
}

export function pqControlsAzureLogsToJSON(
  pqControlsAzureLogs: PqControlsAzureLogs,
): string {
  return JSON.stringify(
    PqControlsAzureLogs$outboundSchema.parse(pqControlsAzureLogs),
  );
}

export function pqControlsAzureLogsFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsAzureLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsAzureLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsAzureLogs' from JSON`,
  );
}

/** @internal */
export const OutputAzureLogs$inboundSchema: z.ZodType<
  OutputAzureLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeAzureLogs$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logType: z.string().default("Cribl"),
  resourceId: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderAzureLogs$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeAzureLogs$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  apiUrl: z.string().default(".ods.opinsights.azure.com"),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingAzureLogs$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsAzureLogs$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorAzureLogs$inboundSchema.default("block"),
  authType: AuthenticationMethodAzureLogs$inboundSchema.default("manual"),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionAzureLogs$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorAzureLogs$inboundSchema.default("block"),
  pqMode: ModeAzureLogs$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsAzureLogs$inboundSchema).optional(),
  workspaceId: z.string().optional(),
  workspaceKey: z.string().optional(),
  keypairSecret: z.string().optional(),
});

/** @internal */
export type OutputAzureLogs$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  logType: string;
  resourceId?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress?: boolean | undefined;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderAzureLogs$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  apiUrl: string;
  responseRetrySettings?:
    | Array<ResponseRetrySettingAzureLogs$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsAzureLogs$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsAzureLogs$Outbound | undefined;
  workspaceId?: string | undefined;
  workspaceKey?: string | undefined;
  keypairSecret?: string | undefined;
};

/** @internal */
export const OutputAzureLogs$outboundSchema: z.ZodType<
  OutputAzureLogs$Outbound,
  z.ZodTypeDef,
  OutputAzureLogs
> = z.object({
  id: z.string(),
  type: TypeAzureLogs$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logType: z.string().default("Cribl"),
  resourceId: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1024),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderAzureLogs$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeAzureLogs$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  apiUrl: z.string().default(".ods.opinsights.azure.com"),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingAzureLogs$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsAzureLogs$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorAzureLogs$outboundSchema.default("block"),
  authType: AuthenticationMethodAzureLogs$outboundSchema.default("manual"),
  description: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionAzureLogs$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorAzureLogs$outboundSchema.default("block"),
  pqMode: ModeAzureLogs$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsAzureLogs$outboundSchema).optional(),
  workspaceId: z.string().optional(),
  workspaceKey: z.string().optional(),
  keypairSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureLogs$ {
  /** @deprecated use `OutputAzureLogs$inboundSchema` instead. */
  export const inboundSchema = OutputAzureLogs$inboundSchema;
  /** @deprecated use `OutputAzureLogs$outboundSchema` instead. */
  export const outboundSchema = OutputAzureLogs$outboundSchema;
  /** @deprecated use `OutputAzureLogs$Outbound` instead. */
  export type Outbound = OutputAzureLogs$Outbound;
}

export function outputAzureLogsToJSON(
  outputAzureLogs: OutputAzureLogs,
): string {
  return JSON.stringify(OutputAzureLogs$outboundSchema.parse(outputAzureLogs));
}

export function outputAzureLogsFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureLogs' from JSON`,
  );
}

/** @internal */
export const TypeAzureDataExplorer$inboundSchema: z.ZodNativeEnum<
  typeof TypeAzureDataExplorer
> = z.nativeEnum(TypeAzureDataExplorer);

/** @internal */
export const TypeAzureDataExplorer$outboundSchema: z.ZodNativeEnum<
  typeof TypeAzureDataExplorer
> = TypeAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeAzureDataExplorer$ {
  /** @deprecated use `TypeAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = TypeAzureDataExplorer$inboundSchema;
  /** @deprecated use `TypeAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema = TypeAzureDataExplorer$outboundSchema;
}

/** @internal */
export const IngestionMode$inboundSchema: z.ZodNativeEnum<
  typeof IngestionMode
> = z.nativeEnum(IngestionMode);

/** @internal */
export const IngestionMode$outboundSchema: z.ZodNativeEnum<
  typeof IngestionMode
> = IngestionMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngestionMode$ {
  /** @deprecated use `IngestionMode$inboundSchema` instead. */
  export const inboundSchema = IngestionMode$inboundSchema;
  /** @deprecated use `IngestionMode$outboundSchema` instead. */
  export const outboundSchema = IngestionMode$outboundSchema;
}

/** @internal */
export const MicrosoftEntraIDAuthenticationEndpoint$inboundSchema:
  z.ZodNativeEnum<typeof MicrosoftEntraIDAuthenticationEndpoint> = z.nativeEnum(
    MicrosoftEntraIDAuthenticationEndpoint,
  );

/** @internal */
export const MicrosoftEntraIDAuthenticationEndpoint$outboundSchema:
  z.ZodNativeEnum<typeof MicrosoftEntraIDAuthenticationEndpoint> =
    MicrosoftEntraIDAuthenticationEndpoint$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MicrosoftEntraIDAuthenticationEndpoint$ {
  /** @deprecated use `MicrosoftEntraIDAuthenticationEndpoint$inboundSchema` instead. */
  export const inboundSchema =
    MicrosoftEntraIDAuthenticationEndpoint$inboundSchema;
  /** @deprecated use `MicrosoftEntraIDAuthenticationEndpoint$outboundSchema` instead. */
  export const outboundSchema =
    MicrosoftEntraIDAuthenticationEndpoint$outboundSchema;
}

/** @internal */
export const OauthTypeAuthenticationMethod$inboundSchema: z.ZodNativeEnum<
  typeof OauthTypeAuthenticationMethod
> = z.nativeEnum(OauthTypeAuthenticationMethod);

/** @internal */
export const OauthTypeAuthenticationMethod$outboundSchema: z.ZodNativeEnum<
  typeof OauthTypeAuthenticationMethod
> = OauthTypeAuthenticationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthTypeAuthenticationMethod$ {
  /** @deprecated use `OauthTypeAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = OauthTypeAuthenticationMethod$inboundSchema;
  /** @deprecated use `OauthTypeAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = OauthTypeAuthenticationMethod$outboundSchema;
}

/** @internal */
export const CertificateAzureDataExplorer$inboundSchema: z.ZodType<
  CertificateAzureDataExplorer,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string().optional(),
});

/** @internal */
export type CertificateAzureDataExplorer$Outbound = {
  certificateName?: string | undefined;
};

/** @internal */
export const CertificateAzureDataExplorer$outboundSchema: z.ZodType<
  CertificateAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  CertificateAzureDataExplorer
> = z.object({
  certificateName: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CertificateAzureDataExplorer$ {
  /** @deprecated use `CertificateAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = CertificateAzureDataExplorer$inboundSchema;
  /** @deprecated use `CertificateAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema = CertificateAzureDataExplorer$outboundSchema;
  /** @deprecated use `CertificateAzureDataExplorer$Outbound` instead. */
  export type Outbound = CertificateAzureDataExplorer$Outbound;
}

export function certificateAzureDataExplorerToJSON(
  certificateAzureDataExplorer: CertificateAzureDataExplorer,
): string {
  return JSON.stringify(
    CertificateAzureDataExplorer$outboundSchema.parse(
      certificateAzureDataExplorer,
    ),
  );
}

export function certificateAzureDataExplorerFromJSON(
  jsonString: string,
): SafeParseResult<CertificateAzureDataExplorer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CertificateAzureDataExplorer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CertificateAzureDataExplorer' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorAzureDataExplorer$inboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorAzureDataExplorer> = z.nativeEnum(
    BackpressureBehaviorAzureDataExplorer,
  );

/** @internal */
export const BackpressureBehaviorAzureDataExplorer$outboundSchema:
  z.ZodNativeEnum<typeof BackpressureBehaviorAzureDataExplorer> =
    BackpressureBehaviorAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorAzureDataExplorer$ {
  /** @deprecated use `BackpressureBehaviorAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema =
    BackpressureBehaviorAzureDataExplorer$inboundSchema;
  /** @deprecated use `BackpressureBehaviorAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema =
    BackpressureBehaviorAzureDataExplorer$outboundSchema;
}

/** @internal */
export const DataFormatAzureDataExplorer$inboundSchema: z.ZodNativeEnum<
  typeof DataFormatAzureDataExplorer
> = z.nativeEnum(DataFormatAzureDataExplorer);

/** @internal */
export const DataFormatAzureDataExplorer$outboundSchema: z.ZodNativeEnum<
  typeof DataFormatAzureDataExplorer
> = DataFormatAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFormatAzureDataExplorer$ {
  /** @deprecated use `DataFormatAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = DataFormatAzureDataExplorer$inboundSchema;
  /** @deprecated use `DataFormatAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema = DataFormatAzureDataExplorer$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionAzureDataExplorer$inboundSchema:
  z.ZodNativeEnum<typeof DiskSpaceProtectionAzureDataExplorer> = z.nativeEnum(
    DiskSpaceProtectionAzureDataExplorer,
  );

/** @internal */
export const DiskSpaceProtectionAzureDataExplorer$outboundSchema:
  z.ZodNativeEnum<typeof DiskSpaceProtectionAzureDataExplorer> =
    DiskSpaceProtectionAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionAzureDataExplorer$ {
  /** @deprecated use `DiskSpaceProtectionAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema =
    DiskSpaceProtectionAzureDataExplorer$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema =
    DiskSpaceProtectionAzureDataExplorer$outboundSchema;
}

/** @internal */
export const PrefixOptional$inboundSchema: z.ZodNativeEnum<
  typeof PrefixOptional
> = z.nativeEnum(PrefixOptional);

/** @internal */
export const PrefixOptional$outboundSchema: z.ZodNativeEnum<
  typeof PrefixOptional
> = PrefixOptional$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrefixOptional$ {
  /** @deprecated use `PrefixOptional$inboundSchema` instead. */
  export const inboundSchema = PrefixOptional$inboundSchema;
  /** @deprecated use `PrefixOptional$outboundSchema` instead. */
  export const outboundSchema = PrefixOptional$outboundSchema;
}

/** @internal */
export const ExtentTag$inboundSchema: z.ZodType<
  ExtentTag,
  z.ZodTypeDef,
  unknown
> = z.object({
  prefix: PrefixOptional$inboundSchema.optional(),
  value: z.string(),
});

/** @internal */
export type ExtentTag$Outbound = {
  prefix?: string | undefined;
  value: string;
};

/** @internal */
export const ExtentTag$outboundSchema: z.ZodType<
  ExtentTag$Outbound,
  z.ZodTypeDef,
  ExtentTag
> = z.object({
  prefix: PrefixOptional$outboundSchema.optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtentTag$ {
  /** @deprecated use `ExtentTag$inboundSchema` instead. */
  export const inboundSchema = ExtentTag$inboundSchema;
  /** @deprecated use `ExtentTag$outboundSchema` instead. */
  export const outboundSchema = ExtentTag$outboundSchema;
  /** @deprecated use `ExtentTag$Outbound` instead. */
  export type Outbound = ExtentTag$Outbound;
}

export function extentTagToJSON(extentTag: ExtentTag): string {
  return JSON.stringify(ExtentTag$outboundSchema.parse(extentTag));
}

export function extentTagFromJSON(
  jsonString: string,
): SafeParseResult<ExtentTag, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtentTag$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtentTag' from JSON`,
  );
}

/** @internal */
export const IngestIfNotExist$inboundSchema: z.ZodType<
  IngestIfNotExist,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
});

/** @internal */
export type IngestIfNotExist$Outbound = {
  value: string;
};

/** @internal */
export const IngestIfNotExist$outboundSchema: z.ZodType<
  IngestIfNotExist$Outbound,
  z.ZodTypeDef,
  IngestIfNotExist
> = z.object({
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngestIfNotExist$ {
  /** @deprecated use `IngestIfNotExist$inboundSchema` instead. */
  export const inboundSchema = IngestIfNotExist$inboundSchema;
  /** @deprecated use `IngestIfNotExist$outboundSchema` instead. */
  export const outboundSchema = IngestIfNotExist$outboundSchema;
  /** @deprecated use `IngestIfNotExist$Outbound` instead. */
  export type Outbound = IngestIfNotExist$Outbound;
}

export function ingestIfNotExistToJSON(
  ingestIfNotExist: IngestIfNotExist,
): string {
  return JSON.stringify(
    IngestIfNotExist$outboundSchema.parse(ingestIfNotExist),
  );
}

export function ingestIfNotExistFromJSON(
  jsonString: string,
): SafeParseResult<IngestIfNotExist, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IngestIfNotExist$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IngestIfNotExist' from JSON`,
  );
}

/** @internal */
export const ReportLevel$inboundSchema: z.ZodNativeEnum<typeof ReportLevel> = z
  .nativeEnum(ReportLevel);

/** @internal */
export const ReportLevel$outboundSchema: z.ZodNativeEnum<typeof ReportLevel> =
  ReportLevel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReportLevel$ {
  /** @deprecated use `ReportLevel$inboundSchema` instead. */
  export const inboundSchema = ReportLevel$inboundSchema;
  /** @deprecated use `ReportLevel$outboundSchema` instead. */
  export const outboundSchema = ReportLevel$outboundSchema;
}

/** @internal */
export const ReportMethod$inboundSchema: z.ZodNativeEnum<typeof ReportMethod> =
  z.nativeEnum(ReportMethod);

/** @internal */
export const ReportMethod$outboundSchema: z.ZodNativeEnum<typeof ReportMethod> =
  ReportMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReportMethod$ {
  /** @deprecated use `ReportMethod$inboundSchema` instead. */
  export const inboundSchema = ReportMethod$inboundSchema;
  /** @deprecated use `ReportMethod$outboundSchema` instead. */
  export const outboundSchema = ReportMethod$outboundSchema;
}

/** @internal */
export const AdditionalProperty$inboundSchema: z.ZodType<
  AdditionalProperty,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  value: z.string(),
});

/** @internal */
export type AdditionalProperty$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const AdditionalProperty$outboundSchema: z.ZodType<
  AdditionalProperty$Outbound,
  z.ZodTypeDef,
  AdditionalProperty
> = z.object({
  key: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdditionalProperty$ {
  /** @deprecated use `AdditionalProperty$inboundSchema` instead. */
  export const inboundSchema = AdditionalProperty$inboundSchema;
  /** @deprecated use `AdditionalProperty$outboundSchema` instead. */
  export const outboundSchema = AdditionalProperty$outboundSchema;
  /** @deprecated use `AdditionalProperty$Outbound` instead. */
  export type Outbound = AdditionalProperty$Outbound;
}

export function additionalPropertyToJSON(
  additionalProperty: AdditionalProperty,
): string {
  return JSON.stringify(
    AdditionalProperty$outboundSchema.parse(additionalProperty),
  );
}

export function additionalPropertyFromJSON(
  jsonString: string,
): SafeParseResult<AdditionalProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdditionalProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdditionalProperty' from JSON`,
  );
}

/** @internal */
export const ResponseRetrySettingAzureDataExplorer$inboundSchema: z.ZodType<
  ResponseRetrySettingAzureDataExplorer,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingAzureDataExplorer$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingAzureDataExplorer$outboundSchema: z.ZodType<
  ResponseRetrySettingAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingAzureDataExplorer
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingAzureDataExplorer$ {
  /** @deprecated use `ResponseRetrySettingAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema =
    ResponseRetrySettingAzureDataExplorer$inboundSchema;
  /** @deprecated use `ResponseRetrySettingAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema =
    ResponseRetrySettingAzureDataExplorer$outboundSchema;
  /** @deprecated use `ResponseRetrySettingAzureDataExplorer$Outbound` instead. */
  export type Outbound = ResponseRetrySettingAzureDataExplorer$Outbound;
}

export function responseRetrySettingAzureDataExplorerToJSON(
  responseRetrySettingAzureDataExplorer: ResponseRetrySettingAzureDataExplorer,
): string {
  return JSON.stringify(
    ResponseRetrySettingAzureDataExplorer$outboundSchema.parse(
      responseRetrySettingAzureDataExplorer,
    ),
  );
}

export function responseRetrySettingAzureDataExplorerFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingAzureDataExplorer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ResponseRetrySettingAzureDataExplorer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingAzureDataExplorer' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsAzureDataExplorer$inboundSchema: z.ZodType<
  TimeoutRetrySettingsAzureDataExplorer,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsAzureDataExplorer$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsAzureDataExplorer$outboundSchema: z.ZodType<
  TimeoutRetrySettingsAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsAzureDataExplorer
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsAzureDataExplorer$ {
  /** @deprecated use `TimeoutRetrySettingsAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema =
    TimeoutRetrySettingsAzureDataExplorer$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema =
    TimeoutRetrySettingsAzureDataExplorer$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsAzureDataExplorer$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsAzureDataExplorer$Outbound;
}

export function timeoutRetrySettingsAzureDataExplorerToJSON(
  timeoutRetrySettingsAzureDataExplorer: TimeoutRetrySettingsAzureDataExplorer,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsAzureDataExplorer$outboundSchema.parse(
      timeoutRetrySettingsAzureDataExplorer,
    ),
  );
}

export function timeoutRetrySettingsAzureDataExplorerFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsAzureDataExplorer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TimeoutRetrySettingsAzureDataExplorer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsAzureDataExplorer' from JSON`,
  );
}

/** @internal */
export const CompressCompressionAzureDataExplorer$inboundSchema:
  z.ZodNativeEnum<typeof CompressCompressionAzureDataExplorer> = z.nativeEnum(
    CompressCompressionAzureDataExplorer,
  );

/** @internal */
export const CompressCompressionAzureDataExplorer$outboundSchema:
  z.ZodNativeEnum<typeof CompressCompressionAzureDataExplorer> =
    CompressCompressionAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressCompressionAzureDataExplorer$ {
  /** @deprecated use `CompressCompressionAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema =
    CompressCompressionAzureDataExplorer$inboundSchema;
  /** @deprecated use `CompressCompressionAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema =
    CompressCompressionAzureDataExplorer$outboundSchema;
}

/** @internal */
export const PqCompressCompressionAzureDataExplorer$inboundSchema:
  z.ZodNativeEnum<typeof PqCompressCompressionAzureDataExplorer> = z.nativeEnum(
    PqCompressCompressionAzureDataExplorer,
  );

/** @internal */
export const PqCompressCompressionAzureDataExplorer$outboundSchema:
  z.ZodNativeEnum<typeof PqCompressCompressionAzureDataExplorer> =
    PqCompressCompressionAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionAzureDataExplorer$ {
  /** @deprecated use `PqCompressCompressionAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema =
    PqCompressCompressionAzureDataExplorer$inboundSchema;
  /** @deprecated use `PqCompressCompressionAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema =
    PqCompressCompressionAzureDataExplorer$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorAzureDataExplorer$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorAzureDataExplorer
> = z.nativeEnum(QueueFullBehaviorAzureDataExplorer);

/** @internal */
export const QueueFullBehaviorAzureDataExplorer$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorAzureDataExplorer
> = QueueFullBehaviorAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorAzureDataExplorer$ {
  /** @deprecated use `QueueFullBehaviorAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorAzureDataExplorer$inboundSchema;
  /** @deprecated use `QueueFullBehaviorAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema =
    QueueFullBehaviorAzureDataExplorer$outboundSchema;
}

/** @internal */
export const ModeAzureDataExplorer$inboundSchema: z.ZodNativeEnum<
  typeof ModeAzureDataExplorer
> = z.nativeEnum(ModeAzureDataExplorer);

/** @internal */
export const ModeAzureDataExplorer$outboundSchema: z.ZodNativeEnum<
  typeof ModeAzureDataExplorer
> = ModeAzureDataExplorer$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeAzureDataExplorer$ {
  /** @deprecated use `ModeAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = ModeAzureDataExplorer$inboundSchema;
  /** @deprecated use `ModeAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema = ModeAzureDataExplorer$outboundSchema;
}

/** @internal */
export const PqControlsAzureDataExplorer$inboundSchema: z.ZodType<
  PqControlsAzureDataExplorer,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsAzureDataExplorer$Outbound = {};

/** @internal */
export const PqControlsAzureDataExplorer$outboundSchema: z.ZodType<
  PqControlsAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  PqControlsAzureDataExplorer
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsAzureDataExplorer$ {
  /** @deprecated use `PqControlsAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = PqControlsAzureDataExplorer$inboundSchema;
  /** @deprecated use `PqControlsAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema = PqControlsAzureDataExplorer$outboundSchema;
  /** @deprecated use `PqControlsAzureDataExplorer$Outbound` instead. */
  export type Outbound = PqControlsAzureDataExplorer$Outbound;
}

export function pqControlsAzureDataExplorerToJSON(
  pqControlsAzureDataExplorer: PqControlsAzureDataExplorer,
): string {
  return JSON.stringify(
    PqControlsAzureDataExplorer$outboundSchema.parse(
      pqControlsAzureDataExplorer,
    ),
  );
}

export function pqControlsAzureDataExplorerFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsAzureDataExplorer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsAzureDataExplorer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsAzureDataExplorer' from JSON`,
  );
}

/** @internal */
export const OutputAzureDataExplorer$inboundSchema: z.ZodType<
  OutputAzureDataExplorer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeAzureDataExplorer$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  clusterUrl: z.string(),
  database: z.string(),
  table: z.string(),
  validateDatabaseSettings: z.boolean().default(true),
  ingestMode: IngestionMode$inboundSchema.default("batching"),
  oauthEndpoint: MicrosoftEntraIDAuthenticationEndpoint$inboundSchema.default(
    "https://login.microsoftonline.com",
  ),
  tenantId: z.string(),
  clientId: z.string(),
  scope: z.string(),
  oauthType: OauthTypeAuthenticationMethod$inboundSchema.default(
    "clientSecret",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
  certificate: z.lazy(() => CertificateAzureDataExplorer$inboundSchema)
    .optional(),
  ingestUrl: z.string().optional(),
  onBackpressure: BackpressureBehaviorAzureDataExplorer$inboundSchema.default(
    "block",
  ),
  isMappingObj: z.boolean().default(false),
  format: DataFormatAzureDataExplorer$inboundSchema.default("json"),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  maxConcurrentFileParts: z.number().default(1),
  onDiskFullBackpressure: DiskSpaceProtectionAzureDataExplorer$inboundSchema
    .default("block"),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  deadletterEnabled: z.boolean().default(false),
  timeoutSec: z.number().default(30),
  flushImmediately: z.boolean().default(false),
  retainBlobOnSuccess: z.boolean().default(false),
  extentTags: z.array(z.lazy(() => ExtentTag$inboundSchema)).optional(),
  ingestIfNotExists: z.array(z.lazy(() => IngestIfNotExist$inboundSchema))
    .optional(),
  reportLevel: ReportLevel$inboundSchema.default("failuresOnly"),
  reportMethod: ReportMethod$inboundSchema.default("queue"),
  additionalProperties: z.array(z.lazy(() => AdditionalProperty$inboundSchema))
    .optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingAzureDataExplorer$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsAzureDataExplorer$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  compress: CompressCompressionAzureDataExplorer$inboundSchema.default("gzip"),
  mappingRef: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  keepAlive: z.boolean().default(true),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionAzureDataExplorer$inboundSchema.default(
    "none",
  ),
  pqOnBackpressure: QueueFullBehaviorAzureDataExplorer$inboundSchema.default(
    "block",
  ),
  pqMode: ModeAzureDataExplorer$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsAzureDataExplorer$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputAzureDataExplorer$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  clusterUrl: string;
  database: string;
  table: string;
  validateDatabaseSettings: boolean;
  ingestMode: string;
  oauthEndpoint: string;
  tenantId: string;
  clientId: string;
  scope: string;
  oauthType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
  certificate?: CertificateAzureDataExplorer$Outbound | undefined;
  ingestUrl?: string | undefined;
  onBackpressure: string;
  isMappingObj: boolean;
  format: string;
  stagePath: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  maxConcurrentFileParts: number;
  onDiskFullBackpressure: string;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  deadletterEnabled: boolean;
  timeoutSec: number;
  flushImmediately: boolean;
  retainBlobOnSuccess: boolean;
  extentTags?: Array<ExtentTag$Outbound> | undefined;
  ingestIfNotExists?: Array<IngestIfNotExist$Outbound> | undefined;
  reportLevel: string;
  reportMethod: string;
  additionalProperties?: Array<AdditionalProperty$Outbound> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingAzureDataExplorer$Outbound>
    | undefined;
  timeoutRetrySettings?:
    | TimeoutRetrySettingsAzureDataExplorer$Outbound
    | undefined;
  responseHonorRetryAfterHeader: boolean;
  compress: string;
  mappingRef?: string | undefined;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  flushPeriodSec: number;
  rejectUnauthorized: boolean;
  useRoundRobinDns: boolean;
  keepAlive: boolean;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsAzureDataExplorer$Outbound | undefined;
};

/** @internal */
export const OutputAzureDataExplorer$outboundSchema: z.ZodType<
  OutputAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  OutputAzureDataExplorer
> = z.object({
  id: z.string(),
  type: TypeAzureDataExplorer$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  clusterUrl: z.string(),
  database: z.string(),
  table: z.string(),
  validateDatabaseSettings: z.boolean().default(true),
  ingestMode: IngestionMode$outboundSchema.default("batching"),
  oauthEndpoint: MicrosoftEntraIDAuthenticationEndpoint$outboundSchema.default(
    "https://login.microsoftonline.com",
  ),
  tenantId: z.string(),
  clientId: z.string(),
  scope: z.string(),
  oauthType: OauthTypeAuthenticationMethod$outboundSchema.default(
    "clientSecret",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
  certificate: z.lazy(() => CertificateAzureDataExplorer$outboundSchema)
    .optional(),
  ingestUrl: z.string().optional(),
  onBackpressure: BackpressureBehaviorAzureDataExplorer$outboundSchema.default(
    "block",
  ),
  isMappingObj: z.boolean().default(false),
  format: DataFormatAzureDataExplorer$outboundSchema.default("json"),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  maxConcurrentFileParts: z.number().default(1),
  onDiskFullBackpressure: DiskSpaceProtectionAzureDataExplorer$outboundSchema
    .default("block"),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  deadletterEnabled: z.boolean().default(false),
  timeoutSec: z.number().default(30),
  flushImmediately: z.boolean().default(false),
  retainBlobOnSuccess: z.boolean().default(false),
  extentTags: z.array(z.lazy(() => ExtentTag$outboundSchema)).optional(),
  ingestIfNotExists: z.array(z.lazy(() => IngestIfNotExist$outboundSchema))
    .optional(),
  reportLevel: ReportLevel$outboundSchema.default("failuresOnly"),
  reportMethod: ReportMethod$outboundSchema.default("queue"),
  additionalProperties: z.array(z.lazy(() => AdditionalProperty$outboundSchema))
    .optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingAzureDataExplorer$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsAzureDataExplorer$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  compress: CompressCompressionAzureDataExplorer$outboundSchema.default("gzip"),
  mappingRef: z.string().optional(),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  flushPeriodSec: z.number().default(1),
  rejectUnauthorized: z.boolean().default(true),
  useRoundRobinDns: z.boolean().default(false),
  keepAlive: z.boolean().default(true),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionAzureDataExplorer$outboundSchema.default(
    "none",
  ),
  pqOnBackpressure: QueueFullBehaviorAzureDataExplorer$outboundSchema.default(
    "block",
  ),
  pqMode: ModeAzureDataExplorer$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsAzureDataExplorer$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureDataExplorer$ {
  /** @deprecated use `OutputAzureDataExplorer$inboundSchema` instead. */
  export const inboundSchema = OutputAzureDataExplorer$inboundSchema;
  /** @deprecated use `OutputAzureDataExplorer$outboundSchema` instead. */
  export const outboundSchema = OutputAzureDataExplorer$outboundSchema;
  /** @deprecated use `OutputAzureDataExplorer$Outbound` instead. */
  export type Outbound = OutputAzureDataExplorer$Outbound;
}

export function outputAzureDataExplorerToJSON(
  outputAzureDataExplorer: OutputAzureDataExplorer,
): string {
  return JSON.stringify(
    OutputAzureDataExplorer$outboundSchema.parse(outputAzureDataExplorer),
  );
}

export function outputAzureDataExplorerFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureDataExplorer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureDataExplorer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureDataExplorer' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeAzureBlob
> = z.nativeEnum(CreateOutputTypeAzureBlob);

/** @internal */
export const CreateOutputTypeAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeAzureBlob
> = CreateOutputTypeAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeAzureBlob$ {
  /** @deprecated use `CreateOutputTypeAzureBlob$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeAzureBlob$inboundSchema;
  /** @deprecated use `CreateOutputTypeAzureBlob$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeAzureBlob$outboundSchema;
}

/** @internal */
export const DataFormatAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof DataFormatAzureBlob
> = z.nativeEnum(DataFormatAzureBlob);

/** @internal */
export const DataFormatAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof DataFormatAzureBlob
> = DataFormatAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFormatAzureBlob$ {
  /** @deprecated use `DataFormatAzureBlob$inboundSchema` instead. */
  export const inboundSchema = DataFormatAzureBlob$inboundSchema;
  /** @deprecated use `DataFormatAzureBlob$outboundSchema` instead. */
  export const outboundSchema = DataFormatAzureBlob$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorAzureBlob
> = z.nativeEnum(BackpressureBehaviorAzureBlob);

/** @internal */
export const BackpressureBehaviorAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorAzureBlob
> = BackpressureBehaviorAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorAzureBlob$ {
  /** @deprecated use `BackpressureBehaviorAzureBlob$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorAzureBlob$inboundSchema;
  /** @deprecated use `BackpressureBehaviorAzureBlob$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorAzureBlob$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionAzureBlob
> = z.nativeEnum(DiskSpaceProtectionAzureBlob);

/** @internal */
export const DiskSpaceProtectionAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionAzureBlob
> = DiskSpaceProtectionAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionAzureBlob$ {
  /** @deprecated use `DiskSpaceProtectionAzureBlob$inboundSchema` instead. */
  export const inboundSchema = DiskSpaceProtectionAzureBlob$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionAzureBlob$outboundSchema` instead. */
  export const outboundSchema = DiskSpaceProtectionAzureBlob$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationMethodAzureBlob$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodAzureBlob> = z
    .nativeEnum(CreateOutputAuthenticationMethodAzureBlob);

/** @internal */
export const CreateOutputAuthenticationMethodAzureBlob$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputAuthenticationMethodAzureBlob> =
    CreateOutputAuthenticationMethodAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationMethodAzureBlob$ {
  /** @deprecated use `CreateOutputAuthenticationMethodAzureBlob$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputAuthenticationMethodAzureBlob$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationMethodAzureBlob$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationMethodAzureBlob$outboundSchema;
}

/** @internal */
export const BlobAccessTier$inboundSchema: z.ZodNativeEnum<
  typeof BlobAccessTier
> = z.nativeEnum(BlobAccessTier);

/** @internal */
export const BlobAccessTier$outboundSchema: z.ZodNativeEnum<
  typeof BlobAccessTier
> = BlobAccessTier$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BlobAccessTier$ {
  /** @deprecated use `BlobAccessTier$inboundSchema` instead. */
  export const inboundSchema = BlobAccessTier$inboundSchema;
  /** @deprecated use `BlobAccessTier$outboundSchema` instead. */
  export const outboundSchema = BlobAccessTier$outboundSchema;
}

/** @internal */
export const CreateOutputCompressionAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionAzureBlob
> = z.nativeEnum(CreateOutputCompressionAzureBlob);

/** @internal */
export const CreateOutputCompressionAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionAzureBlob
> = CreateOutputCompressionAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressionAzureBlob$ {
  /** @deprecated use `CreateOutputCompressionAzureBlob$inboundSchema` instead. */
  export const inboundSchema = CreateOutputCompressionAzureBlob$inboundSchema;
  /** @deprecated use `CreateOutputCompressionAzureBlob$outboundSchema` instead. */
  export const outboundSchema = CreateOutputCompressionAzureBlob$outboundSchema;
}

/** @internal */
export const CompressionLevelAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelAzureBlob
> = z.nativeEnum(CompressionLevelAzureBlob);

/** @internal */
export const CompressionLevelAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelAzureBlob
> = CompressionLevelAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionLevelAzureBlob$ {
  /** @deprecated use `CompressionLevelAzureBlob$inboundSchema` instead. */
  export const inboundSchema = CompressionLevelAzureBlob$inboundSchema;
  /** @deprecated use `CompressionLevelAzureBlob$outboundSchema` instead. */
  export const outboundSchema = CompressionLevelAzureBlob$outboundSchema;
}

/** @internal */
export const ParquetVersionAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionAzureBlob
> = z.nativeEnum(ParquetVersionAzureBlob);

/** @internal */
export const ParquetVersionAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionAzureBlob
> = ParquetVersionAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ParquetVersionAzureBlob$ {
  /** @deprecated use `ParquetVersionAzureBlob$inboundSchema` instead. */
  export const inboundSchema = ParquetVersionAzureBlob$inboundSchema;
  /** @deprecated use `ParquetVersionAzureBlob$outboundSchema` instead. */
  export const outboundSchema = ParquetVersionAzureBlob$outboundSchema;
}

/** @internal */
export const DataPageVersionAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionAzureBlob
> = z.nativeEnum(DataPageVersionAzureBlob);

/** @internal */
export const DataPageVersionAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionAzureBlob
> = DataPageVersionAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataPageVersionAzureBlob$ {
  /** @deprecated use `DataPageVersionAzureBlob$inboundSchema` instead. */
  export const inboundSchema = DataPageVersionAzureBlob$inboundSchema;
  /** @deprecated use `DataPageVersionAzureBlob$outboundSchema` instead. */
  export const outboundSchema = DataPageVersionAzureBlob$outboundSchema;
}

/** @internal */
export const KeyValueMetadatumAzureBlob$inboundSchema: z.ZodType<
  KeyValueMetadatumAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type KeyValueMetadatumAzureBlob$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const KeyValueMetadatumAzureBlob$outboundSchema: z.ZodType<
  KeyValueMetadatumAzureBlob$Outbound,
  z.ZodTypeDef,
  KeyValueMetadatumAzureBlob
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KeyValueMetadatumAzureBlob$ {
  /** @deprecated use `KeyValueMetadatumAzureBlob$inboundSchema` instead. */
  export const inboundSchema = KeyValueMetadatumAzureBlob$inboundSchema;
  /** @deprecated use `KeyValueMetadatumAzureBlob$outboundSchema` instead. */
  export const outboundSchema = KeyValueMetadatumAzureBlob$outboundSchema;
  /** @deprecated use `KeyValueMetadatumAzureBlob$Outbound` instead. */
  export type Outbound = KeyValueMetadatumAzureBlob$Outbound;
}

export function keyValueMetadatumAzureBlobToJSON(
  keyValueMetadatumAzureBlob: KeyValueMetadatumAzureBlob,
): string {
  return JSON.stringify(
    KeyValueMetadatumAzureBlob$outboundSchema.parse(keyValueMetadatumAzureBlob),
  );
}

export function keyValueMetadatumAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<KeyValueMetadatumAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KeyValueMetadatumAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KeyValueMetadatumAzureBlob' from JSON`,
  );
}

/** @internal */
export const CreateOutputCertificateAzureBlob$inboundSchema: z.ZodType<
  CreateOutputCertificateAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string(),
});

/** @internal */
export type CreateOutputCertificateAzureBlob$Outbound = {
  certificateName: string;
};

/** @internal */
export const CreateOutputCertificateAzureBlob$outboundSchema: z.ZodType<
  CreateOutputCertificateAzureBlob$Outbound,
  z.ZodTypeDef,
  CreateOutputCertificateAzureBlob
> = z.object({
  certificateName: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCertificateAzureBlob$ {
  /** @deprecated use `CreateOutputCertificateAzureBlob$inboundSchema` instead. */
  export const inboundSchema = CreateOutputCertificateAzureBlob$inboundSchema;
  /** @deprecated use `CreateOutputCertificateAzureBlob$outboundSchema` instead. */
  export const outboundSchema = CreateOutputCertificateAzureBlob$outboundSchema;
  /** @deprecated use `CreateOutputCertificateAzureBlob$Outbound` instead. */
  export type Outbound = CreateOutputCertificateAzureBlob$Outbound;
}

export function createOutputCertificateAzureBlobToJSON(
  createOutputCertificateAzureBlob: CreateOutputCertificateAzureBlob,
): string {
  return JSON.stringify(
    CreateOutputCertificateAzureBlob$outboundSchema.parse(
      createOutputCertificateAzureBlob,
    ),
  );
}

export function createOutputCertificateAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputCertificateAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputCertificateAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputCertificateAzureBlob' from JSON`,
  );
}

/** @internal */
export const OutputAzureBlob$inboundSchema: z.ZodType<
  OutputAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeAzureBlob$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  containerName: z.string(),
  createContainer: z.boolean().default(false),
  destPath: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  maxConcurrentFileParts: z.number().default(1),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatAzureBlob$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorAzureBlob$inboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionAzureBlob$inboundSchema.default(
    "block",
  ),
  authType: CreateOutputAuthenticationMethodAzureBlob$inboundSchema.default(
    "manual",
  ),
  storageClass: BlobAccessTier$inboundSchema.default("Inferred"),
  description: z.string().optional(),
  compress: CreateOutputCompressionAzureBlob$inboundSchema.default("gzip"),
  compressionLevel: CompressionLevelAzureBlob$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionAzureBlob$inboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: DataPageVersionAzureBlob$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumAzureBlob$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => CreateOutputCertificateAzureBlob$inboundSchema)
    .optional(),
});

/** @internal */
export type OutputAzureBlob$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  containerName: string;
  createContainer: boolean;
  destPath?: string | undefined;
  stagePath: string;
  addIdToStagePath: boolean;
  maxConcurrentFileParts: number;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  authType: string;
  storageClass: string;
  description?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<KeyValueMetadatumAzureBlob$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?: CreateOutputCertificateAzureBlob$Outbound | undefined;
};

/** @internal */
export const OutputAzureBlob$outboundSchema: z.ZodType<
  OutputAzureBlob$Outbound,
  z.ZodTypeDef,
  OutputAzureBlob
> = z.object({
  id: z.string(),
  type: CreateOutputTypeAzureBlob$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  containerName: z.string(),
  createContainer: z.boolean().default(false),
  destPath: z.string().optional(),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  maxConcurrentFileParts: z.number().default(1),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatAzureBlob$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorAzureBlob$outboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionAzureBlob$outboundSchema.default(
    "block",
  ),
  authType: CreateOutputAuthenticationMethodAzureBlob$outboundSchema.default(
    "manual",
  ),
  storageClass: BlobAccessTier$outboundSchema.default("Inferred"),
  description: z.string().optional(),
  compress: CreateOutputCompressionAzureBlob$outboundSchema.default("gzip"),
  compressionLevel: CompressionLevelAzureBlob$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionAzureBlob$outboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: DataPageVersionAzureBlob$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumAzureBlob$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => CreateOutputCertificateAzureBlob$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputAzureBlob$ {
  /** @deprecated use `OutputAzureBlob$inboundSchema` instead. */
  export const inboundSchema = OutputAzureBlob$inboundSchema;
  /** @deprecated use `OutputAzureBlob$outboundSchema` instead. */
  export const outboundSchema = OutputAzureBlob$outboundSchema;
  /** @deprecated use `OutputAzureBlob$Outbound` instead. */
  export type Outbound = OutputAzureBlob$Outbound;
}

export function outputAzureBlobToJSON(
  outputAzureBlob: OutputAzureBlob,
): string {
  return JSON.stringify(OutputAzureBlob$outboundSchema.parse(outputAzureBlob));
}

export function outputAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<OutputAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputAzureBlob' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeS3$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeS3
> = z.nativeEnum(CreateOutputTypeS3);

/** @internal */
export const CreateOutputTypeS3$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeS3
> = CreateOutputTypeS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeS3$ {
  /** @deprecated use `CreateOutputTypeS3$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeS3$inboundSchema;
  /** @deprecated use `CreateOutputTypeS3$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeS3$outboundSchema;
}

/** @internal */
export const CreateOutputAuthenticationMethodS3$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAuthenticationMethodS3
> = z.nativeEnum(CreateOutputAuthenticationMethodS3);

/** @internal */
export const CreateOutputAuthenticationMethodS3$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputAuthenticationMethodS3
> = CreateOutputAuthenticationMethodS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthenticationMethodS3$ {
  /** @deprecated use `CreateOutputAuthenticationMethodS3$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthenticationMethodS3$inboundSchema;
  /** @deprecated use `CreateOutputAuthenticationMethodS3$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputAuthenticationMethodS3$outboundSchema;
}

/** @internal */
export const CreateOutputSignatureVersionS3$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSignatureVersionS3
> = z.nativeEnum(CreateOutputSignatureVersionS3);

/** @internal */
export const CreateOutputSignatureVersionS3$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputSignatureVersionS3
> = CreateOutputSignatureVersionS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputSignatureVersionS3$ {
  /** @deprecated use `CreateOutputSignatureVersionS3$inboundSchema` instead. */
  export const inboundSchema = CreateOutputSignatureVersionS3$inboundSchema;
  /** @deprecated use `CreateOutputSignatureVersionS3$outboundSchema` instead. */
  export const outboundSchema = CreateOutputSignatureVersionS3$outboundSchema;
}

/** @internal */
export const ObjectAcls3$inboundSchema: z.ZodNativeEnum<typeof ObjectAcls3> = z
  .nativeEnum(ObjectAcls3);

/** @internal */
export const ObjectAcls3$outboundSchema: z.ZodNativeEnum<typeof ObjectAcls3> =
  ObjectAcls3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectAcls3$ {
  /** @deprecated use `ObjectAcls3$inboundSchema` instead. */
  export const inboundSchema = ObjectAcls3$inboundSchema;
  /** @deprecated use `ObjectAcls3$outboundSchema` instead. */
  export const outboundSchema = ObjectAcls3$outboundSchema;
}

/** @internal */
export const StorageClassS3$inboundSchema: z.ZodNativeEnum<
  typeof StorageClassS3
> = z.nativeEnum(StorageClassS3);

/** @internal */
export const StorageClassS3$outboundSchema: z.ZodNativeEnum<
  typeof StorageClassS3
> = StorageClassS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StorageClassS3$ {
  /** @deprecated use `StorageClassS3$inboundSchema` instead. */
  export const inboundSchema = StorageClassS3$inboundSchema;
  /** @deprecated use `StorageClassS3$outboundSchema` instead. */
  export const outboundSchema = StorageClassS3$outboundSchema;
}

/** @internal */
export const ServerSideEncryptionForUploadedObjectsS3$inboundSchema:
  z.ZodNativeEnum<typeof ServerSideEncryptionForUploadedObjectsS3> = z
    .nativeEnum(ServerSideEncryptionForUploadedObjectsS3);

/** @internal */
export const ServerSideEncryptionForUploadedObjectsS3$outboundSchema:
  z.ZodNativeEnum<typeof ServerSideEncryptionForUploadedObjectsS3> =
    ServerSideEncryptionForUploadedObjectsS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServerSideEncryptionForUploadedObjectsS3$ {
  /** @deprecated use `ServerSideEncryptionForUploadedObjectsS3$inboundSchema` instead. */
  export const inboundSchema =
    ServerSideEncryptionForUploadedObjectsS3$inboundSchema;
  /** @deprecated use `ServerSideEncryptionForUploadedObjectsS3$outboundSchema` instead. */
  export const outboundSchema =
    ServerSideEncryptionForUploadedObjectsS3$outboundSchema;
}

/** @internal */
export const DataFormatS3$inboundSchema: z.ZodNativeEnum<typeof DataFormatS3> =
  z.nativeEnum(DataFormatS3);

/** @internal */
export const DataFormatS3$outboundSchema: z.ZodNativeEnum<typeof DataFormatS3> =
  DataFormatS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFormatS3$ {
  /** @deprecated use `DataFormatS3$inboundSchema` instead. */
  export const inboundSchema = DataFormatS3$inboundSchema;
  /** @deprecated use `DataFormatS3$outboundSchema` instead. */
  export const outboundSchema = DataFormatS3$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorS3$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorS3
> = z.nativeEnum(BackpressureBehaviorS3);

/** @internal */
export const BackpressureBehaviorS3$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorS3
> = BackpressureBehaviorS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorS3$ {
  /** @deprecated use `BackpressureBehaviorS3$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorS3$inboundSchema;
  /** @deprecated use `BackpressureBehaviorS3$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorS3$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionS3$inboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionS3
> = z.nativeEnum(DiskSpaceProtectionS3);

/** @internal */
export const DiskSpaceProtectionS3$outboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionS3
> = DiskSpaceProtectionS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionS3$ {
  /** @deprecated use `DiskSpaceProtectionS3$inboundSchema` instead. */
  export const inboundSchema = DiskSpaceProtectionS3$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionS3$outboundSchema` instead. */
  export const outboundSchema = DiskSpaceProtectionS3$outboundSchema;
}

/** @internal */
export const CreateOutputCompressionS3$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionS3
> = z.nativeEnum(CreateOutputCompressionS3);

/** @internal */
export const CreateOutputCompressionS3$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputCompressionS3
> = CreateOutputCompressionS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressionS3$ {
  /** @deprecated use `CreateOutputCompressionS3$inboundSchema` instead. */
  export const inboundSchema = CreateOutputCompressionS3$inboundSchema;
  /** @deprecated use `CreateOutputCompressionS3$outboundSchema` instead. */
  export const outboundSchema = CreateOutputCompressionS3$outboundSchema;
}

/** @internal */
export const CompressionLevelS3$inboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelS3
> = z.nativeEnum(CompressionLevelS3);

/** @internal */
export const CompressionLevelS3$outboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelS3
> = CompressionLevelS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionLevelS3$ {
  /** @deprecated use `CompressionLevelS3$inboundSchema` instead. */
  export const inboundSchema = CompressionLevelS3$inboundSchema;
  /** @deprecated use `CompressionLevelS3$outboundSchema` instead. */
  export const outboundSchema = CompressionLevelS3$outboundSchema;
}

/** @internal */
export const ParquetVersionS3$inboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionS3
> = z.nativeEnum(ParquetVersionS3);

/** @internal */
export const ParquetVersionS3$outboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionS3
> = ParquetVersionS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ParquetVersionS3$ {
  /** @deprecated use `ParquetVersionS3$inboundSchema` instead. */
  export const inboundSchema = ParquetVersionS3$inboundSchema;
  /** @deprecated use `ParquetVersionS3$outboundSchema` instead. */
  export const outboundSchema = ParquetVersionS3$outboundSchema;
}

/** @internal */
export const DataPageVersionS3$inboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionS3
> = z.nativeEnum(DataPageVersionS3);

/** @internal */
export const DataPageVersionS3$outboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionS3
> = DataPageVersionS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataPageVersionS3$ {
  /** @deprecated use `DataPageVersionS3$inboundSchema` instead. */
  export const inboundSchema = DataPageVersionS3$inboundSchema;
  /** @deprecated use `DataPageVersionS3$outboundSchema` instead. */
  export const outboundSchema = DataPageVersionS3$outboundSchema;
}

/** @internal */
export const KeyValueMetadatumS3$inboundSchema: z.ZodType<
  KeyValueMetadatumS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type KeyValueMetadatumS3$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const KeyValueMetadatumS3$outboundSchema: z.ZodType<
  KeyValueMetadatumS3$Outbound,
  z.ZodTypeDef,
  KeyValueMetadatumS3
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KeyValueMetadatumS3$ {
  /** @deprecated use `KeyValueMetadatumS3$inboundSchema` instead. */
  export const inboundSchema = KeyValueMetadatumS3$inboundSchema;
  /** @deprecated use `KeyValueMetadatumS3$outboundSchema` instead. */
  export const outboundSchema = KeyValueMetadatumS3$outboundSchema;
  /** @deprecated use `KeyValueMetadatumS3$Outbound` instead. */
  export type Outbound = KeyValueMetadatumS3$Outbound;
}

export function keyValueMetadatumS3ToJSON(
  keyValueMetadatumS3: KeyValueMetadatumS3,
): string {
  return JSON.stringify(
    KeyValueMetadatumS3$outboundSchema.parse(keyValueMetadatumS3),
  );
}

export function keyValueMetadatumS3FromJSON(
  jsonString: string,
): SafeParseResult<KeyValueMetadatumS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KeyValueMetadatumS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KeyValueMetadatumS3' from JSON`,
  );
}

/** @internal */
export const OutputS3$inboundSchema: z.ZodType<
  OutputS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeS3$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: CreateOutputAuthenticationMethodS3$inboundSchema
    .default("auto"),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionS3$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: ObjectAcls3$inboundSchema.default("private"),
  storageClass: StorageClassS3$inboundSchema.optional(),
  serverSideEncryption: ServerSideEncryptionForUploadedObjectsS3$inboundSchema
    .optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatS3$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorS3$inboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionS3$inboundSchema.default("block"),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: CreateOutputCompressionS3$inboundSchema.default("gzip"),
  compressionLevel: CompressionLevelS3$inboundSchema.default("best_speed"),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionS3$inboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: DataPageVersionS3$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(z.lazy(() => KeyValueMetadatumS3$inboundSchema))
    .optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputS3$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region?: string | undefined;
  awsSecretKey?: string | undefined;
  awsAuthenticationMethod: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  stagePath: string;
  addIdToStagePath: boolean;
  destPath: string;
  objectACL: string;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  kmsKeyId?: string | undefined;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxConcurrentFileParts: number;
  verifyPermissions: boolean;
  maxClosingFilesToBackpressure: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<KeyValueMetadatumS3$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputS3$outboundSchema: z.ZodType<
  OutputS3$Outbound,
  z.ZodTypeDef,
  OutputS3
> = z.object({
  id: z.string(),
  type: CreateOutputTypeS3$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: CreateOutputAuthenticationMethodS3$outboundSchema
    .default("auto"),
  endpoint: z.string().optional(),
  signatureVersion: CreateOutputSignatureVersionS3$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  stagePath: z.string().default("$CRIBL_HOME/state/outputs/staging"),
  addIdToStagePath: z.boolean().default(true),
  destPath: z.string().default(""),
  objectACL: ObjectAcls3$outboundSchema.default("private"),
  storageClass: StorageClassS3$outboundSchema.optional(),
  serverSideEncryption: ServerSideEncryptionForUploadedObjectsS3$outboundSchema
    .optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatS3$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorS3$outboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionS3$outboundSchema.default("block"),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxConcurrentFileParts: z.number().default(4),
  verifyPermissions: z.boolean().default(true),
  maxClosingFilesToBackpressure: z.number().default(100),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: CreateOutputCompressionS3$outboundSchema.default("gzip"),
  compressionLevel: CompressionLevelS3$outboundSchema.default("best_speed"),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionS3$outboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: DataPageVersionS3$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(z.lazy(() => KeyValueMetadatumS3$outboundSchema))
    .optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputS3$ {
  /** @deprecated use `OutputS3$inboundSchema` instead. */
  export const inboundSchema = OutputS3$inboundSchema;
  /** @deprecated use `OutputS3$outboundSchema` instead. */
  export const outboundSchema = OutputS3$outboundSchema;
  /** @deprecated use `OutputS3$Outbound` instead. */
  export type Outbound = OutputS3$Outbound;
}

export function outputS3ToJSON(outputS3: OutputS3): string {
  return JSON.stringify(OutputS3$outboundSchema.parse(outputS3));
}

export function outputS3FromJSON(
  jsonString: string,
): SafeParseResult<OutputS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputS3' from JSON`,
  );
}

/** @internal */
export const TypeFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof TypeFilesystem
> = z.nativeEnum(TypeFilesystem);

/** @internal */
export const TypeFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof TypeFilesystem
> = TypeFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeFilesystem$ {
  /** @deprecated use `TypeFilesystem$inboundSchema` instead. */
  export const inboundSchema = TypeFilesystem$inboundSchema;
  /** @deprecated use `TypeFilesystem$outboundSchema` instead. */
  export const outboundSchema = TypeFilesystem$outboundSchema;
}

/** @internal */
export const DataFormatFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof DataFormatFilesystem
> = z.nativeEnum(DataFormatFilesystem);

/** @internal */
export const DataFormatFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof DataFormatFilesystem
> = DataFormatFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFormatFilesystem$ {
  /** @deprecated use `DataFormatFilesystem$inboundSchema` instead. */
  export const inboundSchema = DataFormatFilesystem$inboundSchema;
  /** @deprecated use `DataFormatFilesystem$outboundSchema` instead. */
  export const outboundSchema = DataFormatFilesystem$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorFilesystem
> = z.nativeEnum(BackpressureBehaviorFilesystem);

/** @internal */
export const BackpressureBehaviorFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorFilesystem
> = BackpressureBehaviorFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorFilesystem$ {
  /** @deprecated use `BackpressureBehaviorFilesystem$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorFilesystem$inboundSchema;
  /** @deprecated use `BackpressureBehaviorFilesystem$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorFilesystem$outboundSchema;
}

/** @internal */
export const DiskSpaceProtectionFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionFilesystem
> = z.nativeEnum(DiskSpaceProtectionFilesystem);

/** @internal */
export const DiskSpaceProtectionFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof DiskSpaceProtectionFilesystem
> = DiskSpaceProtectionFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpaceProtectionFilesystem$ {
  /** @deprecated use `DiskSpaceProtectionFilesystem$inboundSchema` instead. */
  export const inboundSchema = DiskSpaceProtectionFilesystem$inboundSchema;
  /** @deprecated use `DiskSpaceProtectionFilesystem$outboundSchema` instead. */
  export const outboundSchema = DiskSpaceProtectionFilesystem$outboundSchema;
}

/** @internal */
export const CompressionFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof CompressionFilesystem
> = z.nativeEnum(CompressionFilesystem);

/** @internal */
export const CompressionFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof CompressionFilesystem
> = CompressionFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionFilesystem$ {
  /** @deprecated use `CompressionFilesystem$inboundSchema` instead. */
  export const inboundSchema = CompressionFilesystem$inboundSchema;
  /** @deprecated use `CompressionFilesystem$outboundSchema` instead. */
  export const outboundSchema = CompressionFilesystem$outboundSchema;
}

/** @internal */
export const CompressionLevelFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelFilesystem
> = z.nativeEnum(CompressionLevelFilesystem);

/** @internal */
export const CompressionLevelFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof CompressionLevelFilesystem
> = CompressionLevelFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionLevelFilesystem$ {
  /** @deprecated use `CompressionLevelFilesystem$inboundSchema` instead. */
  export const inboundSchema = CompressionLevelFilesystem$inboundSchema;
  /** @deprecated use `CompressionLevelFilesystem$outboundSchema` instead. */
  export const outboundSchema = CompressionLevelFilesystem$outboundSchema;
}

/** @internal */
export const ParquetVersionFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionFilesystem
> = z.nativeEnum(ParquetVersionFilesystem);

/** @internal */
export const ParquetVersionFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof ParquetVersionFilesystem
> = ParquetVersionFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ParquetVersionFilesystem$ {
  /** @deprecated use `ParquetVersionFilesystem$inboundSchema` instead. */
  export const inboundSchema = ParquetVersionFilesystem$inboundSchema;
  /** @deprecated use `ParquetVersionFilesystem$outboundSchema` instead. */
  export const outboundSchema = ParquetVersionFilesystem$outboundSchema;
}

/** @internal */
export const DataPageVersionFilesystem$inboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionFilesystem
> = z.nativeEnum(DataPageVersionFilesystem);

/** @internal */
export const DataPageVersionFilesystem$outboundSchema: z.ZodNativeEnum<
  typeof DataPageVersionFilesystem
> = DataPageVersionFilesystem$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataPageVersionFilesystem$ {
  /** @deprecated use `DataPageVersionFilesystem$inboundSchema` instead. */
  export const inboundSchema = DataPageVersionFilesystem$inboundSchema;
  /** @deprecated use `DataPageVersionFilesystem$outboundSchema` instead. */
  export const outboundSchema = DataPageVersionFilesystem$outboundSchema;
}

/** @internal */
export const KeyValueMetadatumFilesystem$inboundSchema: z.ZodType<
  KeyValueMetadatumFilesystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/** @internal */
export type KeyValueMetadatumFilesystem$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const KeyValueMetadatumFilesystem$outboundSchema: z.ZodType<
  KeyValueMetadatumFilesystem$Outbound,
  z.ZodTypeDef,
  KeyValueMetadatumFilesystem
> = z.object({
  key: z.string().default(""),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KeyValueMetadatumFilesystem$ {
  /** @deprecated use `KeyValueMetadatumFilesystem$inboundSchema` instead. */
  export const inboundSchema = KeyValueMetadatumFilesystem$inboundSchema;
  /** @deprecated use `KeyValueMetadatumFilesystem$outboundSchema` instead. */
  export const outboundSchema = KeyValueMetadatumFilesystem$outboundSchema;
  /** @deprecated use `KeyValueMetadatumFilesystem$Outbound` instead. */
  export type Outbound = KeyValueMetadatumFilesystem$Outbound;
}

export function keyValueMetadatumFilesystemToJSON(
  keyValueMetadatumFilesystem: KeyValueMetadatumFilesystem,
): string {
  return JSON.stringify(
    KeyValueMetadatumFilesystem$outboundSchema.parse(
      keyValueMetadatumFilesystem,
    ),
  );
}

export function keyValueMetadatumFilesystemFromJSON(
  jsonString: string,
): SafeParseResult<KeyValueMetadatumFilesystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KeyValueMetadatumFilesystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KeyValueMetadatumFilesystem' from JSON`,
  );
}

/** @internal */
export const OutputFilesystem$inboundSchema: z.ZodType<
  OutputFilesystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeFilesystem$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  destPath: z.string(),
  stagePath: z.string().optional(),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatFilesystem$inboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorFilesystem$inboundSchema.default("block"),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionFilesystem$inboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  compress: CompressionFilesystem$inboundSchema.default("gzip"),
  compressionLevel: CompressionLevelFilesystem$inboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionFilesystem$inboundSchema.default("PARQUET_2_6"),
  parquetDataPageVersion: DataPageVersionFilesystem$inboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumFilesystem$inboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/** @internal */
export type OutputFilesystem$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  destPath: string;
  stagePath?: string | undefined;
  addIdToStagePath: boolean;
  removeEmptyDirs: boolean;
  partitionExpr: string;
  format: string;
  baseFileName: string;
  fileNameSuffix: string;
  maxFileSizeMB: number;
  maxFileOpenTimeSec: number;
  maxFileIdleTimeSec: number;
  maxOpenFiles: number;
  headerLine: string;
  writeHighWaterMark: number;
  onBackpressure: string;
  deadletterEnabled: boolean;
  onDiskFullBackpressure: string;
  description?: string | undefined;
  compress: string;
  compressionLevel: string;
  automaticSchema: boolean;
  parquetVersion: string;
  parquetDataPageVersion: string;
  parquetRowGroupLength: number;
  parquetPageSize: string;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?: Array<KeyValueMetadatumFilesystem$Outbound> | undefined;
  enableStatistics: boolean;
  enableWritePageIndex: boolean;
  enablePageChecksum: boolean;
  emptyDirCleanupSec: number;
  deadletterPath: string;
  maxRetryNum: number;
};

/** @internal */
export const OutputFilesystem$outboundSchema: z.ZodType<
  OutputFilesystem$Outbound,
  z.ZodTypeDef,
  OutputFilesystem
> = z.object({
  id: z.string(),
  type: TypeFilesystem$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  destPath: z.string(),
  stagePath: z.string().optional(),
  addIdToStagePath: z.boolean().default(true),
  removeEmptyDirs: z.boolean().default(true),
  partitionExpr: z.string().default(
    "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')",
  ),
  format: DataFormatFilesystem$outboundSchema.default("json"),
  baseFileName: z.string().default("`CriblOut`"),
  fileNameSuffix: z.string().default(
    "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`",
  ),
  maxFileSizeMB: z.number().default(32),
  maxFileOpenTimeSec: z.number().default(300),
  maxFileIdleTimeSec: z.number().default(30),
  maxOpenFiles: z.number().default(100),
  headerLine: z.string().default(""),
  writeHighWaterMark: z.number().default(64),
  onBackpressure: BackpressureBehaviorFilesystem$outboundSchema.default(
    "block",
  ),
  deadletterEnabled: z.boolean().default(false),
  onDiskFullBackpressure: DiskSpaceProtectionFilesystem$outboundSchema.default(
    "block",
  ),
  description: z.string().optional(),
  compress: CompressionFilesystem$outboundSchema.default("gzip"),
  compressionLevel: CompressionLevelFilesystem$outboundSchema.default(
    "best_speed",
  ),
  automaticSchema: z.boolean().default(false),
  parquetVersion: ParquetVersionFilesystem$outboundSchema.default(
    "PARQUET_2_6",
  ),
  parquetDataPageVersion: DataPageVersionFilesystem$outboundSchema.default(
    "DATA_PAGE_V2",
  ),
  parquetRowGroupLength: z.number().default(10000),
  parquetPageSize: z.string().default("1MB"),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(
    z.lazy(() => KeyValueMetadatumFilesystem$outboundSchema),
  ).optional(),
  enableStatistics: z.boolean().default(true),
  enableWritePageIndex: z.boolean().default(true),
  enablePageChecksum: z.boolean().default(false),
  emptyDirCleanupSec: z.number().default(300),
  deadletterPath: z.string().default("$CRIBL_HOME/state/outputs/dead-letter"),
  maxRetryNum: z.number().default(20),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputFilesystem$ {
  /** @deprecated use `OutputFilesystem$inboundSchema` instead. */
  export const inboundSchema = OutputFilesystem$inboundSchema;
  /** @deprecated use `OutputFilesystem$outboundSchema` instead. */
  export const outboundSchema = OutputFilesystem$outboundSchema;
  /** @deprecated use `OutputFilesystem$Outbound` instead. */
  export type Outbound = OutputFilesystem$Outbound;
}

export function outputFilesystemToJSON(
  outputFilesystem: OutputFilesystem,
): string {
  return JSON.stringify(
    OutputFilesystem$outboundSchema.parse(outputFilesystem),
  );
}

export function outputFilesystemFromJSON(
  jsonString: string,
): SafeParseResult<OutputFilesystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputFilesystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputFilesystem' from JSON`,
  );
}

/** @internal */
export const TypeSignalfx$inboundSchema: z.ZodNativeEnum<typeof TypeSignalfx> =
  z.nativeEnum(TypeSignalfx);

/** @internal */
export const TypeSignalfx$outboundSchema: z.ZodNativeEnum<typeof TypeSignalfx> =
  TypeSignalfx$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSignalfx$ {
  /** @deprecated use `TypeSignalfx$inboundSchema` instead. */
  export const inboundSchema = TypeSignalfx$inboundSchema;
  /** @deprecated use `TypeSignalfx$outboundSchema` instead. */
  export const outboundSchema = TypeSignalfx$outboundSchema;
}

/** @internal */
export const AuthenticationMethodSignalfx$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSignalfx
> = z.nativeEnum(AuthenticationMethodSignalfx);

/** @internal */
export const AuthenticationMethodSignalfx$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSignalfx
> = AuthenticationMethodSignalfx$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodSignalfx$ {
  /** @deprecated use `AuthenticationMethodSignalfx$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodSignalfx$inboundSchema;
  /** @deprecated use `AuthenticationMethodSignalfx$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodSignalfx$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderSignalfx$inboundSchema: z.ZodType<
  ExtraHttpHeaderSignalfx,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderSignalfx$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderSignalfx$outboundSchema: z.ZodType<
  ExtraHttpHeaderSignalfx$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderSignalfx
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderSignalfx$ {
  /** @deprecated use `ExtraHttpHeaderSignalfx$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderSignalfx$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderSignalfx$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderSignalfx$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderSignalfx$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderSignalfx$Outbound;
}

export function extraHttpHeaderSignalfxToJSON(
  extraHttpHeaderSignalfx: ExtraHttpHeaderSignalfx,
): string {
  return JSON.stringify(
    ExtraHttpHeaderSignalfx$outboundSchema.parse(extraHttpHeaderSignalfx),
  );
}

export function extraHttpHeaderSignalfxFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderSignalfx, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderSignalfx$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderSignalfx' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeSignalfx$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeSignalfx
> = z.nativeEnum(FailedRequestLoggingModeSignalfx);

/** @internal */
export const FailedRequestLoggingModeSignalfx$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeSignalfx
> = FailedRequestLoggingModeSignalfx$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeSignalfx$ {
  /** @deprecated use `FailedRequestLoggingModeSignalfx$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeSignalfx$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeSignalfx$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingModeSignalfx$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingSignalfx$inboundSchema: z.ZodType<
  ResponseRetrySettingSignalfx,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingSignalfx$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingSignalfx$outboundSchema: z.ZodType<
  ResponseRetrySettingSignalfx$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingSignalfx
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingSignalfx$ {
  /** @deprecated use `ResponseRetrySettingSignalfx$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingSignalfx$inboundSchema;
  /** @deprecated use `ResponseRetrySettingSignalfx$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingSignalfx$outboundSchema;
  /** @deprecated use `ResponseRetrySettingSignalfx$Outbound` instead. */
  export type Outbound = ResponseRetrySettingSignalfx$Outbound;
}

export function responseRetrySettingSignalfxToJSON(
  responseRetrySettingSignalfx: ResponseRetrySettingSignalfx,
): string {
  return JSON.stringify(
    ResponseRetrySettingSignalfx$outboundSchema.parse(
      responseRetrySettingSignalfx,
    ),
  );
}

export function responseRetrySettingSignalfxFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingSignalfx, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingSignalfx$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingSignalfx' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsSignalfx$inboundSchema: z.ZodType<
  TimeoutRetrySettingsSignalfx,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsSignalfx$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsSignalfx$outboundSchema: z.ZodType<
  TimeoutRetrySettingsSignalfx$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsSignalfx
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsSignalfx$ {
  /** @deprecated use `TimeoutRetrySettingsSignalfx$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsSignalfx$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSignalfx$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsSignalfx$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSignalfx$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsSignalfx$Outbound;
}

export function timeoutRetrySettingsSignalfxToJSON(
  timeoutRetrySettingsSignalfx: TimeoutRetrySettingsSignalfx,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsSignalfx$outboundSchema.parse(
      timeoutRetrySettingsSignalfx,
    ),
  );
}

export function timeoutRetrySettingsSignalfxFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsSignalfx, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsSignalfx$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsSignalfx' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorSignalfx$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSignalfx
> = z.nativeEnum(BackpressureBehaviorSignalfx);

/** @internal */
export const BackpressureBehaviorSignalfx$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSignalfx
> = BackpressureBehaviorSignalfx$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSignalfx$ {
  /** @deprecated use `BackpressureBehaviorSignalfx$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSignalfx$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSignalfx$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSignalfx$outboundSchema;
}

/** @internal */
export const CompressionSignalfx$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSignalfx
> = z.nativeEnum(CompressionSignalfx);

/** @internal */
export const CompressionSignalfx$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSignalfx
> = CompressionSignalfx$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSignalfx$ {
  /** @deprecated use `CompressionSignalfx$inboundSchema` instead. */
  export const inboundSchema = CompressionSignalfx$inboundSchema;
  /** @deprecated use `CompressionSignalfx$outboundSchema` instead. */
  export const outboundSchema = CompressionSignalfx$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSignalfx$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSignalfx
> = z.nativeEnum(QueueFullBehaviorSignalfx);

/** @internal */
export const QueueFullBehaviorSignalfx$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSignalfx
> = QueueFullBehaviorSignalfx$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSignalfx$ {
  /** @deprecated use `QueueFullBehaviorSignalfx$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSignalfx$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSignalfx$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorSignalfx$outboundSchema;
}

/** @internal */
export const ModeSignalfx$inboundSchema: z.ZodNativeEnum<typeof ModeSignalfx> =
  z.nativeEnum(ModeSignalfx);

/** @internal */
export const ModeSignalfx$outboundSchema: z.ZodNativeEnum<typeof ModeSignalfx> =
  ModeSignalfx$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSignalfx$ {
  /** @deprecated use `ModeSignalfx$inboundSchema` instead. */
  export const inboundSchema = ModeSignalfx$inboundSchema;
  /** @deprecated use `ModeSignalfx$outboundSchema` instead. */
  export const outboundSchema = ModeSignalfx$outboundSchema;
}

/** @internal */
export const PqControlsSignalfx$inboundSchema: z.ZodType<
  PqControlsSignalfx,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSignalfx$Outbound = {};

/** @internal */
export const PqControlsSignalfx$outboundSchema: z.ZodType<
  PqControlsSignalfx$Outbound,
  z.ZodTypeDef,
  PqControlsSignalfx
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSignalfx$ {
  /** @deprecated use `PqControlsSignalfx$inboundSchema` instead. */
  export const inboundSchema = PqControlsSignalfx$inboundSchema;
  /** @deprecated use `PqControlsSignalfx$outboundSchema` instead. */
  export const outboundSchema = PqControlsSignalfx$outboundSchema;
  /** @deprecated use `PqControlsSignalfx$Outbound` instead. */
  export type Outbound = PqControlsSignalfx$Outbound;
}

export function pqControlsSignalfxToJSON(
  pqControlsSignalfx: PqControlsSignalfx,
): string {
  return JSON.stringify(
    PqControlsSignalfx$outboundSchema.parse(pqControlsSignalfx),
  );
}

export function pqControlsSignalfxFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSignalfx, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSignalfx$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSignalfx' from JSON`,
  );
}

/** @internal */
export const OutputSignalfx$inboundSchema: z.ZodType<
  OutputSignalfx,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSignalfx$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: AuthenticationMethodSignalfx$inboundSchema.default("manual"),
  realm: z.string().default("us0"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeaderSignalfx$inboundSchema))
    .optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeSignalfx$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSignalfx$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsSignalfx$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSignalfx$inboundSchema.default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSignalfx$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSignalfx$inboundSchema.default("block"),
  pqMode: ModeSignalfx$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSignalfx$inboundSchema).optional(),
});

/** @internal */
export type OutputSignalfx$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  authType: string;
  realm: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderSignalfx$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingSignalfx$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsSignalfx$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSignalfx$Outbound | undefined;
};

/** @internal */
export const OutputSignalfx$outboundSchema: z.ZodType<
  OutputSignalfx$Outbound,
  z.ZodTypeDef,
  OutputSignalfx
> = z.object({
  id: z.string(),
  type: TypeSignalfx$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: AuthenticationMethodSignalfx$outboundSchema.default("manual"),
  realm: z.string().default("us0"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderSignalfx$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeSignalfx$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSignalfx$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsSignalfx$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSignalfx$outboundSchema.default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSignalfx$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSignalfx$outboundSchema.default("block"),
  pqMode: ModeSignalfx$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSignalfx$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSignalfx$ {
  /** @deprecated use `OutputSignalfx$inboundSchema` instead. */
  export const inboundSchema = OutputSignalfx$inboundSchema;
  /** @deprecated use `OutputSignalfx$outboundSchema` instead. */
  export const outboundSchema = OutputSignalfx$outboundSchema;
  /** @deprecated use `OutputSignalfx$Outbound` instead. */
  export type Outbound = OutputSignalfx$Outbound;
}

export function outputSignalfxToJSON(outputSignalfx: OutputSignalfx): string {
  return JSON.stringify(OutputSignalfx$outboundSchema.parse(outputSignalfx));
}

export function outputSignalfxFromJSON(
  jsonString: string,
): SafeParseResult<OutputSignalfx, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSignalfx$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSignalfx' from JSON`,
  );
}

/** @internal */
export const TypeWavefront$inboundSchema: z.ZodNativeEnum<
  typeof TypeWavefront
> = z.nativeEnum(TypeWavefront);

/** @internal */
export const TypeWavefront$outboundSchema: z.ZodNativeEnum<
  typeof TypeWavefront
> = TypeWavefront$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeWavefront$ {
  /** @deprecated use `TypeWavefront$inboundSchema` instead. */
  export const inboundSchema = TypeWavefront$inboundSchema;
  /** @deprecated use `TypeWavefront$outboundSchema` instead. */
  export const outboundSchema = TypeWavefront$outboundSchema;
}

/** @internal */
export const AuthenticationMethodWavefront$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodWavefront
> = z.nativeEnum(AuthenticationMethodWavefront);

/** @internal */
export const AuthenticationMethodWavefront$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodWavefront
> = AuthenticationMethodWavefront$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodWavefront$ {
  /** @deprecated use `AuthenticationMethodWavefront$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodWavefront$inboundSchema;
  /** @deprecated use `AuthenticationMethodWavefront$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodWavefront$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderWavefront$inboundSchema: z.ZodType<
  ExtraHttpHeaderWavefront,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderWavefront$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderWavefront$outboundSchema: z.ZodType<
  ExtraHttpHeaderWavefront$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderWavefront
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderWavefront$ {
  /** @deprecated use `ExtraHttpHeaderWavefront$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderWavefront$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderWavefront$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderWavefront$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderWavefront$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderWavefront$Outbound;
}

export function extraHttpHeaderWavefrontToJSON(
  extraHttpHeaderWavefront: ExtraHttpHeaderWavefront,
): string {
  return JSON.stringify(
    ExtraHttpHeaderWavefront$outboundSchema.parse(extraHttpHeaderWavefront),
  );
}

export function extraHttpHeaderWavefrontFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderWavefront, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderWavefront$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderWavefront' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeWavefront$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeWavefront
> = z.nativeEnum(FailedRequestLoggingModeWavefront);

/** @internal */
export const FailedRequestLoggingModeWavefront$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeWavefront
> = FailedRequestLoggingModeWavefront$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeWavefront$ {
  /** @deprecated use `FailedRequestLoggingModeWavefront$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeWavefront$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeWavefront$outboundSchema` instead. */
  export const outboundSchema =
    FailedRequestLoggingModeWavefront$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingWavefront$inboundSchema: z.ZodType<
  ResponseRetrySettingWavefront,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingWavefront$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingWavefront$outboundSchema: z.ZodType<
  ResponseRetrySettingWavefront$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingWavefront
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingWavefront$ {
  /** @deprecated use `ResponseRetrySettingWavefront$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingWavefront$inboundSchema;
  /** @deprecated use `ResponseRetrySettingWavefront$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingWavefront$outboundSchema;
  /** @deprecated use `ResponseRetrySettingWavefront$Outbound` instead. */
  export type Outbound = ResponseRetrySettingWavefront$Outbound;
}

export function responseRetrySettingWavefrontToJSON(
  responseRetrySettingWavefront: ResponseRetrySettingWavefront,
): string {
  return JSON.stringify(
    ResponseRetrySettingWavefront$outboundSchema.parse(
      responseRetrySettingWavefront,
    ),
  );
}

export function responseRetrySettingWavefrontFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingWavefront, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingWavefront$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingWavefront' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsWavefront$inboundSchema: z.ZodType<
  TimeoutRetrySettingsWavefront,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsWavefront$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsWavefront$outboundSchema: z.ZodType<
  TimeoutRetrySettingsWavefront$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsWavefront
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsWavefront$ {
  /** @deprecated use `TimeoutRetrySettingsWavefront$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsWavefront$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsWavefront$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsWavefront$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsWavefront$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsWavefront$Outbound;
}

export function timeoutRetrySettingsWavefrontToJSON(
  timeoutRetrySettingsWavefront: TimeoutRetrySettingsWavefront,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsWavefront$outboundSchema.parse(
      timeoutRetrySettingsWavefront,
    ),
  );
}

export function timeoutRetrySettingsWavefrontFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsWavefront, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsWavefront$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsWavefront' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorWavefront$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorWavefront
> = z.nativeEnum(BackpressureBehaviorWavefront);

/** @internal */
export const BackpressureBehaviorWavefront$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorWavefront
> = BackpressureBehaviorWavefront$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorWavefront$ {
  /** @deprecated use `BackpressureBehaviorWavefront$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorWavefront$inboundSchema;
  /** @deprecated use `BackpressureBehaviorWavefront$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorWavefront$outboundSchema;
}

/** @internal */
export const CompressionWavefront$inboundSchema: z.ZodNativeEnum<
  typeof CompressionWavefront
> = z.nativeEnum(CompressionWavefront);

/** @internal */
export const CompressionWavefront$outboundSchema: z.ZodNativeEnum<
  typeof CompressionWavefront
> = CompressionWavefront$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionWavefront$ {
  /** @deprecated use `CompressionWavefront$inboundSchema` instead. */
  export const inboundSchema = CompressionWavefront$inboundSchema;
  /** @deprecated use `CompressionWavefront$outboundSchema` instead. */
  export const outboundSchema = CompressionWavefront$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorWavefront$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorWavefront
> = z.nativeEnum(QueueFullBehaviorWavefront);

/** @internal */
export const QueueFullBehaviorWavefront$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorWavefront
> = QueueFullBehaviorWavefront$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorWavefront$ {
  /** @deprecated use `QueueFullBehaviorWavefront$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorWavefront$inboundSchema;
  /** @deprecated use `QueueFullBehaviorWavefront$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorWavefront$outboundSchema;
}

/** @internal */
export const ModeWavefront$inboundSchema: z.ZodNativeEnum<
  typeof ModeWavefront
> = z.nativeEnum(ModeWavefront);

/** @internal */
export const ModeWavefront$outboundSchema: z.ZodNativeEnum<
  typeof ModeWavefront
> = ModeWavefront$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeWavefront$ {
  /** @deprecated use `ModeWavefront$inboundSchema` instead. */
  export const inboundSchema = ModeWavefront$inboundSchema;
  /** @deprecated use `ModeWavefront$outboundSchema` instead. */
  export const outboundSchema = ModeWavefront$outboundSchema;
}

/** @internal */
export const PqControlsWavefront$inboundSchema: z.ZodType<
  PqControlsWavefront,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsWavefront$Outbound = {};

/** @internal */
export const PqControlsWavefront$outboundSchema: z.ZodType<
  PqControlsWavefront$Outbound,
  z.ZodTypeDef,
  PqControlsWavefront
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsWavefront$ {
  /** @deprecated use `PqControlsWavefront$inboundSchema` instead. */
  export const inboundSchema = PqControlsWavefront$inboundSchema;
  /** @deprecated use `PqControlsWavefront$outboundSchema` instead. */
  export const outboundSchema = PqControlsWavefront$outboundSchema;
  /** @deprecated use `PqControlsWavefront$Outbound` instead. */
  export type Outbound = PqControlsWavefront$Outbound;
}

export function pqControlsWavefrontToJSON(
  pqControlsWavefront: PqControlsWavefront,
): string {
  return JSON.stringify(
    PqControlsWavefront$outboundSchema.parse(pqControlsWavefront),
  );
}

export function pqControlsWavefrontFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsWavefront, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsWavefront$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsWavefront' from JSON`,
  );
}

/** @internal */
export const OutputWavefront$inboundSchema: z.ZodType<
  OutputWavefront,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeWavefront$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: AuthenticationMethodWavefront$inboundSchema.default("manual"),
  domain: z.string().default("longboard"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderWavefront$inboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeWavefront$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingWavefront$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsWavefront$inboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorWavefront$inboundSchema.default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionWavefront$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorWavefront$inboundSchema.default("block"),
  pqMode: ModeWavefront$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsWavefront$inboundSchema).optional(),
});

/** @internal */
export type OutputWavefront$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  authType: string;
  domain: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderWavefront$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingWavefront$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsWavefront$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsWavefront$Outbound | undefined;
};

/** @internal */
export const OutputWavefront$outboundSchema: z.ZodType<
  OutputWavefront$Outbound,
  z.ZodTypeDef,
  OutputWavefront
> = z.object({
  id: z.string(),
  type: TypeWavefront$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: AuthenticationMethodWavefront$outboundSchema.default("manual"),
  domain: z.string().default("longboard"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderWavefront$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeWavefront$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingWavefront$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsWavefront$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorWavefront$outboundSchema.default("block"),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionWavefront$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorWavefront$outboundSchema.default("block"),
  pqMode: ModeWavefront$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsWavefront$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputWavefront$ {
  /** @deprecated use `OutputWavefront$inboundSchema` instead. */
  export const inboundSchema = OutputWavefront$inboundSchema;
  /** @deprecated use `OutputWavefront$outboundSchema` instead. */
  export const outboundSchema = OutputWavefront$outboundSchema;
  /** @deprecated use `OutputWavefront$Outbound` instead. */
  export type Outbound = OutputWavefront$Outbound;
}

export function outputWavefrontToJSON(
  outputWavefront: OutputWavefront,
): string {
  return JSON.stringify(OutputWavefront$outboundSchema.parse(outputWavefront));
}

export function outputWavefrontFromJSON(
  jsonString: string,
): SafeParseResult<OutputWavefront, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWavefront$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWavefront' from JSON`,
  );
}

/** @internal */
export const TypeSplunkLb$inboundSchema: z.ZodNativeEnum<typeof TypeSplunkLb> =
  z.nativeEnum(TypeSplunkLb);

/** @internal */
export const TypeSplunkLb$outboundSchema: z.ZodNativeEnum<typeof TypeSplunkLb> =
  TypeSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSplunkLb$ {
  /** @deprecated use `TypeSplunkLb$inboundSchema` instead. */
  export const inboundSchema = TypeSplunkLb$inboundSchema;
  /** @deprecated use `TypeSplunkLb$outboundSchema` instead. */
  export const outboundSchema = TypeSplunkLb$outboundSchema;
}

/** @internal */
export const NestedFieldSerializationSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof NestedFieldSerializationSplunkLb
> = z.nativeEnum(NestedFieldSerializationSplunkLb);

/** @internal */
export const NestedFieldSerializationSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof NestedFieldSerializationSplunkLb
> = NestedFieldSerializationSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NestedFieldSerializationSplunkLb$ {
  /** @deprecated use `NestedFieldSerializationSplunkLb$inboundSchema` instead. */
  export const inboundSchema = NestedFieldSerializationSplunkLb$inboundSchema;
  /** @deprecated use `NestedFieldSerializationSplunkLb$outboundSchema` instead. */
  export const outboundSchema = NestedFieldSerializationSplunkLb$outboundSchema;
}

/** @internal */
export const MinimumTLSVersionSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionSplunkLb
> = z.nativeEnum(MinimumTLSVersionSplunkLb);

/** @internal */
export const MinimumTLSVersionSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionSplunkLb
> = MinimumTLSVersionSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionSplunkLb$ {
  /** @deprecated use `MinimumTLSVersionSplunkLb$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionSplunkLb$inboundSchema;
  /** @deprecated use `MinimumTLSVersionSplunkLb$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionSplunkLb$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionSplunkLb
> = z.nativeEnum(MaximumTLSVersionSplunkLb);

/** @internal */
export const MaximumTLSVersionSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionSplunkLb
> = MaximumTLSVersionSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionSplunkLb$ {
  /** @deprecated use `MaximumTLSVersionSplunkLb$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionSplunkLb$inboundSchema;
  /** @deprecated use `MaximumTLSVersionSplunkLb$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionSplunkLb$outboundSchema;
}

/** @internal */
export const TLSSettingsClientSideSplunkLb$inboundSchema: z.ZodType<
  TLSSettingsClientSideSplunkLb,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: MinimumTLSVersionSplunkLb$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionSplunkLb$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsClientSideSplunkLb$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsClientSideSplunkLb$outboundSchema: z.ZodType<
  TLSSettingsClientSideSplunkLb$Outbound,
  z.ZodTypeDef,
  TLSSettingsClientSideSplunkLb
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: MinimumTLSVersionSplunkLb$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionSplunkLb$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsClientSideSplunkLb$ {
  /** @deprecated use `TLSSettingsClientSideSplunkLb$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsClientSideSplunkLb$inboundSchema;
  /** @deprecated use `TLSSettingsClientSideSplunkLb$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsClientSideSplunkLb$outboundSchema;
  /** @deprecated use `TLSSettingsClientSideSplunkLb$Outbound` instead. */
  export type Outbound = TLSSettingsClientSideSplunkLb$Outbound;
}

export function tlsSettingsClientSideSplunkLbToJSON(
  tlsSettingsClientSideSplunkLb: TLSSettingsClientSideSplunkLb,
): string {
  return JSON.stringify(
    TLSSettingsClientSideSplunkLb$outboundSchema.parse(
      tlsSettingsClientSideSplunkLb,
    ),
  );
}

export function tlsSettingsClientSideSplunkLbFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsClientSideSplunkLb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsClientSideSplunkLb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsClientSideSplunkLb' from JSON`,
  );
}

/** @internal */
export const MaxS2SVersionSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof MaxS2SVersionSplunkLb
> = z.nativeEnum(MaxS2SVersionSplunkLb);

/** @internal */
export const MaxS2SVersionSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof MaxS2SVersionSplunkLb
> = MaxS2SVersionSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaxS2SVersionSplunkLb$ {
  /** @deprecated use `MaxS2SVersionSplunkLb$inboundSchema` instead. */
  export const inboundSchema = MaxS2SVersionSplunkLb$inboundSchema;
  /** @deprecated use `MaxS2SVersionSplunkLb$outboundSchema` instead. */
  export const outboundSchema = MaxS2SVersionSplunkLb$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSplunkLb
> = z.nativeEnum(BackpressureBehaviorSplunkLb);

/** @internal */
export const BackpressureBehaviorSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSplunkLb
> = BackpressureBehaviorSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSplunkLb$ {
  /** @deprecated use `BackpressureBehaviorSplunkLb$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSplunkLb$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSplunkLb$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSplunkLb$outboundSchema;
}

/** @internal */
export const AuthenticationMethodSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSplunkLb
> = z.nativeEnum(AuthenticationMethodSplunkLb);

/** @internal */
export const AuthenticationMethodSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSplunkLb
> = AuthenticationMethodSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodSplunkLb$ {
  /** @deprecated use `AuthenticationMethodSplunkLb$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodSplunkLb$inboundSchema;
  /** @deprecated use `AuthenticationMethodSplunkLb$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodSplunkLb$outboundSchema;
}

/** @internal */
export const CompressCompressionSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof CompressCompressionSplunkLb
> = z.nativeEnum(CompressCompressionSplunkLb);

/** @internal */
export const CompressCompressionSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof CompressCompressionSplunkLb
> = CompressCompressionSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressCompressionSplunkLb$ {
  /** @deprecated use `CompressCompressionSplunkLb$inboundSchema` instead. */
  export const inboundSchema = CompressCompressionSplunkLb$inboundSchema;
  /** @deprecated use `CompressCompressionSplunkLb$outboundSchema` instead. */
  export const outboundSchema = CompressCompressionSplunkLb$outboundSchema;
}

/** @internal */
export const IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema:
  z.ZodNativeEnum<typeof IndexerDiscoveryConfigsAuthTokenAuthenticationMethod> =
    z.nativeEnum(IndexerDiscoveryConfigsAuthTokenAuthenticationMethod);

/** @internal */
export const IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema:
  z.ZodNativeEnum<typeof IndexerDiscoveryConfigsAuthTokenAuthenticationMethod> =
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$ {
  /** @deprecated use `IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema;
}

/** @internal */
export const CreateOutputAuthToken$inboundSchema: z.ZodType<
  CreateOutputAuthToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$inboundSchema
    .default("manual"),
});

/** @internal */
export type CreateOutputAuthToken$Outbound = {
  authType: string;
};

/** @internal */
export const CreateOutputAuthToken$outboundSchema: z.ZodType<
  CreateOutputAuthToken$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthToken
> = z.object({
  authType: IndexerDiscoveryConfigsAuthTokenAuthenticationMethod$outboundSchema
    .default("manual"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputAuthToken$ {
  /** @deprecated use `CreateOutputAuthToken$inboundSchema` instead. */
  export const inboundSchema = CreateOutputAuthToken$inboundSchema;
  /** @deprecated use `CreateOutputAuthToken$outboundSchema` instead. */
  export const outboundSchema = CreateOutputAuthToken$outboundSchema;
  /** @deprecated use `CreateOutputAuthToken$Outbound` instead. */
  export type Outbound = CreateOutputAuthToken$Outbound;
}

export function createOutputAuthTokenToJSON(
  createOutputAuthToken: CreateOutputAuthToken,
): string {
  return JSON.stringify(
    CreateOutputAuthToken$outboundSchema.parse(createOutputAuthToken),
  );
}

export function createOutputAuthTokenFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputAuthToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputAuthToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputAuthToken' from JSON`,
  );
}

/** @internal */
export const IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema:
  z.ZodNativeEnum<typeof IndexerDiscoveryConfigsAuthenticationMethod> = z
    .nativeEnum(IndexerDiscoveryConfigsAuthenticationMethod);

/** @internal */
export const IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema:
  z.ZodNativeEnum<typeof IndexerDiscoveryConfigsAuthenticationMethod> =
    IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IndexerDiscoveryConfigsAuthenticationMethod$ {
  /** @deprecated use `IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema;
}

/** @internal */
export const IndexerDiscoveryConfigs$inboundSchema: z.ZodType<
  IndexerDiscoveryConfigs,
  z.ZodTypeDef,
  unknown
> = z.object({
  site: z.string().default("default"),
  masterUri: z.string(),
  refreshIntervalSec: z.number().default(300),
  rejectUnauthorized: z.boolean().default(false),
  authTokens: z.array(z.lazy(() => CreateOutputAuthToken$inboundSchema))
    .optional(),
  authType: IndexerDiscoveryConfigsAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type IndexerDiscoveryConfigs$Outbound = {
  site: string;
  masterUri: string;
  refreshIntervalSec: number;
  rejectUnauthorized: boolean;
  authTokens?: Array<CreateOutputAuthToken$Outbound> | undefined;
  authType: string;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const IndexerDiscoveryConfigs$outboundSchema: z.ZodType<
  IndexerDiscoveryConfigs$Outbound,
  z.ZodTypeDef,
  IndexerDiscoveryConfigs
> = z.object({
  site: z.string().default("default"),
  masterUri: z.string(),
  refreshIntervalSec: z.number().default(300),
  rejectUnauthorized: z.boolean().default(false),
  authTokens: z.array(z.lazy(() => CreateOutputAuthToken$outboundSchema))
    .optional(),
  authType: IndexerDiscoveryConfigsAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IndexerDiscoveryConfigs$ {
  /** @deprecated use `IndexerDiscoveryConfigs$inboundSchema` instead. */
  export const inboundSchema = IndexerDiscoveryConfigs$inboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigs$outboundSchema` instead. */
  export const outboundSchema = IndexerDiscoveryConfigs$outboundSchema;
  /** @deprecated use `IndexerDiscoveryConfigs$Outbound` instead. */
  export type Outbound = IndexerDiscoveryConfigs$Outbound;
}

export function indexerDiscoveryConfigsToJSON(
  indexerDiscoveryConfigs: IndexerDiscoveryConfigs,
): string {
  return JSON.stringify(
    IndexerDiscoveryConfigs$outboundSchema.parse(indexerDiscoveryConfigs),
  );
}

export function indexerDiscoveryConfigsFromJSON(
  jsonString: string,
): SafeParseResult<IndexerDiscoveryConfigs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IndexerDiscoveryConfigs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IndexerDiscoveryConfigs' from JSON`,
  );
}

/** @internal */
export const Tls$inboundSchema: z.ZodNativeEnum<typeof Tls> = z.nativeEnum(Tls);

/** @internal */
export const Tls$outboundSchema: z.ZodNativeEnum<typeof Tls> =
  Tls$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tls$ {
  /** @deprecated use `Tls$inboundSchema` instead. */
  export const inboundSchema = Tls$inboundSchema;
  /** @deprecated use `Tls$outboundSchema` instead. */
  export const outboundSchema = Tls$outboundSchema;
}

/** @internal */
export const HostSplunkLb$inboundSchema: z.ZodType<
  HostSplunkLb,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  port: z.number().default(9997),
  tls: Tls$inboundSchema.default("inherit"),
  servername: z.string().optional(),
  weight: z.number().default(1),
});

/** @internal */
export type HostSplunkLb$Outbound = {
  host: string;
  port: number;
  tls: string;
  servername?: string | undefined;
  weight: number;
};

/** @internal */
export const HostSplunkLb$outboundSchema: z.ZodType<
  HostSplunkLb$Outbound,
  z.ZodTypeDef,
  HostSplunkLb
> = z.object({
  host: z.string(),
  port: z.number().default(9997),
  tls: Tls$outboundSchema.default("inherit"),
  servername: z.string().optional(),
  weight: z.number().default(1),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HostSplunkLb$ {
  /** @deprecated use `HostSplunkLb$inboundSchema` instead. */
  export const inboundSchema = HostSplunkLb$inboundSchema;
  /** @deprecated use `HostSplunkLb$outboundSchema` instead. */
  export const outboundSchema = HostSplunkLb$outboundSchema;
  /** @deprecated use `HostSplunkLb$Outbound` instead. */
  export type Outbound = HostSplunkLb$Outbound;
}

export function hostSplunkLbToJSON(hostSplunkLb: HostSplunkLb): string {
  return JSON.stringify(HostSplunkLb$outboundSchema.parse(hostSplunkLb));
}

export function hostSplunkLbFromJSON(
  jsonString: string,
): SafeParseResult<HostSplunkLb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HostSplunkLb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HostSplunkLb' from JSON`,
  );
}

/** @internal */
export const PqCompressCompressionSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionSplunkLb
> = z.nativeEnum(PqCompressCompressionSplunkLb);

/** @internal */
export const PqCompressCompressionSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionSplunkLb
> = PqCompressCompressionSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionSplunkLb$ {
  /** @deprecated use `PqCompressCompressionSplunkLb$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionSplunkLb$inboundSchema;
  /** @deprecated use `PqCompressCompressionSplunkLb$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionSplunkLb$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSplunkLb$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSplunkLb
> = z.nativeEnum(QueueFullBehaviorSplunkLb);

/** @internal */
export const QueueFullBehaviorSplunkLb$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSplunkLb
> = QueueFullBehaviorSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSplunkLb$ {
  /** @deprecated use `QueueFullBehaviorSplunkLb$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSplunkLb$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSplunkLb$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorSplunkLb$outboundSchema;
}

/** @internal */
export const ModeSplunkLb$inboundSchema: z.ZodNativeEnum<typeof ModeSplunkLb> =
  z.nativeEnum(ModeSplunkLb);

/** @internal */
export const ModeSplunkLb$outboundSchema: z.ZodNativeEnum<typeof ModeSplunkLb> =
  ModeSplunkLb$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSplunkLb$ {
  /** @deprecated use `ModeSplunkLb$inboundSchema` instead. */
  export const inboundSchema = ModeSplunkLb$inboundSchema;
  /** @deprecated use `ModeSplunkLb$outboundSchema` instead. */
  export const outboundSchema = ModeSplunkLb$outboundSchema;
}

/** @internal */
export const PqControlsSplunkLb$inboundSchema: z.ZodType<
  PqControlsSplunkLb,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSplunkLb$Outbound = {};

/** @internal */
export const PqControlsSplunkLb$outboundSchema: z.ZodType<
  PqControlsSplunkLb$Outbound,
  z.ZodTypeDef,
  PqControlsSplunkLb
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSplunkLb$ {
  /** @deprecated use `PqControlsSplunkLb$inboundSchema` instead. */
  export const inboundSchema = PqControlsSplunkLb$inboundSchema;
  /** @deprecated use `PqControlsSplunkLb$outboundSchema` instead. */
  export const outboundSchema = PqControlsSplunkLb$outboundSchema;
  /** @deprecated use `PqControlsSplunkLb$Outbound` instead. */
  export type Outbound = PqControlsSplunkLb$Outbound;
}

export function pqControlsSplunkLbToJSON(
  pqControlsSplunkLb: PqControlsSplunkLb,
): string {
  return JSON.stringify(
    PqControlsSplunkLb$outboundSchema.parse(pqControlsSplunkLb),
  );
}

export function pqControlsSplunkLbFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSplunkLb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSplunkLb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSplunkLb' from JSON`,
  );
}

/** @internal */
export const OutputSplunkLb$inboundSchema: z.ZodType<
  OutputSplunkLb,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSplunkLb$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  maxConcurrentSenders: z.number().default(0),
  nestedFields: NestedFieldSerializationSplunkLb$inboundSchema.default("none"),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => TLSSettingsClientSideSplunkLb$inboundSchema).optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: MaxS2SVersionSplunkLb$inboundSchema.default("v3"),
  onBackpressure: BackpressureBehaviorSplunkLb$inboundSchema.default("block"),
  indexerDiscovery: z.boolean().default(false),
  senderUnhealthyTimeAllowance: z.number().default(100),
  authType: AuthenticationMethodSplunkLb$inboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: CompressCompressionSplunkLb$inboundSchema.default("disabled"),
  indexerDiscoveryConfigs: z.lazy(() => IndexerDiscoveryConfigs$inboundSchema)
    .optional(),
  excludeSelf: z.boolean().default(false),
  hosts: z.array(z.lazy(() => HostSplunkLb$inboundSchema)),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionSplunkLb$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSplunkLb$inboundSchema.default("block"),
  pqMode: ModeSplunkLb$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSplunkLb$inboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputSplunkLb$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
  maxConcurrentSenders: number;
  nestedFields: string;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  tls?: TLSSettingsClientSideSplunkLb$Outbound | undefined;
  enableMultiMetrics: boolean;
  enableACK: boolean;
  logFailedRequests: boolean;
  maxS2Sversion: string;
  onBackpressure: string;
  indexerDiscovery: boolean;
  senderUnhealthyTimeAllowance: number;
  authType: string;
  description?: string | undefined;
  maxFailedHealthChecks: number;
  compress: string;
  indexerDiscoveryConfigs?: IndexerDiscoveryConfigs$Outbound | undefined;
  excludeSelf: boolean;
  hosts: Array<HostSplunkLb$Outbound>;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSplunkLb$Outbound | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputSplunkLb$outboundSchema: z.ZodType<
  OutputSplunkLb$Outbound,
  z.ZodTypeDef,
  OutputSplunkLb
> = z.object({
  id: z.string(),
  type: TypeSplunkLb$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
  maxConcurrentSenders: z.number().default(0),
  nestedFields: NestedFieldSerializationSplunkLb$outboundSchema.default("none"),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => TLSSettingsClientSideSplunkLb$outboundSchema).optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: MaxS2SVersionSplunkLb$outboundSchema.default("v3"),
  onBackpressure: BackpressureBehaviorSplunkLb$outboundSchema.default("block"),
  indexerDiscovery: z.boolean().default(false),
  senderUnhealthyTimeAllowance: z.number().default(100),
  authType: AuthenticationMethodSplunkLb$outboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: CompressCompressionSplunkLb$outboundSchema.default("disabled"),
  indexerDiscoveryConfigs: z.lazy(() => IndexerDiscoveryConfigs$outboundSchema)
    .optional(),
  excludeSelf: z.boolean().default(false),
  hosts: z.array(z.lazy(() => HostSplunkLb$outboundSchema)),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionSplunkLb$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSplunkLb$outboundSchema.default("block"),
  pqMode: ModeSplunkLb$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSplunkLb$outboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunkLb$ {
  /** @deprecated use `OutputSplunkLb$inboundSchema` instead. */
  export const inboundSchema = OutputSplunkLb$inboundSchema;
  /** @deprecated use `OutputSplunkLb$outboundSchema` instead. */
  export const outboundSchema = OutputSplunkLb$outboundSchema;
  /** @deprecated use `OutputSplunkLb$Outbound` instead. */
  export type Outbound = OutputSplunkLb$Outbound;
}

export function outputSplunkLbToJSON(outputSplunkLb: OutputSplunkLb): string {
  return JSON.stringify(OutputSplunkLb$outboundSchema.parse(outputSplunkLb));
}

export function outputSplunkLbFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunkLb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunkLb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunkLb' from JSON`,
  );
}

/** @internal */
export const CreateOutputTypeSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSplunk
> = z.nativeEnum(CreateOutputTypeSplunk);

/** @internal */
export const CreateOutputTypeSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputTypeSplunk
> = CreateOutputTypeSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputTypeSplunk$ {
  /** @deprecated use `CreateOutputTypeSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputTypeSplunk$inboundSchema;
  /** @deprecated use `CreateOutputTypeSplunk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputTypeSplunk$outboundSchema;
}

/** @internal */
export const NestedFieldSerializationSplunk$inboundSchema: z.ZodNativeEnum<
  typeof NestedFieldSerializationSplunk
> = z.nativeEnum(NestedFieldSerializationSplunk);

/** @internal */
export const NestedFieldSerializationSplunk$outboundSchema: z.ZodNativeEnum<
  typeof NestedFieldSerializationSplunk
> = NestedFieldSerializationSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NestedFieldSerializationSplunk$ {
  /** @deprecated use `NestedFieldSerializationSplunk$inboundSchema` instead. */
  export const inboundSchema = NestedFieldSerializationSplunk$inboundSchema;
  /** @deprecated use `NestedFieldSerializationSplunk$outboundSchema` instead. */
  export const outboundSchema = NestedFieldSerializationSplunk$outboundSchema;
}

/** @internal */
export const CreateOutputMinimumTLSVersionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMinimumTLSVersionSplunk
> = z.nativeEnum(CreateOutputMinimumTLSVersionSplunk);

/** @internal */
export const CreateOutputMinimumTLSVersionSplunk$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMinimumTLSVersionSplunk> =
    CreateOutputMinimumTLSVersionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMinimumTLSVersionSplunk$ {
  /** @deprecated use `CreateOutputMinimumTLSVersionSplunk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputMinimumTLSVersionSplunk$inboundSchema;
  /** @deprecated use `CreateOutputMinimumTLSVersionSplunk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMinimumTLSVersionSplunk$outboundSchema;
}

/** @internal */
export const CreateOutputMaximumTLSVersionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMaximumTLSVersionSplunk
> = z.nativeEnum(CreateOutputMaximumTLSVersionSplunk);

/** @internal */
export const CreateOutputMaximumTLSVersionSplunk$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputMaximumTLSVersionSplunk> =
    CreateOutputMaximumTLSVersionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMaximumTLSVersionSplunk$ {
  /** @deprecated use `CreateOutputMaximumTLSVersionSplunk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputMaximumTLSVersionSplunk$inboundSchema;
  /** @deprecated use `CreateOutputMaximumTLSVersionSplunk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputMaximumTLSVersionSplunk$outboundSchema;
}

/** @internal */
export const TLSSettingsClientSideSplunk$inboundSchema: z.ZodType<
  TLSSettingsClientSideSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionSplunk$inboundSchema.optional(),
  maxVersion: CreateOutputMaximumTLSVersionSplunk$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsClientSideSplunk$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsClientSideSplunk$outboundSchema: z.ZodType<
  TLSSettingsClientSideSplunk$Outbound,
  z.ZodTypeDef,
  TLSSettingsClientSideSplunk
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateOutputMinimumTLSVersionSplunk$outboundSchema.optional(),
  maxVersion: CreateOutputMaximumTLSVersionSplunk$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsClientSideSplunk$ {
  /** @deprecated use `TLSSettingsClientSideSplunk$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsClientSideSplunk$inboundSchema;
  /** @deprecated use `TLSSettingsClientSideSplunk$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsClientSideSplunk$outboundSchema;
  /** @deprecated use `TLSSettingsClientSideSplunk$Outbound` instead. */
  export type Outbound = TLSSettingsClientSideSplunk$Outbound;
}

export function tlsSettingsClientSideSplunkToJSON(
  tlsSettingsClientSideSplunk: TLSSettingsClientSideSplunk,
): string {
  return JSON.stringify(
    TLSSettingsClientSideSplunk$outboundSchema.parse(
      tlsSettingsClientSideSplunk,
    ),
  );
}

export function tlsSettingsClientSideSplunkFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsClientSideSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsClientSideSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsClientSideSplunk' from JSON`,
  );
}

/** @internal */
export const CreateOutputMaxS2SVersionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMaxS2SVersionSplunk
> = z.nativeEnum(CreateOutputMaxS2SVersionSplunk);

/** @internal */
export const CreateOutputMaxS2SVersionSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputMaxS2SVersionSplunk
> = CreateOutputMaxS2SVersionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputMaxS2SVersionSplunk$ {
  /** @deprecated use `CreateOutputMaxS2SVersionSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputMaxS2SVersionSplunk$inboundSchema;
  /** @deprecated use `CreateOutputMaxS2SVersionSplunk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputMaxS2SVersionSplunk$outboundSchema;
}

/** @internal */
export const BackpressureBehaviorSplunk$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSplunk
> = z.nativeEnum(BackpressureBehaviorSplunk);

/** @internal */
export const BackpressureBehaviorSplunk$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSplunk
> = BackpressureBehaviorSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSplunk$ {
  /** @deprecated use `BackpressureBehaviorSplunk$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSplunk$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSplunk$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSplunk$outboundSchema;
}

/** @internal */
export const AuthenticationMethodSplunk$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSplunk
> = z.nativeEnum(AuthenticationMethodSplunk);

/** @internal */
export const AuthenticationMethodSplunk$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSplunk
> = AuthenticationMethodSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodSplunk$ {
  /** @deprecated use `AuthenticationMethodSplunk$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodSplunk$inboundSchema;
  /** @deprecated use `AuthenticationMethodSplunk$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodSplunk$outboundSchema;
}

/** @internal */
export const CreateOutputCompressCompressionSplunk$inboundSchema:
  z.ZodNativeEnum<typeof CreateOutputCompressCompressionSplunk> = z.nativeEnum(
    CreateOutputCompressCompressionSplunk,
  );

/** @internal */
export const CreateOutputCompressCompressionSplunk$outboundSchema:
  z.ZodNativeEnum<typeof CreateOutputCompressCompressionSplunk> =
    CreateOutputCompressCompressionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputCompressCompressionSplunk$ {
  /** @deprecated use `CreateOutputCompressCompressionSplunk$inboundSchema` instead. */
  export const inboundSchema =
    CreateOutputCompressCompressionSplunk$inboundSchema;
  /** @deprecated use `CreateOutputCompressCompressionSplunk$outboundSchema` instead. */
  export const outboundSchema =
    CreateOutputCompressCompressionSplunk$outboundSchema;
}

/** @internal */
export const PqCompressCompressionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionSplunk
> = z.nativeEnum(PqCompressCompressionSplunk);

/** @internal */
export const PqCompressCompressionSplunk$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressCompressionSplunk
> = PqCompressCompressionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressCompressionSplunk$ {
  /** @deprecated use `PqCompressCompressionSplunk$inboundSchema` instead. */
  export const inboundSchema = PqCompressCompressionSplunk$inboundSchema;
  /** @deprecated use `PqCompressCompressionSplunk$outboundSchema` instead. */
  export const outboundSchema = PqCompressCompressionSplunk$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSplunk$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSplunk
> = z.nativeEnum(QueueFullBehaviorSplunk);

/** @internal */
export const QueueFullBehaviorSplunk$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSplunk
> = QueueFullBehaviorSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSplunk$ {
  /** @deprecated use `QueueFullBehaviorSplunk$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSplunk$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSplunk$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorSplunk$outboundSchema;
}

/** @internal */
export const CreateOutputModeSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeSplunk
> = z.nativeEnum(CreateOutputModeSplunk);

/** @internal */
export const CreateOutputModeSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateOutputModeSplunk
> = CreateOutputModeSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputModeSplunk$ {
  /** @deprecated use `CreateOutputModeSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateOutputModeSplunk$inboundSchema;
  /** @deprecated use `CreateOutputModeSplunk$outboundSchema` instead. */
  export const outboundSchema = CreateOutputModeSplunk$outboundSchema;
}

/** @internal */
export const PqControlsSplunk$inboundSchema: z.ZodType<
  PqControlsSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSplunk$Outbound = {};

/** @internal */
export const PqControlsSplunk$outboundSchema: z.ZodType<
  PqControlsSplunk$Outbound,
  z.ZodTypeDef,
  PqControlsSplunk
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSplunk$ {
  /** @deprecated use `PqControlsSplunk$inboundSchema` instead. */
  export const inboundSchema = PqControlsSplunk$inboundSchema;
  /** @deprecated use `PqControlsSplunk$outboundSchema` instead. */
  export const outboundSchema = PqControlsSplunk$outboundSchema;
  /** @deprecated use `PqControlsSplunk$Outbound` instead. */
  export type Outbound = PqControlsSplunk$Outbound;
}

export function pqControlsSplunkToJSON(
  pqControlsSplunk: PqControlsSplunk,
): string {
  return JSON.stringify(
    PqControlsSplunk$outboundSchema.parse(pqControlsSplunk),
  );
}

export function pqControlsSplunkFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSplunk' from JSON`,
  );
}

/** @internal */
export const OutputSplunk$inboundSchema: z.ZodType<
  OutputSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSplunk$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  host: z.string(),
  port: z.number().default(9997),
  nestedFields: NestedFieldSerializationSplunk$inboundSchema.default("none"),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => TLSSettingsClientSideSplunk$inboundSchema).optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: CreateOutputMaxS2SVersionSplunk$inboundSchema.default("v3"),
  onBackpressure: BackpressureBehaviorSplunk$inboundSchema.default("block"),
  authType: AuthenticationMethodSplunk$inboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: CreateOutputCompressCompressionSplunk$inboundSchema.default(
    "disabled",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionSplunk$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSplunk$inboundSchema.default("block"),
  pqMode: CreateOutputModeSplunk$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSplunk$inboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type OutputSplunk$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  host: string;
  port: number;
  nestedFields: string;
  throttleRatePerSec: string;
  connectionTimeout: number;
  writeTimeout: number;
  tls?: TLSSettingsClientSideSplunk$Outbound | undefined;
  enableMultiMetrics: boolean;
  enableACK: boolean;
  logFailedRequests: boolean;
  maxS2Sversion: string;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  maxFailedHealthChecks: number;
  compress: string;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSplunk$Outbound | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputSplunk$outboundSchema: z.ZodType<
  OutputSplunk$Outbound,
  z.ZodTypeDef,
  OutputSplunk
> = z.object({
  id: z.string(),
  type: CreateOutputTypeSplunk$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  host: z.string(),
  port: z.number().default(9997),
  nestedFields: NestedFieldSerializationSplunk$outboundSchema.default("none"),
  throttleRatePerSec: z.string().default("0"),
  connectionTimeout: z.number().default(10000),
  writeTimeout: z.number().default(60000),
  tls: z.lazy(() => TLSSettingsClientSideSplunk$outboundSchema).optional(),
  enableMultiMetrics: z.boolean().default(false),
  enableACK: z.boolean().default(true),
  logFailedRequests: z.boolean().default(false),
  maxS2Sversion: CreateOutputMaxS2SVersionSplunk$outboundSchema.default("v3"),
  onBackpressure: BackpressureBehaviorSplunk$outboundSchema.default("block"),
  authType: AuthenticationMethodSplunk$outboundSchema.default("manual"),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().default(1),
  compress: CreateOutputCompressCompressionSplunk$outboundSchema.default(
    "disabled",
  ),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressCompressionSplunk$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSplunk$outboundSchema.default("block"),
  pqMode: CreateOutputModeSplunk$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSplunk$outboundSchema).optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSplunk$ {
  /** @deprecated use `OutputSplunk$inboundSchema` instead. */
  export const inboundSchema = OutputSplunk$inboundSchema;
  /** @deprecated use `OutputSplunk$outboundSchema` instead. */
  export const outboundSchema = OutputSplunk$outboundSchema;
  /** @deprecated use `OutputSplunk$Outbound` instead. */
  export type Outbound = OutputSplunk$Outbound;
}

export function outputSplunkToJSON(outputSplunk: OutputSplunk): string {
  return JSON.stringify(OutputSplunk$outboundSchema.parse(outputSplunk));
}

export function outputSplunkFromJSON(
  jsonString: string,
): SafeParseResult<OutputSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSplunk' from JSON`,
  );
}

/** @internal */
export const TypeSentinel$inboundSchema: z.ZodNativeEnum<typeof TypeSentinel> =
  z.nativeEnum(TypeSentinel);

/** @internal */
export const TypeSentinel$outboundSchema: z.ZodNativeEnum<typeof TypeSentinel> =
  TypeSentinel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSentinel$ {
  /** @deprecated use `TypeSentinel$inboundSchema` instead. */
  export const inboundSchema = TypeSentinel$inboundSchema;
  /** @deprecated use `TypeSentinel$outboundSchema` instead. */
  export const outboundSchema = TypeSentinel$outboundSchema;
}

/** @internal */
export const ExtraHttpHeaderSentinel$inboundSchema: z.ZodType<
  ExtraHttpHeaderSentinel,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type ExtraHttpHeaderSentinel$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const ExtraHttpHeaderSentinel$outboundSchema: z.ZodType<
  ExtraHttpHeaderSentinel$Outbound,
  z.ZodTypeDef,
  ExtraHttpHeaderSentinel
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtraHttpHeaderSentinel$ {
  /** @deprecated use `ExtraHttpHeaderSentinel$inboundSchema` instead. */
  export const inboundSchema = ExtraHttpHeaderSentinel$inboundSchema;
  /** @deprecated use `ExtraHttpHeaderSentinel$outboundSchema` instead. */
  export const outboundSchema = ExtraHttpHeaderSentinel$outboundSchema;
  /** @deprecated use `ExtraHttpHeaderSentinel$Outbound` instead. */
  export type Outbound = ExtraHttpHeaderSentinel$Outbound;
}

export function extraHttpHeaderSentinelToJSON(
  extraHttpHeaderSentinel: ExtraHttpHeaderSentinel,
): string {
  return JSON.stringify(
    ExtraHttpHeaderSentinel$outboundSchema.parse(extraHttpHeaderSentinel),
  );
}

export function extraHttpHeaderSentinelFromJSON(
  jsonString: string,
): SafeParseResult<ExtraHttpHeaderSentinel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtraHttpHeaderSentinel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtraHttpHeaderSentinel' from JSON`,
  );
}

/** @internal */
export const FailedRequestLoggingModeSentinel$inboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeSentinel
> = z.nativeEnum(FailedRequestLoggingModeSentinel);

/** @internal */
export const FailedRequestLoggingModeSentinel$outboundSchema: z.ZodNativeEnum<
  typeof FailedRequestLoggingModeSentinel
> = FailedRequestLoggingModeSentinel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedRequestLoggingModeSentinel$ {
  /** @deprecated use `FailedRequestLoggingModeSentinel$inboundSchema` instead. */
  export const inboundSchema = FailedRequestLoggingModeSentinel$inboundSchema;
  /** @deprecated use `FailedRequestLoggingModeSentinel$outboundSchema` instead. */
  export const outboundSchema = FailedRequestLoggingModeSentinel$outboundSchema;
}

/** @internal */
export const ResponseRetrySettingSentinel$inboundSchema: z.ZodType<
  ResponseRetrySettingSentinel,
  z.ZodTypeDef,
  unknown
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type ResponseRetrySettingSentinel$Outbound = {
  httpStatus: number;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const ResponseRetrySettingSentinel$outboundSchema: z.ZodType<
  ResponseRetrySettingSentinel$Outbound,
  z.ZodTypeDef,
  ResponseRetrySettingSentinel
> = z.object({
  httpStatus: z.number(),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseRetrySettingSentinel$ {
  /** @deprecated use `ResponseRetrySettingSentinel$inboundSchema` instead. */
  export const inboundSchema = ResponseRetrySettingSentinel$inboundSchema;
  /** @deprecated use `ResponseRetrySettingSentinel$outboundSchema` instead. */
  export const outboundSchema = ResponseRetrySettingSentinel$outboundSchema;
  /** @deprecated use `ResponseRetrySettingSentinel$Outbound` instead. */
  export type Outbound = ResponseRetrySettingSentinel$Outbound;
}

export function responseRetrySettingSentinelToJSON(
  responseRetrySettingSentinel: ResponseRetrySettingSentinel,
): string {
  return JSON.stringify(
    ResponseRetrySettingSentinel$outboundSchema.parse(
      responseRetrySettingSentinel,
    ),
  );
}

export function responseRetrySettingSentinelFromJSON(
  jsonString: string,
): SafeParseResult<ResponseRetrySettingSentinel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseRetrySettingSentinel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseRetrySettingSentinel' from JSON`,
  );
}

/** @internal */
export const TimeoutRetrySettingsSentinel$inboundSchema: z.ZodType<
  TimeoutRetrySettingsSentinel,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/** @internal */
export type TimeoutRetrySettingsSentinel$Outbound = {
  timeoutRetry: boolean;
  initialBackoff: number;
  backoffRate: number;
  maxBackoff: number;
};

/** @internal */
export const TimeoutRetrySettingsSentinel$outboundSchema: z.ZodType<
  TimeoutRetrySettingsSentinel$Outbound,
  z.ZodTypeDef,
  TimeoutRetrySettingsSentinel
> = z.object({
  timeoutRetry: z.boolean().default(false),
  initialBackoff: z.number().default(1000),
  backoffRate: z.number().default(2),
  maxBackoff: z.number().default(10000),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeoutRetrySettingsSentinel$ {
  /** @deprecated use `TimeoutRetrySettingsSentinel$inboundSchema` instead. */
  export const inboundSchema = TimeoutRetrySettingsSentinel$inboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSentinel$outboundSchema` instead. */
  export const outboundSchema = TimeoutRetrySettingsSentinel$outboundSchema;
  /** @deprecated use `TimeoutRetrySettingsSentinel$Outbound` instead. */
  export type Outbound = TimeoutRetrySettingsSentinel$Outbound;
}

export function timeoutRetrySettingsSentinelToJSON(
  timeoutRetrySettingsSentinel: TimeoutRetrySettingsSentinel,
): string {
  return JSON.stringify(
    TimeoutRetrySettingsSentinel$outboundSchema.parse(
      timeoutRetrySettingsSentinel,
    ),
  );
}

export function timeoutRetrySettingsSentinelFromJSON(
  jsonString: string,
): SafeParseResult<TimeoutRetrySettingsSentinel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeoutRetrySettingsSentinel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeoutRetrySettingsSentinel' from JSON`,
  );
}

/** @internal */
export const BackpressureBehaviorSentinel$inboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSentinel
> = z.nativeEnum(BackpressureBehaviorSentinel);

/** @internal */
export const BackpressureBehaviorSentinel$outboundSchema: z.ZodNativeEnum<
  typeof BackpressureBehaviorSentinel
> = BackpressureBehaviorSentinel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackpressureBehaviorSentinel$ {
  /** @deprecated use `BackpressureBehaviorSentinel$inboundSchema` instead. */
  export const inboundSchema = BackpressureBehaviorSentinel$inboundSchema;
  /** @deprecated use `BackpressureBehaviorSentinel$outboundSchema` instead. */
  export const outboundSchema = BackpressureBehaviorSentinel$outboundSchema;
}

/** @internal */
export const AuthType$inboundSchema: z.ZodNativeEnum<typeof AuthType> = z
  .nativeEnum(AuthType);

/** @internal */
export const AuthType$outboundSchema: z.ZodNativeEnum<typeof AuthType> =
  AuthType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthType$ {
  /** @deprecated use `AuthType$inboundSchema` instead. */
  export const inboundSchema = AuthType$inboundSchema;
  /** @deprecated use `AuthType$outboundSchema` instead. */
  export const outboundSchema = AuthType$outboundSchema;
}

/** @internal */
export const EndpointConfiguration$inboundSchema: z.ZodNativeEnum<
  typeof EndpointConfiguration
> = z.nativeEnum(EndpointConfiguration);

/** @internal */
export const EndpointConfiguration$outboundSchema: z.ZodNativeEnum<
  typeof EndpointConfiguration
> = EndpointConfiguration$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointConfiguration$ {
  /** @deprecated use `EndpointConfiguration$inboundSchema` instead. */
  export const inboundSchema = EndpointConfiguration$inboundSchema;
  /** @deprecated use `EndpointConfiguration$outboundSchema` instead. */
  export const outboundSchema = EndpointConfiguration$outboundSchema;
}

/** @internal */
export const FormatSentinel$inboundSchema: z.ZodNativeEnum<
  typeof FormatSentinel
> = z.nativeEnum(FormatSentinel);

/** @internal */
export const FormatSentinel$outboundSchema: z.ZodNativeEnum<
  typeof FormatSentinel
> = FormatSentinel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatSentinel$ {
  /** @deprecated use `FormatSentinel$inboundSchema` instead. */
  export const inboundSchema = FormatSentinel$inboundSchema;
  /** @deprecated use `FormatSentinel$outboundSchema` instead. */
  export const outboundSchema = FormatSentinel$outboundSchema;
}

/** @internal */
export const CompressionSentinel$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSentinel
> = z.nativeEnum(CompressionSentinel);

/** @internal */
export const CompressionSentinel$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSentinel
> = CompressionSentinel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSentinel$ {
  /** @deprecated use `CompressionSentinel$inboundSchema` instead. */
  export const inboundSchema = CompressionSentinel$inboundSchema;
  /** @deprecated use `CompressionSentinel$outboundSchema` instead. */
  export const outboundSchema = CompressionSentinel$outboundSchema;
}

/** @internal */
export const QueueFullBehaviorSentinel$inboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSentinel
> = z.nativeEnum(QueueFullBehaviorSentinel);

/** @internal */
export const QueueFullBehaviorSentinel$outboundSchema: z.ZodNativeEnum<
  typeof QueueFullBehaviorSentinel
> = QueueFullBehaviorSentinel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueueFullBehaviorSentinel$ {
  /** @deprecated use `QueueFullBehaviorSentinel$inboundSchema` instead. */
  export const inboundSchema = QueueFullBehaviorSentinel$inboundSchema;
  /** @deprecated use `QueueFullBehaviorSentinel$outboundSchema` instead. */
  export const outboundSchema = QueueFullBehaviorSentinel$outboundSchema;
}

/** @internal */
export const ModeSentinel$inboundSchema: z.ZodNativeEnum<typeof ModeSentinel> =
  z.nativeEnum(ModeSentinel);

/** @internal */
export const ModeSentinel$outboundSchema: z.ZodNativeEnum<typeof ModeSentinel> =
  ModeSentinel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSentinel$ {
  /** @deprecated use `ModeSentinel$inboundSchema` instead. */
  export const inboundSchema = ModeSentinel$inboundSchema;
  /** @deprecated use `ModeSentinel$outboundSchema` instead. */
  export const outboundSchema = ModeSentinel$outboundSchema;
}

/** @internal */
export const PqControlsSentinel$inboundSchema: z.ZodType<
  PqControlsSentinel,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type PqControlsSentinel$Outbound = {};

/** @internal */
export const PqControlsSentinel$outboundSchema: z.ZodType<
  PqControlsSentinel$Outbound,
  z.ZodTypeDef,
  PqControlsSentinel
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqControlsSentinel$ {
  /** @deprecated use `PqControlsSentinel$inboundSchema` instead. */
  export const inboundSchema = PqControlsSentinel$inboundSchema;
  /** @deprecated use `PqControlsSentinel$outboundSchema` instead. */
  export const outboundSchema = PqControlsSentinel$outboundSchema;
  /** @deprecated use `PqControlsSentinel$Outbound` instead. */
  export type Outbound = PqControlsSentinel$Outbound;
}

export function pqControlsSentinelToJSON(
  pqControlsSentinel: PqControlsSentinel,
): string {
  return JSON.stringify(
    PqControlsSentinel$outboundSchema.parse(pqControlsSentinel),
  );
}

export function pqControlsSentinelFromJSON(
  jsonString: string,
): SafeParseResult<PqControlsSentinel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqControlsSentinel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqControlsSentinel' from JSON`,
  );
}

/** @internal */
export const OutputSentinel$inboundSchema: z.ZodType<
  OutputSentinel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSentinel$inboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1000),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(z.lazy(() => ExtraHttpHeaderSentinel$inboundSchema))
    .optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeSentinel$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSentinel$inboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() => TimeoutRetrySettingsSentinel$inboundSchema)
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSentinel$inboundSchema.default("block"),
  authType: AuthType$inboundSchema.optional(),
  loginUrl: z.string(),
  secret: z.string(),
  client_id: z.string(),
  scope: z.string().default("https://monitor.azure.com/.default"),
  endpointURLConfiguration: EndpointConfiguration$inboundSchema.default("url"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  format: FormatSentinel$inboundSchema.optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSentinel$inboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSentinel$inboundSchema.default("block"),
  pqMode: ModeSentinel$inboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSentinel$inboundSchema).optional(),
  url: z.string().optional(),
  dcrID: z.string().optional(),
  dceEndpoint: z.string().optional(),
  streamName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "client_id": "clientId",
  });
});

/** @internal */
export type OutputSentinel$Outbound = {
  id: string;
  type?: string | undefined;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeaderSentinel$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<ResponseRetrySettingSentinel$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsSentinel$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType?: string | undefined;
  loginUrl: string;
  secret: string;
  client_id: string;
  scope: string;
  endpointURLConfiguration: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  format?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqMode: string;
  pqControls?: PqControlsSentinel$Outbound | undefined;
  url?: string | undefined;
  dcrID?: string | undefined;
  dceEndpoint?: string | undefined;
  streamName?: string | undefined;
};

/** @internal */
export const OutputSentinel$outboundSchema: z.ZodType<
  OutputSentinel$Outbound,
  z.ZodTypeDef,
  OutputSentinel
> = z.object({
  id: z.string(),
  type: TypeSentinel$outboundSchema.optional(),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(1000),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(
    z.lazy(() => ExtraHttpHeaderSentinel$outboundSchema),
  ).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeSentinel$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    z.lazy(() => ResponseRetrySettingSentinel$outboundSchema),
  ).optional(),
  timeoutRetrySettings: z.lazy(() =>
    TimeoutRetrySettingsSentinel$outboundSchema
  ).optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: BackpressureBehaviorSentinel$outboundSchema.default("block"),
  authType: AuthType$outboundSchema.optional(),
  loginUrl: z.string(),
  secret: z.string(),
  clientId: z.string(),
  scope: z.string().default("https://monitor.azure.com/.default"),
  endpointURLConfiguration: EndpointConfiguration$outboundSchema.default("url"),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  format: FormatSentinel$outboundSchema.optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: CompressionSentinel$outboundSchema.default("none"),
  pqOnBackpressure: QueueFullBehaviorSentinel$outboundSchema.default("block"),
  pqMode: ModeSentinel$outboundSchema.default("error"),
  pqControls: z.lazy(() => PqControlsSentinel$outboundSchema).optional(),
  url: z.string().optional(),
  dcrID: z.string().optional(),
  dceEndpoint: z.string().optional(),
  streamName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    clientId: "client_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSentinel$ {
  /** @deprecated use `OutputSentinel$inboundSchema` instead. */
  export const inboundSchema = OutputSentinel$inboundSchema;
  /** @deprecated use `OutputSentinel$outboundSchema` instead. */
  export const outboundSchema = OutputSentinel$outboundSchema;
  /** @deprecated use `OutputSentinel$Outbound` instead. */
  export type Outbound = OutputSentinel$Outbound;
}

export function outputSentinelToJSON(outputSentinel: OutputSentinel): string {
  return JSON.stringify(OutputSentinel$outboundSchema.parse(outputSentinel));
}

export function outputSentinelFromJSON(
  jsonString: string,
): SafeParseResult<OutputSentinel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSentinel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSentinel' from JSON`,
  );
}

/** @internal */
export const TypeDefault$inboundSchema: z.ZodNativeEnum<typeof TypeDefault> = z
  .nativeEnum(TypeDefault);

/** @internal */
export const TypeDefault$outboundSchema: z.ZodNativeEnum<typeof TypeDefault> =
  TypeDefault$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeDefault$ {
  /** @deprecated use `TypeDefault$inboundSchema` instead. */
  export const inboundSchema = TypeDefault$inboundSchema;
  /** @deprecated use `TypeDefault$outboundSchema` instead. */
  export const outboundSchema = TypeDefault$outboundSchema;
}

/** @internal */
export const OutputDefault$inboundSchema: z.ZodType<
  OutputDefault,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeDefault$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  defaultId: z.string(),
});

/** @internal */
export type OutputDefault$Outbound = {
  id: string;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  defaultId: string;
};

/** @internal */
export const OutputDefault$outboundSchema: z.ZodType<
  OutputDefault$Outbound,
  z.ZodTypeDef,
  OutputDefault
> = z.object({
  id: z.string(),
  type: TypeDefault$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  defaultId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputDefault$ {
  /** @deprecated use `OutputDefault$inboundSchema` instead. */
  export const inboundSchema = OutputDefault$inboundSchema;
  /** @deprecated use `OutputDefault$outboundSchema` instead. */
  export const outboundSchema = OutputDefault$outboundSchema;
  /** @deprecated use `OutputDefault$Outbound` instead. */
  export type Outbound = OutputDefault$Outbound;
}

export function outputDefaultToJSON(outputDefault: OutputDefault): string {
  return JSON.stringify(OutputDefault$outboundSchema.parse(outputDefault));
}

export function outputDefaultFromJSON(
  jsonString: string,
): SafeParseResult<OutputDefault, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputDefault$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputDefault' from JSON`,
  );
}

/** @internal */
export const CreateOutputRequest$inboundSchema: z.ZodType<
  CreateOutputRequest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OutputAzureDataExplorer$inboundSchema),
  z.lazy(() => OutputSecurityLake$inboundSchema),
  z.lazy(() => OutputSentinel$inboundSchema),
  z.lazy(() => OutputGoogleCloudLogging$inboundSchema),
  z.lazy(() => OutputExabeam$inboundSchema),
  z.lazy(() => OutputMsk$inboundSchema),
  z.lazy(() => OutputCloudwatch$inboundSchema),
  z.lazy(() => OutputClickHouse$inboundSchema),
  z.lazy(() => OutputDefault$inboundSchema),
  z.lazy(() => OutputSplunkLb$inboundSchema),
  z.lazy(() => OutputFilesystem$inboundSchema),
  z.lazy(() => OutputKinesis$inboundSchema),
  z.lazy(() => OutputHoneycomb$inboundSchema),
  z.lazy(() => OutputAzureEventhub$inboundSchema),
  z.lazy(() => OutputGoogleCloudStorage$inboundSchema),
  z.lazy(() => OutputGooglePubsub$inboundSchema),
  z.lazy(() => OutputKafka$inboundSchema),
  z.lazy(() => OutputConfluentCloud$inboundSchema),
  z.lazy(() => OutputElastic$inboundSchema),
  z.lazy(() => OutputElasticCloud$inboundSchema),
  z.lazy(() => OutputNewrelicEvents$inboundSchema),
  z.lazy(() => OutputInfluxdb$inboundSchema),
  z.lazy(() => OutputMinio$inboundSchema),
  z.lazy(() => OutputRouter$inboundSchema),
  z.lazy(() => OutputSns$inboundSchema),
  z.lazy(() => OutputSnmp$inboundSchema),
  z.lazy(() => OutputSumoLogic$inboundSchema),
  z.lazy(() => OutputLoki$inboundSchema),
  z.lazy(() => OutputPrometheus$inboundSchema),
  z.lazy(() => OutputOpenTelemetry$inboundSchema),
  z.lazy(() => OutputNetflow$inboundSchema),
  models.OutputWebhook$inboundSchema,
  models.OutputDevnull$inboundSchema,
  models.OutputSyslog$inboundSchema,
  z.lazy(() => OutputSplunk$inboundSchema),
  models.OutputSplunkHec$inboundSchema,
  models.OutputTcpjson$inboundSchema,
  z.lazy(() => OutputWavefront$inboundSchema),
  z.lazy(() => OutputSignalfx$inboundSchema),
  z.lazy(() => OutputS3$inboundSchema),
  z.lazy(() => OutputAzureBlob$inboundSchema),
  z.lazy(() => OutputAzureLogs$inboundSchema),
  z.lazy(() => OutputGoogleChronicle$inboundSchema),
  models.OutputNewrelic$inboundSchema,
  z.lazy(() => OutputStatsd$inboundSchema),
  z.lazy(() => OutputStatsdExt$inboundSchema),
  z.lazy(() => OutputGraphite$inboundSchema),
  z.lazy(() => OutputSqs$inboundSchema),
  models.OutputDatadog$inboundSchema,
  models.OutputRing$inboundSchema,
  z.lazy(() => OutputServiceNow$inboundSchema),
  models.OutputDataset$inboundSchema,
  models.OutputCriblTcp$inboundSchema,
  models.OutputCriblHttp$inboundSchema,
  z.lazy(() => OutputCrowdstrikeNextGenSiem$inboundSchema),
  z.lazy(() => OutputDlS3$inboundSchema),
  models.OutputCriblLake$inboundSchema,
  models.OutputDiskSpool$inboundSchema,
  models.OutputXsiam$inboundSchema,
  z.lazy(() => OutputDynatraceOtlp$inboundSchema),
  z.lazy(() => OutputHumioHec$inboundSchema),
  z.lazy(() => OutputDynatraceHttp$inboundSchema),
  z.lazy(() => OutputSentinelOneAiSiem$inboundSchema),
  models.OutputGrafanaCloud$inboundSchema,
]);

/** @internal */
export type CreateOutputRequest$Outbound =
  | OutputAzureDataExplorer$Outbound
  | OutputSecurityLake$Outbound
  | OutputSentinel$Outbound
  | OutputGoogleCloudLogging$Outbound
  | OutputExabeam$Outbound
  | OutputMsk$Outbound
  | OutputCloudwatch$Outbound
  | OutputClickHouse$Outbound
  | OutputDefault$Outbound
  | OutputSplunkLb$Outbound
  | OutputFilesystem$Outbound
  | OutputKinesis$Outbound
  | OutputHoneycomb$Outbound
  | OutputAzureEventhub$Outbound
  | OutputGoogleCloudStorage$Outbound
  | OutputGooglePubsub$Outbound
  | OutputKafka$Outbound
  | OutputConfluentCloud$Outbound
  | OutputElastic$Outbound
  | OutputElasticCloud$Outbound
  | OutputNewrelicEvents$Outbound
  | OutputInfluxdb$Outbound
  | OutputMinio$Outbound
  | OutputRouter$Outbound
  | OutputSns$Outbound
  | OutputSnmp$Outbound
  | OutputSumoLogic$Outbound
  | OutputLoki$Outbound
  | OutputPrometheus$Outbound
  | OutputOpenTelemetry$Outbound
  | OutputNetflow$Outbound
  | models.OutputWebhook$Outbound
  | models.OutputDevnull$Outbound
  | models.OutputSyslog$Outbound
  | OutputSplunk$Outbound
  | models.OutputSplunkHec$Outbound
  | models.OutputTcpjson$Outbound
  | OutputWavefront$Outbound
  | OutputSignalfx$Outbound
  | OutputS3$Outbound
  | OutputAzureBlob$Outbound
  | OutputAzureLogs$Outbound
  | OutputGoogleChronicle$Outbound
  | models.OutputNewrelic$Outbound
  | OutputStatsd$Outbound
  | OutputStatsdExt$Outbound
  | OutputGraphite$Outbound
  | OutputSqs$Outbound
  | models.OutputDatadog$Outbound
  | models.OutputRing$Outbound
  | OutputServiceNow$Outbound
  | models.OutputDataset$Outbound
  | models.OutputCriblTcp$Outbound
  | models.OutputCriblHttp$Outbound
  | OutputCrowdstrikeNextGenSiem$Outbound
  | OutputDlS3$Outbound
  | models.OutputCriblLake$Outbound
  | models.OutputDiskSpool$Outbound
  | models.OutputXsiam$Outbound
  | OutputDynatraceOtlp$Outbound
  | OutputHumioHec$Outbound
  | OutputDynatraceHttp$Outbound
  | OutputSentinelOneAiSiem$Outbound
  | models.OutputGrafanaCloud$Outbound;

/** @internal */
export const CreateOutputRequest$outboundSchema: z.ZodType<
  CreateOutputRequest$Outbound,
  z.ZodTypeDef,
  CreateOutputRequest
> = z.union([
  z.lazy(() => OutputAzureDataExplorer$outboundSchema),
  z.lazy(() => OutputSecurityLake$outboundSchema),
  z.lazy(() => OutputSentinel$outboundSchema),
  z.lazy(() => OutputGoogleCloudLogging$outboundSchema),
  z.lazy(() => OutputExabeam$outboundSchema),
  z.lazy(() => OutputMsk$outboundSchema),
  z.lazy(() => OutputCloudwatch$outboundSchema),
  z.lazy(() => OutputClickHouse$outboundSchema),
  z.lazy(() => OutputDefault$outboundSchema),
  z.lazy(() => OutputSplunkLb$outboundSchema),
  z.lazy(() => OutputFilesystem$outboundSchema),
  z.lazy(() => OutputKinesis$outboundSchema),
  z.lazy(() => OutputHoneycomb$outboundSchema),
  z.lazy(() => OutputAzureEventhub$outboundSchema),
  z.lazy(() => OutputGoogleCloudStorage$outboundSchema),
  z.lazy(() => OutputGooglePubsub$outboundSchema),
  z.lazy(() => OutputKafka$outboundSchema),
  z.lazy(() => OutputConfluentCloud$outboundSchema),
  z.lazy(() => OutputElastic$outboundSchema),
  z.lazy(() => OutputElasticCloud$outboundSchema),
  z.lazy(() => OutputNewrelicEvents$outboundSchema),
  z.lazy(() => OutputInfluxdb$outboundSchema),
  z.lazy(() => OutputMinio$outboundSchema),
  z.lazy(() => OutputRouter$outboundSchema),
  z.lazy(() => OutputSns$outboundSchema),
  z.lazy(() => OutputSnmp$outboundSchema),
  z.lazy(() => OutputSumoLogic$outboundSchema),
  z.lazy(() => OutputLoki$outboundSchema),
  z.lazy(() => OutputPrometheus$outboundSchema),
  z.lazy(() => OutputOpenTelemetry$outboundSchema),
  z.lazy(() => OutputNetflow$outboundSchema),
  models.OutputWebhook$outboundSchema,
  models.OutputDevnull$outboundSchema,
  models.OutputSyslog$outboundSchema,
  z.lazy(() => OutputSplunk$outboundSchema),
  models.OutputSplunkHec$outboundSchema,
  models.OutputTcpjson$outboundSchema,
  z.lazy(() => OutputWavefront$outboundSchema),
  z.lazy(() => OutputSignalfx$outboundSchema),
  z.lazy(() => OutputS3$outboundSchema),
  z.lazy(() => OutputAzureBlob$outboundSchema),
  z.lazy(() => OutputAzureLogs$outboundSchema),
  z.lazy(() => OutputGoogleChronicle$outboundSchema),
  models.OutputNewrelic$outboundSchema,
  z.lazy(() => OutputStatsd$outboundSchema),
  z.lazy(() => OutputStatsdExt$outboundSchema),
  z.lazy(() => OutputGraphite$outboundSchema),
  z.lazy(() => OutputSqs$outboundSchema),
  models.OutputDatadog$outboundSchema,
  models.OutputRing$outboundSchema,
  z.lazy(() => OutputServiceNow$outboundSchema),
  models.OutputDataset$outboundSchema,
  models.OutputCriblTcp$outboundSchema,
  models.OutputCriblHttp$outboundSchema,
  z.lazy(() => OutputCrowdstrikeNextGenSiem$outboundSchema),
  z.lazy(() => OutputDlS3$outboundSchema),
  models.OutputCriblLake$outboundSchema,
  models.OutputDiskSpool$outboundSchema,
  models.OutputXsiam$outboundSchema,
  z.lazy(() => OutputDynatraceOtlp$outboundSchema),
  z.lazy(() => OutputHumioHec$outboundSchema),
  z.lazy(() => OutputDynatraceHttp$outboundSchema),
  z.lazy(() => OutputSentinelOneAiSiem$outboundSchema),
  models.OutputGrafanaCloud$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputRequest$ {
  /** @deprecated use `CreateOutputRequest$inboundSchema` instead. */
  export const inboundSchema = CreateOutputRequest$inboundSchema;
  /** @deprecated use `CreateOutputRequest$outboundSchema` instead. */
  export const outboundSchema = CreateOutputRequest$outboundSchema;
  /** @deprecated use `CreateOutputRequest$Outbound` instead. */
  export type Outbound = CreateOutputRequest$Outbound;
}

export function createOutputRequestToJSON(
  createOutputRequest: CreateOutputRequest,
): string {
  return JSON.stringify(
    CreateOutputRequest$outboundSchema.parse(createOutputRequest),
  );
}

export function createOutputRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputRequest' from JSON`,
  );
}

/** @internal */
export const CreateOutputResponse$inboundSchema: z.ZodType<
  CreateOutputResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Output$inboundSchema).optional(),
});

/** @internal */
export type CreateOutputResponse$Outbound = {
  count?: number | undefined;
  items?: Array<models.Output$Outbound> | undefined;
};

/** @internal */
export const CreateOutputResponse$outboundSchema: z.ZodType<
  CreateOutputResponse$Outbound,
  z.ZodTypeDef,
  CreateOutputResponse
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Output$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateOutputResponse$ {
  /** @deprecated use `CreateOutputResponse$inboundSchema` instead. */
  export const inboundSchema = CreateOutputResponse$inboundSchema;
  /** @deprecated use `CreateOutputResponse$outboundSchema` instead. */
  export const outboundSchema = CreateOutputResponse$outboundSchema;
  /** @deprecated use `CreateOutputResponse$Outbound` instead. */
  export type Outbound = CreateOutputResponse$Outbound;
}

export function createOutputResponseToJSON(
  createOutputResponse: CreateOutputResponse,
): string {
  return JSON.stringify(
    CreateOutputResponse$outboundSchema.parse(createOutputResponse),
  );
}

export function createOutputResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateOutputResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateOutputResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateOutputResponse' from JSON`,
  );
}
